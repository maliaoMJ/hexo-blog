{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":1,"renderable":0},{"_id":"source/img/avatar/alipay.jpg","path":"img/avatar/alipay.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/wechat.jpg","path":"img/avatar/wechat.jpg","modified":1,"renderable":0},{"_id":"themes/carlos/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":1,"renderable":0},{"_id":"themes/carlos/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"themes/carlos/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1565790078000},{"_id":"themes/carlos/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1565790078000},{"_id":"source/CNAME","hash":"6d05053964eda7371ae3fdd373dae51cf5d3f413","modified":1565790078000},{"_id":"themes/carlos/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1565790078000},{"_id":"source/_posts/Docker 中如何安装WordPress.md","hash":"a5d0db018071fdeaf6384e44dd8dfbb1c7bbc207","modified":1565790078000},{"_id":"source/_posts/Docker 学习笔记 如何安装Docker.md","hash":"a30b02dbd6453c4f799c6373f14a1cf884f0d159","modified":1565790078000},{"_id":"source/_posts/JavaScript数据结构与算法-字典和哈希表.md","hash":"cc8ab6a384939e4b732f3e2356851b5ada4bad1b","modified":1565790078000},{"_id":"source/_posts/GraphQL 简介.md","hash":"75bc3cc11f9a77afc2aeefef65258656924a1395","modified":1565790078000},{"_id":"source/_posts/GraphQL入门之GraphQL的查询.md","hash":"2896cdc6d10de79dadfbeaa415f798647b6a5773","modified":1565790078000},{"_id":"source/_posts/JavaScript数据结构与算法-栈（Stack）.md","hash":"be51b8102b8d27ed7699f981eb38db2bb29b1abf","modified":1565790078000},{"_id":"source/_posts/JavaScript数据结构与算法-树.md","hash":"f9ed48d679f6878b3699e87161bb486e784d239b","modified":1565790078000},{"_id":"source/_posts/JavaScript数据结构与算法-链表（LinkedList）.md","hash":"0ef74c71d3e559cba2d625e93ea88b92bfac3ee6","modified":1565790078000},{"_id":"source/_posts/TypeScript 学习第一章 初识TypeScript.md","hash":"d65e1b71944efe2a604d2b82b749aa10e392a075","modified":1565794570000},{"_id":"source/_posts/TypeScript 学习第三章 TypeScript基本类型.md","hash":"692325edde5f186c3477f584aca383ea000b7cd1","modified":1565794879000},{"_id":"source/_posts/JavaScript数据结构与算法-集合.md","hash":"ca36cb3e02b16dd40735bed8eba458e7a576164e","modified":1565790078000},{"_id":"source/_posts/TypeScript 学习第二章 编写第一个 TypeScript.md","hash":"d583cd24b784a5bfc0aea2b791b14ecbc31f5e82","modified":1565794829000},{"_id":"source/_posts/JavaScript数据结构与算法队列（Queue）.md","hash":"c6bda3f42e3e46d2a1cf53a2c65dc6d0ad8060b9","modified":1565790078000},{"_id":"source/_posts/TypeScript 学习第七章 TypeScript变量声明.md","hash":"9ecab484a034338b4884b266a5111ecfb9c6836f","modified":1566040314000},{"_id":"source/_posts/TypeScript 学习第九章 TypeScript泛型.md","hash":"62c12bbb37e53f9c288b9f1b316627a15b35f05f","modified":1566040166000},{"_id":"source/_posts/TypeScript 学习第五章 TypeScript接口.md","hash":"ccbf243fa493b8b6ae315f5b54f8b420da429fb5","modified":1566040040000},{"_id":"source/_posts/TypeScript 学习第八章 TypeScript类型推断.md","hash":"c97ef4e43e13020cd4767c4b484c7a2f42ca6cc2","modified":1566040407000},{"_id":"source/_posts/TypeScript 学习第六章 TypeScript类.md","hash":"06dacdb1487d16fd9e8b17b4114664fa035b62a0","modified":1566040249000},{"_id":"source/_posts/TypeScript 学习第十章 TypeScript高级类型.md","hash":"122eb1e2884b302e25f6a46c69ec25e480a47edc","modified":1566040544000},{"_id":"source/_posts/Uni-App 基于Vue技术栈方向跨端技术实践.md","hash":"811e5d515c36cbaf0ce806ade65613c07266271f","modified":1565790078000},{"_id":"source/_posts/TypeScript 学习第四章 TypeScript函数.md","hash":"36d8c46598d1ded5bbc1f6e4e01c9ba46ece425a","modified":1566039969000},{"_id":"source/_posts/centOS中利用Docker安装gitlab.md","hash":"24da1cc9ebf0a36b429f1700c8da1e8459412133","modified":1565790078000},{"_id":"source/_posts/graphQL 如和在客户端调用.md","hash":"04ed731505e3ba9b9f580f0e331683afa59b58f0","modified":1565790078000},{"_id":"source/_posts/前端面试系列 — HMTL基础篇.md","hash":"3557fedafac5b51e7e2276f3e7fcab471a0d1792","modified":1565790078000},{"_id":"source/_posts/前端面试系列 — 布局篇.md","hash":"cde6b572e5f9a0de01f72f314a3411a968ce1440","modified":1565790078000},{"_id":"source/_posts/前端面试系列-HTTP常考点.md","hash":"e72785bda53cc4b95b50d4e296472d6b8fa624ce","modified":1565790078000},{"_id":"source/_posts/前端面试系列- CSS基础篇.md","hash":"d03034efbb1bee374236a7611efe0fe560cbf651","modified":1565790078000},{"_id":"source/_posts/前端面试系列-JavaScript 数组.md","hash":"4ab0ba7506c3eb572de4e5c24e66a8b705d03216","modified":1565790078000},{"_id":"source/_posts/前端面试系列-JS基础数据类型.md","hash":"117b966c2f8428d0ee3ed466b4ff56dfc86f3d27","modified":1565790078000},{"_id":"source/_posts/前端面试系列-JavaScript中的this指向问题.md","hash":"8efaadf5b1cc49d8840586d3f1d0367397fd8d8c","modified":1565790078000},{"_id":"source/_posts/前端面试系列-JavaScript继承.md","hash":"095911c2e083cb38e9c66420558aaffa16f0ba9c","modified":1565790078000},{"_id":"source/_posts/前端面试系列-前端跨域常用的几种方式.md","hash":"42a3780bb357e5bc300c4c63bce0e80750fac06e","modified":1565790078000},{"_id":"source/_posts/前端面试系列-游览器中的事件.md","hash":"cd5a025a0e4ac8feb9efaff703ec3659731f0090","modified":1565790078000},{"_id":"source/_posts/如何在Vue SPA中集成GraphQL.md","hash":"730fd59babdf590ec1e2b240c3f989ae4d5da095","modified":1565790078000},{"_id":"source/_posts/微信小程序开发技术选型分享.md","hash":"c39a7378fd22753d6ed79f85a3fa61f02fc0735d","modified":1565790078000},{"_id":"source/_posts/第一章 TheeJS 创建场景.md","hash":"244e57ee56c7024c6f6c995c2b6662b56b2c3d20","modified":1565790078000},{"_id":"source/about/index.md","hash":"87b9f62b9fc93ea81bd20e698ff102203bcd2927","modified":1565790078000},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1565790078000},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1565790078000},{"_id":"themes/carlos/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1565790078000},{"_id":"themes/carlos/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1565790078000},{"_id":"themes/carlos/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1565790078000},{"_id":"themes/carlos/layout/archive.ejs","hash":"a990910af3d5e402c27ffdc7e3f8831ffc3a88e2","modified":1565790078000},{"_id":"themes/carlos/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1565790078000},{"_id":"themes/carlos/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1565790078000},{"_id":"themes/carlos/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1565790078000},{"_id":"themes/carlos/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1565790078000},{"_id":"themes/carlos/layout/post.ejs","hash":"03107af08fec9a00f65d6692b01a419054dbf80e","modified":1565790078000},{"_id":"themes/carlos/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1565790078000},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1565790078000},{"_id":"source/img/avatar/alipay.jpg","hash":"1a748a29b0634999ee26512f696b7b7249eb5a1c","modified":1565790078000},{"_id":"source/img/avatar/wechat.jpg","hash":"3db1455b6616a182a7ef46773ef9750f1ec84831","modified":1565790078000},{"_id":"themes/carlos/layout/_partial/footer.ejs","hash":"f6197dccef7904fb7c2401e62d3219fab6f5ece0","modified":1565790078000},{"_id":"themes/carlos/layout/_partial/head.ejs","hash":"720349195a5ea7b610a82ce3ce74298fb2bc7347","modified":1565790078000},{"_id":"themes/carlos/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1565790078000},{"_id":"themes/carlos/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1565790078000},{"_id":"themes/carlos/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1565790078000},{"_id":"themes/carlos/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1565790078000},{"_id":"themes/carlos/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1565790078000},{"_id":"themes/carlos/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1565790078000},{"_id":"themes/carlos/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1565790078000},{"_id":"themes/carlos/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1565790078000},{"_id":"themes/carlos/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1565790078000},{"_id":"themes/carlos/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1565790078000},{"_id":"themes/carlos/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1565790078000},{"_id":"themes/carlos/source/css/beantech.min.css","hash":"b57004e24164568c938ad14d2c9f4df4b44a7e6c","modified":1565790078000},{"_id":"themes/carlos/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1565790078000},{"_id":"themes/carlos/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1565790078000},{"_id":"themes/carlos/source/css/beantech.css","hash":"f2aeda0e7bb732c0c16f77afb482f78b14dc42b7","modified":1565790078000},{"_id":"themes/carlos/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1565790078000},{"_id":"themes/carlos/source/css/hux-blog.min.css","hash":"eba8a9219b55d1f30c78927d6583ef03be5715f0","modified":1565790078000},{"_id":"themes/carlos/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1565790078000},{"_id":"themes/carlos/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1565790078000},{"_id":"themes/carlos/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1565790078000},{"_id":"themes/carlos/source/css/widget.styl","hash":"9940278d0b3cf92bdcf9cead877bb3a3338d1f23","modified":1565790078000},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1565790078000},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1565790078000},{"_id":"themes/carlos/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1565790078000},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1565790078000},{"_id":"themes/carlos/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1565790078000},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1565790078000},{"_id":"themes/carlos/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1565790078000},{"_id":"themes/carlos/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1565790078000},{"_id":"themes/carlos/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1565790078000},{"_id":"themes/carlos/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1565790078000},{"_id":"themes/carlos/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1565790078000},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1565790078000},{"_id":"themes/carlos/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1565790078000},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1565790078000},{"_id":"themes/carlos/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1565790078000},{"_id":"themes/carlos/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1565790078000},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1565790078000},{"_id":"themes/carlos/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1565790078000},{"_id":"themes/carlos/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1565790078000},{"_id":"themes/carlos/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1565790078000},{"_id":"themes/carlos/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1565790078000},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1565790078000},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1565790078000},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1565790078000},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1565790078000},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1565790078000},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1565790078000},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1565790078000},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1565790078000},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1565790078000},{"_id":"public/post-sitemap.xml","hash":"b496151d9e31d0a1f79997ce0a442f16e641518e","modified":1566040682642},{"_id":"public/page-sitemap.xml","hash":"0d2205ef3b3607f35bf0389b5b194b9565bac76c","modified":1566040682643},{"_id":"public/category-sitemap.xml","hash":"c4b6cefcf997a5811f5d163bfe068421cb895278","modified":1566040683515},{"_id":"public/tag-sitemap.xml","hash":"17327c59ef5e85a6109e828ef296bf1b8db1183c","modified":1566040683516},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1566040683776},{"_id":"public/sitemap.xml","hash":"bd81ff49e64e2e77b1388f0e8d2332990dfcbe32","modified":1566040683776},{"_id":"public/404.html","hash":"9aa1df52fdfc9227ffb768f45cbc70d035282599","modified":1566040683812},{"_id":"public/tags/index.html","hash":"94bf34ad66a990acc8884cdc80a9999663ee142a","modified":1566040683812},{"_id":"public/TypeScript/TypeScript 学习第十章 TypeScript高级类型/index.html","hash":"a61ecfb4977f64d92a4528e453980931a283de94","modified":1566040683812},{"_id":"public/TypeScript/TypeScript 学习第九章 TypeScript泛型/index.html","hash":"85af34b7a207d97df86ee2de211b68dec27cc391","modified":1566040683812},{"_id":"public/TypeScript/TypeScript 学习第八章 TypeScript类型推断/index.html","hash":"375220650ec481beb87d5f0542c1349a27f95c81","modified":1566040683813},{"_id":"public/TypeScript/TypeScript 学习第七章 TypeScript变量声明/index.html","hash":"b9797ec3f055bab830c03125eac9cb14721dc78b","modified":1566040683813},{"_id":"public/TypeScript/TypeScript 学习第六章 TypeScript类/index.html","hash":"ca62da7e68ba61d99624b237aa5af9437204ed2d","modified":1566040683813},{"_id":"public/TypeScript/TypeScript 学习第五章 TypeScript接口/index.html","hash":"f54b0e7f8b8d8f342d777c2bb040cc506ea6e359","modified":1566040683813},{"_id":"public/TypeScript/TypeScript 学习第四章 TypeScript函数/index.html","hash":"604b6f0252df056c886ce9397e2d22aec96e9f51","modified":1566040683813},{"_id":"public/TypeScript/TypeScript 学习第三章 TypeScript基本类型/index.html","hash":"095a4173b270281fd2f4647e6420acc5c11c1c6d","modified":1566040683813},{"_id":"public/TypeScript/TypeScript 学习第二章 编写第一个 TypeScript/index.html","hash":"6e856efbf3d5b3bf39fb062841b5a8f88f8a3b44","modified":1566040683813},{"_id":"public/TypeScript/TypeScript 学习第一章 初识TypeScript/index.html","hash":"785fc614ea91d2dcfbceb7d50119c5e5f37de429","modified":1566040683813},{"_id":"public/ThreeJS/第一章 TheeJS 创建场景/index.html","hash":"49c322b99312eaa5da6e29e60954f7a268bc4946","modified":1566040683813},{"_id":"public/Vue/Uni-App 基于Vue技术栈方向跨端技术实践/index.html","hash":"16b59dfcfb251d1421aad58f7c1327b7a657ec13","modified":1566040683813},{"_id":"public/数据结构/JavaScript数据结构与算法-树/index.html","hash":"b1f606005164a6c01c909864b2295851711b9af1","modified":1566040683813},{"_id":"public/数据结构/JavaScript数据结构与算法-字典和哈希表/index.html","hash":"dd03c793fa8ae9ec2216b26ecd57c8b128300a11","modified":1566040683813},{"_id":"public/数据结构/JavaScript数据结构与算法-集合/index.html","hash":"ca527c2edb8e5b0c67abd76fbcd9dcde851d5d00","modified":1566040683814},{"_id":"public/数据结构/JavaScript数据结构与算法-链表（LinkedList）/index.html","hash":"47bf5481da41f6c9f031a87c76a0c5b5a6703f21","modified":1566040683814},{"_id":"public/数据结构/JavaScript数据结构与算法队列（Queue）/index.html","hash":"25b81a47bd578be3e6bfffa1bdf14442fd1b68b5","modified":1566040683814},{"_id":"public/数据结构/JavaScript数据结构与算法-栈（Stack）/index.html","hash":"27b98c893481f37de2db45c886c2a37b065e7e08","modified":1566040683814},{"_id":"public/JavaScript/前端面试系列-JavaScript继承/index.html","hash":"bd8faa9b054cd6c3dbe57b155cd009265fab8bb5","modified":1566040683814},{"_id":"public/HTTP/前端面试系列-HTTP常考点/index.html","hash":"9347e1dfc2011add285856f4f1f65d3c22bfc460","modified":1566040683814},{"_id":"public/前端面试/前端面试系列-JavaScript 数组/index.html","hash":"6eec5373989dcbc556fb238c849841d22a954984","modified":1566040683814},{"_id":"public/前端面试/前端面试系列- CSS基础篇/index.html","hash":"9bd9519b9ee17ec708a1f79aae1839ed3c86eb11","modified":1566040683814},{"_id":"public/前端面试/前端面试系列-JavaScript中的this指向问题/index.html","hash":"29d24e9b24f9cf5c35d51e97553a8374e0751322","modified":1566040683814},{"_id":"public/前端面试/前端面试系列-游览器中的事件/index.html","hash":"343b59c5752655effb9dc121bdc4f3ef11a80cb1","modified":1566040683814},{"_id":"public/前端面试/前端面试系列-前端跨域常用的几种方式/index.html","hash":"833b568f61ad04e049aed0fe6a6a8a5ad0d5a190","modified":1566040683814},{"_id":"public/前端面试/前端面试系列-JS基础数据类型/index.html","hash":"f600b23068ca9d0f04cb4a9feaba53828e0168aa","modified":1566040683814},{"_id":"public/CSS3/前端面试系列 — 布局篇/index.html","hash":"1d206a865690c23d2020fc59ea4a5cff94f09f2e","modified":1566040683814},{"_id":"public/HTML5/前端面试系列 — HMTL基础篇/index.html","hash":"edfd7123a04e4abed61f52e5a92c05aa3892aa4c","modified":1566040683814},{"_id":"public/微信小程序/微信小程序开发技术选型分享/index.html","hash":"a0fb5f45e5b5470c1c5161abe17afe240cd0940b","modified":1566040683814},{"_id":"public/docker/Docker 学习笔记 如何安装Docker/index.html","hash":"0472c968ee6cc7293fcc62362f74c1ed08d7ac7d","modified":1566040683814},{"_id":"public/docker/centOS中利用Docker安装gitlab/index.html","hash":"50cf662b77256f3c3a0bd914e58578f073be0178","modified":1566040683815},{"_id":"public/GraphQL/如何在Vue SPA中集成GraphQL/index.html","hash":"a88216d42b3eb82dd53ebbaf724648a9ff4ca8de","modified":1566040683815},{"_id":"public/GraphQL/graphQL 如和在客户端调用/index.html","hash":"684e8b0e417a92aaa30e486a802397ff01a4ed0d","modified":1566040683815},{"_id":"public/GraphQL/GraphQL入门之GraphQL的查询/index.html","hash":"0d2057769e26ea56b061c4a1cd5381e8a659b7f9","modified":1566040683815},{"_id":"public/docker/Docker 中如何安装WordPress/index.html","hash":"91a8207252bf6eb85ecd1be5962568601191d9f3","modified":1566040683815},{"_id":"public/GraphQL/GraphQL 简介/index.html","hash":"c5a08d071bfb5e7344df5ec92e9e895dbb2fd87a","modified":1566040683815},{"_id":"public/archive/index.html","hash":"c9484156fcf955aa3a1395424c3c43bfcd608aad","modified":1566040683815},{"_id":"public/about/index.html","hash":"f401286c0b45b274a99765ea8efe6f1efb445118","modified":1566040683815},{"_id":"public/archives/index.html","hash":"e8ab4724d1c3b3c8666c51b4954fb3f87ab04d0d","modified":1566040683815},{"_id":"public/archives/archives/2/index.html","hash":"d92cfc2425c40032ea2f7b620db417735e77774e","modified":1566040683815},{"_id":"public/archives/archives/3/index.html","hash":"d6e3963494881781a163328bc4760f1f16b8d283","modified":1566040683815},{"_id":"public/archives/archives/4/index.html","hash":"efba912a826ae2a1e0e9fd1d13b702b7af4c9a47","modified":1566040683815},{"_id":"public/archives/2019/index.html","hash":"d5dd5ae614d5f655da00b33eda2f520550080dee","modified":1566040683815},{"_id":"public/archives/2019/archives/2/index.html","hash":"26153bca3c8dfa521e9eda0131257a1a52dc0b42","modified":1566040683815},{"_id":"public/archives/2019/archives/3/index.html","hash":"76bd4e39e9802c0972997113e11288fd0fbb7ce6","modified":1566040683816},{"_id":"public/archives/2019/archives/4/index.html","hash":"99d023ab5cc6ebe88e0c9de9b216117d90a3a338","modified":1566040683816},{"_id":"public/archives/2019/02/index.html","hash":"a247db88c203a3b1ec004ac6a2d748715a775d13","modified":1566040683816},{"_id":"public/archives/2019/02/archives/2/index.html","hash":"d7a32fa3af5aa564bdf3c2abe76b8c13a610083e","modified":1566040683816},{"_id":"public/archives/2019/03/index.html","hash":"bba37d06e725e801bc1df3717c5f63cf7dd857db","modified":1566040683816},{"_id":"public/archives/2019/04/index.html","hash":"3df969b1a7078222e138ae2b65b64ef68f032fba","modified":1566040683816},{"_id":"public/archives/2019/08/index.html","hash":"b4ed2bf3c7336b9635115dbe1438bc051917eaa9","modified":1566040683816},{"_id":"public/archives/2019/08/archives/2/index.html","hash":"0cebac45a7f2e4a005278b57327680826f8c5b48","modified":1566040683816},{"_id":"public/categories/docker/index.html","hash":"c71dbce5d18680f96ef6ed2d1e13bf9eabf9a74a","modified":1566040683816},{"_id":"public/categories/数据结构/index.html","hash":"431a1a1fc71effeaa44e9f978668fddfd1b7b0e5","modified":1566040683816},{"_id":"public/categories/GraphQL/index.html","hash":"3cfc3e5917b8a5c7915f303a644f852b0d9fc727","modified":1566040683816},{"_id":"public/categories/TypeScript/index.html","hash":"e35e46158999423513dd0a27ae3304ad02dd6ddc","modified":1566040683816},{"_id":"public/categories/Vue/index.html","hash":"5e5467c58bc799ddf6e8d61af2b7f5ce977c5468","modified":1566040683816},{"_id":"public/categories/HTML5/index.html","hash":"c5a076f4ff917403ae8ea79bd70ef2ee53d2870d","modified":1566040683816},{"_id":"public/categories/CSS3/index.html","hash":"2143a75095f8afbd78f601ce68f6476eba2b85a7","modified":1566040683817},{"_id":"public/categories/HTTP/index.html","hash":"4dfa8d6d4989c2f274871a1f771c1148a10c8d0c","modified":1566040683817},{"_id":"public/categories/前端面试/index.html","hash":"58252b7c2597f558b1c958cf6d9070ba7f51e31c","modified":1566040683817},{"_id":"public/categories/JavaScript/index.html","hash":"ffb4f4fef2658bb45f7738fa535750be4920fb9a","modified":1566040683817},{"_id":"public/categories/微信小程序/index.html","hash":"a33b4419ff85b449347e3f686f393d910420ffc5","modified":1566040683817},{"_id":"public/categories/ThreeJS/index.html","hash":"55226ca1a2cff574867971cbd46114a4333c42cc","modified":1566040683817},{"_id":"public/index.html","hash":"a36d2e3302081a7f9c28917ac6fe4737f952ee7e","modified":1566040683817},{"_id":"public/archives/2/index.html","hash":"fb40f6a768b87a9652b4722dbebf63f5a98613e6","modified":1566040683817},{"_id":"public/archives/3/index.html","hash":"648160c9f977a7d07b6610b649839f607283d171","modified":1566040683817},{"_id":"public/archives/4/index.html","hash":"1e7768ec1e9576494b119808da0ef07f44182ed6","modified":1566040683817},{"_id":"public/tags/Docker/index.html","hash":"bde90bc9e63aeab11cef67e9c54e91a255873e78","modified":1566040683817},{"_id":"public/tags/WordPress/index.html","hash":"dfe4ca8740b35ecc6a5285d15ab98ef06d90ef50","modified":1566040683817},{"_id":"public/tags/javascript/index.html","hash":"991cf156a3b94afb0455ae73133b3189a8f4b899","modified":1566040683817},{"_id":"public/tags/数据结构/index.html","hash":"bd08772e123c8c586f7f44651d5a52859fb73da4","modified":1566040683817},{"_id":"public/tags/graphql/index.html","hash":"e8e3d6ffef8f58d06c77533f542c81f33955e284","modified":1566040683818},{"_id":"public/tags/JavaScript/index.html","hash":"d1ca8d3bec7300f73bb50b254a6fc204aa397635","modified":1566040683818},{"_id":"public/tags/JavaScript/archives/2/index.html","hash":"503dfbb0978972064879636b2fd0229e5d50aab4","modified":1566040683818},{"_id":"public/tags/TypeScript/index.html","hash":"f94eee19d8b7b165a661f7866e21ff5c35b2dfcf","modified":1566040683818},{"_id":"public/tags/Vue/index.html","hash":"abd67ffdf881c9f0ae074069e432ab63827eee57","modified":1566040683818},{"_id":"public/tags/Weex/index.html","hash":"9f0a47445543e3927d264b6e47519cae7240e168","modified":1566040683818},{"_id":"public/tags/微信小程序/index.html","hash":"a54a087a7b26b9c32ff92aadf238a7f321697aca","modified":1566040683818},{"_id":"public/tags/git/index.html","hash":"ded84f31dda15023fc4c6e4656902c5a61cd605d","modified":1566040683818},{"_id":"public/tags/gitlab/index.html","hash":"473350a60049ae64d8550224ee4c51165745f3f9","modified":1566040683818},{"_id":"public/tags/nodejs/index.html","hash":"3f75e28fbea9f966e58307d293620a388308ec81","modified":1566040683818},{"_id":"public/tags/http/index.html","hash":"36e35d767af0d4203ca5a1716df2fc06930576d2","modified":1566040683818},{"_id":"public/tags/CSS3/index.html","hash":"5b184242557de657f5f357cb0cccc211285dd1f9","modified":1566040683818},{"_id":"public/tags/Frontend-Interview/index.html","hash":"7d430fe930df0bdee3c5670db546a821cce52e50","modified":1566040683818},{"_id":"public/tags/html/index.html","hash":"18dff7d3854a205bde956e05cea9cada696e3d43","modified":1566040683819},{"_id":"public/tags/ES6/index.html","hash":"90e0dfe469faface10afbe6aef4346cedb9701c7","modified":1566040683819},{"_id":"public/tags/vuejs/index.html","hash":"10de098b9760dec89a636e11eadd843ff0f3075d","modified":1566040683819},{"_id":"public/tags/HTML/index.html","hash":"c3cd20a404aefff929970081d39abe1e498e83f5","modified":1566040683819},{"_id":"public/tags/Threejs/index.html","hash":"b64001a2c7a73a93b0a6e71e0eedfeb69d65315c","modified":1566040683819},{"_id":"public/CNAME","hash":"6d05053964eda7371ae3fdd373dae51cf5d3f413","modified":1566040683828},{"_id":"public/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1566040683828},{"_id":"public/img/avatar/alipay.jpg","hash":"1a748a29b0634999ee26512f696b7b7249eb5a1c","modified":1566040683828},{"_id":"public/img/avatar/wechat.jpg","hash":"3db1455b6616a182a7ef46773ef9750f1ec84831","modified":1566040683828},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1566040683828},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1566040683828},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1566040683828},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1566040683828},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1566040683828},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1566040683828},{"_id":"public/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1566040684045},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1566040684046},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1566040684053},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1566040684054},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1566040684054},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1566040684054},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1566040684054},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1566040684054},{"_id":"public/css/widget.css","hash":"6ab0367504355a703f180f10343d2f5558f30fbd","modified":1566040684054},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1566040684054},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1566040684054},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1566040684054},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1566040684054},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1566040684054},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1566040684054},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1566040684054},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1566040684055},{"_id":"public/css/beantech.min.css","hash":"b57004e24164568c938ad14d2c9f4df4b44a7e6c","modified":1566040684072},{"_id":"public/css/beantech.css","hash":"f2aeda0e7bb732c0c16f77afb482f78b14dc42b7","modified":1566040684073},{"_id":"public/css/hux-blog.min.css","hash":"eba8a9219b55d1f30c78927d6583ef03be5715f0","modified":1566040684073},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1566040684089},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1566040684089},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1566040684135},{"_id":"public/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1566040684135},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1566040684142},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1566040684146},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1566040684183},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1566040684188},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1566040684194},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1566040684201},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1566040684207},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1566040684207},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1566040684211},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1566040684219}],"Category":[{"name":"Docker","_id":"cjzfg6r430005w72sr3prjqu5"},{"name":"数据结构","_id":"cjzfg6r4n000fw72sh46x1551"},{"name":"GraphQL","_id":"cjzfg6r4r000nw72s9t7leazu"},{"name":"TypeScript","_id":"cjzfg6r53001dw72s3wrtr4gd"},{"name":"Vue","_id":"cjzfg6r5b001vw72sssaryt5e"},{"name":"HTML5","_id":"cjzfg6r5f0024w72ss33ab84e"},{"name":"CSS3","_id":"cjzfg6r5g0029w72s65sjuzy9"},{"name":"HTTP","_id":"cjzfg6r5h002dw72segz08ap2"},{"name":"前端面试","_id":"cjzfg6r5j002jw72swiug9hcq"},{"name":"JavaScript","_id":"cjzfg6r5p002yw72sd5b6d8xv"},{"name":"微信小程序","_id":"cjzfg6r6t0051w72s4uztdxg8"},{"name":"ThreeJS","_id":"cjzfg6r6v0057w72stvgnkvt3"}],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-08-14T13:41:18.000Z","updated":"2019-08-14T13:41:18.000Z","path":"404.html","title":"","comments":1,"_id":"cjzfg6r300000w72sgpq6aalv","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-08-14T13:41:18.000Z","path":"archive/index.html","_id":"cjzfg6r400002w72s83z82d06","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About Me","date":"2019-05-01T02:48:33.000Z","description":"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。","header-img":"/img/header_img/about.jpg","aplayer":true,"fixed":false,"_content":"\n### 一句话\n\n> 吾生也有涯，而知也无涯。\n\n### 关于我\n\n>性格：外表冷淡 内心火热 雷厉风行 幽默\n\n### 兴趣方向\n\n> 前端（Vue、React等）相关生态技术研究。\n> 运维：GitLab,Jenkins等CI/CD 的构建。\n> 后端：Nodejs,Golang等。\n---\n> 一个不会运维的后端，不是一个好的前端。\n### 联系我\n>QQ: 1302151931\n>邮箱: lazykids520@gmail.com\n>微信: wxid_ooyfs990jdvs22\n\n### 我的音乐\n> 用户名：神秘的地下党\n> 数据来源于： 网易云音乐 --> 我喜欢的音乐\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About Me\"\ndate: 2019-05-01 10:48:33\ndescription: \"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: true\nfixed: false\n---\n\n### 一句话\n\n> 吾生也有涯，而知也无涯。\n\n### 关于我\n\n>性格：外表冷淡 内心火热 雷厉风行 幽默\n\n### 兴趣方向\n\n> 前端（Vue、React等）相关生态技术研究。\n> 运维：GitLab,Jenkins等CI/CD 的构建。\n> 后端：Nodejs,Golang等。\n---\n> 一个不会运维的后端，不是一个好的前端。\n### 联系我\n>QQ: 1302151931\n>邮箱: lazykids520@gmail.com\n>微信: wxid_ooyfs990jdvs22\n\n### 我的音乐\n> 用户名：神秘的地下党\n> 数据来源于： 网易云音乐 --> 我喜欢的音乐\n\n","updated":"2019-08-14T13:41:18.000Z","path":"about/index.html","comments":1,"_id":"cjzfg6r420004w72sb244hv5i","content":"<h3><span id=\"一句话\">一句话</span></h3>\n<blockquote>\n<p>吾生也有涯，而知也无涯。</p>\n</blockquote>\n<h3><span id=\"关于我\">关于我</span></h3>\n<blockquote>\n<p>性格：外表冷淡 内心火热 雷厉风行 幽默</p>\n</blockquote>\n<h3><span id=\"兴趣方向\">兴趣方向</span></h3>\n<blockquote>\n<p>前端（Vue、React等）相关生态技术研究。<br>\n运维：GitLab,Jenkins等CI/CD 的构建。<br>\n后端：Nodejs,Golang等。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>一个不会运维的后端，不是一个好的前端。</p>\n</blockquote>\n<h3><span id=\"联系我\">联系我</span></h3>\n<blockquote>\n<p>QQ: 1302151931<br>\n邮箱: <a href=\"mailto:lazykids520@gmail.com\" target=\"_blank\" rel=\"noopener\">lazykids520@gmail.com</a><br>\n微信: wxid_ooyfs990jdvs22</p>\n</blockquote>\n<h3><span id=\"我的音乐\">我的音乐</span></h3>\n<blockquote>\n<p>用户名：神秘的地下党<br>\n数据来源于： 网易云音乐 --&gt; 我喜欢的音乐</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>吾生也有涯，而知也无涯。</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote>\n<p>性格：外表冷淡 内心火热 雷厉风行 幽默</p>\n</blockquote>\n<h3>兴趣方向</h3>\n<blockquote>\n<p>前端（Vue、React等）相关生态技术研究。<br>\n运维：GitLab,Jenkins等CI/CD 的构建。<br>\n后端：Nodejs,Golang等。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>一个不会运维的后端，不是一个好的前端。</p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>QQ: 1302151931<br>\n邮箱: <a href=\"mailto:lazykids520@gmail.com\" target=\"_blank\" rel=\"noopener\">lazykids520@gmail.com</a><br>\n微信: wxid_ooyfs990jdvs22</p>\n</blockquote>\n<h3>我的音乐</h3>\n<blockquote>\n<p>用户名：神秘的地下党<br>\n数据来源于： 网易云音乐 --&gt; 我喜欢的音乐</p>\n</blockquote>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2019-08-14T13:41:18.000Z","updated":"2019-08-14T13:41:18.000Z","path":"tags/index.html","comments":1,"_id":"cjzfg6r460008w72s2bt0qx5z","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Docker 中如何安装WordPress","catalog":true,"url":"39.html","id":"39","date":"2019-02-18T10:12:44.000Z","subtitle":null,"header-img":null,"_content":"\n### Docker 中如何安装WordPress\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> ##### 1\\. 从dockerHub 中拉取mysql镜像\n\n       docker pull mysql:5.6\n    \n\n当然你也可选用最新的mysql版本\n\n    docker pull mysql\n    \n\n![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&fm=58&bpow=1024&bpoh=1024)\n\n> ##### 2\\. 从dockerHub 中拉取 wordpress镜像\n\n    docker pull wordpress:latest\n    \n\n> ##### 3\\. 创建mysql容器 并且做一些设置\n\n    docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n    \n    \n\n> ##### 4\\. 创建WordPress 容器并且做一些基础配置\n\n    docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n    \n\n> ##### 5\\. 访问localhost:8080 端口进行配置wordpress站点","source":"_posts/Docker 中如何安装WordPress.md","raw":"---\ntitle: Docker 中如何安装WordPress\ncatalog: true\ntags:\n  - Docker\n  - WordPress\nurl: 39.html\nid: 39\ncategories:\n  - Docker\ndate: 2019-02-18 18:12:44\nsubtitle:\nheader-img:\n---\n\n### Docker 中如何安装WordPress\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> ##### 1\\. 从dockerHub 中拉取mysql镜像\n\n       docker pull mysql:5.6\n    \n\n当然你也可选用最新的mysql版本\n\n    docker pull mysql\n    \n\n![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&fm=58&bpow=1024&bpoh=1024)\n\n> ##### 2\\. 从dockerHub 中拉取 wordpress镜像\n\n    docker pull wordpress:latest\n    \n\n> ##### 3\\. 创建mysql容器 并且做一些设置\n\n    docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n    \n    \n\n> ##### 4\\. 创建WordPress 容器并且做一些基础配置\n\n    docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n    \n\n> ##### 5\\. 访问localhost:8080 端口进行配置wordpress站点","slug":"Docker 中如何安装WordPress","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r3w0001w72sn7yafu7t","content":"<h3><span id=\"docker-中如何安装wordpress\">Docker 中如何安装WordPress</span></h3>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h5><span id=\"1-从dockerhub-中拉取mysql镜像\">1. 从dockerHub 中拉取mysql镜像</span></h5>\n</blockquote>\n<pre><code>   docker pull mysql:5.6\n</code></pre>\n<p>当然你也可选用最新的mysql版本</p>\n<pre><code>docker pull mysql\n</code></pre>\n<p><img src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&amp;fm=58&amp;bpow=1024&amp;bpoh=1024\" alt></p>\n<blockquote>\n<h5><span id=\"2-从dockerhub-中拉取-wordpress镜像\">2. 从dockerHub 中拉取 wordpress镜像</span></h5>\n</blockquote>\n<pre><code>docker pull wordpress:latest\n</code></pre>\n<blockquote>\n<h5><span id=\"3-创建mysql容器-并且做一些设置\">3. 创建mysql容器 并且做一些设置</span></h5>\n</blockquote>\n<pre><code>docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n</code></pre>\n<blockquote>\n<h5><span id=\"4-创建wordpress-容器并且做一些基础配置\">4. 创建WordPress 容器并且做一些基础配置</span></h5>\n</blockquote>\n<pre><code>docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n</code></pre>\n<blockquote>\n<h5><span id=\"5-访问localhost8080-端口进行配置wordpress站点\">5. 访问localhost:8080 端口进行配置wordpress站点</span></h5>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>Docker 中如何安装WordPress</h3>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h5>1. 从dockerHub 中拉取mysql镜像</h5>\n</blockquote>\n<pre><code>   docker pull mysql:5.6\n</code></pre>\n<p>当然你也可选用最新的mysql版本</p>\n<pre><code>docker pull mysql\n</code></pre>\n<p><img src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&amp;fm=58&amp;bpow=1024&amp;bpoh=1024\" alt></p>\n<blockquote>\n<h5>2. 从dockerHub 中拉取 wordpress镜像</h5>\n</blockquote>\n<pre><code>docker pull wordpress:latest\n</code></pre>\n<blockquote>\n<h5>3. 创建mysql容器 并且做一些设置</h5>\n</blockquote>\n<pre><code>docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n</code></pre>\n<blockquote>\n<h5>4. 创建WordPress 容器并且做一些基础配置</h5>\n</blockquote>\n<pre><code>docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n</code></pre>\n<blockquote>\n<h5>5. 访问localhost:8080 端口进行配置wordpress站点</h5>\n</blockquote>\n"},{"title":"Docker 学习笔记 如何安装Docker","catalog":true,"url":"114.html","id":"114","date":"2019-02-21T03:41:50.000Z","subtitle":null,"header-img":null,"_content":"\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> #### 1.安装环境 CentOS7\n\n      sudo yum install docker\n    \n\n> #### 2.启动Docker\n\n       sudo yum systemctl start docker\n    \n\n> #### 3.搜索镜像\n\n       docker search ubuntu\n    \n\n> #### 4.拉取镜像\n\n    docker pull ubuntu:16.04\n    \n\n> #### 5.docker 权限问题\n> \n> 运行如下命令\n\n     sudo groupadd docker #创建docker用户组\n     sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n     sudo service docker restart # 重启docker服务，退出ssh,重新连接即可","source":"_posts/Docker 学习笔记 如何安装Docker.md","raw":"---\ntitle: Docker 学习笔记 如何安装Docker\ncatalog: true\ntags:\n  - Docker\nurl: 114.html\nid: 114\ncategories:\n  - Docker\ndate: 2019-02-21 11:41:50\nsubtitle:\nheader-img:\n---\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> #### 1.安装环境 CentOS7\n\n      sudo yum install docker\n    \n\n> #### 2.启动Docker\n\n       sudo yum systemctl start docker\n    \n\n> #### 3.搜索镜像\n\n       docker search ubuntu\n    \n\n> #### 4.拉取镜像\n\n    docker pull ubuntu:16.04\n    \n\n> #### 5.docker 权限问题\n> \n> 运行如下命令\n\n     sudo groupadd docker #创建docker用户组\n     sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n     sudo service docker restart # 重启docker服务，退出ssh,重新连接即可","slug":"Docker 学习笔记 如何安装Docker","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r410003w72s327649wk","content":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h4><span id=\"1安装环境-centos7\">1.安装环境 CentOS7</span></h4>\n</blockquote>\n<pre><code>  sudo yum install docker\n</code></pre>\n<blockquote>\n<h4><span id=\"2启动docker\">2.启动Docker</span></h4>\n</blockquote>\n<pre><code>   sudo yum systemctl start docker\n</code></pre>\n<blockquote>\n<h4><span id=\"3搜索镜像\">3.搜索镜像</span></h4>\n</blockquote>\n<pre><code>   docker search ubuntu\n</code></pre>\n<blockquote>\n<h4><span id=\"4拉取镜像\">4.拉取镜像</span></h4>\n</blockquote>\n<pre><code>docker pull ubuntu:16.04\n</code></pre>\n<blockquote>\n<h4><span id=\"5docker-权限问题\">5.docker 权限问题</span></h4>\n<p>运行如下命令</p>\n</blockquote>\n<pre><code> sudo groupadd docker #创建docker用户组\n sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n sudo service docker restart # 重启docker服务，退出ssh,重新连接即可</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h4>1.安装环境 CentOS7</h4>\n</blockquote>\n<pre><code>  sudo yum install docker\n</code></pre>\n<blockquote>\n<h4>2.启动Docker</h4>\n</blockquote>\n<pre><code>   sudo yum systemctl start docker\n</code></pre>\n<blockquote>\n<h4>3.搜索镜像</h4>\n</blockquote>\n<pre><code>   docker search ubuntu\n</code></pre>\n<blockquote>\n<h4>4.拉取镜像</h4>\n</blockquote>\n<pre><code>docker pull ubuntu:16.04\n</code></pre>\n<blockquote>\n<h4>5.docker 权限问题</h4>\n<p>运行如下命令</p>\n</blockquote>\n<pre><code> sudo groupadd docker #创建docker用户组\n sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n sudo service docker restart # 重启docker服务，退出ssh,重新连接即可</code></pre>\n"},{"title":"JavaScript数据结构与算法-字典和哈希表","catalog":true,"url":"199.html","id":"199","date":"2019-03-10T07:56:49.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是字典？\n\n集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是\\[键，值\\] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以\\[值，值\\]的形式存储元素，字 典则是以\\[键，值\\]的形式来存储元素。字典也称作映射。\n\n#### 2\\. 手动实现Dirctionary\n\n    // 字典 Dirctionary\n    \n    class Dirctionary {\n        constructor(){\n            this.items = new Map();\n        }\n        set(key,value){\n            this.items.set(key,value);\n        }\n        get(key){\n            return this.items.get(key);\n        }\n        remove(key){\n            this.items.delete(key);\n        }\n        has(key){\n            return this.items.has(key);\n        }\n        size(){\n            return this.items.size();\n        }\n        clear(){\n            this.items = new Map();\n        }\n        values(){\n            const arr = []\n            for(let key of this.items.keys()){\n              arr.push(this.items.get(key));\n            }\n            return arr;\n        }\n    \n    }\n    \n    \n\n#### 3\\. 什么是散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。\n\n#### 4\\. 手动实现一个散列表\n\n    // 散列表\n    \n    var loseloseHashCode = function (key) {\n        var hash = 0;                          \n        for (var i = 0; i < key.length; i++) { \n            hash += key.charCodeAt(i);         \n        }\n        return hash % 37; \n    };\n    function HashTable() {\n        var table = [];\n    \n        this.put = function (key, value) {\n            var position = loseloseHashCode(key);\n            console.log(position + ' - ' + key);\n            table[position] = value; \n        };\n        this.get = function (key) {\n            return table[loseloseHashCode(key)];\n        };\n        this.remove = function (key) {\n            table[loseloseHashCode(key)] = undefined;\n        };\n    }\n    var hash = new HashTable();\n    hash.put('Gandalf', 'gandalf@email.com');\n    hash.put('John', 'johnsnow@email.com');\n    hash.put('Tyrion', 'tyrion@email.com');\n    // 19 - Gandalf\n    // 29 - John\n    // 16 - Tyrion","source":"_posts/JavaScript数据结构与算法-字典和哈希表.md","raw":"---\ntitle: JavaScript数据结构与算法-字典和哈希表\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 199.html\nid: 199\ncategories:\n  - 数据结构\ndate: 2019-03-10 15:56:49\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是字典？\n\n集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是\\[键，值\\] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以\\[值，值\\]的形式存储元素，字 典则是以\\[键，值\\]的形式来存储元素。字典也称作映射。\n\n#### 2\\. 手动实现Dirctionary\n\n    // 字典 Dirctionary\n    \n    class Dirctionary {\n        constructor(){\n            this.items = new Map();\n        }\n        set(key,value){\n            this.items.set(key,value);\n        }\n        get(key){\n            return this.items.get(key);\n        }\n        remove(key){\n            this.items.delete(key);\n        }\n        has(key){\n            return this.items.has(key);\n        }\n        size(){\n            return this.items.size();\n        }\n        clear(){\n            this.items = new Map();\n        }\n        values(){\n            const arr = []\n            for(let key of this.items.keys()){\n              arr.push(this.items.get(key));\n            }\n            return arr;\n        }\n    \n    }\n    \n    \n\n#### 3\\. 什么是散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。\n\n#### 4\\. 手动实现一个散列表\n\n    // 散列表\n    \n    var loseloseHashCode = function (key) {\n        var hash = 0;                          \n        for (var i = 0; i < key.length; i++) { \n            hash += key.charCodeAt(i);         \n        }\n        return hash % 37; \n    };\n    function HashTable() {\n        var table = [];\n    \n        this.put = function (key, value) {\n            var position = loseloseHashCode(key);\n            console.log(position + ' - ' + key);\n            table[position] = value; \n        };\n        this.get = function (key) {\n            return table[loseloseHashCode(key)];\n        };\n        this.remove = function (key) {\n            table[loseloseHashCode(key)] = undefined;\n        };\n    }\n    var hash = new HashTable();\n    hash.put('Gandalf', 'gandalf@email.com');\n    hash.put('John', 'johnsnow@email.com');\n    hash.put('Tyrion', 'tyrion@email.com');\n    // 19 - Gandalf\n    // 29 - John\n    // 16 - Tyrion","slug":"JavaScript数据结构与算法-字典和哈希表","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r450007w72sbkdvtga4","content":"<h4><span id=\"1-什么是字典\">1. 什么是字典？</span></h4>\n<p>集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。</p>\n<h4><span id=\"2-手动实现dirctionary\">2. 手动实现Dirctionary</span></h4>\n<pre><code>// 字典 Dirctionary\n\nclass Dirctionary {\n    constructor(){\n        this.items = new Map();\n    }\n    set(key,value){\n        this.items.set(key,value);\n    }\n    get(key){\n        return this.items.get(key);\n    }\n    remove(key){\n        this.items.delete(key);\n    }\n    has(key){\n        return this.items.has(key);\n    }\n    size(){\n        return this.items.size();\n    }\n    clear(){\n        this.items = new Map();\n    }\n    values(){\n        const arr = []\n        for(let key of this.items.keys()){\n          arr.push(this.items.get(key));\n        }\n        return arr;\n    }\n\n}\n</code></pre>\n<h4><span id=\"3-什么是散列表\">3. 什么是散列表</span></h4>\n<p>散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。</p>\n<h4><span id=\"4-手动实现一个散列表\">4. 手动实现一个散列表</span></h4>\n<pre><code>// 散列表\n\nvar loseloseHashCode = function (key) {\n    var hash = 0;                          \n    for (var i = 0; i &lt; key.length; i++) { \n        hash += key.charCodeAt(i);         \n    }\n    return hash % 37; \n};\nfunction HashTable() {\n    var table = [];\n\n    this.put = function (key, value) {\n        var position = loseloseHashCode(key);\n        console.log(position + ' - ' + key);\n        table[position] = value; \n    };\n    this.get = function (key) {\n        return table[loseloseHashCode(key)];\n    };\n    this.remove = function (key) {\n        table[loseloseHashCode(key)] = undefined;\n    };\n}\nvar hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是字典？</h4>\n<p>集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。</p>\n<h4>2. 手动实现Dirctionary</h4>\n<pre><code>// 字典 Dirctionary\n\nclass Dirctionary {\n    constructor(){\n        this.items = new Map();\n    }\n    set(key,value){\n        this.items.set(key,value);\n    }\n    get(key){\n        return this.items.get(key);\n    }\n    remove(key){\n        this.items.delete(key);\n    }\n    has(key){\n        return this.items.has(key);\n    }\n    size(){\n        return this.items.size();\n    }\n    clear(){\n        this.items = new Map();\n    }\n    values(){\n        const arr = []\n        for(let key of this.items.keys()){\n          arr.push(this.items.get(key));\n        }\n        return arr;\n    }\n\n}\n</code></pre>\n<h4>3. 什么是散列表</h4>\n<p>散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。</p>\n<h4>4. 手动实现一个散列表</h4>\n<pre><code>// 散列表\n\nvar loseloseHashCode = function (key) {\n    var hash = 0;                          \n    for (var i = 0; i &lt; key.length; i++) { \n        hash += key.charCodeAt(i);         \n    }\n    return hash % 37; \n};\nfunction HashTable() {\n    var table = [];\n\n    this.put = function (key, value) {\n        var position = loseloseHashCode(key);\n        console.log(position + ' - ' + key);\n        table[position] = value; \n    };\n    this.get = function (key) {\n        return table[loseloseHashCode(key)];\n    };\n    this.remove = function (key) {\n        table[loseloseHashCode(key)] = undefined;\n    };\n}\nvar hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion</code></pre>\n"},{"title":"GraphQL 简介","catalog":true,"url":"12.html","id":"12","date":"2019-02-18T08:12:40.000Z","subtitle":null,"header-img":null,"_content":"\n### GraphQL 简介\n\n![](http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png)\n\n#### 1\\. 什么是GraphQL ?\n\n1.  GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。\n    \n2.  GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。\n    \n3.  GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n    \n\n#### 2\\. GraphQL 有什么特点？\n\n1.  请求的数据，不多不少 \\> 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。\n2.  获取多个资源，只用一个请求。\n3.  描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。\n\n#### 3\\. GraphQL与Restful API 对比\n\n1.  restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。\n2.  restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。\n3.  restful用不同的url来区分资源，graphql用类型区分资源。\n\n#### 4\\. 构建一个GraphQL简单的服务端（Nodejs Express）\n\n1.  定义查询的Schema和类型\n\n       const Schema = buildSchema(\n       `\n        type Query {\n            hello: String\n        }\n       `);\n    \n\n2.  定义查询对应的处理器\n\n    const rootValue = {\n        hello: ()=>{\n            return \"hello graphql!\"\n        }\n    }\n    \n    \n\n3.  结合Schema和对应的处理器\n\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true // 打开graphql语言查询调试图形界面\n    }))\n    \n\n4.  打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句\n\n      nodemon app.js\n    \n\n    query {\n        hello\n    }\n    \n\n> 结果如图 [![](https://i.loli.net/2019/02/18/5c6a69c78a41b.png)](https://i.loli.net/2019/02/18/5c6a69c78a41b.png) 源码文件 app.js\n\n    // npm install express exprss-graphql graphql --save\n    const express = require('express');\n    const graphqlHTTP = require('express-graphql');\n    const { buildSchema } = require('graphql');\n    const app = express();\n    const schema = buildSchema(`\n        type Query {\n            hello: String\n        }\n       `);\n    const rootValue = {hello: () => \"hello graphql\"};\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    app.listen(3000, ()=>{\n        console.log(\"Now browser to localhost:3000/graphql!\");\n    })","source":"_posts/GraphQL 简介.md","raw":"---\ntitle: GraphQL 简介\ncatalog: true\ntags:\n  - graphql\nurl: 12.html\nid: 12\ncategories:\n  - GraphQL\ndate: 2019-02-18 16:12:40\nsubtitle:\nheader-img:\n---\n\n### GraphQL 简介\n\n![](http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png)\n\n#### 1\\. 什么是GraphQL ?\n\n1.  GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。\n    \n2.  GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。\n    \n3.  GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n    \n\n#### 2\\. GraphQL 有什么特点？\n\n1.  请求的数据，不多不少 \\> 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。\n2.  获取多个资源，只用一个请求。\n3.  描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。\n\n#### 3\\. GraphQL与Restful API 对比\n\n1.  restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。\n2.  restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。\n3.  restful用不同的url来区分资源，graphql用类型区分资源。\n\n#### 4\\. 构建一个GraphQL简单的服务端（Nodejs Express）\n\n1.  定义查询的Schema和类型\n\n       const Schema = buildSchema(\n       `\n        type Query {\n            hello: String\n        }\n       `);\n    \n\n2.  定义查询对应的处理器\n\n    const rootValue = {\n        hello: ()=>{\n            return \"hello graphql!\"\n        }\n    }\n    \n    \n\n3.  结合Schema和对应的处理器\n\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true // 打开graphql语言查询调试图形界面\n    }))\n    \n\n4.  打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句\n\n      nodemon app.js\n    \n\n    query {\n        hello\n    }\n    \n\n> 结果如图 [![](https://i.loli.net/2019/02/18/5c6a69c78a41b.png)](https://i.loli.net/2019/02/18/5c6a69c78a41b.png) 源码文件 app.js\n\n    // npm install express exprss-graphql graphql --save\n    const express = require('express');\n    const graphqlHTTP = require('express-graphql');\n    const { buildSchema } = require('graphql');\n    const app = express();\n    const schema = buildSchema(`\n        type Query {\n            hello: String\n        }\n       `);\n    const rootValue = {hello: () => \"hello graphql\"};\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    app.listen(3000, ()=>{\n        console.log(\"Now browser to localhost:3000/graphql!\");\n    })","slug":"GraphQL 简介","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r470009w72slsglxwcb","content":"<h3><span id=\"graphql-简介\">GraphQL 简介</span></h3>\n<p><img src=\"http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png\" alt></p>\n<h4><span id=\"1-什么是graphql\">1. 什么是GraphQL ?</span></h4>\n<ol>\n<li>\n<p>GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。</p>\n</li>\n<li>\n<p>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</p>\n</li>\n<li>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>\n</li>\n</ol>\n<h4><span id=\"2-graphql-有什么特点\">2. GraphQL 有什么特点？</span></h4>\n<ol>\n<li>请求的数据，不多不少 &gt; 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。</li>\n<li>获取多个资源，只用一个请求。</li>\n<li>描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。</li>\n</ol>\n<h4><span id=\"3-graphql与restful-api-对比\">3. GraphQL与Restful API 对比</span></h4>\n<ol>\n<li>restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。</li>\n<li>restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。</li>\n<li>restful用不同的url来区分资源，graphql用类型区分资源。</li>\n</ol>\n<h4><span id=\"4-构建一个graphql简单的服务端nodejs-express\">4. 构建一个GraphQL简单的服务端（Nodejs Express）</span></h4>\n<ol>\n<li>\n<p>定义查询的Schema和类型</p>\n<p>const Schema = buildSchema(<br>\n<code>type Query { hello: String }</code>);</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>定义查询对应的处理器</p>\n<p>const rootValue = {<br>\nhello: ()=&gt;{<br>\nreturn “hello graphql!”<br>\n}<br>\n}</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>结合Schema和对应的处理器</p>\n<p>app.use(’/graphql’, graphqlHTTP({<br>\nschema,<br>\nrootValue,<br>\ngraphiql: true // 打开graphql语言查询调试图形界面<br>\n}))</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句</p>\n<p>nodemon app.js</p>\n</li>\n</ol>\n<pre><code>query {\n    hello\n}\n</code></pre>\n<blockquote>\n<p>结果如图 <a href=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" alt></a> 源码文件 app.js</p>\n</blockquote>\n<pre><code>// npm install express exprss-graphql graphql --save\nconst express = require('express');\nconst graphqlHTTP = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n    type Query {\n        hello: String\n    }\n   `);\nconst rootValue = {hello: () =&gt; &quot;hello graphql&quot;};\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\napp.listen(3000, ()=&gt;{\n    console.log(&quot;Now browser to localhost:3000/graphql!&quot;);\n})</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3>GraphQL 简介</h3>\n<p><img src=\"http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png\" alt></p>\n<h4>1. 什么是GraphQL ?</h4>\n<ol>\n<li>\n<p>GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。</p>\n</li>\n<li>\n<p>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</p>\n</li>\n<li>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>\n</li>\n</ol>\n<h4>2. GraphQL 有什么特点？</h4>\n<ol>\n<li>请求的数据，不多不少 &gt; 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。</li>\n<li>获取多个资源，只用一个请求。</li>\n<li>描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。</li>\n</ol>\n<h4>3. GraphQL与Restful API 对比</h4>\n<ol>\n<li>restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。</li>\n<li>restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。</li>\n<li>restful用不同的url来区分资源，graphql用类型区分资源。</li>\n</ol>\n<h4>4. 构建一个GraphQL简单的服务端（Nodejs Express）</h4>\n<ol>\n<li>\n<p>定义查询的Schema和类型</p>\n<p>const Schema = buildSchema(<br>\n<code>type Query { hello: String }</code>);</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>定义查询对应的处理器</p>\n<p>const rootValue = {<br>\nhello: ()=&gt;{<br>\nreturn “hello graphql!”<br>\n}<br>\n}</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>结合Schema和对应的处理器</p>\n<p>app.use(’/graphql’, graphqlHTTP({<br>\nschema,<br>\nrootValue,<br>\ngraphiql: true // 打开graphql语言查询调试图形界面<br>\n}))</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句</p>\n<p>nodemon app.js</p>\n</li>\n</ol>\n<pre><code>query {\n    hello\n}\n</code></pre>\n<blockquote>\n<p>结果如图 <a href=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" alt></a> 源码文件 app.js</p>\n</blockquote>\n<pre><code>// npm install express exprss-graphql graphql --save\nconst express = require('express');\nconst graphqlHTTP = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n    type Query {\n        hello: String\n    }\n   `);\nconst rootValue = {hello: () =&gt; &quot;hello graphql&quot;};\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\napp.listen(3000, ()=&gt;{\n    console.log(&quot;Now browser to localhost:3000/graphql!&quot;);\n})</code></pre>\n"},{"title":"GraphQL入门之GraphQL的查询","catalog":true,"url":"69.html","id":"69","date":"2019-02-19T05:18:01.000Z","subtitle":null,"header-img":null,"_content":"\n#### \n\nGraphQL入门之GraphQL的查询\n\n![](http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&fm=26&gp=0.jpg)\n\n#### 先附上源代码文件\n\n> app.js\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    \n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n\n> 然后运行\n\n     nodemon app.js\n    \n\n> 打开游览器访问 localhost:3000/graphql\n\n#### 一. 字段（Fields）\n\n> 1.  简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFields{\n     hello\n    }\n    \n\n> 在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/2.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFieldsObject {\n      randomUser {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 二. 参数（Arguments）\n\n> 即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/8.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n    \n\n#### 三. 别名（Aliases）\n\n> 你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/5.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail: userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 四. 片段（Fragments）\n\n> 假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/6.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail:userInfo(id: 10001) {\n        ...useItem\n      }\n    }\n    \n    fragment useItem on User {\n      name\n      age\n      id\n      gender\n    }\n    \n    \n\n#### 五. 变量（Variables）\n\n> 目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：\n\n1.  使用 $variableName 替代查询中的静态值。\n2.  声明 $variableName 为查询接受的变量之一。\n3.  将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/9.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n    }\n    \n\n#### 六. 操作名称（Operation name）\n\n> 这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。\n\n#### 七. 指令（Directives）\n\n> 我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/10.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001,$showId:Boolean=false){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n      userList: users{\n        name @include(if:$showId)\n        age\n        gender\n      }\n    }\n    \n\n> #### 更多学习请参考 [GraphQL官网](http://graphql.cn/)","source":"_posts/GraphQL入门之GraphQL的查询.md","raw":"---\ntitle: GraphQL入门之GraphQL的查询\ncatalog: true\ntags:\n  - graphql\nurl: 69.html\nid: 69\ncategories:\n  - GraphQL\ndate: 2019-02-19 13:18:01\nsubtitle:\nheader-img:\n---\n\n#### \n\nGraphQL入门之GraphQL的查询\n\n![](http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&fm=26&gp=0.jpg)\n\n#### 先附上源代码文件\n\n> app.js\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    \n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n\n> 然后运行\n\n     nodemon app.js\n    \n\n> 打开游览器访问 localhost:3000/graphql\n\n#### 一. 字段（Fields）\n\n> 1.  简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFields{\n     hello\n    }\n    \n\n> 在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/2.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFieldsObject {\n      randomUser {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 二. 参数（Arguments）\n\n> 即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/8.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n    \n\n#### 三. 别名（Aliases）\n\n> 你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/5.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail: userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 四. 片段（Fragments）\n\n> 假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/6.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail:userInfo(id: 10001) {\n        ...useItem\n      }\n    }\n    \n    fragment useItem on User {\n      name\n      age\n      id\n      gender\n    }\n    \n    \n\n#### 五. 变量（Variables）\n\n> 目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：\n\n1.  使用 $variableName 替代查询中的静态值。\n2.  声明 $variableName 为查询接受的变量之一。\n3.  将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/9.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n    }\n    \n\n#### 六. 操作名称（Operation name）\n\n> 这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。\n\n#### 七. 指令（Directives）\n\n> 我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/10.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001,$showId:Boolean=false){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n      userList: users{\n        name @include(if:$showId)\n        age\n        gender\n      }\n    }\n    \n\n> #### 更多学习请参考 [GraphQL官网](http://graphql.cn/)","slug":"GraphQL入门之GraphQL的查询","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r49000aw72stgxo9za2","content":"<h4><span id></span></h4>\n<p>GraphQL入门之GraphQL的查询</p>\n<p><img src=\"http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h4><span id=\"先附上源代码文件\">先附上源代码文件</span></h4>\n<blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\n\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<p>然后运行</p>\n</blockquote>\n<pre><code> nodemon app.js\n</code></pre>\n<blockquote>\n<p>打开游览器访问 localhost:3000/graphql</p>\n</blockquote>\n<h4><span id=\"一-字段fields\">一. 字段（Fields）</span></h4>\n<blockquote>\n<ol>\n<li>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFields{\n hello\n}\n</code></pre>\n<blockquote>\n<p>在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/2.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFieldsObject {\n  randomUser {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"二-参数arguments\">二. 参数（Arguments）</span></h4>\n<blockquote>\n<p>即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/8.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"三-别名aliases\">三. 别名（Aliases）</span></h4>\n<blockquote>\n<p>你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/5.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail: userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"四-片段fragments\">四. 片段（Fragments）</span></h4>\n<blockquote>\n<p>假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/6.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail:userInfo(id: 10001) {\n    ...useItem\n  }\n}\n\nfragment useItem on User {\n  name\n  age\n  id\n  gender\n}\n</code></pre>\n<h4><span id=\"五-变量variables\">五. 变量（Variables）</span></h4>\n<blockquote>\n<p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：</p>\n</blockquote>\n<ol>\n<li>使用 $variableName 替代查询中的静态值。</li>\n<li>声明 $variableName 为查询接受的变量之一。</li>\n<li>将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/9.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n}\n</code></pre>\n<h4><span id=\"六-操作名称operation-name\">六. 操作名称（Operation name）</span></h4>\n<blockquote>\n<p>这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。</p>\n</blockquote>\n<h4><span id=\"七-指令directives\">七. 指令（Directives）</span></h4>\n<blockquote>\n<p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/10.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001,$showId:Boolean=false){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n  userList: users{\n    name @include(if:$showId)\n    age\n    gender\n  }\n}\n</code></pre>\n<blockquote>\n<h4><span id=\"更多学习请参考-graphql官网\">更多学习请参考 </span></h4>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4></h4>\n<p>GraphQL入门之GraphQL的查询</p>\n<p><img src=\"http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h4>先附上源代码文件</h4>\n<blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\n\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<p>然后运行</p>\n</blockquote>\n<pre><code> nodemon app.js\n</code></pre>\n<blockquote>\n<p>打开游览器访问 localhost:3000/graphql</p>\n</blockquote>\n<h4>一. 字段（Fields）</h4>\n<blockquote>\n<ol>\n<li>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFields{\n hello\n}\n</code></pre>\n<blockquote>\n<p>在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/2.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFieldsObject {\n  randomUser {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>二. 参数（Arguments）</h4>\n<blockquote>\n<p>即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/8.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>三. 别名（Aliases）</h4>\n<blockquote>\n<p>你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/5.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail: userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>四. 片段（Fragments）</h4>\n<blockquote>\n<p>假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/6.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail:userInfo(id: 10001) {\n    ...useItem\n  }\n}\n\nfragment useItem on User {\n  name\n  age\n  id\n  gender\n}\n</code></pre>\n<h4>五. 变量（Variables）</h4>\n<blockquote>\n<p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：</p>\n</blockquote>\n<ol>\n<li>使用 $variableName 替代查询中的静态值。</li>\n<li>声明 $variableName 为查询接受的变量之一。</li>\n<li>将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/9.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n}\n</code></pre>\n<h4>六. 操作名称（Operation name）</h4>\n<blockquote>\n<p>这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。</p>\n</blockquote>\n<h4>七. 指令（Directives）</h4>\n<blockquote>\n<p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/10.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001,$showId:Boolean=false){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n  userList: users{\n    name @include(if:$showId)\n    age\n    gender\n  }\n}\n</code></pre>\n<blockquote>\n<h4>更多学习请参考 <a href=\"http://graphql.cn/\" target=\"_blank\" rel=\"noopener\">GraphQL官网</a></h4>\n</blockquote>\n"},{"title":"JavaScript数据结构与算法-栈（Stack）","catalog":true,"url":"181.html","id":"181","date":"2019-03-06T09:51:10.000Z","subtitle":null,"header-img":null,"_content":"\n### JavaScript 数据结构-栈\n\n#### 1\\. 什么是栈？\n\n栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #\n\n#### 2\\. 用JavaScript实现一个简单的栈\n\n    class Stack {\n      constructor() {\n        this.items = []\n      }\n      // 进栈\n      push(item) {\n        this.items.push(item);\n      }\n      // 出栈\n      pop() {\n        return this.items.pop();\n      }\n      // 返回栈顶的元素\n      peek() {\n        return this.items[this.items.length - 1]\n      }\n      // 判断栈是否为空\n      isEmpty() {\n        return this.items.length == 0;\n      }\n      // 移除栈里的所有元素\n      clear() {\n        this.items = []\n      }\n      // 返回栈的长度\n      size() {\n        return this.items.length;\n      },\n      print() {\n          return this.items.toString();\n      }\n    }\n    \n    let stack1 = new Stack();\n    console.log(stack1);  // Stack { items: [] }\n    \n    \n\n#### 3\\. 用栈解决问题\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。\n\n> 1.  十进制转二进制\n\n    function divideBy2(decNumber){\n        let stack = new Stack();\n        let binaryString = \"\";\n        let rem = \"\";\n        while(decNumber > 0){\n            rem = Math.floor(decNumber % 2);\n            stack.push(rem);\n            decNumber = Math.floor(decNumber / 2);\n        }\n        while(!stack.isEmpty()){\n            binaryString += stack.pop().toString() \n        }\n        return binaryString;\n    }\n    console.log(divideBy2(5)); // 101\n    \n\n> 2.  十进制转任意进制\n\n    function baseConverter(decNumber, base) {\n      let stack = new Stack();\n      let binaryString = '';\n      let rem = '';\n      const DIGITS = '0123456789ABCDEF';\n      while (decNumber > 0) {\n        rem = Math.floor(decNumber % base);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    \n      }\n      while (!stack.isEmpty()) {\n        binaryString += DIGITS[stack.pop()]\n      }\n      return binaryString;\n    }\n    console.log(baseConverter(455, 15)); //137EDB825","source":"_posts/JavaScript数据结构与算法-栈（Stack）.md","raw":"---\ntitle: JavaScript数据结构与算法-栈（Stack）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 181.html\nid: 181\ncategories:\n  - 数据结构\ndate: 2019-03-06 17:51:10\nsubtitle:\nheader-img:\n---\n\n### JavaScript 数据结构-栈\n\n#### 1\\. 什么是栈？\n\n栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #\n\n#### 2\\. 用JavaScript实现一个简单的栈\n\n    class Stack {\n      constructor() {\n        this.items = []\n      }\n      // 进栈\n      push(item) {\n        this.items.push(item);\n      }\n      // 出栈\n      pop() {\n        return this.items.pop();\n      }\n      // 返回栈顶的元素\n      peek() {\n        return this.items[this.items.length - 1]\n      }\n      // 判断栈是否为空\n      isEmpty() {\n        return this.items.length == 0;\n      }\n      // 移除栈里的所有元素\n      clear() {\n        this.items = []\n      }\n      // 返回栈的长度\n      size() {\n        return this.items.length;\n      },\n      print() {\n          return this.items.toString();\n      }\n    }\n    \n    let stack1 = new Stack();\n    console.log(stack1);  // Stack { items: [] }\n    \n    \n\n#### 3\\. 用栈解决问题\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。\n\n> 1.  十进制转二进制\n\n    function divideBy2(decNumber){\n        let stack = new Stack();\n        let binaryString = \"\";\n        let rem = \"\";\n        while(decNumber > 0){\n            rem = Math.floor(decNumber % 2);\n            stack.push(rem);\n            decNumber = Math.floor(decNumber / 2);\n        }\n        while(!stack.isEmpty()){\n            binaryString += stack.pop().toString() \n        }\n        return binaryString;\n    }\n    console.log(divideBy2(5)); // 101\n    \n\n> 2.  十进制转任意进制\n\n    function baseConverter(decNumber, base) {\n      let stack = new Stack();\n      let binaryString = '';\n      let rem = '';\n      const DIGITS = '0123456789ABCDEF';\n      while (decNumber > 0) {\n        rem = Math.floor(decNumber % base);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    \n      }\n      while (!stack.isEmpty()) {\n        binaryString += DIGITS[stack.pop()]\n      }\n      return binaryString;\n    }\n    console.log(baseConverter(455, 15)); //137EDB825","slug":"JavaScript数据结构与算法-栈（Stack）","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4c000dw72sia380sh0","content":"<h3><span id=\"javascript-数据结构-栈\">JavaScript 数据结构-栈</span></h3>\n<h4><span id=\"1-什么是栈\">1. 什么是栈？</span></h4>\n<p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #</p>\n<h4><span id=\"2-用javascript实现一个简单的栈\">2. 用JavaScript实现一个简单的栈</span></h4>\n<pre><code>class Stack {\n  constructor() {\n    this.items = []\n  }\n  // 进栈\n  push(item) {\n    this.items.push(item);\n  }\n  // 出栈\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n  // 判断栈是否为空\n  isEmpty() {\n    return this.items.length == 0;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = []\n  }\n  // 返回栈的长度\n  size() {\n    return this.items.length;\n  },\n  print() {\n      return this.items.toString();\n  }\n}\n\nlet stack1 = new Stack();\nconsole.log(stack1);  // Stack { items: [] }\n</code></pre>\n<h4><span id=\"3-用栈解决问题\">3. 用栈解决问题</span></h4>\n<p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。</p>\n<blockquote>\n<ol>\n<li>十进制转二进制</li>\n</ol>\n</blockquote>\n<pre><code>function divideBy2(decNumber){\n    let stack = new Stack();\n    let binaryString = &quot;&quot;;\n    let rem = &quot;&quot;;\n    while(decNumber &gt; 0){\n        rem = Math.floor(decNumber % 2);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    }\n    while(!stack.isEmpty()){\n        binaryString += stack.pop().toString() \n    }\n    return binaryString;\n}\nconsole.log(divideBy2(5)); // 101\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>十进制转任意进制</li>\n</ol>\n</blockquote>\n<pre><code>function baseConverter(decNumber, base) {\n  let stack = new Stack();\n  let binaryString = '';\n  let rem = '';\n  const DIGITS = '0123456789ABCDEF';\n  while (decNumber &gt; 0) {\n    rem = Math.floor(decNumber % base);\n    stack.push(rem);\n    decNumber = Math.floor(decNumber / 2);\n\n  }\n  while (!stack.isEmpty()) {\n    binaryString += DIGITS[stack.pop()]\n  }\n  return binaryString;\n}\nconsole.log(baseConverter(455, 15)); //137EDB825</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3>JavaScript 数据结构-栈</h3>\n<h4>1. 什么是栈？</h4>\n<p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #</p>\n<h4>2. 用JavaScript实现一个简单的栈</h4>\n<pre><code>class Stack {\n  constructor() {\n    this.items = []\n  }\n  // 进栈\n  push(item) {\n    this.items.push(item);\n  }\n  // 出栈\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n  // 判断栈是否为空\n  isEmpty() {\n    return this.items.length == 0;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = []\n  }\n  // 返回栈的长度\n  size() {\n    return this.items.length;\n  },\n  print() {\n      return this.items.toString();\n  }\n}\n\nlet stack1 = new Stack();\nconsole.log(stack1);  // Stack { items: [] }\n</code></pre>\n<h4>3. 用栈解决问题</h4>\n<p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。</p>\n<blockquote>\n<ol>\n<li>十进制转二进制</li>\n</ol>\n</blockquote>\n<pre><code>function divideBy2(decNumber){\n    let stack = new Stack();\n    let binaryString = &quot;&quot;;\n    let rem = &quot;&quot;;\n    while(decNumber &gt; 0){\n        rem = Math.floor(decNumber % 2);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    }\n    while(!stack.isEmpty()){\n        binaryString += stack.pop().toString() \n    }\n    return binaryString;\n}\nconsole.log(divideBy2(5)); // 101\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>十进制转任意进制</li>\n</ol>\n</blockquote>\n<pre><code>function baseConverter(decNumber, base) {\n  let stack = new Stack();\n  let binaryString = '';\n  let rem = '';\n  const DIGITS = '0123456789ABCDEF';\n  while (decNumber &gt; 0) {\n    rem = Math.floor(decNumber % base);\n    stack.push(rem);\n    decNumber = Math.floor(decNumber / 2);\n\n  }\n  while (!stack.isEmpty()) {\n    binaryString += DIGITS[stack.pop()]\n  }\n  return binaryString;\n}\nconsole.log(baseConverter(455, 15)); //137EDB825</code></pre>\n"},{"title":"JavaScript数据结构与算法-链表（LinkedList）","catalog":true,"url":"191.html","id":"191","date":"2019-03-07T03:52:47.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1.什么是链表？\n\n要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的\\[\\]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png)\n\n#### 2\\. 实现一个链表结构（单向链表）\n\n    // JavaScript 数据结构值列表\n    function LinkedList() {\n      let Node = function (element) {\n        this.element = element;\n        this.next = null;\n      }\n      let length = 0;\n      let head = null;\n      // 添加元素\n      this.append = function (element) {\n        let node = new Node(element);\n        let current;\n        if (head == null) {\n          head = node\n        } else {\n          current = head;\n          while (current.next) {\n            current = current.next\n          }\n          current.next = node\n        }\n        length++;\n      }\n      // 插入元素\n      this.insert = function (position, element) {\n        if (position > -1 && position <= length) {\n          let node = new Node(element);\n          let current = head;\n          let pervious;\n          let index = 0;\n          if (position == 0) {\n            node.next = current;\n            head = node;\n          } else {\n            while (index++ < position) {\n              pervious = current;\n              current = current.next;\n            }\n            node.next = current;\n            pervious.next = node;\n            length++;\n            return true;\n          }\n        } else {\n          return false;\n        }\n      }\n      // 从列表中移除一项\n      this.getHead = function () {\n        return head;\n      }\n      // 从列表移除指定的一项\n      this.removeAt = function (position) {\n        if (position > -1 && position < length) {\n          let current = head;\n          let previous;\n          let index = 0;\n          // 边界检查合法的情况下\n          if (position == 0) {\n            head = current.next;\n          } else {\n            while (index++ < position) {\n              previous = current;\n              current = current.next;\n            }\n            previous.next = current.next;\n          }\n          length--;\n          return current.element;\n        } else {\n          return false;\n        }\n      }\n      // 返回元素在列表中的索引\n      this.indexOf = function (element) {\n        let current = head;\n        index = 0;\n        while (current) {\n          if (current.element === element) {\n            return index;\n          }\n          index++;\n          current = current.next();\n        }\n        return -1;\n      }\n      // 判断列表是否为空\n      this.isEmpty = function () {\n        return length === 0;\n      }\n      // 获取列表的长度\n      this.size = function () {\n        return length;\n      }\n      // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n      this.toString = function () {\n        let current = head,\n          string = '';\n        while (current) {\n          string += current.element + (current.next ? 'n' : '');\n          current = current.next;\n        }\n        return string;\n      }\n      this.remove = function (element) {\n        let index = this.indexOf(element);\n        return this.removeAt(index);\n      }\n    }\n    \n    let list = new LinkedList();\n    list.append(15);\n    list.append(14);\n    list.append(13);\n    list.append(13);\n    \n    console.log(list);\n    console.log(list.toString()); // 15n14n13n13\n    \n    \n\n#### 3 .双向链表\n\n链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/222222222.png)\n\n#### 4.循环链表\n\n`循环链表`可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/3333333.png)\n\n#### 5\\. 双向循坏列表\n\n双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/444444.png)","source":"_posts/JavaScript数据结构与算法-链表（LinkedList）.md","raw":"---\ntitle: JavaScript数据结构与算法-链表（LinkedList）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 191.html\nid: 191\ncategories:\n  - 数据结构\ndate: 2019-03-07 11:52:47\nsubtitle:\nheader-img:\n---\n\n#### 1.什么是链表？\n\n要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的\\[\\]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png)\n\n#### 2\\. 实现一个链表结构（单向链表）\n\n    // JavaScript 数据结构值列表\n    function LinkedList() {\n      let Node = function (element) {\n        this.element = element;\n        this.next = null;\n      }\n      let length = 0;\n      let head = null;\n      // 添加元素\n      this.append = function (element) {\n        let node = new Node(element);\n        let current;\n        if (head == null) {\n          head = node\n        } else {\n          current = head;\n          while (current.next) {\n            current = current.next\n          }\n          current.next = node\n        }\n        length++;\n      }\n      // 插入元素\n      this.insert = function (position, element) {\n        if (position > -1 && position <= length) {\n          let node = new Node(element);\n          let current = head;\n          let pervious;\n          let index = 0;\n          if (position == 0) {\n            node.next = current;\n            head = node;\n          } else {\n            while (index++ < position) {\n              pervious = current;\n              current = current.next;\n            }\n            node.next = current;\n            pervious.next = node;\n            length++;\n            return true;\n          }\n        } else {\n          return false;\n        }\n      }\n      // 从列表中移除一项\n      this.getHead = function () {\n        return head;\n      }\n      // 从列表移除指定的一项\n      this.removeAt = function (position) {\n        if (position > -1 && position < length) {\n          let current = head;\n          let previous;\n          let index = 0;\n          // 边界检查合法的情况下\n          if (position == 0) {\n            head = current.next;\n          } else {\n            while (index++ < position) {\n              previous = current;\n              current = current.next;\n            }\n            previous.next = current.next;\n          }\n          length--;\n          return current.element;\n        } else {\n          return false;\n        }\n      }\n      // 返回元素在列表中的索引\n      this.indexOf = function (element) {\n        let current = head;\n        index = 0;\n        while (current) {\n          if (current.element === element) {\n            return index;\n          }\n          index++;\n          current = current.next();\n        }\n        return -1;\n      }\n      // 判断列表是否为空\n      this.isEmpty = function () {\n        return length === 0;\n      }\n      // 获取列表的长度\n      this.size = function () {\n        return length;\n      }\n      // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n      this.toString = function () {\n        let current = head,\n          string = '';\n        while (current) {\n          string += current.element + (current.next ? 'n' : '');\n          current = current.next;\n        }\n        return string;\n      }\n      this.remove = function (element) {\n        let index = this.indexOf(element);\n        return this.removeAt(index);\n      }\n    }\n    \n    let list = new LinkedList();\n    list.append(15);\n    list.append(14);\n    list.append(13);\n    list.append(13);\n    \n    console.log(list);\n    console.log(list.toString()); // 15n14n13n13\n    \n    \n\n#### 3 .双向链表\n\n链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/222222222.png)\n\n#### 4.循环链表\n\n`循环链表`可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/3333333.png)\n\n#### 5\\. 双向循坏列表\n\n双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/444444.png)","slug":"JavaScript数据结构与算法-链表（LinkedList）","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4m000ew72sepo36urk","content":"<h4><span id=\"1什么是链表\">1.什么是链表？</span></h4>\n<p>要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png\" alt></p>\n<h4><span id=\"2-实现一个链表结构单向链表\">2. 实现一个链表结构（单向链表）</span></h4>\n<pre><code>// JavaScript 数据结构值列表\nfunction LinkedList() {\n  let Node = function (element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head = null;\n  // 添加元素\n  this.append = function (element) {\n    let node = new Node(element);\n    let current;\n    if (head == null) {\n      head = node\n    } else {\n      current = head;\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n    }\n    length++;\n  }\n  // 插入元素\n  this.insert = function (position, element) {\n    if (position &gt; -1 &amp;&amp; position &lt;= length) {\n      let node = new Node(element);\n      let current = head;\n      let pervious;\n      let index = 0;\n      if (position == 0) {\n        node.next = current;\n        head = node;\n      } else {\n        while (index++ &lt; position) {\n          pervious = current;\n          current = current.next;\n        }\n        node.next = current;\n        pervious.next = node;\n        length++;\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  // 从列表中移除一项\n  this.getHead = function () {\n    return head;\n  }\n  // 从列表移除指定的一项\n  this.removeAt = function (position) {\n    if (position &gt; -1 &amp;&amp; position &lt; length) {\n      let current = head;\n      let previous;\n      let index = 0;\n      // 边界检查合法的情况下\n      if (position == 0) {\n        head = current.next;\n      } else {\n        while (index++ &lt; position) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      length--;\n      return current.element;\n    } else {\n      return false;\n    }\n  }\n  // 返回元素在列表中的索引\n  this.indexOf = function (element) {\n    let current = head;\n    index = 0;\n    while (current) {\n      if (current.element === element) {\n        return index;\n      }\n      index++;\n      current = current.next();\n    }\n    return -1;\n  }\n  // 判断列表是否为空\n  this.isEmpty = function () {\n    return length === 0;\n  }\n  // 获取列表的长度\n  this.size = function () {\n    return length;\n  }\n  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n  this.toString = function () {\n    let current = head,\n      string = '';\n    while (current) {\n      string += current.element + (current.next ? 'n' : '');\n      current = current.next;\n    }\n    return string;\n  }\n  this.remove = function (element) {\n    let index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n}\n\nlet list = new LinkedList();\nlist.append(15);\nlist.append(14);\nlist.append(13);\nlist.append(13);\n\nconsole.log(list);\nconsole.log(list.toString()); // 15n14n13n13\n</code></pre>\n<h4><span id=\"3-双向链表\">3 .双向链表</span></h4>\n<p>链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/222222222.png\" alt></p>\n<h4><span id=\"4循环链表\">4.循环链表</span></h4>\n<p><code>循环链表</code>可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333.png\" alt></p>\n<h4><span id=\"5-双向循坏列表\">5. 双向循坏列表</span></h4>\n<p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h4>1.什么是链表？</h4>\n<p>要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png\" alt></p>\n<h4>2. 实现一个链表结构（单向链表）</h4>\n<pre><code>// JavaScript 数据结构值列表\nfunction LinkedList() {\n  let Node = function (element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head = null;\n  // 添加元素\n  this.append = function (element) {\n    let node = new Node(element);\n    let current;\n    if (head == null) {\n      head = node\n    } else {\n      current = head;\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n    }\n    length++;\n  }\n  // 插入元素\n  this.insert = function (position, element) {\n    if (position &gt; -1 &amp;&amp; position &lt;= length) {\n      let node = new Node(element);\n      let current = head;\n      let pervious;\n      let index = 0;\n      if (position == 0) {\n        node.next = current;\n        head = node;\n      } else {\n        while (index++ &lt; position) {\n          pervious = current;\n          current = current.next;\n        }\n        node.next = current;\n        pervious.next = node;\n        length++;\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  // 从列表中移除一项\n  this.getHead = function () {\n    return head;\n  }\n  // 从列表移除指定的一项\n  this.removeAt = function (position) {\n    if (position &gt; -1 &amp;&amp; position &lt; length) {\n      let current = head;\n      let previous;\n      let index = 0;\n      // 边界检查合法的情况下\n      if (position == 0) {\n        head = current.next;\n      } else {\n        while (index++ &lt; position) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      length--;\n      return current.element;\n    } else {\n      return false;\n    }\n  }\n  // 返回元素在列表中的索引\n  this.indexOf = function (element) {\n    let current = head;\n    index = 0;\n    while (current) {\n      if (current.element === element) {\n        return index;\n      }\n      index++;\n      current = current.next();\n    }\n    return -1;\n  }\n  // 判断列表是否为空\n  this.isEmpty = function () {\n    return length === 0;\n  }\n  // 获取列表的长度\n  this.size = function () {\n    return length;\n  }\n  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n  this.toString = function () {\n    let current = head,\n      string = '';\n    while (current) {\n      string += current.element + (current.next ? 'n' : '');\n      current = current.next;\n    }\n    return string;\n  }\n  this.remove = function (element) {\n    let index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n}\n\nlet list = new LinkedList();\nlist.append(15);\nlist.append(14);\nlist.append(13);\nlist.append(13);\n\nconsole.log(list);\nconsole.log(list.toString()); // 15n14n13n13\n</code></pre>\n<h4>3 .双向链表</h4>\n<p>链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/222222222.png\" alt></p>\n<h4>4.循环链表</h4>\n<p><code>循环链表</code>可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333.png\" alt></p>\n<h4>5. 双向循坏列表</h4>\n<p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444.png\" alt></p>\n"},{"title":"TypeScript 学习第一章 初识TypeScript","catalog":true,"date":"2019-08-14T13:37:05.000Z","subtitle":null,"header-img":"http://www.3dmgame.com/uploads/allimg/170612/1316-1F6121I945.jpg","_content":"\n# 初识 TypeScript\n\nTypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。\n\n## TypeScript 的特点\n\nTypeScript 主要有 3 大特点：\n\n- **始于JavaScript，归于JavaScript**\n\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。\n\n- **强大的工具构建大型应用程序**\n\n类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。\n\n- **先进的 JavaScript**\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。\n\n\n## 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\n```bash\nnpm install -g typescript\n```\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\n```bash\ntsc -V \n```\n\n\n## 总结\n\nTypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。\n                                                                          \n\n","source":"_posts/TypeScript 学习第一章 初识TypeScript.md","raw":"---\ntitle: TypeScript 学习第一章 初识TypeScript\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-14 21:37:05\nsubtitle:\nheader-img: \"http://www.3dmgame.com/uploads/allimg/170612/1316-1F6121I945.jpg\"\n---\n\n# 初识 TypeScript\n\nTypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。\n\n## TypeScript 的特点\n\nTypeScript 主要有 3 大特点：\n\n- **始于JavaScript，归于JavaScript**\n\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。\n\n- **强大的工具构建大型应用程序**\n\n类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。\n\n- **先进的 JavaScript**\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。\n\n\n## 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\n```bash\nnpm install -g typescript\n```\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\n```bash\ntsc -V \n```\n\n\n## 总结\n\nTypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。\n                                                                          \n\n","slug":"TypeScript 学习第一章 初识TypeScript","published":1,"updated":"2019-08-14T14:56:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4p000iw72s6u98rf74","content":"<h1><span id=\"初识-typescript\">初识 TypeScript</span></h1>\n<p>TypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p>\n<h2><span id=\"typescript-的特点\">TypeScript 的特点</span></h2>\n<p>TypeScript 主要有 3 大特点：</p>\n<ul>\n<li><strong>始于JavaScript，归于JavaScript</strong></li>\n</ul>\n<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>\n<ul>\n<li><strong>强大的工具构建大型应用程序</strong></li>\n</ul>\n<p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>\n<p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p>\n<ul>\n<li><strong>先进的 JavaScript</strong></li>\n</ul>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>\n<p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p>\n<h2><span id=\"安装-typescript\">安装 TypeScript</span></h2>\n<p>命令行运行如下命令，全局安装 TypeScript：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc -V</span><br></pre></td></tr></table></figure>\n<h2><span id=\"总结\">总结</span></h2>\n<p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>初识 TypeScript</h1>\n<p>TypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p>\n<h2>TypeScript 的特点</h2>\n<p>TypeScript 主要有 3 大特点：</p>\n<ul>\n<li><strong>始于JavaScript，归于JavaScript</strong></li>\n</ul>\n<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>\n<ul>\n<li><strong>强大的工具构建大型应用程序</strong></li>\n</ul>\n<p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>\n<p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p>\n<ul>\n<li><strong>先进的 JavaScript</strong></li>\n</ul>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>\n<p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p>\n<h2>安装 TypeScript</h2>\n<p>命令行运行如下命令，全局安装 TypeScript：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc -V</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。</p>\n"},{"title":"JavaScript数据结构与算法-集合","catalog":true,"url":"195.html","id":"195","date":"2019-03-07T06:49:23.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是集合 ？\n\n集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。\n\n#### 2\\. 代码实现集合\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      values() {\n        return [...this.set]\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    console.log(setA.values());\n    console.log(setA.has(3));\n    \n    \n\n#### 3\\. 集合操作 交集\n\n交集的数学概念是集合A和集合B的交集\n\n     intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n    \n\n#### 4\\. 集合操作 并集\n\n并集的数学概念是集合A和集合B的并集\n\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n    \n\n#### 5\\. 集合操作 差集\n\n差集的数学概念是集合A和集合B的差集\n\n     difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n    \n\n#### 6\\. 集合操作 子集\n\n子集的数学概念是集合A是集合B的子集\n\n     subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    \n\n#### PS: 完整代码以及结果\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      value() {\n        return [...this.set]\n      }\n      // 交集\n      intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n      // 并集\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n      // 差集\n      difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n      // 子集\n      subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    setB.add(4);\n    setB.add(4);\n    setB.add(5);\n    console.log(setA.value());\n    console.log(setB.value());\n    console.log(setA.has(3));\n    console.log(setA.union(setB));\n    console.log(setA.intersection(setB));\n    console.log(setA.difference(setB));\n    console.log(setA.subset(setB));\n    // [ 2, 3, 4, 5 ]\n    // [ 4, 5 ]\n    // true\n    // Set { 2, 3, 4, 5 }\n    // Set { 4, 5 }\n    // Set { 2, 3 }\n    // true","source":"_posts/JavaScript数据结构与算法-集合.md","raw":"---\ntitle: JavaScript数据结构与算法-集合\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 195.html\nid: 195\ncategories:\n  - 数据结构\ndate: 2019-03-07 14:49:23\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是集合 ？\n\n集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。\n\n#### 2\\. 代码实现集合\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      values() {\n        return [...this.set]\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    console.log(setA.values());\n    console.log(setA.has(3));\n    \n    \n\n#### 3\\. 集合操作 交集\n\n交集的数学概念是集合A和集合B的交集\n\n     intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n    \n\n#### 4\\. 集合操作 并集\n\n并集的数学概念是集合A和集合B的并集\n\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n    \n\n#### 5\\. 集合操作 差集\n\n差集的数学概念是集合A和集合B的差集\n\n     difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n    \n\n#### 6\\. 集合操作 子集\n\n子集的数学概念是集合A是集合B的子集\n\n     subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    \n\n#### PS: 完整代码以及结果\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      value() {\n        return [...this.set]\n      }\n      // 交集\n      intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n      // 并集\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n      // 差集\n      difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n      // 子集\n      subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    setB.add(4);\n    setB.add(4);\n    setB.add(5);\n    console.log(setA.value());\n    console.log(setB.value());\n    console.log(setA.has(3));\n    console.log(setA.union(setB));\n    console.log(setA.intersection(setB));\n    console.log(setA.difference(setB));\n    console.log(setA.subset(setB));\n    // [ 2, 3, 4, 5 ]\n    // [ 4, 5 ]\n    // true\n    // Set { 2, 3, 4, 5 }\n    // Set { 4, 5 }\n    // Set { 2, 3 }\n    // true","slug":"JavaScript数据结构与算法-集合","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4q000kw72ss1dgrqyn","content":"<h4><span id=\"1-什么是集合\">1. 什么是集合 ？</span></h4>\n<p>集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。</p>\n<h4><span id=\"2-代码实现集合\">2. 代码实现集合</span></h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  values() {\n    return [...this.set]\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nconsole.log(setA.values());\nconsole.log(setA.has(3));\n</code></pre>\n<h4><span id=\"3-集合操作-交集\">3. 集合操作 交集</span></h4>\n<p>交集的数学概念是集合A和集合B的交集</p>\n<pre><code> intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n</code></pre>\n<h4><span id=\"4-集合操作-并集\">4. 集合操作 并集</span></h4>\n<p>并集的数学概念是集合A和集合B的并集</p>\n<pre><code>  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n</code></pre>\n<h4><span id=\"5-集合操作-差集\">5. 集合操作 差集</span></h4>\n<p>差集的数学概念是集合A和集合B的差集</p>\n<pre><code> difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n</code></pre>\n<h4><span id=\"6-集合操作-子集\">6. 集合操作 子集</span></h4>\n<p>子集的数学概念是集合A是集合B的子集</p>\n<pre><code> subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n</code></pre>\n<h4><span id=\"ps-完整代码以及结果\">PS: 完整代码以及结果</span></h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  value() {\n    return [...this.set]\n  }\n  // 交集\n  intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n  // 并集\n  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n  // 差集\n  difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n  // 子集\n  subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nsetB.add(4);\nsetB.add(4);\nsetB.add(5);\nconsole.log(setA.value());\nconsole.log(setB.value());\nconsole.log(setA.has(3));\nconsole.log(setA.union(setB));\nconsole.log(setA.intersection(setB));\nconsole.log(setA.difference(setB));\nconsole.log(setA.subset(setB));\n// [ 2, 3, 4, 5 ]\n// [ 4, 5 ]\n// true\n// Set { 2, 3, 4, 5 }\n// Set { 4, 5 }\n// Set { 2, 3 }\n// true</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是集合 ？</h4>\n<p>集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。</p>\n<h4>2. 代码实现集合</h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  values() {\n    return [...this.set]\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nconsole.log(setA.values());\nconsole.log(setA.has(3));\n</code></pre>\n<h4>3. 集合操作 交集</h4>\n<p>交集的数学概念是集合A和集合B的交集</p>\n<pre><code> intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n</code></pre>\n<h4>4. 集合操作 并集</h4>\n<p>并集的数学概念是集合A和集合B的并集</p>\n<pre><code>  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n</code></pre>\n<h4>5. 集合操作 差集</h4>\n<p>差集的数学概念是集合A和集合B的差集</p>\n<pre><code> difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n</code></pre>\n<h4>6. 集合操作 子集</h4>\n<p>子集的数学概念是集合A是集合B的子集</p>\n<pre><code> subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n</code></pre>\n<h4>PS: 完整代码以及结果</h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  value() {\n    return [...this.set]\n  }\n  // 交集\n  intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n  // 并集\n  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n  // 差集\n  difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n  // 子集\n  subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nsetB.add(4);\nsetB.add(4);\nsetB.add(5);\nconsole.log(setA.value());\nconsole.log(setB.value());\nconsole.log(setA.has(3));\nconsole.log(setA.union(setB));\nconsole.log(setA.intersection(setB));\nconsole.log(setA.difference(setB));\nconsole.log(setA.subset(setB));\n// [ 2, 3, 4, 5 ]\n// [ 4, 5 ]\n// true\n// Set { 2, 3, 4, 5 }\n// Set { 4, 5 }\n// Set { 2, 3 }\n// true</code></pre>\n"},{"title":"TypeScript 学习第二章 编写第一个 TypeScript","catalog":true,"date":"2019-08-15T11:37:05.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/blog/201403/20/20140320120519_M2nYE.jpeg","_content":"\n# 编写第一个 TypeScript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\n\n```javascript\nfunction greeter (person) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\n## 编译代码\n\n我们使用了 `.ts` 扩展名，但是这段代码仅仅是 JavaScript 而已。\n\n在命令行上，运行 TypeScript 编译器：\n\n```bash\ntsc greeter.ts\n```\n\n输出结果为一个 `greeter.js` 文件，它包含了和输入文件中相同的 JavsScript 代码。\n\n在命令行上，通过 Node.js 运行这段代码：\n\n```bash\nnode greeter.js\n```\n\n控制台输出：\n\n```\nHello, Yee\n```\n\n## 类型注解\n\n接下来让我们看看 TypeScript 工具带来的高级功能。 给  `person` 函数的参数添加 `: string` 类型注解，如下：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\nTypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 `greeter` 函数接收一个字符串参数。 然后尝试把 `greeter` 的调用改成传入一个数组：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n```\n\n重新编译，你会看到产生了一个错误：\n\n```\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n```\n\n类似地，尝试删除 `greeter` 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，`greeter.js` 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。\n\n## 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 `firstName` 和 `lastName` 字段的对象。 在 `TypeScript` 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 `implements` 语句。\n\n```typescript\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = {\n  firstName: 'Yee',\n  lastName: 'Huang'\n}\n\nconsole.log(greeter(user))\n```\n\n## 类\n\n最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 `Student` 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\n```typescript\nclass User {\n  fullName: string\n  firstName: string\n  lastName: string\n\n  constructor (firstName: string, lastName: string) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = firstName + ' ' + lastName\n  }\n}\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = new User('Yee', 'Huang')\n\nconsole.log(greeter(user))\n```\n\n重新运行 `tsc greeter.ts`，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 `JavaScript` 函数的实现。\n\n## 总结\n\n到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。\n\n\n\n\n","source":"_posts/TypeScript 学习第二章 编写第一个 TypeScript.md","raw":"---\ntitle: TypeScript 学习第二章 编写第一个 TypeScript\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-15 19:37:05\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/blog/201403/20/20140320120519_M2nYE.jpeg\"\n---\n\n# 编写第一个 TypeScript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\n\n```javascript\nfunction greeter (person) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\n## 编译代码\n\n我们使用了 `.ts` 扩展名，但是这段代码仅仅是 JavaScript 而已。\n\n在命令行上，运行 TypeScript 编译器：\n\n```bash\ntsc greeter.ts\n```\n\n输出结果为一个 `greeter.js` 文件，它包含了和输入文件中相同的 JavsScript 代码。\n\n在命令行上，通过 Node.js 运行这段代码：\n\n```bash\nnode greeter.js\n```\n\n控制台输出：\n\n```\nHello, Yee\n```\n\n## 类型注解\n\n接下来让我们看看 TypeScript 工具带来的高级功能。 给  `person` 函数的参数添加 `: string` 类型注解，如下：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\nTypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 `greeter` 函数接收一个字符串参数。 然后尝试把 `greeter` 的调用改成传入一个数组：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n```\n\n重新编译，你会看到产生了一个错误：\n\n```\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n```\n\n类似地，尝试删除 `greeter` 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，`greeter.js` 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。\n\n## 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 `firstName` 和 `lastName` 字段的对象。 在 `TypeScript` 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 `implements` 语句。\n\n```typescript\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = {\n  firstName: 'Yee',\n  lastName: 'Huang'\n}\n\nconsole.log(greeter(user))\n```\n\n## 类\n\n最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 `Student` 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\n```typescript\nclass User {\n  fullName: string\n  firstName: string\n  lastName: string\n\n  constructor (firstName: string, lastName: string) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = firstName + ' ' + lastName\n  }\n}\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = new User('Yee', 'Huang')\n\nconsole.log(greeter(user))\n```\n\n重新运行 `tsc greeter.ts`，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 `JavaScript` 函数的实现。\n\n## 总结\n\n到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。\n\n\n\n\n","slug":"TypeScript 学习第二章 编写第一个 TypeScript","published":1,"updated":"2019-08-14T15:00:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4s000pw72sljkt9eao","content":"<h1><span id=\"编写第一个-typescript-程序\">编写第一个 TypeScript 程序</span></h1>\n<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"编译代码\">编译代码</span></h2>\n<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>\n<p>在命令行上，运行 TypeScript 编译器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc greeter.ts</span><br></pre></td></tr></table></figure>\n<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>\n<p>在命令行上，通过 Node.js 运行这段代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node greeter.js</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, Yee</span><br></pre></td></tr></table></figure>\n<h2><span id=\"类型注解\">类型注解</span></h2>\n<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新编译，你会看到产生了一个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>\n<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>\n<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>\n<h2><span id=\"接口\">接口</span></h2>\n<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Yee'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Huang'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"类\">类</span></h2>\n<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>\n<p>让我们创建一个 <code>Student</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>\n<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'Yee'</span>, <span class=\"string\">'Huang'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>\n<h2><span id=\"总结\">总结</span></h2>\n<p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>编写第一个 TypeScript 程序</h1>\n<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2>编译代码</h2>\n<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>\n<p>在命令行上，运行 TypeScript 编译器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc greeter.ts</span><br></pre></td></tr></table></figure>\n<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>\n<p>在命令行上，通过 Node.js 运行这段代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node greeter.js</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, Yee</span><br></pre></td></tr></table></figure>\n<h2>类型注解</h2>\n<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新编译，你会看到产生了一个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>\n<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>\n<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>\n<h2>接口</h2>\n<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Yee'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Huang'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2>类</h2>\n<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>\n<p>让我们创建一个 <code>Student</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>\n<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'Yee'</span>, <span class=\"string\">'Huang'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>\n<h2>总结</h2>\n<p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>\n"},{"title":"JavaScript数据结构与算法队列（Queue）","catalog":true,"url":"184.html","id":"184","date":"2019-03-06T09:53:17.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是队列？\n\n队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。\n\n#### 2\\. 代码实现一个队列Queue\n\n    class Queue {\n    \n      constructor() {\n        this.items = [];\n      }\n      // 向队列添加元素\n      push(element) {\n        this.items.push(element);\n      }\n      // 从队列移除元素\n      shift() {\n        return this.items.shift();\n      }\n      // 查看队列头元素\n      peek() {\n        return this.items[0];\n      }\n      // 检查队列是否为空\n      isEmpty() {\n        return this.items.length === 0;\n      }\n      // 打印队列\n      print() {\n        return this.items.toString();\n      }\n    \n    }\n    \n    \n\n#### 3\\. 什么是优先队列？\n\n队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。\n\n    function PriorityQueue() {\n      let items = [];\n      function QueueElement (element, priority){ // {1}\n        this.element = element;\n        this.priority = priority;\n      }\n      this.enqueue = function(element, priority){\n        let queueElement = new QueueElement(element, priority);\n        let added = false;\n        for (let i=0; i<items.length; i++){\n          if (queueElement.priority < items[i].priority){ // {2}\n            items.splice(i,0,queueElement); // {3}\n            added = true;\n            break; // {4}\n    } }\n        if (!added){\n          items.push(queueElement); //{5}\n    } };\n      this.print = function(){\n        for (let i=0; i<items.length; i++){\n          console.log(`${items[i].element} -\n          ${items[i].priority}`);\n        }\n    };\n    //其他方法和默认的Queue实现相同 }\n    \n\n#### 4\\. 什么是循环队列？\n\n还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。\n\n> 循环队列——击鼓传花\n\n    function hotPotato(nameList, num) {\n      var queue = new Queue();\n      var eliminated = \"\";\n      for (let i = 0; i < nameList.length; i++) {\n        queue.push(nameList[i]);\n      }\n      while (queue.size() > 0) {\n        for (let i = 0; i < num; i++) {\n          queue.push(queue.shift())\n        }\n        eliminated = queue.shift();\n        console.log(`eliminated: ${eliminated}`);\n      }\n      return eliminated\n    }\n    var nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\n    hotPotato(nameList, 3);\n    \n    // eliminated: golang\n    // eliminated: python\n    // eliminated: php\n    // eliminated: cpp\n    // eliminated: java\n    // eliminated: c#\n    // eliminated: javascript\n    // eliminated: basic\n    \n\n#### 5\\. JavaScript 任务队列\n\n当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。","source":"_posts/JavaScript数据结构与算法队列（Queue）.md","raw":"---\ntitle: JavaScript数据结构与算法队列（Queue）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 184.html\nid: 184\ncategories:\n  - 数据结构\ndate: 2019-03-06 17:53:17\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是队列？\n\n队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。\n\n#### 2\\. 代码实现一个队列Queue\n\n    class Queue {\n    \n      constructor() {\n        this.items = [];\n      }\n      // 向队列添加元素\n      push(element) {\n        this.items.push(element);\n      }\n      // 从队列移除元素\n      shift() {\n        return this.items.shift();\n      }\n      // 查看队列头元素\n      peek() {\n        return this.items[0];\n      }\n      // 检查队列是否为空\n      isEmpty() {\n        return this.items.length === 0;\n      }\n      // 打印队列\n      print() {\n        return this.items.toString();\n      }\n    \n    }\n    \n    \n\n#### 3\\. 什么是优先队列？\n\n队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。\n\n    function PriorityQueue() {\n      let items = [];\n      function QueueElement (element, priority){ // {1}\n        this.element = element;\n        this.priority = priority;\n      }\n      this.enqueue = function(element, priority){\n        let queueElement = new QueueElement(element, priority);\n        let added = false;\n        for (let i=0; i<items.length; i++){\n          if (queueElement.priority < items[i].priority){ // {2}\n            items.splice(i,0,queueElement); // {3}\n            added = true;\n            break; // {4}\n    } }\n        if (!added){\n          items.push(queueElement); //{5}\n    } };\n      this.print = function(){\n        for (let i=0; i<items.length; i++){\n          console.log(`${items[i].element} -\n          ${items[i].priority}`);\n        }\n    };\n    //其他方法和默认的Queue实现相同 }\n    \n\n#### 4\\. 什么是循环队列？\n\n还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。\n\n> 循环队列——击鼓传花\n\n    function hotPotato(nameList, num) {\n      var queue = new Queue();\n      var eliminated = \"\";\n      for (let i = 0; i < nameList.length; i++) {\n        queue.push(nameList[i]);\n      }\n      while (queue.size() > 0) {\n        for (let i = 0; i < num; i++) {\n          queue.push(queue.shift())\n        }\n        eliminated = queue.shift();\n        console.log(`eliminated: ${eliminated}`);\n      }\n      return eliminated\n    }\n    var nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\n    hotPotato(nameList, 3);\n    \n    // eliminated: golang\n    // eliminated: python\n    // eliminated: php\n    // eliminated: cpp\n    // eliminated: java\n    // eliminated: c#\n    // eliminated: javascript\n    // eliminated: basic\n    \n\n#### 5\\. JavaScript 任务队列\n\n当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。","slug":"JavaScript数据结构与算法队列（Queue）","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4t000rw72sq1aq2216","content":"<h4><span id=\"1-什么是队列\">1. 什么是队列？</span></h4>\n<p>队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。</p>\n<h4><span id=\"2-代码实现一个队列queue\">2. 代码实现一个队列Queue</span></h4>\n<pre><code>class Queue {\n\n  constructor() {\n    this.items = [];\n  }\n  // 向队列添加元素\n  push(element) {\n    this.items.push(element);\n  }\n  // 从队列移除元素\n  shift() {\n    return this.items.shift();\n  }\n  // 查看队列头元素\n  peek() {\n    return this.items[0];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 打印队列\n  print() {\n    return this.items.toString();\n  }\n\n}\n</code></pre>\n<h4><span id=\"3-什么是优先队列\">3. 什么是优先队列？</span></h4>\n<p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。</p>\n<pre><code>function PriorityQueue() {\n  let items = [];\n  function QueueElement (element, priority){ // {1}\n    this.element = element;\n    this.priority = priority;\n  }\n  this.enqueue = function(element, priority){\n    let queueElement = new QueueElement(element, priority);\n    let added = false;\n    for (let i=0; i&lt;items.length; i++){\n      if (queueElement.priority &lt; items[i].priority){ // {2}\n        items.splice(i,0,queueElement); // {3}\n        added = true;\n        break; // {4}\n} }\n    if (!added){\n      items.push(queueElement); //{5}\n} };\n  this.print = function(){\n    for (let i=0; i&lt;items.length; i++){\n      console.log(`${items[i].element} -\n      ${items[i].priority}`);\n    }\n};\n//其他方法和默认的Queue实现相同 }\n</code></pre>\n<h4><span id=\"4-什么是循环队列\">4. 什么是循环队列？</span></h4>\n<p>还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。</p>\n<blockquote>\n<p>循环队列——击鼓传花</p>\n</blockquote>\n<pre><code>function hotPotato(nameList, num) {\n  var queue = new Queue();\n  var eliminated = &quot;&quot;;\n  for (let i = 0; i &lt; nameList.length; i++) {\n    queue.push(nameList[i]);\n  }\n  while (queue.size() &gt; 0) {\n    for (let i = 0; i &lt; num; i++) {\n      queue.push(queue.shift())\n    }\n    eliminated = queue.shift();\n    console.log(`eliminated: ${eliminated}`);\n  }\n  return eliminated\n}\nvar nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\nhotPotato(nameList, 3);\n\n// eliminated: golang\n// eliminated: python\n// eliminated: php\n// eliminated: cpp\n// eliminated: java\n// eliminated: c#\n// eliminated: javascript\n// eliminated: basic\n</code></pre>\n<h4><span id=\"5-javascript-任务队列\">5. JavaScript 任务队列</span></h4>\n<p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是队列？</h4>\n<p>队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。</p>\n<h4>2. 代码实现一个队列Queue</h4>\n<pre><code>class Queue {\n\n  constructor() {\n    this.items = [];\n  }\n  // 向队列添加元素\n  push(element) {\n    this.items.push(element);\n  }\n  // 从队列移除元素\n  shift() {\n    return this.items.shift();\n  }\n  // 查看队列头元素\n  peek() {\n    return this.items[0];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 打印队列\n  print() {\n    return this.items.toString();\n  }\n\n}\n</code></pre>\n<h4>3. 什么是优先队列？</h4>\n<p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。</p>\n<pre><code>function PriorityQueue() {\n  let items = [];\n  function QueueElement (element, priority){ // {1}\n    this.element = element;\n    this.priority = priority;\n  }\n  this.enqueue = function(element, priority){\n    let queueElement = new QueueElement(element, priority);\n    let added = false;\n    for (let i=0; i&lt;items.length; i++){\n      if (queueElement.priority &lt; items[i].priority){ // {2}\n        items.splice(i,0,queueElement); // {3}\n        added = true;\n        break; // {4}\n} }\n    if (!added){\n      items.push(queueElement); //{5}\n} };\n  this.print = function(){\n    for (let i=0; i&lt;items.length; i++){\n      console.log(`${items[i].element} -\n      ${items[i].priority}`);\n    }\n};\n//其他方法和默认的Queue实现相同 }\n</code></pre>\n<h4>4. 什么是循环队列？</h4>\n<p>还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。</p>\n<blockquote>\n<p>循环队列——击鼓传花</p>\n</blockquote>\n<pre><code>function hotPotato(nameList, num) {\n  var queue = new Queue();\n  var eliminated = &quot;&quot;;\n  for (let i = 0; i &lt; nameList.length; i++) {\n    queue.push(nameList[i]);\n  }\n  while (queue.size() &gt; 0) {\n    for (let i = 0; i &lt; num; i++) {\n      queue.push(queue.shift())\n    }\n    eliminated = queue.shift();\n    console.log(`eliminated: ${eliminated}`);\n  }\n  return eliminated\n}\nvar nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\nhotPotato(nameList, 3);\n\n// eliminated: golang\n// eliminated: python\n// eliminated: php\n// eliminated: cpp\n// eliminated: java\n// eliminated: c#\n// eliminated: javascript\n// eliminated: basic\n</code></pre>\n<h4>5. JavaScript 任务队列</h4>\n<p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。</p>\n"},{"title":"TypeScript 学习第八章 TypeScript 类型推断","catalog":true,"date":"2019-08-21T11:09:32.000Z","subtitle":null,"header-img":"http://hbimg.b0.upaiyun.com/5df06a8b37e2da0a167432e9ab712aca1abe4b507e404-NYeXeZ_fw658","_content":"\n# 类型推断\n\n这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。\n\n## 基础\n\nTypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：\n\n```typescript\nlet x = 3\n```\n\n变量 `x` 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。\n\n## 最佳通用类型\n\n有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\n```typescript\nlet x = [0, 1, null]\n```\n\n为了推断 `x` 的类型，我们必须考虑所有元素的类型。 这里有两种选择：`number` 和 `null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：\n\n```typescript\nclass Animal {\n  numLegs: number\n}\n\nclass Bee extends Animal {\n}\n\nclass Lion extends Animal {\n}\n\nlet zoo = [new Bee(), new Lion()]\n```\n这里，我们想让 `zoo` 被推断为 `Animal[]` 类型，但是这个数组里没有对象是 `Animal` 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：\n\n```typescript\nlet zoo: Animal[] = [new Bee(), new Lion()]\n```\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Bee | Lion)[]`\n\n## 上下文类型\n\n有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：\n\n```typescript\nwindow.onmousedown = function(mouseEvent) {\n  console.log(mouseEvent.clickTime)  // Error\n}\n```\n\n这个例子会得到一个类型错误，TypeScript 类型检查器使用 `window.onmousedown` 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 `mouseEvent` 参数的类型了，所以 `mouseEvent` 访问了一个不存在的属性，就报错了。\n\n如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：\n\n```typescript\nwindow.onmousedown = function(mouseEvent:any) {\n  console.log(mouseEvent.clickTime)  // OK\n}\n```\n\n这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。\n\n上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n  return [new Bee(), new Lion()]\n}\n\nlet zoo = createZoo()\n```\n\n这个例子里，最佳通用类型有 `3` 个候选者：`Animal`，`Bee` 和 `Lion`。 其中，`Animal` 会被做为最佳通用类型。\n","source":"_posts/TypeScript 学习第八章 TypeScript类型推断.md","raw":"---\ntitle: TypeScript 学习第八章 TypeScript 类型推断\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-21 19:09:32\nsubtitle:\nheader-img: \"http://hbimg.b0.upaiyun.com/5df06a8b37e2da0a167432e9ab712aca1abe4b507e404-NYeXeZ_fw658\"\n---\n\n# 类型推断\n\n这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。\n\n## 基础\n\nTypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：\n\n```typescript\nlet x = 3\n```\n\n变量 `x` 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。\n\n## 最佳通用类型\n\n有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\n```typescript\nlet x = [0, 1, null]\n```\n\n为了推断 `x` 的类型，我们必须考虑所有元素的类型。 这里有两种选择：`number` 和 `null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：\n\n```typescript\nclass Animal {\n  numLegs: number\n}\n\nclass Bee extends Animal {\n}\n\nclass Lion extends Animal {\n}\n\nlet zoo = [new Bee(), new Lion()]\n```\n这里，我们想让 `zoo` 被推断为 `Animal[]` 类型，但是这个数组里没有对象是 `Animal` 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：\n\n```typescript\nlet zoo: Animal[] = [new Bee(), new Lion()]\n```\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Bee | Lion)[]`\n\n## 上下文类型\n\n有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：\n\n```typescript\nwindow.onmousedown = function(mouseEvent) {\n  console.log(mouseEvent.clickTime)  // Error\n}\n```\n\n这个例子会得到一个类型错误，TypeScript 类型检查器使用 `window.onmousedown` 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 `mouseEvent` 参数的类型了，所以 `mouseEvent` 访问了一个不存在的属性，就报错了。\n\n如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：\n\n```typescript\nwindow.onmousedown = function(mouseEvent:any) {\n  console.log(mouseEvent.clickTime)  // OK\n}\n```\n\n这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。\n\n上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n  return [new Bee(), new Lion()]\n}\n\nlet zoo = createZoo()\n```\n\n这个例子里，最佳通用类型有 `3` 个候选者：`Animal`，`Bee` 和 `Lion`。 其中，`Animal` 会被做为最佳通用类型。\n","slug":"TypeScript 学习第八章 TypeScript类型推断","published":1,"updated":"2019-08-17T11:13:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4v000vw72smh7yxoz6","content":"<h1><span id=\"类型推断\">类型推断</span></h1>\n<p>这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。</p>\n<h2><span id=\"基础\">基础</span></h2>\n<p>TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>变量 <code>x</code> 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>\n<p>大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。</p>\n<h2><span id=\"最佳通用类型\">最佳通用类型</span></h2>\n<p>有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>]</span><br></pre></td></tr></table></figure>\n<p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code> 和 <code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>\n<p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  numLegs: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bee <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Lion <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo: Animal[] = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Bee | Lion)[]</code></p>\n<h2><span id=\"上下文类型\">上下文类型</span></h2>\n<p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code> 参数的类型了，所以 <code>mouseEvent</code> 访问了一个不存在的属性，就报错了。</p>\n<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent:<span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p>\n<p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title\">Animal</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = createZoo()</span><br></pre></td></tr></table></figure>\n<p>这个例子里，最佳通用类型有 <code>3</code> 个候选者：<code>Animal</code>，<code>Bee</code> 和 <code>Lion</code>。 其中，<code>Animal</code> 会被做为最佳通用类型。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>类型推断</h1>\n<p>这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。</p>\n<h2>基础</h2>\n<p>TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>变量 <code>x</code> 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>\n<p>大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。</p>\n<h2>最佳通用类型</h2>\n<p>有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>]</span><br></pre></td></tr></table></figure>\n<p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code> 和 <code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>\n<p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  numLegs: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bee <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Lion <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo: Animal[] = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Bee | Lion)[]</code></p>\n<h2>上下文类型</h2>\n<p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code> 参数的类型了，所以 <code>mouseEvent</code> 访问了一个不存在的属性，就报错了。</p>\n<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent:<span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p>\n<p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title\">Animal</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = createZoo()</span><br></pre></td></tr></table></figure>\n<p>这个例子里，最佳通用类型有 <code>3</code> 个候选者：<code>Animal</code>，<code>Bee</code> 和 <code>Lion</code>。 其中，<code>Animal</code> 会被做为最佳通用类型。</p>\n"},{"title":"Uni-App 基于Vue技术栈方向跨端技术实践","catalog":true,"date":"2019-04-29T22:37:05.000Z","subtitle":null,"header-img":"https://p4.ssl.cdn.btime.com/t0125a8daac3dbdb9f2.jpg?size=1200x616","_content":"\n### 1.什么是Uni-App?\nuni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。\n如下图：\n---\n![跨端图](http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&fm=26&gp=0.jpg)\n![功能架构图](https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png)\n\nuni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示\n\n![多端图](http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png)\n\n> PS: 学习一门技术最好的方式，就是看官网： https://uniapp.dcloud.io/\n\n### 2. 语法原理以及注意事项\n\nuni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。\n> PS: 过于啰嗦和简单，官网文档在此： https://uniapp.dcloud.io/use\n\n### 3. 技术实践\n> 1.先看一下项目的目录结构图\n\n\n![目录结构图](https://s2.ax1x.com/2019/04/30/EG8srn.png)\n\n\n1. src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。\n2. src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多\n3. src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。\n4. src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等\n5. src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件\n6. src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息\n7. src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录\n8. src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。\n9. src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --> unx,具体看官网\n10. dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令\n\n> PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~\n\n### 4. 实践结果\n![实践结果图](https://s2.ax1x.com/2019/04/30/EGJN9S.png)\n1. 目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。\n2. 采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。\n3. 解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。\n\n> PS: 商业项目没有参考示例代码，更多介绍请参见官网： https://uniapp.dcloud.io/","source":"_posts/Uni-App 基于Vue技术栈方向跨端技术实践.md","raw":"---\ntitle: Uni-App 基于Vue技术栈方向跨端技术实践\ncatalog: true\ntags:\n  - Vue\n  - Weex\n  - 微信小程序\ncategories:\n  - Vue\ndate: 2019-04-30 6:37:05\nsubtitle:\nheader-img: \"https://p4.ssl.cdn.btime.com/t0125a8daac3dbdb9f2.jpg?size=1200x616\"\n---\n\n### 1.什么是Uni-App?\nuni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。\n如下图：\n---\n![跨端图](http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&fm=26&gp=0.jpg)\n![功能架构图](https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png)\n\nuni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示\n\n![多端图](http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png)\n\n> PS: 学习一门技术最好的方式，就是看官网： https://uniapp.dcloud.io/\n\n### 2. 语法原理以及注意事项\n\nuni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。\n> PS: 过于啰嗦和简单，官网文档在此： https://uniapp.dcloud.io/use\n\n### 3. 技术实践\n> 1.先看一下项目的目录结构图\n\n\n![目录结构图](https://s2.ax1x.com/2019/04/30/EG8srn.png)\n\n\n1. src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。\n2. src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多\n3. src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。\n4. src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等\n5. src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件\n6. src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息\n7. src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录\n8. src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。\n9. src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --> unx,具体看官网\n10. dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令\n\n> PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~\n\n### 4. 实践结果\n![实践结果图](https://s2.ax1x.com/2019/04/30/EGJN9S.png)\n1. 目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。\n2. 采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。\n3. 解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。\n\n> PS: 商业项目没有参考示例代码，更多介绍请参见官网： https://uniapp.dcloud.io/","slug":"Uni-App 基于Vue技术栈方向跨端技术实践","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4w000xw72svvnm9b39","content":"<h3><span id=\"1什么是uni-app\">1.什么是Uni-App?</span></h3>\n<p>uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。<br>\n如下图：</p>\n<hr>\n<p><img src=\"http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&amp;fm=26&amp;gp=0.jpg\" alt=\"跨端图\"><br>\n<img src=\"https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png\" alt=\"功能架构图\"></p>\n<p>uni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示</p>\n<p><img src=\"http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png\" alt=\"多端图\"></p>\n<blockquote>\n<p>PS: 学习一门技术最好的方式，就是看官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n<h3><span id=\"2-语法原理以及注意事项\">2. 语法原理以及注意事项</span></h3>\n<p>uni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。</p>\n<blockquote>\n<p>PS: 过于啰嗦和简单，官网文档在此： <a href=\"https://uniapp.dcloud.io/use\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/use</a></p>\n</blockquote>\n<h3><span id=\"3-技术实践\">3. 技术实践</span></h3>\n<blockquote>\n<p>1.先看一下项目的目录结构图</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EG8srn.png\" alt=\"目录结构图\"></p>\n<ol>\n<li>src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。</li>\n<li>src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多</li>\n<li>src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。</li>\n<li>src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等</li>\n<li>src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件</li>\n<li>src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息</li>\n<li>src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录</li>\n<li>src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。</li>\n<li>src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --&gt; unx,具体看官网</li>\n<li>dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令</li>\n</ol>\n<blockquote>\n<p>PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~</p>\n</blockquote>\n<h3><span id=\"4-实践结果\">4. 实践结果</span></h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGJN9S.png\" alt=\"实践结果图\"></p>\n<ol>\n<li>目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。</li>\n<li>采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。</li>\n<li>解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。</li>\n</ol>\n<blockquote>\n<p>PS: 商业项目没有参考示例代码，更多介绍请参见官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>1.什么是Uni-App?</h3>\n<p>uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。<br>\n如下图：</p>\n<hr>\n<p><img src=\"http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&amp;fm=26&amp;gp=0.jpg\" alt=\"跨端图\"><br>\n<img src=\"https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png\" alt=\"功能架构图\"></p>\n<p>uni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示</p>\n<p><img src=\"http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png\" alt=\"多端图\"></p>\n<blockquote>\n<p>PS: 学习一门技术最好的方式，就是看官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n<h3>2. 语法原理以及注意事项</h3>\n<p>uni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。</p>\n<blockquote>\n<p>PS: 过于啰嗦和简单，官网文档在此： <a href=\"https://uniapp.dcloud.io/use\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/use</a></p>\n</blockquote>\n<h3>3. 技术实践</h3>\n<blockquote>\n<p>1.先看一下项目的目录结构图</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EG8srn.png\" alt=\"目录结构图\"></p>\n<ol>\n<li>src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。</li>\n<li>src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多</li>\n<li>src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。</li>\n<li>src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等</li>\n<li>src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件</li>\n<li>src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息</li>\n<li>src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录</li>\n<li>src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。</li>\n<li>src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --&gt; unx,具体看官网</li>\n<li>dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令</li>\n</ol>\n<blockquote>\n<p>PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~</p>\n</blockquote>\n<h3>4. 实践结果</h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGJN9S.png\" alt=\"实践结果图\"></p>\n<ol>\n<li>目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。</li>\n<li>采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。</li>\n<li>解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。</li>\n</ol>\n<blockquote>\n<p>PS: 商业项目没有参考示例代码，更多介绍请参见官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n"},{"title":"centOS中利用Docker安装gitlab","catalog":true,"url":"111.html","id":"111","date":"2019-02-21T03:37:05.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://images0.cnblogs.com/news/66372/201507/052157452643027.png)\n\n#### 首先安装虚拟机或者直接在你的云主机上操作\n\n#### 修改centos 默认配置 查看IP\n\n> centos 配置最好高于：4G 2核，否则运行不起来\n\n#### 查看centos的IP地址\n\n     ip addr \n    \n\n#### 无法查询IP的解决办法\n\n> 进入`ect/sysconfig/network-scripts`文件夹,修改对应的网卡配置文件，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/17.png)\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/18.png)\n\n      service network start\n    \n\n> 然后查看IP地址\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/19.png)\n\n#### 安装docker 并启动\n\n> 1.  `yum -y install docker`\n> 2.  `systemctl start docker`\n> 3.  `docker login #输入你的用户名和密码`\n> 4.  `docker pull gitlab/gitlab-ce:latest #可能需要一些时间`\n> \n> 最后创建并启动容器\n\n    docker run -d \\\n    --hostname 192.168.50.27 \\\n    -p 443:443 \\\n    -p 80:80 \\\n    -p 9090:9090 \\\n    --name gitlab \\\n    --restart always \\\n    -v /home/gitlab/config:/etc/gitlab \\\n    -v /home/gitlab/log:/var/log/gitlab \\\n    -v /home/gitlab/opt:/var/opt/gitlab \\\n    --privileged=true gitlab/gitlab-ce:latest\n    \n\n#### 需要等一会，打开游览器输入虚拟机或者云服务器的公网IP\n\n> 如图 1\\. 重置密码\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/20.png)\n\n> 2.  登录和注册\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/21.png)\n\n> 3.  登录后主界面\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/22.png)\n\n#### 配置gitlab\n\n> 查看容器id `shell docekr ps -a` 进入容器命令行\n\n      docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n    \n\n> 参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)","source":"_posts/centOS中利用Docker安装gitlab.md","raw":"---\ntitle: centOS中利用Docker安装gitlab\ncatalog: true\ntags:\n  - Docker\n  - git\n  - gitlab\nurl: 111.html\nid: 111\ncategories:\n  - Docker\ndate: 2019-02-21 11:37:05\nsubtitle:\nheader-img:\n---\n\n![](http://images0.cnblogs.com/news/66372/201507/052157452643027.png)\n\n#### 首先安装虚拟机或者直接在你的云主机上操作\n\n#### 修改centos 默认配置 查看IP\n\n> centos 配置最好高于：4G 2核，否则运行不起来\n\n#### 查看centos的IP地址\n\n     ip addr \n    \n\n#### 无法查询IP的解决办法\n\n> 进入`ect/sysconfig/network-scripts`文件夹,修改对应的网卡配置文件，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/17.png)\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/18.png)\n\n      service network start\n    \n\n> 然后查看IP地址\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/19.png)\n\n#### 安装docker 并启动\n\n> 1.  `yum -y install docker`\n> 2.  `systemctl start docker`\n> 3.  `docker login #输入你的用户名和密码`\n> 4.  `docker pull gitlab/gitlab-ce:latest #可能需要一些时间`\n> \n> 最后创建并启动容器\n\n    docker run -d \\\n    --hostname 192.168.50.27 \\\n    -p 443:443 \\\n    -p 80:80 \\\n    -p 9090:9090 \\\n    --name gitlab \\\n    --restart always \\\n    -v /home/gitlab/config:/etc/gitlab \\\n    -v /home/gitlab/log:/var/log/gitlab \\\n    -v /home/gitlab/opt:/var/opt/gitlab \\\n    --privileged=true gitlab/gitlab-ce:latest\n    \n\n#### 需要等一会，打开游览器输入虚拟机或者云服务器的公网IP\n\n> 如图 1\\. 重置密码\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/20.png)\n\n> 2.  登录和注册\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/21.png)\n\n> 3.  登录后主界面\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/22.png)\n\n#### 配置gitlab\n\n> 查看容器id `shell docekr ps -a` 进入容器命令行\n\n      docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n    \n\n> 参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)","slug":"centOS中利用Docker安装gitlab","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4x0011w72sw1gtzhxt","content":"<p><img src=\"http://images0.cnblogs.com/news/66372/201507/052157452643027.png\" alt></p>\n<h4><span id=\"首先安装虚拟机或者直接在你的云主机上操作\">首先安装虚拟机或者直接在你的云主机上操作</span></h4>\n<h4><span id=\"修改centos-默认配置-查看ip\">修改centos 默认配置 查看IP</span></h4>\n<blockquote>\n<p>centos 配置最好高于：4G 2核，否则运行不起来</p>\n</blockquote>\n<h4><span id=\"查看centos的ip地址\">查看centos的IP地址</span></h4>\n<pre><code> ip addr \n</code></pre>\n<h4><span id=\"无法查询ip的解决办法\">无法查询IP的解决办法</span></h4>\n<blockquote>\n<p>进入<code>ect/sysconfig/network-scripts</code>文件夹,修改对应的网卡配置文件，如图所示</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/17.png\" alt></p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/18.png\" alt></p>\n<pre><code>  service network start\n</code></pre>\n<blockquote>\n<p>然后查看IP地址</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/19.png\" alt></p>\n<h4><span id=\"安装docker-并启动\">安装docker 并启动</span></h4>\n<blockquote>\n<ol>\n<li><code>yum -y install docker</code></li>\n<li><code>systemctl start docker</code></li>\n<li><code>docker login #输入你的用户名和密码</code></li>\n<li><code>docker pull gitlab/gitlab-ce:latest #可能需要一些时间</code></li>\n</ol>\n<p>最后创建并启动容器</p>\n</blockquote>\n<pre><code>docker run -d \\\n--hostname 192.168.50.27 \\\n-p 443:443 \\\n-p 80:80 \\\n-p 9090:9090 \\\n--name gitlab \\\n--restart always \\\n-v /home/gitlab/config:/etc/gitlab \\\n-v /home/gitlab/log:/var/log/gitlab \\\n-v /home/gitlab/opt:/var/opt/gitlab \\\n--privileged=true gitlab/gitlab-ce:latest\n</code></pre>\n<h4><span id=\"需要等一会打开游览器输入虚拟机或者云服务器的公网ip\">需要等一会，打开游览器输入虚拟机或者云服务器的公网IP</span></h4>\n<blockquote>\n<p>如图 1. 重置密码</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/20.png\" alt></p>\n<blockquote>\n<ol start=\"2\">\n<li>登录和注册</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/21.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>登录后主界面</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/22.png\" alt></p>\n<h4><span id=\"配置gitlab\">配置gitlab</span></h4>\n<blockquote>\n<p>查看容器id <code>shell docekr ps -a</code> 进入容器命令行</p>\n</blockquote>\n<pre><code>  docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n</code></pre>\n<blockquote>\n<p>参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://images0.cnblogs.com/news/66372/201507/052157452643027.png\" alt></p>\n<h4>首先安装虚拟机或者直接在你的云主机上操作</h4>\n<h4>修改centos 默认配置 查看IP</h4>\n<blockquote>\n<p>centos 配置最好高于：4G 2核，否则运行不起来</p>\n</blockquote>\n<h4>查看centos的IP地址</h4>\n<pre><code> ip addr \n</code></pre>\n<h4>无法查询IP的解决办法</h4>\n<blockquote>\n<p>进入<code>ect/sysconfig/network-scripts</code>文件夹,修改对应的网卡配置文件，如图所示</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/17.png\" alt></p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/18.png\" alt></p>\n<pre><code>  service network start\n</code></pre>\n<blockquote>\n<p>然后查看IP地址</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/19.png\" alt></p>\n<h4>安装docker 并启动</h4>\n<blockquote>\n<ol>\n<li><code>yum -y install docker</code></li>\n<li><code>systemctl start docker</code></li>\n<li><code>docker login #输入你的用户名和密码</code></li>\n<li><code>docker pull gitlab/gitlab-ce:latest #可能需要一些时间</code></li>\n</ol>\n<p>最后创建并启动容器</p>\n</blockquote>\n<pre><code>docker run -d \\\n--hostname 192.168.50.27 \\\n-p 443:443 \\\n-p 80:80 \\\n-p 9090:9090 \\\n--name gitlab \\\n--restart always \\\n-v /home/gitlab/config:/etc/gitlab \\\n-v /home/gitlab/log:/var/log/gitlab \\\n-v /home/gitlab/opt:/var/opt/gitlab \\\n--privileged=true gitlab/gitlab-ce:latest\n</code></pre>\n<h4>需要等一会，打开游览器输入虚拟机或者云服务器的公网IP</h4>\n<blockquote>\n<p>如图 1. 重置密码</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/20.png\" alt></p>\n<blockquote>\n<ol start=\"2\">\n<li>登录和注册</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/21.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>登录后主界面</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/22.png\" alt></p>\n<h4>配置gitlab</h4>\n<blockquote>\n<p>查看容器id <code>shell docekr ps -a</code> 进入容器命令行</p>\n</blockquote>\n<pre><code>  docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n</code></pre>\n<blockquote>\n<p>参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)</p>\n</blockquote>\n"},{"title":"graphQL 如和在客户端调用","catalog":true,"url":"92.html","id":"92","date":"2019-02-20T09:45:16.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://116.85.35.63/wp-content/uploads/2019/02/12.png)\n\n> 源码地址：[github地址](https://github.com/maliaoMJ/graphql-api-server)\n\n#### 1\\. 先展示目录结构\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/13.png)\n\n#### 2\\. 如何搭建\n\n> 1.  在上一篇文章的基础上，在 `index.js` 添加Express静态文件托管并且指明静态文件夹目录\n\n    app.use(express.static('public'));\n    \n\n> 2.  创建public目录并且在此文件中创建`index.html` 文件\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    </html>\n    \n\n此时你可以访问`localhost:3000/index.html` 可以看见你创建的index.html 文件，如下图：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/14.png)\n\n> 3.  我们要请求GraphQL数据 `(GraphQL 只支持GET和POST请求)`，在index.html的js中，添加如下代码：\n\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    \n\n1.  这里的query 请求的查询语句\n2.  这里的variables 是变量\n3.  这里的$id:Int!中的`!` 表示该参数不能为空,具体细节看下图:\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/15.png)\n\n> 4.  点击按钮，请求数据，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16.png)\n\n#### 3\\. 最后附源代码：\n\n> 1.  index.js 代码\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    \n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n    \n\n> 2.  index.html\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    <script type=\"text/javascript\">\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    </script>\n    \n    </html>\n    \n\n> 3.  执行命令,打开游览器localhost:3000/index.html\n\n      nodemon index.js","source":"_posts/graphQL 如和在客户端调用.md","raw":"---\ntitle: graphQL 如和在客户端调用\ncatalog: true\ntags:\n  - graphql\n  - nodejs\nurl: 92.html\nid: 92\ncategories:\n  - GraphQL\ndate: 2019-02-20 17:45:16\nsubtitle:\nheader-img:\n---\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/12.png)\n\n> 源码地址：[github地址](https://github.com/maliaoMJ/graphql-api-server)\n\n#### 1\\. 先展示目录结构\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/13.png)\n\n#### 2\\. 如何搭建\n\n> 1.  在上一篇文章的基础上，在 `index.js` 添加Express静态文件托管并且指明静态文件夹目录\n\n    app.use(express.static('public'));\n    \n\n> 2.  创建public目录并且在此文件中创建`index.html` 文件\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    </html>\n    \n\n此时你可以访问`localhost:3000/index.html` 可以看见你创建的index.html 文件，如下图：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/14.png)\n\n> 3.  我们要请求GraphQL数据 `(GraphQL 只支持GET和POST请求)`，在index.html的js中，添加如下代码：\n\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    \n\n1.  这里的query 请求的查询语句\n2.  这里的variables 是变量\n3.  这里的$id:Int!中的`!` 表示该参数不能为空,具体细节看下图:\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/15.png)\n\n> 4.  点击按钮，请求数据，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16.png)\n\n#### 3\\. 最后附源代码：\n\n> 1.  index.js 代码\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    \n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n    \n\n> 2.  index.html\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    <script type=\"text/javascript\">\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    </script>\n    \n    </html>\n    \n\n> 3.  执行命令,打开游览器localhost:3000/index.html\n\n      nodemon index.js","slug":"graphQL 如和在客户端调用","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r4y0014w72sd7bgo8d7","content":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/12.png\" alt></p>\n<blockquote>\n<p>源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n<h4><span id=\"1-先展示目录结构\">1. 先展示目录结构</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/13.png\" alt></p>\n<h4><span id=\"2-如何搭建\">2. 如何搭建</span></h4>\n<blockquote>\n<ol>\n<li>在上一篇文章的基础上，在 <code>index.js</code> 添加Express静态文件托管并且指明静态文件夹目录</li>\n</ol>\n</blockquote>\n<pre><code>app.use(express.static('public'));\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>创建public目录并且在此文件中创建<code>index.html</code> 文件</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时你可以访问<code>localhost:3000/index.html</code> 可以看见你创建的index.html 文件，如下图：</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/14.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>我们要请求GraphQL数据 <code>(GraphQL 只支持GET和POST请求)</code>，在index.html的js中，添加如下代码：</li>\n</ol>\n</blockquote>\n<pre><code>let btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n</code></pre>\n<ol>\n<li>这里的query 请求的查询语句</li>\n<li>这里的variables 是变量</li>\n<li>这里的$id:Int!中的<code>!</code> 表示该参数不能为空,具体细节看下图:</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/15.png\" alt></p>\n<blockquote>\n<ol start=\"4\">\n<li>点击按钮，请求数据，如图所示</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16.png\" alt></p>\n<h4><span id=\"3-最后附源代码\">3. 最后附源代码：</span></h4>\n<blockquote>\n<ol>\n<li>index.js 代码</li>\n</ol>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\n\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>index.html</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nlet btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>执行命令,打开游览器localhost:3000/index.html</li>\n</ol>\n</blockquote>\n<pre><code>  nodemon index.js</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/12.png\" alt></p>\n<blockquote>\n<p>源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n<h4>1. 先展示目录结构</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/13.png\" alt></p>\n<h4>2. 如何搭建</h4>\n<blockquote>\n<ol>\n<li>在上一篇文章的基础上，在 <code>index.js</code> 添加Express静态文件托管并且指明静态文件夹目录</li>\n</ol>\n</blockquote>\n<pre><code>app.use(express.static('public'));\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>创建public目录并且在此文件中创建<code>index.html</code> 文件</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时你可以访问<code>localhost:3000/index.html</code> 可以看见你创建的index.html 文件，如下图：</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/14.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>我们要请求GraphQL数据 <code>(GraphQL 只支持GET和POST请求)</code>，在index.html的js中，添加如下代码：</li>\n</ol>\n</blockquote>\n<pre><code>let btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n</code></pre>\n<ol>\n<li>这里的query 请求的查询语句</li>\n<li>这里的variables 是变量</li>\n<li>这里的$id:Int!中的<code>!</code> 表示该参数不能为空,具体细节看下图:</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/15.png\" alt></p>\n<blockquote>\n<ol start=\"4\">\n<li>点击按钮，请求数据，如图所示</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16.png\" alt></p>\n<h4>3. 最后附源代码：</h4>\n<blockquote>\n<ol>\n<li>index.js 代码</li>\n</ol>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\n\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>index.html</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nlet btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>执行命令,打开游览器localhost:3000/index.html</li>\n</ol>\n</blockquote>\n<pre><code>  nodemon index.js</code></pre>\n"},{"title":"前端面试系列 — HMTL基础篇","catalog":true,"url":"133.html","id":"133","date":"2019-02-26T04:25:17.000Z","subtitle":null,"header-img":null,"_content":"\n![banner image](http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg)\n\n> ##### 1\\. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。\n\n1.  DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）\n2.  DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。\n3.  DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。\n4.  如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。\n\n> ##### 2\\. HTML 与 XML 有什么区别\n\n主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。\n\n> ##### 3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。\n\n1.  块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr...\n2.  内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u...\n3.  判断行内元素和块级元素的快捷方法就是判断是否能并列。\n\n> ##### 4.说说HTML5新增了那些元素，以及如何更好的语义化。\n\n1.  header--显示头部信息，article---定义独立内容，常用于用户评语或博客条目，section---节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav---导航链接，在一个html中可以有多个nav， hgroup---适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer---眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。\n2.  其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等\n\n> #### 5.HTML5新增了那些API?\n> \n> 1.  Media API\n> 2.  Text Track API\n> 3.  Application Cache API\n> 4.  User Interaction\n> 5.  Data Transfer API\n> 6.  Command API\n> 7.  Constraint Validation API\n> 8.  History API\n> 9.  Canvas API\n> 10.  Geolocation API等等","source":"_posts/前端面试系列 — HMTL基础篇.md","raw":"---\ntitle: 前端面试系列 — HMTL基础篇\ncatalog: true\nurl: 133.html\nid: 133\ncategories:\n  - HTML5\ndate: 2019-02-26 12:25:17\nsubtitle:\nheader-img:\ntags:\n---\n\n![banner image](http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg)\n\n> ##### 1\\. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。\n\n1.  DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）\n2.  DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。\n3.  DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。\n4.  如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。\n\n> ##### 2\\. HTML 与 XML 有什么区别\n\n主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。\n\n> ##### 3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。\n\n1.  块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr...\n2.  内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u...\n3.  判断行内元素和块级元素的快捷方法就是判断是否能并列。\n\n> ##### 4.说说HTML5新增了那些元素，以及如何更好的语义化。\n\n1.  header--显示头部信息，article---定义独立内容，常用于用户评语或博客条目，section---节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav---导航链接，在一个html中可以有多个nav， hgroup---适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer---眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。\n2.  其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等\n\n> #### 5.HTML5新增了那些API?\n> \n> 1.  Media API\n> 2.  Text Track API\n> 3.  Application Cache API\n> 4.  User Interaction\n> 5.  Data Transfer API\n> 6.  Command API\n> 7.  Constraint Validation API\n> 8.  History API\n> 9.  Canvas API\n> 10.  Geolocation API等等","slug":"前端面试系列 — HMTL基础篇","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r500018w72sehdjwszq","content":"<p><img src=\"http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg\" alt=\"banner image\"></p>\n<blockquote>\n<h5><span id=\"1-html中首行-有什么作用-doctype-又分哪几类其中这些每一类由对应有什么作用请简单描述一下\">1. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。</span></h5>\n</blockquote>\n<ol>\n<li>DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）</li>\n<li>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。</li>\n<li>DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。</li>\n<li>如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。</li>\n</ol>\n<blockquote>\n<h5><span id=\"2-html-与-xml-有什么区别\">2. HTML 与 XML 有什么区别</span></h5>\n</blockquote>\n<p>主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。</p>\n<blockquote>\n<h5><span id=\"3说说html中有哪些块级元素那些内联元素以及块级元素与内联元素的区别\">3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。</span></h5>\n</blockquote>\n<ol>\n<li>块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr…</li>\n<li>内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u…</li>\n<li>判断行内元素和块级元素的快捷方法就是判断是否能并列。</li>\n</ol>\n<blockquote>\n<h5><span id=\"4说说html5新增了那些元素以及如何更好的语义化\">4.说说HTML5新增了那些元素，以及如何更好的语义化。</span></h5>\n</blockquote>\n<ol>\n<li>header–显示头部信息，article—定义独立内容，常用于用户评语或博客条目，section—节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav—导航链接，在一个html中可以有多个nav， hgroup—适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer—眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。</li>\n<li>其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等</li>\n</ol>\n<blockquote>\n<h4><span id=\"5html5新增了那些api\">5.HTML5新增了那些API?</span></h4>\n<ol>\n<li>Media API</li>\n<li>Text Track API</li>\n<li>Application Cache API</li>\n<li>User Interaction</li>\n<li>Data Transfer API</li>\n<li>Command API</li>\n<li>Constraint Validation API</li>\n<li>History API</li>\n<li>Canvas API</li>\n<li>Geolocation API等等</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg\" alt=\"banner image\"></p>\n<blockquote>\n<h5>1. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。</h5>\n</blockquote>\n<ol>\n<li>DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）</li>\n<li>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。</li>\n<li>DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。</li>\n<li>如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。</li>\n</ol>\n<blockquote>\n<h5>2. HTML 与 XML 有什么区别</h5>\n</blockquote>\n<p>主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。</p>\n<blockquote>\n<h5>3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。</h5>\n</blockquote>\n<ol>\n<li>块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr…</li>\n<li>内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u…</li>\n<li>判断行内元素和块级元素的快捷方法就是判断是否能并列。</li>\n</ol>\n<blockquote>\n<h5>4.说说HTML5新增了那些元素，以及如何更好的语义化。</h5>\n</blockquote>\n<ol>\n<li>header–显示头部信息，article—定义独立内容，常用于用户评语或博客条目，section—节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav—导航链接，在一个html中可以有多个nav， hgroup—适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer—眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。</li>\n<li>其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等</li>\n</ol>\n<blockquote>\n<h4>5.HTML5新增了那些API?</h4>\n<ol>\n<li>Media API</li>\n<li>Text Track API</li>\n<li>Application Cache API</li>\n<li>User Interaction</li>\n<li>Data Transfer API</li>\n<li>Command API</li>\n<li>Constraint Validation API</li>\n<li>History API</li>\n<li>Canvas API</li>\n<li>Geolocation API等等</li>\n</ol>\n</blockquote>\n"},{"title":"前端面试系列 — 布局篇","catalog":true,"url":"137.html","id":"137","date":"2019-02-26T04:28:40.000Z","subtitle":null,"header-img":null,"_content":"\n![images](http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg)\n\n> 一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。\n\n1.  利用浮动布局（圣杯布局和双飞翼布局）\n2.  利用定位布局\n3.  flex 布局\n4.  table 表格布局\n5.  grid 布局\n\n代码如下:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>layout</title>\n        <style>\n            *{\n                padding:0;\n                margin:0;\n            }\n            .layout{\n                height: 100px;\n                width: 100%;\n                margin-bottom:50px;\n                overflow: hidden;\n                position: relative;\n            }\n            .layout>div{\n                height:100px;\n            }\n            .float .left,.float .right {\n             width: 200px;\n             height:100px;\n            }\n            .float>.left{\n                float:left;\n                background:red;\n    \n            }\n            .float>.right{\n             float:right;\n             background:blue;\n            }\n            .float>.center{\n                background:green;\n    \n            }\n            /*定位 解决方案*/\n            .position>.left{\n                position:absolute;\n                left:0;\n                top:0;\n                background: red;\n                width:200px;\n                height:100px;\n            }\n            .position>.right{\n                position:absolute;\n                right:0;\n                top:0;\n                background: yellow;\n                width:200px;\n                height:100px;\n            }\n            .position>.center{\n                position: absolute;\n                left:200px;\n                right:200px;\n                background:green;\n            }\n            /*flex 解决方案*/\n            .flex{\n                display: flex;\n                height:100px;\n            }\n            .flex .right, .flex .left{\n                width:200px;\n                background:blue;\n            }\n            .flex .center{\n                flex:1;\n                background:red;\n            }\n            /*table 解决方案*/\n            .table{\n                display: table;\n            }\n            .table>.left,.table>.right{\n                height:100px;\n                width:300px;\n                display: table-cell;\n                background:yellow;\n            }\n            .table>.center{\n                background:red;\n                display: table-cell;\n            }\n            /*grid 解决方案*/\n            .grid {\n                display: grid;\n                grid-template-rows: 100;\n                grid-template-columns: 300px auto 300px;\n            }\n            .grid > .left,.grid >.right{\n               background:red;\n            }\n            .grid > .center{\n               background:yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <!-- float布局 圣杯和双飞翼布局-->\n        <section class=\"layout float\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>float 解决方案</h1>\n                <p>float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案</p>\n            </div>\n        </section>\n        <!-- 定位布局 -->\n        <section class=\"layout position\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>定位 解决方案</h1>\n                <p>定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案</p>\n            </div>\n        </section>\n        <!-- flex 布局 实现太过于简单略-->\n        <section class=\"layout flex\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>flex 解决方案</h1>\n                <p>flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- table 布局 -->\n        <section class=\"layout table\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>table 解决方案</h1>\n                <p>table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- grid 布局 -->\n        <section class=\"layout grid\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>Grid 解决方案</h1>\n                <p>Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n    </body>\n    </html>\n    \n    \n\n> ##### 思考假如高度不固定，上述的方案中又有那些符合要求。\n\n1.  flex布局\n2.  table布局\n3.  grid 布局","source":"_posts/前端面试系列 — 布局篇.md","raw":"---\ntitle: 前端面试系列 — 布局篇\ncatalog: true\nurl: 137.html\nid: 137\ncategories:\n  - CSS3\ndate: 2019-02-26 12:28:40\nsubtitle:\nheader-img:\ntags:\n---\n\n![images](http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg)\n\n> 一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。\n\n1.  利用浮动布局（圣杯布局和双飞翼布局）\n2.  利用定位布局\n3.  flex 布局\n4.  table 表格布局\n5.  grid 布局\n\n代码如下:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>layout</title>\n        <style>\n            *{\n                padding:0;\n                margin:0;\n            }\n            .layout{\n                height: 100px;\n                width: 100%;\n                margin-bottom:50px;\n                overflow: hidden;\n                position: relative;\n            }\n            .layout>div{\n                height:100px;\n            }\n            .float .left,.float .right {\n             width: 200px;\n             height:100px;\n            }\n            .float>.left{\n                float:left;\n                background:red;\n    \n            }\n            .float>.right{\n             float:right;\n             background:blue;\n            }\n            .float>.center{\n                background:green;\n    \n            }\n            /*定位 解决方案*/\n            .position>.left{\n                position:absolute;\n                left:0;\n                top:0;\n                background: red;\n                width:200px;\n                height:100px;\n            }\n            .position>.right{\n                position:absolute;\n                right:0;\n                top:0;\n                background: yellow;\n                width:200px;\n                height:100px;\n            }\n            .position>.center{\n                position: absolute;\n                left:200px;\n                right:200px;\n                background:green;\n            }\n            /*flex 解决方案*/\n            .flex{\n                display: flex;\n                height:100px;\n            }\n            .flex .right, .flex .left{\n                width:200px;\n                background:blue;\n            }\n            .flex .center{\n                flex:1;\n                background:red;\n            }\n            /*table 解决方案*/\n            .table{\n                display: table;\n            }\n            .table>.left,.table>.right{\n                height:100px;\n                width:300px;\n                display: table-cell;\n                background:yellow;\n            }\n            .table>.center{\n                background:red;\n                display: table-cell;\n            }\n            /*grid 解决方案*/\n            .grid {\n                display: grid;\n                grid-template-rows: 100;\n                grid-template-columns: 300px auto 300px;\n            }\n            .grid > .left,.grid >.right{\n               background:red;\n            }\n            .grid > .center{\n               background:yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <!-- float布局 圣杯和双飞翼布局-->\n        <section class=\"layout float\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>float 解决方案</h1>\n                <p>float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案</p>\n            </div>\n        </section>\n        <!-- 定位布局 -->\n        <section class=\"layout position\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>定位 解决方案</h1>\n                <p>定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案</p>\n            </div>\n        </section>\n        <!-- flex 布局 实现太过于简单略-->\n        <section class=\"layout flex\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>flex 解决方案</h1>\n                <p>flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- table 布局 -->\n        <section class=\"layout table\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>table 解决方案</h1>\n                <p>table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- grid 布局 -->\n        <section class=\"layout grid\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>Grid 解决方案</h1>\n                <p>Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n    </body>\n    </html>\n    \n    \n\n> ##### 思考假如高度不固定，上述的方案中又有那些符合要求。\n\n1.  flex布局\n2.  table布局\n3.  grid 布局","slug":"前端面试系列 — 布局篇","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r52001bw72s3irsshg7","content":"<p><img src=\"http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg\" alt=\"images\"></p>\n<blockquote>\n<p>一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。</p>\n</blockquote>\n<ol>\n<li>利用浮动布局（圣杯布局和双飞翼布局）</li>\n<li>利用定位布局</li>\n<li>flex 布局</li>\n<li>table 表格布局</li>\n<li>grid 布局</li>\n</ol>\n<p>代码如下:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;layout&lt;/title&gt;\n    &lt;style&gt;\n        *{\n            padding:0;\n            margin:0;\n        }\n        .layout{\n            height: 100px;\n            width: 100%;\n            margin-bottom:50px;\n            overflow: hidden;\n            position: relative;\n        }\n        .layout&gt;div{\n            height:100px;\n        }\n        .float .left,.float .right {\n         width: 200px;\n         height:100px;\n        }\n        .float&gt;.left{\n            float:left;\n            background:red;\n\n        }\n        .float&gt;.right{\n         float:right;\n         background:blue;\n        }\n        .float&gt;.center{\n            background:green;\n\n        }\n        /*定位 解决方案*/\n        .position&gt;.left{\n            position:absolute;\n            left:0;\n            top:0;\n            background: red;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.right{\n            position:absolute;\n            right:0;\n            top:0;\n            background: yellow;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.center{\n            position: absolute;\n            left:200px;\n            right:200px;\n            background:green;\n        }\n        /*flex 解决方案*/\n        .flex{\n            display: flex;\n            height:100px;\n        }\n        .flex .right, .flex .left{\n            width:200px;\n            background:blue;\n        }\n        .flex .center{\n            flex:1;\n            background:red;\n        }\n        /*table 解决方案*/\n        .table{\n            display: table;\n        }\n        .table&gt;.left,.table&gt;.right{\n            height:100px;\n            width:300px;\n            display: table-cell;\n            background:yellow;\n        }\n        .table&gt;.center{\n            background:red;\n            display: table-cell;\n        }\n        /*grid 解决方案*/\n        .grid {\n            display: grid;\n            grid-template-rows: 100;\n            grid-template-columns: 300px auto 300px;\n        }\n        .grid &gt; .left,.grid &gt;.right{\n           background:red;\n        }\n        .grid &gt; .center{\n           background:yellow;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- float布局 圣杯和双飞翼布局--&gt;\n    &lt;section class=&quot;layout float&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;float 解决方案&lt;/h1&gt;\n            &lt;p&gt;float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- 定位布局 --&gt;\n    &lt;section class=&quot;layout position&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;定位 解决方案&lt;/h1&gt;\n            &lt;p&gt;定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- flex 布局 实现太过于简单略--&gt;\n    &lt;section class=&quot;layout flex&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;flex 解决方案&lt;/h1&gt;\n            &lt;p&gt;flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- table 布局 --&gt;\n    &lt;section class=&quot;layout table&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;table 解决方案&lt;/h1&gt;\n            &lt;p&gt;table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- grid 布局 --&gt;\n    &lt;section class=&quot;layout grid&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;Grid 解决方案&lt;/h1&gt;\n            &lt;p&gt;Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<h5><span id=\"思考假如高度不固定上述的方案中又有那些符合要求\">思考假如高度不固定，上述的方案中又有那些符合要求。</span></h5>\n</blockquote>\n<ol>\n<li>flex布局</li>\n<li>table布局</li>\n<li>grid 布局</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg\" alt=\"images\"></p>\n<blockquote>\n<p>一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。</p>\n</blockquote>\n<ol>\n<li>利用浮动布局（圣杯布局和双飞翼布局）</li>\n<li>利用定位布局</li>\n<li>flex 布局</li>\n<li>table 表格布局</li>\n<li>grid 布局</li>\n</ol>\n<p>代码如下:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;layout&lt;/title&gt;\n    &lt;style&gt;\n        *{\n            padding:0;\n            margin:0;\n        }\n        .layout{\n            height: 100px;\n            width: 100%;\n            margin-bottom:50px;\n            overflow: hidden;\n            position: relative;\n        }\n        .layout&gt;div{\n            height:100px;\n        }\n        .float .left,.float .right {\n         width: 200px;\n         height:100px;\n        }\n        .float&gt;.left{\n            float:left;\n            background:red;\n\n        }\n        .float&gt;.right{\n         float:right;\n         background:blue;\n        }\n        .float&gt;.center{\n            background:green;\n\n        }\n        /*定位 解决方案*/\n        .position&gt;.left{\n            position:absolute;\n            left:0;\n            top:0;\n            background: red;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.right{\n            position:absolute;\n            right:0;\n            top:0;\n            background: yellow;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.center{\n            position: absolute;\n            left:200px;\n            right:200px;\n            background:green;\n        }\n        /*flex 解决方案*/\n        .flex{\n            display: flex;\n            height:100px;\n        }\n        .flex .right, .flex .left{\n            width:200px;\n            background:blue;\n        }\n        .flex .center{\n            flex:1;\n            background:red;\n        }\n        /*table 解决方案*/\n        .table{\n            display: table;\n        }\n        .table&gt;.left,.table&gt;.right{\n            height:100px;\n            width:300px;\n            display: table-cell;\n            background:yellow;\n        }\n        .table&gt;.center{\n            background:red;\n            display: table-cell;\n        }\n        /*grid 解决方案*/\n        .grid {\n            display: grid;\n            grid-template-rows: 100;\n            grid-template-columns: 300px auto 300px;\n        }\n        .grid &gt; .left,.grid &gt;.right{\n           background:red;\n        }\n        .grid &gt; .center{\n           background:yellow;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- float布局 圣杯和双飞翼布局--&gt;\n    &lt;section class=&quot;layout float&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;float 解决方案&lt;/h1&gt;\n            &lt;p&gt;float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- 定位布局 --&gt;\n    &lt;section class=&quot;layout position&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;定位 解决方案&lt;/h1&gt;\n            &lt;p&gt;定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- flex 布局 实现太过于简单略--&gt;\n    &lt;section class=&quot;layout flex&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;flex 解决方案&lt;/h1&gt;\n            &lt;p&gt;flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- table 布局 --&gt;\n    &lt;section class=&quot;layout table&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;table 解决方案&lt;/h1&gt;\n            &lt;p&gt;table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- grid 布局 --&gt;\n    &lt;section class=&quot;layout grid&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;Grid 解决方案&lt;/h1&gt;\n            &lt;p&gt;Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<h5>思考假如高度不固定，上述的方案中又有那些符合要求。</h5>\n</blockquote>\n<ol>\n<li>flex布局</li>\n<li>table布局</li>\n<li>grid 布局</li>\n</ol>\n"},{"title":"前端面试系列-HTTP常考点","catalog":true,"url":"172.html","id":"172","date":"2019-03-05T08:44:04.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg)\n\n#### 经典五层模型\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png)\n\n1.  物理层主要作用是定义物理设备如何传输数据\n2.  数据链路层在通信的实体间建立数据链路连接\n3.  网络层为数据在结点之间传输创建逻辑链路\n4.  传输层（TCP，UDP...）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。\n5.  应用层（HTTP，FTP...）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。\n\n> 1.  从输入 URL 到页面加载完成的过程\n\n1.  首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP\n    \n2.  协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n    \n3.  TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件\n    \n4.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错\n    \n5.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件\n    \n6.  文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML\n    \n7.  解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。\n    \n8.  初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件\n    \n9.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n    \n10.  在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了\n    \n\n> 2.  DNS\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg)\n\n1\\. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。\n\n> 3.  HTTPS与HTTP的一些区别\n\n*   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n*   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n*   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n*   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n\n> 4.  HTTP1.x与HTTP2.0的区别\n\n*   `新的二进制格式`（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n*   `MultiPlexing）`，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n*   `header压缩`，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n*   `服务端推送（server push）`，同SPDY一样，HTTP2.0也具有server push功能。\n\n> 5.  HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？\n\n*   HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；\n*   HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；\n*   HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；\n\n### HTTP----HTTP缓存机制\n\n#### 强缓存\n\n实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200\n\n    Expires: Wed, 22 Oct 2018 08:41:00 GMT\n    \n\n`Expires` 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。\n\n    Cache-control: max-age=30\n    \n\n`Cache-Control` 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。\n\n#### 协商缓存\n\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。\n\n> 1.  Last-Modified 和 If-Modified-Since\n\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。\n\n> 2.  ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。\n\n#### 选择合适的缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n*   对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n*   对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n*   对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。","source":"_posts/前端面试系列-HTTP常考点.md","raw":"---\ntitle: 前端面试系列-HTTP常考点\ncatalog: true\ntags:\n  - http\nurl: 172.html\nid: 172\ncategories:\n  - HTTP\ndate: 2019-03-05 16:44:04\nsubtitle:\nheader-img:\n---\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg)\n\n#### 经典五层模型\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png)\n\n1.  物理层主要作用是定义物理设备如何传输数据\n2.  数据链路层在通信的实体间建立数据链路连接\n3.  网络层为数据在结点之间传输创建逻辑链路\n4.  传输层（TCP，UDP...）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。\n5.  应用层（HTTP，FTP...）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。\n\n> 1.  从输入 URL 到页面加载完成的过程\n\n1.  首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP\n    \n2.  协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n    \n3.  TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件\n    \n4.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错\n    \n5.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件\n    \n6.  文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML\n    \n7.  解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。\n    \n8.  初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件\n    \n9.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n    \n10.  在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了\n    \n\n> 2.  DNS\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg)\n\n1\\. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。\n\n> 3.  HTTPS与HTTP的一些区别\n\n*   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n*   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n*   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n*   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n\n> 4.  HTTP1.x与HTTP2.0的区别\n\n*   `新的二进制格式`（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n*   `MultiPlexing）`，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n*   `header压缩`，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n*   `服务端推送（server push）`，同SPDY一样，HTTP2.0也具有server push功能。\n\n> 5.  HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？\n\n*   HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；\n*   HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；\n*   HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；\n\n### HTTP----HTTP缓存机制\n\n#### 强缓存\n\n实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200\n\n    Expires: Wed, 22 Oct 2018 08:41:00 GMT\n    \n\n`Expires` 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。\n\n    Cache-control: max-age=30\n    \n\n`Cache-Control` 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。\n\n#### 协商缓存\n\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。\n\n> 1.  Last-Modified 和 If-Modified-Since\n\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。\n\n> 2.  ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。\n\n#### 选择合适的缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n*   对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n*   对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n*   对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。","slug":"前端面试系列-HTTP常考点","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r53001ew72srg6c5djc","content":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg\" alt></p>\n<h4><span id=\"经典五层模型\">经典五层模型</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png\" alt></p>\n<ol>\n<li>物理层主要作用是定义物理设备如何传输数据</li>\n<li>数据链路层在通信的实体间建立数据链路连接</li>\n<li>网络层为数据在结点之间传输创建逻辑链路</li>\n<li>传输层（TCP，UDP…）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。</li>\n<li>应用层（HTTP，FTP…）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。</li>\n</ol>\n<blockquote>\n<ol>\n<li>从输入 URL 到页面加载完成的过程</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP</p>\n</li>\n<li>\n<p>协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</p>\n</li>\n<li>\n<p>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</p>\n</li>\n<li>\n<p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</p>\n</li>\n<li>\n<p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</p>\n</li>\n<li>\n<p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML</p>\n</li>\n<li>\n<p>解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</p>\n</li>\n<li>\n<p>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</p>\n</li>\n<li>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n</li>\n<li>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"2\">\n<li>DNS</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg\" alt></p>\n<p>1. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。</p>\n<blockquote>\n<ol start=\"3\">\n<li>HTTPS与HTTP的一些区别</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>\n<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>\n<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>\n<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>HTTP1.x与HTTP2.0的区别</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>新的二进制格式</code>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li><code>MultiPlexing）</code>，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>\n<li><code>header压缩</code>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>\n<li><code>服务端推送（server push）</code>，同SPDY一样，HTTP2.0也具有server push功能。</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h3><span id=\"http-http缓存机制\">HTTP----HTTP缓存机制</span></h3>\n<h4><span id=\"强缓存\">强缓存</span></h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，state code 为 200</p>\n<pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre><code>Cache-control: max-age=30\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4><span id=\"协商缓存\">协商缓存</span></h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<blockquote>\n<ol>\n<li>Last-Modified 和 If-Modified-Since</li>\n</ol>\n</blockquote>\n<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。</p>\n<blockquote>\n<ol start=\"2\">\n<li>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</li>\n</ol>\n</blockquote>\n<h4><span id=\"选择合适的缓存策略\">选择合适的缓存策略</span></h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg\" alt></p>\n<h4>经典五层模型</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png\" alt></p>\n<ol>\n<li>物理层主要作用是定义物理设备如何传输数据</li>\n<li>数据链路层在通信的实体间建立数据链路连接</li>\n<li>网络层为数据在结点之间传输创建逻辑链路</li>\n<li>传输层（TCP，UDP…）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。</li>\n<li>应用层（HTTP，FTP…）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。</li>\n</ol>\n<blockquote>\n<ol>\n<li>从输入 URL 到页面加载完成的过程</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP</p>\n</li>\n<li>\n<p>协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</p>\n</li>\n<li>\n<p>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</p>\n</li>\n<li>\n<p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</p>\n</li>\n<li>\n<p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</p>\n</li>\n<li>\n<p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML</p>\n</li>\n<li>\n<p>解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</p>\n</li>\n<li>\n<p>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</p>\n</li>\n<li>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n</li>\n<li>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"2\">\n<li>DNS</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg\" alt></p>\n<p>1. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。</p>\n<blockquote>\n<ol start=\"3\">\n<li>HTTPS与HTTP的一些区别</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>\n<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>\n<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>\n<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>HTTP1.x与HTTP2.0的区别</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>新的二进制格式</code>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li><code>MultiPlexing）</code>，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>\n<li><code>header压缩</code>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>\n<li><code>服务端推送（server push）</code>，同SPDY一样，HTTP2.0也具有server push功能。</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h3>HTTP----HTTP缓存机制</h3>\n<h4>强缓存</h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，state code 为 200</p>\n<pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre><code>Cache-control: max-age=30\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4>协商缓存</h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<blockquote>\n<ol>\n<li>Last-Modified 和 If-Modified-Since</li>\n</ol>\n</blockquote>\n<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。</p>\n<blockquote>\n<ol start=\"2\">\n<li>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</li>\n</ol>\n</blockquote>\n<h4>选择合适的缓存策略</h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n"},{"title":"前端面试系列- CSS基础篇","catalog":true,"url":"153.html","id":"153","date":"2019-02-26T04:41:20.000Z","subtitle":null,"header-img":null,"_content":"\n![banner](http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg)\n\n> 一. 有哪几种游览器内核 1\\. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。\\[又称为MSHTML\\] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。\\[Opera内核原为：Presto，现为：Blink\\] 4. Webkit内核：Safari,Chrome等。\\[Chrome的:Blink(Webkit的分支)\\] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both\n\n最好的一种方式：伪类清除浮动\n\n    .clearfix:after {\n      visibility: hidden;\n      display: block;\n      font-size: 0;\n      content: \" \";\n      clear: both;\n      height: 0;\n    }\n    .clearfix{\n        zoom:1\n    }","source":"_posts/前端面试系列- CSS基础篇.md","raw":"---\ntitle: 前端面试系列- CSS基础篇\ncatalog: true\ntags:\n  - CSS3\n  - Frontend Interview\n  - html\nurl: 153.html\nid: 153\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:41:20\nsubtitle:\nheader-img:\n---\n\n![banner](http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg)\n\n> 一. 有哪几种游览器内核 1\\. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。\\[又称为MSHTML\\] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。\\[Opera内核原为：Presto，现为：Blink\\] 4. Webkit内核：Safari,Chrome等。\\[Chrome的:Blink(Webkit的分支)\\] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both\n\n最好的一种方式：伪类清除浮动\n\n    .clearfix:after {\n      visibility: hidden;\n      display: block;\n      font-size: 0;\n      content: \" \";\n      clear: both;\n      height: 0;\n    }\n    .clearfix{\n        zoom:1\n    }","slug":"前端面试系列- CSS基础篇","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r55001iw72s58fhukul","content":"<p><img src=\"http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg\" alt=\"banner\"></p>\n<blockquote>\n<p>一. 有哪几种游览器内核 1. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink] 4. Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both</p>\n</blockquote>\n<p>最好的一种方式：伪类清除浮动</p>\n<pre><code>.clearfix:after {\n  visibility: hidden;\n  display: block;\n  font-size: 0;\n  content: &quot; &quot;;\n  clear: both;\n  height: 0;\n}\n.clearfix{\n    zoom:1\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg\" alt=\"banner\"></p>\n<blockquote>\n<p>一. 有哪几种游览器内核 1. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink] 4. Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both</p>\n</blockquote>\n<p>最好的一种方式：伪类清除浮动</p>\n<pre><code>.clearfix:after {\n  visibility: hidden;\n  display: block;\n  font-size: 0;\n  content: &quot; &quot;;\n  clear: both;\n  height: 0;\n}\n.clearfix{\n    zoom:1\n}</code></pre>\n"},{"title":"前端面试系列-JavaScript 数组","catalog":true,"url":"156.html","id":"156","date":"2019-02-26T04:45:15.000Z","subtitle":null,"header-img":null,"_content":"\n#### 一. 如何对一个多维数组进行扁平化\n\n首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组\n\n    const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n    \n\n> 1.  利用递归思想来解决\n\n    let tempArr = [];\n    function flattenArrFirst(array){\n    array.map(item=>{\n        if(Array.isArray(item)){\n            tempArr.concat(flattenArrFirst(item));\n        }else{\n            tempArr.push(item);\n        }\n    });\n    return tempArr;\n    }\n    \n    console.log(flattenArrFirst(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 2.  利用toString()方法和split方法\n\n    function flattenArrSecond(array){\n        let arrStr = array.toString().split(',');\n    \n        return arrStr.map(item=>Number(item));\n    }\n    console.log(flattenArrSecond(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 3.  第三种 利用ES6语法\n\n    function flattenArrThird(array){\n        while(array.some(item => Array.isArray(item))){\n          array = [].concat(...array);\n        }\n        return array;\n    }\n    console.log(flattenArrThird(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 4.  利用数组reduce方法（高端操作，哈哈 ^_^~）\n\n    function flattenFour(array){\n       return array.reduce((result,item)=>{\n           return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n       },[])\n    }\n    console.log(flattenFour(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 5.  利用join方法和split 方法\n\n    function flattenArrFive(array){\n        return arr.join(\",\").split(\",\").map(item => Number(item))\n    }\n    \n    console.log(flattenArrFive(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n#### 二. 如何对一个数组去重\n\n假如现在有数组:\n\n    const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n    \n\n> 1.第一种利用循环遍历\n\n    function uniqueFirst(arr){\n        let tempArr = [];\n        for (let i = 0; i < arr.length; i++) {\n          if(tempArr.indexOf(arr[i]) == -1){\n              tempArr.push(arr[i]);\n          }\n        }\n        return tempArr;\n    }\n    console.log(uniqueFirst(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 2.第二种排序相邻去重法\n\n    function uniqueSecond(arr){\n        arr.sort();\n        let tempArr = [arr[0]];\n        for(let i = 1; i < arr.length; i++){\n           if(tempArr[tempArr.length-1] !== arr[i]){\n               tempArr.push(arr[i])\n           }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSecond(arr));\n    // 打印结果：\n    // [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 3.第三种利用ES6 Set\n\n    var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\n    function uniqueThird(arr){\n        return Array.from(new Set(arr));\n    }\n    console.log(uniqueThird(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 4.第四种利用reduce\n\n    function uniqueFour(array) {\n        return array.reduce((a,b)=>{\n            a.indexOf(b) == -1 ? false : a.push(b);\n            return a\n        },[])\n    }\n    console.log(uniqueFour(arr));\n    // 打印结果：\n    //[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 5.第五种利用filter和includes方法\n\n    function uniqueFive(array){\n        let tempArr = [];\n       tempArr = array.filter(item=>{\n          return tempArr.includes(item)? false : tempArr.push(item)\n       });\n       return tempArr;\n    }\n    console.log(uniqueFive(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 6.第六种 对象键值对法\n\n    function uniqueSix(array){\n        let obj = {};\n        let tempArr = [];\n        for(let i =0;i<array.length;i++){\n            if(!obj[array[i]]){\n               tempArr.push(array[i]);\n               obj[arr[i]] = arr[i];\n            }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSix(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 7.  面试官追问题：如何对一个对象数组按照规定的字段去重\n\n    var usersArr = [\n        { name: \"name1\", age: \"1\" },\n        { name: \"name2\", age: \"11\" },\n        { name: \"name7\", age: \"11\" },\n        { name: \"name3\", age: \"12\" },\n        { name: \"name4\", age: \"13\" },\n        { name: \"name2\", age: \"1\" },\n        { name: \"name6\", age: \"12\" }\n    ]\n    \n    function uniqueByFields(array,fields){\n       let hash = {}\n       return array.reduce((arr,item)=>{\n           hash[item[fields]] ? \"\" : hash[item[fields]] = true && arr.push(item);\n           return arr\n       },[])\n    }\n    \n    console.log(uniqueByFields(usersArr, \"age\"));\n    // 打印结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name4', age: '13' } ]\n    \n\n> 8.  面试时关联题目：如何对对象数组按照特定字段进行排序\n\n    function sortByFileds(arr,fields){\n        return arr.sort((a,b)=>{\n            return a[fields] - b[fields];\n        });\n    }\n    console.log(sortByFileds(usersArr, \"age\"));\n    // 输出结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name7', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name6', age: '12' },\n      { name: 'name4', age: '13' } ]","source":"_posts/前端面试系列-JavaScript 数组.md","raw":"---\ntitle: 前端面试系列-JavaScript 数组\ncatalog: true\ntags:\n  - ES6\n  - Frontend Interview\n  - javascript\nurl: 156.html\nid: 156\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:45:15\nsubtitle:\nheader-img:\n---\n\n#### 一. 如何对一个多维数组进行扁平化\n\n首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组\n\n    const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n    \n\n> 1.  利用递归思想来解决\n\n    let tempArr = [];\n    function flattenArrFirst(array){\n    array.map(item=>{\n        if(Array.isArray(item)){\n            tempArr.concat(flattenArrFirst(item));\n        }else{\n            tempArr.push(item);\n        }\n    });\n    return tempArr;\n    }\n    \n    console.log(flattenArrFirst(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 2.  利用toString()方法和split方法\n\n    function flattenArrSecond(array){\n        let arrStr = array.toString().split(',');\n    \n        return arrStr.map(item=>Number(item));\n    }\n    console.log(flattenArrSecond(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 3.  第三种 利用ES6语法\n\n    function flattenArrThird(array){\n        while(array.some(item => Array.isArray(item))){\n          array = [].concat(...array);\n        }\n        return array;\n    }\n    console.log(flattenArrThird(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 4.  利用数组reduce方法（高端操作，哈哈 ^_^~）\n\n    function flattenFour(array){\n       return array.reduce((result,item)=>{\n           return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n       },[])\n    }\n    console.log(flattenFour(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 5.  利用join方法和split 方法\n\n    function flattenArrFive(array){\n        return arr.join(\",\").split(\",\").map(item => Number(item))\n    }\n    \n    console.log(flattenArrFive(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n#### 二. 如何对一个数组去重\n\n假如现在有数组:\n\n    const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n    \n\n> 1.第一种利用循环遍历\n\n    function uniqueFirst(arr){\n        let tempArr = [];\n        for (let i = 0; i < arr.length; i++) {\n          if(tempArr.indexOf(arr[i]) == -1){\n              tempArr.push(arr[i]);\n          }\n        }\n        return tempArr;\n    }\n    console.log(uniqueFirst(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 2.第二种排序相邻去重法\n\n    function uniqueSecond(arr){\n        arr.sort();\n        let tempArr = [arr[0]];\n        for(let i = 1; i < arr.length; i++){\n           if(tempArr[tempArr.length-1] !== arr[i]){\n               tempArr.push(arr[i])\n           }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSecond(arr));\n    // 打印结果：\n    // [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 3.第三种利用ES6 Set\n\n    var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\n    function uniqueThird(arr){\n        return Array.from(new Set(arr));\n    }\n    console.log(uniqueThird(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 4.第四种利用reduce\n\n    function uniqueFour(array) {\n        return array.reduce((a,b)=>{\n            a.indexOf(b) == -1 ? false : a.push(b);\n            return a\n        },[])\n    }\n    console.log(uniqueFour(arr));\n    // 打印结果：\n    //[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 5.第五种利用filter和includes方法\n\n    function uniqueFive(array){\n        let tempArr = [];\n       tempArr = array.filter(item=>{\n          return tempArr.includes(item)? false : tempArr.push(item)\n       });\n       return tempArr;\n    }\n    console.log(uniqueFive(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 6.第六种 对象键值对法\n\n    function uniqueSix(array){\n        let obj = {};\n        let tempArr = [];\n        for(let i =0;i<array.length;i++){\n            if(!obj[array[i]]){\n               tempArr.push(array[i]);\n               obj[arr[i]] = arr[i];\n            }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSix(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 7.  面试官追问题：如何对一个对象数组按照规定的字段去重\n\n    var usersArr = [\n        { name: \"name1\", age: \"1\" },\n        { name: \"name2\", age: \"11\" },\n        { name: \"name7\", age: \"11\" },\n        { name: \"name3\", age: \"12\" },\n        { name: \"name4\", age: \"13\" },\n        { name: \"name2\", age: \"1\" },\n        { name: \"name6\", age: \"12\" }\n    ]\n    \n    function uniqueByFields(array,fields){\n       let hash = {}\n       return array.reduce((arr,item)=>{\n           hash[item[fields]] ? \"\" : hash[item[fields]] = true && arr.push(item);\n           return arr\n       },[])\n    }\n    \n    console.log(uniqueByFields(usersArr, \"age\"));\n    // 打印结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name4', age: '13' } ]\n    \n\n> 8.  面试时关联题目：如何对对象数组按照特定字段进行排序\n\n    function sortByFileds(arr,fields){\n        return arr.sort((a,b)=>{\n            return a[fields] - b[fields];\n        });\n    }\n    console.log(sortByFileds(usersArr, \"age\"));\n    // 输出结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name7', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name6', age: '12' },\n      { name: 'name4', age: '13' } ]","slug":"前端面试系列-JavaScript 数组","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r56001lw72stybu89dd","content":"<h4><span id=\"一-如何对一个多维数组进行扁平化\">一. 如何对一个多维数组进行扁平化</span></h4>\n<p>首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组</p>\n<pre><code>const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n</code></pre>\n<blockquote>\n<ol>\n<li>利用递归思想来解决</li>\n</ol>\n</blockquote>\n<pre><code>let tempArr = [];\nfunction flattenArrFirst(array){\narray.map(item=&gt;{\n    if(Array.isArray(item)){\n        tempArr.concat(flattenArrFirst(item));\n    }else{\n        tempArr.push(item);\n    }\n});\nreturn tempArr;\n}\n\nconsole.log(flattenArrFirst(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>利用toString()方法和split方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrSecond(array){\n    let arrStr = array.toString().split(',');\n\n    return arrStr.map(item=&gt;Number(item));\n}\nconsole.log(flattenArrSecond(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>第三种 利用ES6语法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrThird(array){\n    while(array.some(item =&gt; Array.isArray(item))){\n      array = [].concat(...array);\n    }\n    return array;\n}\nconsole.log(flattenArrThird(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>利用数组reduce方法（高端操作，哈哈 ^_^~）</li>\n</ol>\n</blockquote>\n<pre><code>function flattenFour(array){\n   return array.reduce((result,item)=&gt;{\n       return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n   },[])\n}\nconsole.log(flattenFour(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>利用join方法和split 方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrFive(array){\n    return arr.join(&quot;,&quot;).split(&quot;,&quot;).map(item =&gt; Number(item))\n}\n\nconsole.log(flattenArrFive(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<h4><span id=\"二-如何对一个数组去重\">二. 如何对一个数组去重</span></h4>\n<p>假如现在有数组:</p>\n<pre><code>const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n</code></pre>\n<blockquote>\n<p>1.第一种利用循环遍历</p>\n</blockquote>\n<pre><code>function uniqueFirst(arr){\n    let tempArr = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n      if(tempArr.indexOf(arr[i]) == -1){\n          tempArr.push(arr[i]);\n      }\n    }\n    return tempArr;\n}\nconsole.log(uniqueFirst(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>2.第二种排序相邻去重法</p>\n</blockquote>\n<pre><code>function uniqueSecond(arr){\n    arr.sort();\n    let tempArr = [arr[0]];\n    for(let i = 1; i &lt; arr.length; i++){\n       if(tempArr[tempArr.length-1] !== arr[i]){\n           tempArr.push(arr[i])\n       }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSecond(arr));\n// 打印结果：\n// [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>3.第三种利用ES6 Set</p>\n</blockquote>\n<pre><code>var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\nfunction uniqueThird(arr){\n    return Array.from(new Set(arr));\n}\nconsole.log(uniqueThird(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>4.第四种利用reduce</p>\n</blockquote>\n<pre><code>function uniqueFour(array) {\n    return array.reduce((a,b)=&gt;{\n        a.indexOf(b) == -1 ? false : a.push(b);\n        return a\n    },[])\n}\nconsole.log(uniqueFour(arr));\n// 打印结果：\n//[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>5.第五种利用filter和includes方法</p>\n</blockquote>\n<pre><code>function uniqueFive(array){\n    let tempArr = [];\n   tempArr = array.filter(item=&gt;{\n      return tempArr.includes(item)? false : tempArr.push(item)\n   });\n   return tempArr;\n}\nconsole.log(uniqueFive(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>6.第六种 对象键值对法</p>\n</blockquote>\n<pre><code>function uniqueSix(array){\n    let obj = {};\n    let tempArr = [];\n    for(let i =0;i&lt;array.length;i++){\n        if(!obj[array[i]]){\n           tempArr.push(array[i]);\n           obj[arr[i]] = arr[i];\n        }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSix(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<ol start=\"7\">\n<li>面试官追问题：如何对一个对象数组按照规定的字段去重</li>\n</ol>\n</blockquote>\n<pre><code>var usersArr = [\n    { name: &quot;name1&quot;, age: &quot;1&quot; },\n    { name: &quot;name2&quot;, age: &quot;11&quot; },\n    { name: &quot;name7&quot;, age: &quot;11&quot; },\n    { name: &quot;name3&quot;, age: &quot;12&quot; },\n    { name: &quot;name4&quot;, age: &quot;13&quot; },\n    { name: &quot;name2&quot;, age: &quot;1&quot; },\n    { name: &quot;name6&quot;, age: &quot;12&quot; }\n]\n\nfunction uniqueByFields(array,fields){\n   let hash = {}\n   return array.reduce((arr,item)=&gt;{\n       hash[item[fields]] ? &quot;&quot; : hash[item[fields]] = true &amp;&amp; arr.push(item);\n       return arr\n   },[])\n}\n\nconsole.log(uniqueByFields(usersArr, &quot;age&quot;));\n// 打印结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name4', age: '13' } ]\n</code></pre>\n<blockquote>\n<ol start=\"8\">\n<li>面试时关联题目：如何对对象数组按照特定字段进行排序</li>\n</ol>\n</blockquote>\n<pre><code>function sortByFileds(arr,fields){\n    return arr.sort((a,b)=&gt;{\n        return a[fields] - b[fields];\n    });\n}\nconsole.log(sortByFileds(usersArr, &quot;age&quot;));\n// 输出结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name7', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name6', age: '12' },\n  { name: 'name4', age: '13' } ]</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>一. 如何对一个多维数组进行扁平化</h4>\n<p>首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组</p>\n<pre><code>const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n</code></pre>\n<blockquote>\n<ol>\n<li>利用递归思想来解决</li>\n</ol>\n</blockquote>\n<pre><code>let tempArr = [];\nfunction flattenArrFirst(array){\narray.map(item=&gt;{\n    if(Array.isArray(item)){\n        tempArr.concat(flattenArrFirst(item));\n    }else{\n        tempArr.push(item);\n    }\n});\nreturn tempArr;\n}\n\nconsole.log(flattenArrFirst(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>利用toString()方法和split方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrSecond(array){\n    let arrStr = array.toString().split(',');\n\n    return arrStr.map(item=&gt;Number(item));\n}\nconsole.log(flattenArrSecond(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>第三种 利用ES6语法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrThird(array){\n    while(array.some(item =&gt; Array.isArray(item))){\n      array = [].concat(...array);\n    }\n    return array;\n}\nconsole.log(flattenArrThird(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>利用数组reduce方法（高端操作，哈哈 ^_^~）</li>\n</ol>\n</blockquote>\n<pre><code>function flattenFour(array){\n   return array.reduce((result,item)=&gt;{\n       return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n   },[])\n}\nconsole.log(flattenFour(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>利用join方法和split 方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrFive(array){\n    return arr.join(&quot;,&quot;).split(&quot;,&quot;).map(item =&gt; Number(item))\n}\n\nconsole.log(flattenArrFive(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<h4>二. 如何对一个数组去重</h4>\n<p>假如现在有数组:</p>\n<pre><code>const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n</code></pre>\n<blockquote>\n<p>1.第一种利用循环遍历</p>\n</blockquote>\n<pre><code>function uniqueFirst(arr){\n    let tempArr = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n      if(tempArr.indexOf(arr[i]) == -1){\n          tempArr.push(arr[i]);\n      }\n    }\n    return tempArr;\n}\nconsole.log(uniqueFirst(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>2.第二种排序相邻去重法</p>\n</blockquote>\n<pre><code>function uniqueSecond(arr){\n    arr.sort();\n    let tempArr = [arr[0]];\n    for(let i = 1; i &lt; arr.length; i++){\n       if(tempArr[tempArr.length-1] !== arr[i]){\n           tempArr.push(arr[i])\n       }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSecond(arr));\n// 打印结果：\n// [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>3.第三种利用ES6 Set</p>\n</blockquote>\n<pre><code>var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\nfunction uniqueThird(arr){\n    return Array.from(new Set(arr));\n}\nconsole.log(uniqueThird(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>4.第四种利用reduce</p>\n</blockquote>\n<pre><code>function uniqueFour(array) {\n    return array.reduce((a,b)=&gt;{\n        a.indexOf(b) == -1 ? false : a.push(b);\n        return a\n    },[])\n}\nconsole.log(uniqueFour(arr));\n// 打印结果：\n//[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>5.第五种利用filter和includes方法</p>\n</blockquote>\n<pre><code>function uniqueFive(array){\n    let tempArr = [];\n   tempArr = array.filter(item=&gt;{\n      return tempArr.includes(item)? false : tempArr.push(item)\n   });\n   return tempArr;\n}\nconsole.log(uniqueFive(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>6.第六种 对象键值对法</p>\n</blockquote>\n<pre><code>function uniqueSix(array){\n    let obj = {};\n    let tempArr = [];\n    for(let i =0;i&lt;array.length;i++){\n        if(!obj[array[i]]){\n           tempArr.push(array[i]);\n           obj[arr[i]] = arr[i];\n        }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSix(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<ol start=\"7\">\n<li>面试官追问题：如何对一个对象数组按照规定的字段去重</li>\n</ol>\n</blockquote>\n<pre><code>var usersArr = [\n    { name: &quot;name1&quot;, age: &quot;1&quot; },\n    { name: &quot;name2&quot;, age: &quot;11&quot; },\n    { name: &quot;name7&quot;, age: &quot;11&quot; },\n    { name: &quot;name3&quot;, age: &quot;12&quot; },\n    { name: &quot;name4&quot;, age: &quot;13&quot; },\n    { name: &quot;name2&quot;, age: &quot;1&quot; },\n    { name: &quot;name6&quot;, age: &quot;12&quot; }\n]\n\nfunction uniqueByFields(array,fields){\n   let hash = {}\n   return array.reduce((arr,item)=&gt;{\n       hash[item[fields]] ? &quot;&quot; : hash[item[fields]] = true &amp;&amp; arr.push(item);\n       return arr\n   },[])\n}\n\nconsole.log(uniqueByFields(usersArr, &quot;age&quot;));\n// 打印结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name4', age: '13' } ]\n</code></pre>\n<blockquote>\n<ol start=\"8\">\n<li>面试时关联题目：如何对对象数组按照特定字段进行排序</li>\n</ol>\n</blockquote>\n<pre><code>function sortByFileds(arr,fields){\n    return arr.sort((a,b)=&gt;{\n        return a[fields] - b[fields];\n    });\n}\nconsole.log(sortByFileds(usersArr, &quot;age&quot;));\n// 输出结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name7', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name6', age: '12' },\n  { name: 'name4', age: '13' } ]</code></pre>\n"},{"title":"前端面试系列-JS基础数据类型","catalog":true,"url":"141.html","id":"141","date":"2019-02-26T04:30:16.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  typeof 结果可能有哪些值\n\n`number`,`string`, `function`, `object`, `undfined`, `boolean`, `symbol`\n\n> 2.  JS 的数据类型\n\n1.  值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。\n2.  引用数据类型：对象(Object)、数组(Array)、函数(Function)。\n    \n    > 3.  JS 中有哪些内置函数 - 数据封装类对象\n    \n    1.  Object\n    2.  Array\n    3.  Boolean\n    4.  Number\n    5.  String\n    6.  Function\n    7.  Date\n    8.  RegExp\n    9.  Error\n    10.  Math(对象)","source":"_posts/前端面试系列-JS基础数据类型.md","raw":"---\ntitle: 前端面试系列-JS基础数据类型\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 141.html\nid: 141\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:30:16\nsubtitle:\nheader-img:\n---\n\n> 1.  typeof 结果可能有哪些值\n\n`number`,`string`, `function`, `object`, `undfined`, `boolean`, `symbol`\n\n> 2.  JS 的数据类型\n\n1.  值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。\n2.  引用数据类型：对象(Object)、数组(Array)、函数(Function)。\n    \n    > 3.  JS 中有哪些内置函数 - 数据封装类对象\n    \n    1.  Object\n    2.  Array\n    3.  Boolean\n    4.  Number\n    5.  String\n    6.  Function\n    7.  Date\n    8.  RegExp\n    9.  Error\n    10.  Math(对象)","slug":"前端面试系列-JS基础数据类型","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r58001ow72s21vlb5kj","content":"<blockquote>\n<ol>\n<li>typeof 结果可能有哪些值</li>\n</ol>\n</blockquote>\n<p><code>number</code>,<code>string</code>, <code>function</code>, <code>object</code>, <code>undfined</code>, <code>boolean</code>, <code>symbol</code></p>\n<blockquote>\n<ol start=\"2\">\n<li>JS 的数据类型</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>\n</li>\n<li>\n<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>\n<blockquote>\n<ol start=\"3\">\n<li>JS 中有哪些内置函数 - 数据封装类对象</li>\n</ol>\n</blockquote>\n<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Function</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>Math(对象)</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>typeof 结果可能有哪些值</li>\n</ol>\n</blockquote>\n<p><code>number</code>,<code>string</code>, <code>function</code>, <code>object</code>, <code>undfined</code>, <code>boolean</code>, <code>symbol</code></p>\n<blockquote>\n<ol start=\"2\">\n<li>JS 的数据类型</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>\n</li>\n<li>\n<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>\n<blockquote>\n<ol start=\"3\">\n<li>JS 中有哪些内置函数 - 数据封装类对象</li>\n</ol>\n</blockquote>\n<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Function</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>Math(对象)</li>\n</ol>\n</li>\n</ol>\n"},{"title":"前端面试系列-JavaScript中的this指向问题","catalog":true,"url":"150.html","id":"150","date":"2019-02-26T04:39:33.000Z","subtitle":null,"header-img":null,"_content":"\n谁调用它他就指向谁，箭头函数没有this\n\n> 1.  new 的过程中发生了什么\n\n1.  首先创建一个新的对象\n2.  链接到原型\n3.  绑定this\n4.  返回新的对象\n\n代码实现：\n\n    function create() {\n      let obj = {};\n      let Constructor = [].shift.call(arguments);\n      obj.__proto__ = Constructor.prototype\n      let result = Constructor.apply(obj, arguments);\n      return typeof result === 'object' ? result : obj\n    }\n    \n\n> 2.  怎么实现bind, call, apply 手动实现一下\n> 3.  如果不传入参数默认是window\n> 4.  改变this的指向，让新的对象执行该函数\n> 5.  先给新的对象添加一个该函数，然后执行，执行后删除\n\n代码模拟实现Call：\n\n    Function.prototype.myCall = function (context) {\n      var context = context || window;\n      context.fn = this;\n      let args = [...arguments].slice(1);\n      let result = context.fn(...args);\n      delete context.fn;\n      return result;\n    }\n    \n\n代码模拟实现Apply：\n\n    Function.prototype.myApply = function (context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn\n      return result;\n    }\n    \n\n代码模拟实现Bind：\n\n    Function.prototype.myBind = function (context) {\n      if (typeof this != 'object') {\n        throw new TypeError('type error');\n      }\n      var self = this;\n      var args = [...arguments].slice(1);\n      return function Fn() {\n        if (typeof this instanceof Fn) {\n          return new self(...args, ...arguments);\n        } else {\n          return self.apply(context, args.concat(...arguments));\n        }\n      }\n    }\n    \n    \n\n> 3.instanceof 原理是什么？手动实现一下\n\n    function instanceOf(left, right) {\n      let prototype = right.prototype;\n      let left = left.__proto__\n      while (true) {\n        if (left == null) return false\n        if (left == prototype) return true\n        left = left.__proto__\n      }\n    }","source":"_posts/前端面试系列-JavaScript中的this指向问题.md","raw":"---\ntitle: 前端面试系列-JavaScript中的this指向问题\ncatalog: true\ntags:\n  - Frontend Interview\n  - html\n  - javascript\nurl: 150.html\nid: 150\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:39:33\nsubtitle:\nheader-img:\n---\n\n谁调用它他就指向谁，箭头函数没有this\n\n> 1.  new 的过程中发生了什么\n\n1.  首先创建一个新的对象\n2.  链接到原型\n3.  绑定this\n4.  返回新的对象\n\n代码实现：\n\n    function create() {\n      let obj = {};\n      let Constructor = [].shift.call(arguments);\n      obj.__proto__ = Constructor.prototype\n      let result = Constructor.apply(obj, arguments);\n      return typeof result === 'object' ? result : obj\n    }\n    \n\n> 2.  怎么实现bind, call, apply 手动实现一下\n> 3.  如果不传入参数默认是window\n> 4.  改变this的指向，让新的对象执行该函数\n> 5.  先给新的对象添加一个该函数，然后执行，执行后删除\n\n代码模拟实现Call：\n\n    Function.prototype.myCall = function (context) {\n      var context = context || window;\n      context.fn = this;\n      let args = [...arguments].slice(1);\n      let result = context.fn(...args);\n      delete context.fn;\n      return result;\n    }\n    \n\n代码模拟实现Apply：\n\n    Function.prototype.myApply = function (context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn\n      return result;\n    }\n    \n\n代码模拟实现Bind：\n\n    Function.prototype.myBind = function (context) {\n      if (typeof this != 'object') {\n        throw new TypeError('type error');\n      }\n      var self = this;\n      var args = [...arguments].slice(1);\n      return function Fn() {\n        if (typeof this instanceof Fn) {\n          return new self(...args, ...arguments);\n        } else {\n          return self.apply(context, args.concat(...arguments));\n        }\n      }\n    }\n    \n    \n\n> 3.instanceof 原理是什么？手动实现一下\n\n    function instanceOf(left, right) {\n      let prototype = right.prototype;\n      let left = left.__proto__\n      while (true) {\n        if (left == null) return false\n        if (left == prototype) return true\n        left = left.__proto__\n      }\n    }","slug":"前端面试系列-JavaScript中的this指向问题","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r59001rw72so2amxzx2","content":"<p>谁调用它他就指向谁，箭头函数没有this</p>\n<blockquote>\n<ol>\n<li>new 的过程中发生了什么</li>\n</ol>\n</blockquote>\n<ol>\n<li>首先创建一个新的对象</li>\n<li>链接到原型</li>\n<li>绑定this</li>\n<li>返回新的对象</li>\n</ol>\n<p>代码实现：</p>\n<pre><code>function create() {\n  let obj = {};\n  let Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments);\n  return typeof result === 'object' ? result : obj\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>怎么实现bind, call, apply 手动实现一下</li>\n<li>如果不传入参数默认是window</li>\n<li>改变this的指向，让新的对象执行该函数</li>\n<li>先给新的对象添加一个该函数，然后执行，执行后删除</li>\n</ol>\n</blockquote>\n<p>代码模拟实现Call：</p>\n<pre><code>Function.prototype.myCall = function (context) {\n  var context = context || window;\n  context.fn = this;\n  let args = [...arguments].slice(1);\n  let result = context.fn(...args);\n  delete context.fn;\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Apply：</p>\n<pre><code>Function.prototype.myApply = function (context) {\n  var context = context || window;\n  context.fn = this;\n  var result;\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Bind：</p>\n<pre><code>Function.prototype.myBind = function (context) {\n  if (typeof this != 'object') {\n    throw new TypeError('type error');\n  }\n  var self = this;\n  var args = [...arguments].slice(1);\n  return function Fn() {\n    if (typeof this instanceof Fn) {\n      return new self(...args, ...arguments);\n    } else {\n      return self.apply(context, args.concat(...arguments));\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>3.instanceof 原理是什么？手动实现一下</p>\n</blockquote>\n<pre><code>function instanceOf(left, right) {\n  let prototype = right.prototype;\n  let left = left.__proto__\n  while (true) {\n    if (left == null) return false\n    if (left == prototype) return true\n    left = left.__proto__\n  }\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>谁调用它他就指向谁，箭头函数没有this</p>\n<blockquote>\n<ol>\n<li>new 的过程中发生了什么</li>\n</ol>\n</blockquote>\n<ol>\n<li>首先创建一个新的对象</li>\n<li>链接到原型</li>\n<li>绑定this</li>\n<li>返回新的对象</li>\n</ol>\n<p>代码实现：</p>\n<pre><code>function create() {\n  let obj = {};\n  let Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments);\n  return typeof result === 'object' ? result : obj\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>怎么实现bind, call, apply 手动实现一下</li>\n<li>如果不传入参数默认是window</li>\n<li>改变this的指向，让新的对象执行该函数</li>\n<li>先给新的对象添加一个该函数，然后执行，执行后删除</li>\n</ol>\n</blockquote>\n<p>代码模拟实现Call：</p>\n<pre><code>Function.prototype.myCall = function (context) {\n  var context = context || window;\n  context.fn = this;\n  let args = [...arguments].slice(1);\n  let result = context.fn(...args);\n  delete context.fn;\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Apply：</p>\n<pre><code>Function.prototype.myApply = function (context) {\n  var context = context || window;\n  context.fn = this;\n  var result;\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Bind：</p>\n<pre><code>Function.prototype.myBind = function (context) {\n  if (typeof this != 'object') {\n    throw new TypeError('type error');\n  }\n  var self = this;\n  var args = [...arguments].slice(1);\n  return function Fn() {\n    if (typeof this instanceof Fn) {\n      return new self(...args, ...arguments);\n    } else {\n      return self.apply(context, args.concat(...arguments));\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>3.instanceof 原理是什么？手动实现一下</p>\n</blockquote>\n<pre><code>function instanceOf(left, right) {\n  let prototype = right.prototype;\n  let left = left.__proto__\n  while (true) {\n    if (left == null) return false\n    if (left == prototype) return true\n    left = left.__proto__\n  }\n}</code></pre>\n"},{"title":"前端面试系列-JavaScript继承","catalog":true,"url":"178.html","id":"178","date":"2019-03-05T15:12:36.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg)\n\n### Javascript 继承\n\n#### 1\\. 通过构造函数实现继承\n\n    function Parent(){\n        this.parent = 'parent'\n        this.getWho = function(){\n            return 'getWho:'+this.parent\n        }\n    }\n    Parent.prototype.sayWho = function(){\n       console.log(`prototype from ${this.parent}`);\n        return `prototype from ${this.parent}`\n    }\n    \n    function Child(){\n        Parent.call(this);\n        this.child = \"child\"\n    }\n    \n    let children = new Child();\n    \n    console.log(children.child);// child\n    console.log(children.getWho());// getWho:parent\n    console.log(children.parent); // parent\n    console.log(children.sayWho()); // TypeError: children.sayWho is not a function\n    \n    \n\n这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。\n\n#### 2\\. 借助原型链实现继承\n\n    function Parent1(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n        this.lookList=function(){\n            return this.list\n        }\n    }\n    Parent1.prototype.getList=function(){\n        return this.list\n    }\n    function Child1(){\n        this.child = 'child'\n    }\n    Child1.prototype = new Parent1();\n    \n    let s1 = new Child1();\n    let s2 = new Child1();\n    console.log(s1.list); // [ 1, 2, 3 ]\n    s1.list.push(4)\n    console.log(s2.list); // [ 1, 2, 3, 4 ]\n    console.log(s1.lookList()); // [ 1, 2, 3, 4 ]\n    console.log(s1.getList()); // [ 1, 2, 3, 4 ]\n    \n\n通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); <=> Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.pro 和 s2.pro指向同一个地址即 父类的 prototype\n\n#### 3\\. 组合式继承\n\n    function Parent2(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n    }\n    Parent2.prototype.getList = function(){\n        return this.list\n    }\n    function Child2(){\n        Parent2.call(this)\n        this.child = 'child';\n    }\n    Child2.prototype = new Parent2();\n    \n    let s3 = new Child2();\n    let s4 = new Child2();\n    \n    console.log(s3.getList());// [ 1, 2, 3 ]\n    console.log(s4.list);//[ 1, 2, 3]\n    s3.list.push(4);\n    console.log(s3.list); // [ 1, 2, 3, 4 ]\n    \n\n将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。\n\n#### 4\\. 寄生组合继承\n\n    function Parent3() {\n        this.parent = 'parent3'\n        this.list = [1, 2, 3]\n    }\n    Parent3.prototype.getList = function () {\n        return this.list\n    }\n    function Child3() {\n        Parent3.call(this)\n        this.child = 'child';\n    }\n    Child3.prototype =Object.create(Parent3.prototype); //重点\n    Child3.prototype.constructor = Child3;// 重点\n    let s5 = new Child3();\n    let s6 = new Child3();\n    \n    console.log(s5.getList());// [ 1, 2, 3 ]\n    s5.list.push(4);\n    console.log(s5.list); // [ 1, 2, 3, 4 ]\n    console.log(s6.list);//[ 1, 2, 3]\n    \n\n这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor","source":"_posts/前端面试系列-JavaScript继承.md","raw":"---\ntitle: 前端面试系列-JavaScript继承\ncatalog: true\ntags:\n  - javascript\nurl: 178.html\nid: 178\ncategories:\n  - JavaScript\ndate: 2019-03-05 23:12:36\nsubtitle:\nheader-img:\n---\n\n![](http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg)\n\n### Javascript 继承\n\n#### 1\\. 通过构造函数实现继承\n\n    function Parent(){\n        this.parent = 'parent'\n        this.getWho = function(){\n            return 'getWho:'+this.parent\n        }\n    }\n    Parent.prototype.sayWho = function(){\n       console.log(`prototype from ${this.parent}`);\n        return `prototype from ${this.parent}`\n    }\n    \n    function Child(){\n        Parent.call(this);\n        this.child = \"child\"\n    }\n    \n    let children = new Child();\n    \n    console.log(children.child);// child\n    console.log(children.getWho());// getWho:parent\n    console.log(children.parent); // parent\n    console.log(children.sayWho()); // TypeError: children.sayWho is not a function\n    \n    \n\n这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。\n\n#### 2\\. 借助原型链实现继承\n\n    function Parent1(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n        this.lookList=function(){\n            return this.list\n        }\n    }\n    Parent1.prototype.getList=function(){\n        return this.list\n    }\n    function Child1(){\n        this.child = 'child'\n    }\n    Child1.prototype = new Parent1();\n    \n    let s1 = new Child1();\n    let s2 = new Child1();\n    console.log(s1.list); // [ 1, 2, 3 ]\n    s1.list.push(4)\n    console.log(s2.list); // [ 1, 2, 3, 4 ]\n    console.log(s1.lookList()); // [ 1, 2, 3, 4 ]\n    console.log(s1.getList()); // [ 1, 2, 3, 4 ]\n    \n\n通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); <=> Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.pro 和 s2.pro指向同一个地址即 父类的 prototype\n\n#### 3\\. 组合式继承\n\n    function Parent2(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n    }\n    Parent2.prototype.getList = function(){\n        return this.list\n    }\n    function Child2(){\n        Parent2.call(this)\n        this.child = 'child';\n    }\n    Child2.prototype = new Parent2();\n    \n    let s3 = new Child2();\n    let s4 = new Child2();\n    \n    console.log(s3.getList());// [ 1, 2, 3 ]\n    console.log(s4.list);//[ 1, 2, 3]\n    s3.list.push(4);\n    console.log(s3.list); // [ 1, 2, 3, 4 ]\n    \n\n将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。\n\n#### 4\\. 寄生组合继承\n\n    function Parent3() {\n        this.parent = 'parent3'\n        this.list = [1, 2, 3]\n    }\n    Parent3.prototype.getList = function () {\n        return this.list\n    }\n    function Child3() {\n        Parent3.call(this)\n        this.child = 'child';\n    }\n    Child3.prototype =Object.create(Parent3.prototype); //重点\n    Child3.prototype.constructor = Child3;// 重点\n    let s5 = new Child3();\n    let s6 = new Child3();\n    \n    console.log(s5.getList());// [ 1, 2, 3 ]\n    s5.list.push(4);\n    console.log(s5.list); // [ 1, 2, 3, 4 ]\n    console.log(s6.list);//[ 1, 2, 3]\n    \n\n这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor","slug":"前端面试系列-JavaScript继承","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r5b001uw72s8xp7nsbw","content":"<p><img src=\"http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg\" alt></p>\n<h3><span id=\"javascript-继承\">Javascript 继承</span></h3>\n<h4><span id=\"1-通过构造函数实现继承\">1. 通过构造函数实现继承</span></h4>\n<pre><code>function Parent(){\n    this.parent = 'parent'\n    this.getWho = function(){\n        return 'getWho:'+this.parent\n    }\n}\nParent.prototype.sayWho = function(){\n   console.log(`prototype from ${this.parent}`);\n    return `prototype from ${this.parent}`\n}\n\nfunction Child(){\n    Parent.call(this);\n    this.child = &quot;child&quot;\n}\n\nlet children = new Child();\n\nconsole.log(children.child);// child\nconsole.log(children.getWho());// getWho:parent\nconsole.log(children.parent); // parent\nconsole.log(children.sayWho()); // TypeError: children.sayWho is not a function\n</code></pre>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4><span id=\"2-借助原型链实现继承\">2. 借助原型链实现继承</span></h4>\n<pre><code>function Parent1(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n    this.lookList=function(){\n        return this.list\n    }\n}\nParent1.prototype.getList=function(){\n    return this.list\n}\nfunction Child1(){\n    this.child = 'child'\n}\nChild1.prototype = new Parent1();\n\nlet s1 = new Child1();\nlet s2 = new Child1();\nconsole.log(s1.list); // [ 1, 2, 3 ]\ns1.list.push(4)\nconsole.log(s2.list); // [ 1, 2, 3, 4 ]\nconsole.log(s1.lookList()); // [ 1, 2, 3, 4 ]\nconsole.log(s1.getList()); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); &lt;=&gt; Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 <a href=\"http://s1.pro\" target=\"_blank\" rel=\"noopener\">s1.pro</a> 和 s2.pro指向同一个地址即 父类的 prototype</p>\n<h4><span id=\"3-组合式继承\">3. 组合式继承</span></h4>\n<pre><code>function Parent2(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n}\nParent2.prototype.getList = function(){\n    return this.list\n}\nfunction Child2(){\n    Parent2.call(this)\n    this.child = 'child';\n}\nChild2.prototype = new Parent2();\n\nlet s3 = new Child2();\nlet s4 = new Child2();\n\nconsole.log(s3.getList());// [ 1, 2, 3 ]\nconsole.log(s4.list);//[ 1, 2, 3]\ns3.list.push(4);\nconsole.log(s3.list); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。</p>\n<h4><span id=\"4-寄生组合继承\">4. 寄生组合继承</span></h4>\n<pre><code>function Parent3() {\n    this.parent = 'parent3'\n    this.list = [1, 2, 3]\n}\nParent3.prototype.getList = function () {\n    return this.list\n}\nfunction Child3() {\n    Parent3.call(this)\n    this.child = 'child';\n}\nChild3.prototype =Object.create(Parent3.prototype); //重点\nChild3.prototype.constructor = Child3;// 重点\nlet s5 = new Child3();\nlet s6 = new Child3();\n\nconsole.log(s5.getList());// [ 1, 2, 3 ]\ns5.list.push(4);\nconsole.log(s5.list); // [ 1, 2, 3, 4 ]\nconsole.log(s6.list);//[ 1, 2, 3]\n</code></pre>\n<p>这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg\" alt></p>\n<h3>Javascript 继承</h3>\n<h4>1. 通过构造函数实现继承</h4>\n<pre><code>function Parent(){\n    this.parent = 'parent'\n    this.getWho = function(){\n        return 'getWho:'+this.parent\n    }\n}\nParent.prototype.sayWho = function(){\n   console.log(`prototype from ${this.parent}`);\n    return `prototype from ${this.parent}`\n}\n\nfunction Child(){\n    Parent.call(this);\n    this.child = &quot;child&quot;\n}\n\nlet children = new Child();\n\nconsole.log(children.child);// child\nconsole.log(children.getWho());// getWho:parent\nconsole.log(children.parent); // parent\nconsole.log(children.sayWho()); // TypeError: children.sayWho is not a function\n</code></pre>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4>2. 借助原型链实现继承</h4>\n<pre><code>function Parent1(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n    this.lookList=function(){\n        return this.list\n    }\n}\nParent1.prototype.getList=function(){\n    return this.list\n}\nfunction Child1(){\n    this.child = 'child'\n}\nChild1.prototype = new Parent1();\n\nlet s1 = new Child1();\nlet s2 = new Child1();\nconsole.log(s1.list); // [ 1, 2, 3 ]\ns1.list.push(4)\nconsole.log(s2.list); // [ 1, 2, 3, 4 ]\nconsole.log(s1.lookList()); // [ 1, 2, 3, 4 ]\nconsole.log(s1.getList()); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); &lt;=&gt; Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 <a href=\"http://s1.pro\" target=\"_blank\" rel=\"noopener\">s1.pro</a> 和 s2.pro指向同一个地址即 父类的 prototype</p>\n<h4>3. 组合式继承</h4>\n<pre><code>function Parent2(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n}\nParent2.prototype.getList = function(){\n    return this.list\n}\nfunction Child2(){\n    Parent2.call(this)\n    this.child = 'child';\n}\nChild2.prototype = new Parent2();\n\nlet s3 = new Child2();\nlet s4 = new Child2();\n\nconsole.log(s3.getList());// [ 1, 2, 3 ]\nconsole.log(s4.list);//[ 1, 2, 3]\ns3.list.push(4);\nconsole.log(s3.list); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。</p>\n<h4>4. 寄生组合继承</h4>\n<pre><code>function Parent3() {\n    this.parent = 'parent3'\n    this.list = [1, 2, 3]\n}\nParent3.prototype.getList = function () {\n    return this.list\n}\nfunction Child3() {\n    Parent3.call(this)\n    this.child = 'child';\n}\nChild3.prototype =Object.create(Parent3.prototype); //重点\nChild3.prototype.constructor = Child3;// 重点\nlet s5 = new Child3();\nlet s6 = new Child3();\n\nconsole.log(s5.getList());// [ 1, 2, 3 ]\ns5.list.push(4);\nconsole.log(s5.list); // [ 1, 2, 3, 4 ]\nconsole.log(s6.list);//[ 1, 2, 3]\n</code></pre>\n<p>这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor</p>\n"},{"title":"前端面试系列-前端跨域常用的几种方式","catalog":true,"url":"143.html","id":"143","date":"2019-02-26T04:32:55.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。\n\n封装JOSNP\n\n    function jsonp(url,callback,success){\n        var scprit = document.createElement('script');\n        script.src=url;\n        script.async = true;\n        script.type = 'text/javascript';\n        window[callback] = function(data){\n            success && success(data)\n        }\n        document.body.appendChild(script);\n    }\n    // 调用\n    jsonp('http://xvideo.com',callback,function(data){\n        console.log(data);\n    })\n    \n\n> 2.  CORS 推荐 我最常用的手段之一\n\n1.  CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。\n    \n2.  浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n    \n3.  服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n    \n\n> 3.  `document.domain` 可以思考思考如何做单点登录和cookie跨域\n\n1.  该方式只能用于`二级域名相同`的情况下，比如 `a.test.com` 和 \\`\\`\\`b.test.com\\`\\` 适用于该方式。\n    \n2.  只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域\n    \n\n> 4.PostMessage\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n    // 发送消息端\n    window.parent.postMessage('message', 'http://test.com');\n    // 接收消息端\n    var mc = new MessageChannel();\n    mc.addEventListener('message', event => {\n        var origin = event.origin || event.originalEvent.origin\n        if (origin === 'http://test.com') {\n            console.log('验证通过')\n        }\n    })\n    \n\n##### 还有更多种跨域，比如window.name等等","source":"_posts/前端面试系列-前端跨域常用的几种方式.md","raw":"---\ntitle: 前端面试系列-前端跨域常用的几种方式\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 143.html\nid: 143\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:32:55\nsubtitle:\nheader-img:\n---\n\n> 1.  JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。\n\n封装JOSNP\n\n    function jsonp(url,callback,success){\n        var scprit = document.createElement('script');\n        script.src=url;\n        script.async = true;\n        script.type = 'text/javascript';\n        window[callback] = function(data){\n            success && success(data)\n        }\n        document.body.appendChild(script);\n    }\n    // 调用\n    jsonp('http://xvideo.com',callback,function(data){\n        console.log(data);\n    })\n    \n\n> 2.  CORS 推荐 我最常用的手段之一\n\n1.  CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。\n    \n2.  浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n    \n3.  服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n    \n\n> 3.  `document.domain` 可以思考思考如何做单点登录和cookie跨域\n\n1.  该方式只能用于`二级域名相同`的情况下，比如 `a.test.com` 和 \\`\\`\\`b.test.com\\`\\` 适用于该方式。\n    \n2.  只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域\n    \n\n> 4.PostMessage\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n    // 发送消息端\n    window.parent.postMessage('message', 'http://test.com');\n    // 接收消息端\n    var mc = new MessageChannel();\n    mc.addEventListener('message', event => {\n        var origin = event.origin || event.originalEvent.origin\n        if (origin === 'http://test.com') {\n            console.log('验证通过')\n        }\n    })\n    \n\n##### 还有更多种跨域，比如window.name等等","slug":"前端面试系列-前端跨域常用的几种方式","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r5c001yw72saxax7j7q","content":"<blockquote>\n<ol>\n<li>JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。</li>\n</ol>\n</blockquote>\n<p>封装JOSNP</p>\n<pre><code>function jsonp(url,callback,success){\n    var scprit = document.createElement('script');\n    script.src=url;\n    script.async = true;\n    script.type = 'text/javascript';\n    window[callback] = function(data){\n        success &amp;&amp; success(data)\n    }\n    document.body.appendChild(script);\n}\n// 调用\njsonp('http://xvideo.com',callback,function(data){\n    console.log(data);\n})\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>CORS 推荐 我最常用的手段之一</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>\n</li>\n<li>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n</li>\n<li>\n<p>服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li><code>document.domain</code> 可以思考思考如何做单点登录和cookie跨域</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>该方式只能用于<code>二级域名相同</code>的情况下，比如 <code>a.test.com</code> 和 ```b.test.com`` 适用于该方式。</p>\n</li>\n<li>\n<p>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</p>\n</li>\n</ol>\n<blockquote>\n<p>4.PostMessage</p>\n</blockquote>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<pre><code>// 发送消息端\nwindow.parent.postMessage('message', 'http://test.com');\n// 接收消息端\nvar mc = new MessageChannel();\nmc.addEventListener('message', event =&gt; {\n    var origin = event.origin || event.originalEvent.origin\n    if (origin === 'http://test.com') {\n        console.log('验证通过')\n    }\n})\n</code></pre>\n<h5><span id=\"还有更多种跨域比如windowname等等\">还有更多种跨域，比如window.name等等</span></h5>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。</li>\n</ol>\n</blockquote>\n<p>封装JOSNP</p>\n<pre><code>function jsonp(url,callback,success){\n    var scprit = document.createElement('script');\n    script.src=url;\n    script.async = true;\n    script.type = 'text/javascript';\n    window[callback] = function(data){\n        success &amp;&amp; success(data)\n    }\n    document.body.appendChild(script);\n}\n// 调用\njsonp('http://xvideo.com',callback,function(data){\n    console.log(data);\n})\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>CORS 推荐 我最常用的手段之一</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>\n</li>\n<li>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n</li>\n<li>\n<p>服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li><code>document.domain</code> 可以思考思考如何做单点登录和cookie跨域</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>该方式只能用于<code>二级域名相同</code>的情况下，比如 <code>a.test.com</code> 和 ```b.test.com`` 适用于该方式。</p>\n</li>\n<li>\n<p>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</p>\n</li>\n</ol>\n<blockquote>\n<p>4.PostMessage</p>\n</blockquote>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<pre><code>// 发送消息端\nwindow.parent.postMessage('message', 'http://test.com');\n// 接收消息端\nvar mc = new MessageChannel();\nmc.addEventListener('message', event =&gt; {\n    var origin = event.origin || event.originalEvent.origin\n    if (origin === 'http://test.com') {\n        console.log('验证通过')\n    }\n})\n</code></pre>\n<h5>还有更多种跨域，比如window.name等等</h5>\n"},{"title":"前端面试系列-游览器中的事件","catalog":true,"url":"147.html","id":"147","date":"2019-02-26T04:36:25.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  事件触发的过程\n> \n> \\- `window` 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）\n\n*   传播到事件处发处注册事件会触发\n    \n*   从事件触发处往window传播，遇见注册的事件冒泡会触发\n    \n*   事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n    \n\n    // 以下会先打印冒泡然后是捕获\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('冒泡')\n      },\n      false\n    )\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('捕获 ')\n      },\n      true\n    )\n    \n\n> 2.  事件代理\n\n    <ul id=\"ul\">\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n    </ul>\n    <script>\n      let ul = document.querySelector('#ul')\n      ul.addEventListener('click', event => {\n        console.log(event.target)\n      })\n    </script>\n    \n\n> 3.自定义事件\n\n1.  第一种利用customEvent\n\n    let customEvent = new CustomEvent(\"customEventName\", {\n        detail:{\n            data: \"hello customEvent\"\n        }\n    });\n    \n    // 分派事件对象\n    document.dispatchEvent(customEvent);\n    // 监听事件\n    document.addEventListener('customEventName', (e)=>{\n        console.log(e.detail.data); // \"hello customEvent\"\n    });\n    \n\n2.  第二种利用createEvent\n\n    // 创建事件对象\n    let customCreateEvent = new createEvent('customEventName');\n    // 初始化事件对象\n    customCreateEvent.initCustomEvent(\"ev\", false, true, {data: \"hello createEvent\"});\n    // 分派事件\n    document.dispatchEvent(customCreateEvent);\n    // 监听事件\n    document.addEventListener('ev',e=>{\n        console.log(e.detail.data) // \"hello createEvent\"\n    });","source":"_posts/前端面试系列-游览器中的事件.md","raw":"---\ntitle: 前端面试系列-游览器中的事件\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 147.html\nid: 147\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:36:25\nsubtitle:\nheader-img:\n---\n\n> 1.  事件触发的过程\n> \n> \\- `window` 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）\n\n*   传播到事件处发处注册事件会触发\n    \n*   从事件触发处往window传播，遇见注册的事件冒泡会触发\n    \n*   事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n    \n\n    // 以下会先打印冒泡然后是捕获\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('冒泡')\n      },\n      false\n    )\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('捕获 ')\n      },\n      true\n    )\n    \n\n> 2.  事件代理\n\n    <ul id=\"ul\">\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n    </ul>\n    <script>\n      let ul = document.querySelector('#ul')\n      ul.addEventListener('click', event => {\n        console.log(event.target)\n      })\n    </script>\n    \n\n> 3.自定义事件\n\n1.  第一种利用customEvent\n\n    let customEvent = new CustomEvent(\"customEventName\", {\n        detail:{\n            data: \"hello customEvent\"\n        }\n    });\n    \n    // 分派事件对象\n    document.dispatchEvent(customEvent);\n    // 监听事件\n    document.addEventListener('customEventName', (e)=>{\n        console.log(e.detail.data); // \"hello customEvent\"\n    });\n    \n\n2.  第二种利用createEvent\n\n    // 创建事件对象\n    let customCreateEvent = new createEvent('customEventName');\n    // 初始化事件对象\n    customCreateEvent.initCustomEvent(\"ev\", false, true, {data: \"hello createEvent\"});\n    // 分派事件\n    document.dispatchEvent(customCreateEvent);\n    // 监听事件\n    document.addEventListener('ev',e=>{\n        console.log(e.detail.data) // \"hello createEvent\"\n    });","slug":"前端面试系列-游览器中的事件","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r5d0021w72sagnlw0y9","content":"<blockquote>\n<ol>\n<li>事件触发的过程</li>\n</ol>\n<p>- <code>window</code> 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）</p>\n</blockquote>\n<ul>\n<li>\n<p>传播到事件处发处注册事件会触发</p>\n</li>\n<li>\n<p>从事件触发处往window传播，遇见注册的事件冒泡会触发</p>\n</li>\n<li>\n<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>\n</li>\n</ul>\n<pre><code>// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('捕获 ')\n  },\n  true\n)\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>事件代理</li>\n</ol>\n</blockquote>\n<pre><code>&lt;ul id=&quot;ul&quot;&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  &lt;li&gt;4&lt;/li&gt;\n  &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n  let ul = document.querySelector('#ul')\n  ul.addEventListener('click', event =&gt; {\n    console.log(event.target)\n  })\n&lt;/script&gt;\n</code></pre>\n<blockquote>\n<p>3.自定义事件</p>\n</blockquote>\n<ol>\n<li>\n<p>第一种利用customEvent</p>\n<p>let customEvent = new CustomEvent(“customEventName”, {<br>\ndetail:{<br>\ndata: “hello customEvent”<br>\n}<br>\n});</p>\n<p>// 分派事件对象<br>\ndocument.dispatchEvent(customEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘customEventName’, (e)=&gt;{<br>\nconsole.log(e.detail.data); // “hello customEvent”<br>\n});</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>第二种利用createEvent</p>\n<p>// 创建事件对象<br>\nlet customCreateEvent = new createEvent(‘customEventName’);<br>\n// 初始化事件对象<br>\ncustomCreateEvent.initCustomEvent(“ev”, false, true, {data: “hello createEvent”});<br>\n// 分派事件<br>\ndocument.dispatchEvent(customCreateEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘ev’,e=&gt;{<br>\nconsole.log(e.detail.data) // “hello createEvent”<br>\n});</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>事件触发的过程</li>\n</ol>\n<p>- <code>window</code> 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）</p>\n</blockquote>\n<ul>\n<li>\n<p>传播到事件处发处注册事件会触发</p>\n</li>\n<li>\n<p>从事件触发处往window传播，遇见注册的事件冒泡会触发</p>\n</li>\n<li>\n<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>\n</li>\n</ul>\n<pre><code>// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('捕获 ')\n  },\n  true\n)\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>事件代理</li>\n</ol>\n</blockquote>\n<pre><code>&lt;ul id=&quot;ul&quot;&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  &lt;li&gt;4&lt;/li&gt;\n  &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n  let ul = document.querySelector('#ul')\n  ul.addEventListener('click', event =&gt; {\n    console.log(event.target)\n  })\n&lt;/script&gt;\n</code></pre>\n<blockquote>\n<p>3.自定义事件</p>\n</blockquote>\n<ol>\n<li>\n<p>第一种利用customEvent</p>\n<p>let customEvent = new CustomEvent(“customEventName”, {<br>\ndetail:{<br>\ndata: “hello customEvent”<br>\n}<br>\n});</p>\n<p>// 分派事件对象<br>\ndocument.dispatchEvent(customEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘customEventName’, (e)=&gt;{<br>\nconsole.log(e.detail.data); // “hello customEvent”<br>\n});</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>第二种利用createEvent</p>\n<p>// 创建事件对象<br>\nlet customCreateEvent = new createEvent(‘customEventName’);<br>\n// 初始化事件对象<br>\ncustomCreateEvent.initCustomEvent(“ev”, false, true, {data: “hello createEvent”});<br>\n// 分派事件<br>\ndocument.dispatchEvent(customCreateEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘ev’,e=&gt;{<br>\nconsole.log(e.detail.data) // “hello createEvent”<br>\n});</p>\n</li>\n</ol>\n"},{"title":"如何在Vue SPA中集成GraphQL","catalog":true,"url":"101.html","id":"101","date":"2019-02-20T10:50:50.000Z","subtitle":null,"header-img":null,"_content":"\n![](https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67)\n\n> 1.  为了快速搭建，首先我们安装vue-cli@3.x\n\n     sudo npm install -g @vue/cli\n     yarn global add @vue/cli\n    \n\n> 2.  我们快速搭建一个Vue-SPA项目\n\n      mkdir learn_vue_with_graphql\n      cd learn_vue_with_graphql\n      vue create vue-ssr-graphql\n      # 按照你自己的需求选择插件\n      # 安装完毕后，进入vue-ssr-graphql目录\n      cd vue-ssr-graphql\n    \n\n> 3.  安装关于在vue中使用graphQL的一些包\n\n    npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n或者\n\n    yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n> 4.  在项目`src` 目录下创建`apolloClient.js`文件\n\n    import { ApolloClient } from 'apollo-client';\n    import { HttpLink } from 'apollo-link-http';\n    import { InMemoryCache } from 'apollo-cache-inmemory';\n    \n    const httpLink = new HttpLink({\n      uri: 'http://localhost:3000/graphql'\n    });\n    \n    const cache = new InMemoryCache();\n    // 导出 ApolloClient graphQL客户端\n    export default new ApolloClient({\n      link: httpLink,\n      cache\n    });\n    \n\n> 5.  修改`main.js`安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）\n\n    import Vue from 'vue'\n    import App from './App.vue'\n    import router from './router'\n    import store from './store'\n    import apolloClient from './apolloClient'\n    import './registerServiceWorker'\n    import VueApollo from 'vue-apollo';\n    \n    Vue.config.productionTip = false\n    \n    const apolloProvider = new VueApollo({\n      defaultClient: apolloClient\n    })\n    Vue.use(VueApollo);\n    new Vue({\n      router,\n      store,\n      apolloProvider,\n      render: h => h(App)\n    }).$mount('#app')\n    \n    \n\n> 6.在组件中使用（需要配合graphQL服务端）\n\n服务端源码地址：[github](https://github.com/maliaoMJ/graphql-api-server)\n\n1.  首先打开`views`目录下的`Home.vue` 文件\n\n在vue文件的JS部分做如下修改\n\n    <script>\n    // @ is an alias to /src\n    import gql from \"graphql-tag\";\n    export default {\n      name: \"home\",\n      computed: {\n        loading() {\n          return this.$apollo.loading;\n        }\n      },\n      data() {\n        return {\n          hello: \"\"\n        };\n      },\n      mounted() {\n        console.log(this.$apollo.loading, this.$apollo.data);\n      },\n      apollo: {\n        hello: {\n          query: gql`\n            query getUserInfo($id: Int!) {\n              hello\n              userInfo(id: $id) {\n                name\n                age\n                gender\n                id\n              }\n            }\n          `,\n          variables: {\n            id: 10001\n          }\n        }\n      }\n    };\n    </script>\n    \n    \n\n2.  运行项目\n\n运行如下命令\n\n    yarn run serve\n    \n\n然后打开游览器访问`localhost:8080`可以看到如下结果\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16-1.png)\n\n##### 最后附上源代码文件地址 [github](https://github.com/maliaoMJ/vue-graphQL-template)","source":"_posts/如何在Vue SPA中集成GraphQL.md","raw":"---\ntitle: 如何在Vue SPA中集成GraphQL\ncatalog: true\ntags:\n  - graphql\n  - nodejs\n  - vuejs\nurl: 101.html\nid: 101\ncategories:\n  - GraphQL\ndate: 2019-02-20 18:50:50\nsubtitle:\nheader-img:\n---\n\n![](https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67)\n\n> 1.  为了快速搭建，首先我们安装vue-cli@3.x\n\n     sudo npm install -g @vue/cli\n     yarn global add @vue/cli\n    \n\n> 2.  我们快速搭建一个Vue-SPA项目\n\n      mkdir learn_vue_with_graphql\n      cd learn_vue_with_graphql\n      vue create vue-ssr-graphql\n      # 按照你自己的需求选择插件\n      # 安装完毕后，进入vue-ssr-graphql目录\n      cd vue-ssr-graphql\n    \n\n> 3.  安装关于在vue中使用graphQL的一些包\n\n    npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n或者\n\n    yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n> 4.  在项目`src` 目录下创建`apolloClient.js`文件\n\n    import { ApolloClient } from 'apollo-client';\n    import { HttpLink } from 'apollo-link-http';\n    import { InMemoryCache } from 'apollo-cache-inmemory';\n    \n    const httpLink = new HttpLink({\n      uri: 'http://localhost:3000/graphql'\n    });\n    \n    const cache = new InMemoryCache();\n    // 导出 ApolloClient graphQL客户端\n    export default new ApolloClient({\n      link: httpLink,\n      cache\n    });\n    \n\n> 5.  修改`main.js`安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）\n\n    import Vue from 'vue'\n    import App from './App.vue'\n    import router from './router'\n    import store from './store'\n    import apolloClient from './apolloClient'\n    import './registerServiceWorker'\n    import VueApollo from 'vue-apollo';\n    \n    Vue.config.productionTip = false\n    \n    const apolloProvider = new VueApollo({\n      defaultClient: apolloClient\n    })\n    Vue.use(VueApollo);\n    new Vue({\n      router,\n      store,\n      apolloProvider,\n      render: h => h(App)\n    }).$mount('#app')\n    \n    \n\n> 6.在组件中使用（需要配合graphQL服务端）\n\n服务端源码地址：[github](https://github.com/maliaoMJ/graphql-api-server)\n\n1.  首先打开`views`目录下的`Home.vue` 文件\n\n在vue文件的JS部分做如下修改\n\n    <script>\n    // @ is an alias to /src\n    import gql from \"graphql-tag\";\n    export default {\n      name: \"home\",\n      computed: {\n        loading() {\n          return this.$apollo.loading;\n        }\n      },\n      data() {\n        return {\n          hello: \"\"\n        };\n      },\n      mounted() {\n        console.log(this.$apollo.loading, this.$apollo.data);\n      },\n      apollo: {\n        hello: {\n          query: gql`\n            query getUserInfo($id: Int!) {\n              hello\n              userInfo(id: $id) {\n                name\n                age\n                gender\n                id\n              }\n            }\n          `,\n          variables: {\n            id: 10001\n          }\n        }\n      }\n    };\n    </script>\n    \n    \n\n2.  运行项目\n\n运行如下命令\n\n    yarn run serve\n    \n\n然后打开游览器访问`localhost:8080`可以看到如下结果\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16-1.png)\n\n##### 最后附上源代码文件地址 [github](https://github.com/maliaoMJ/vue-graphQL-template)","slug":"如何在Vue SPA中集成GraphQL","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r5e0023w72srzfxl52p","content":"<p><img src=\"https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67\" alt></p>\n<blockquote>\n<ol>\n<li>为了快速搭建，首先我们安装vue-cli@3.x</li>\n</ol>\n</blockquote>\n<pre><code> sudo npm install -g @vue/cli\n yarn global add @vue/cli\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>我们快速搭建一个Vue-SPA项目</li>\n</ol>\n</blockquote>\n<pre><code>  mkdir learn_vue_with_graphql\n  cd learn_vue_with_graphql\n  vue create vue-ssr-graphql\n  # 按照你自己的需求选择插件\n  # 安装完毕后，进入vue-ssr-graphql目录\n  cd vue-ssr-graphql\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>安装关于在vue中使用graphQL的一些包</li>\n</ol>\n</blockquote>\n<pre><code>npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<p>或者</p>\n<pre><code>yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>在项目<code>src</code> 目录下创建<code>apolloClient.js</code>文件</li>\n</ol>\n</blockquote>\n<pre><code>import { ApolloClient } from 'apollo-client';\nimport { HttpLink } from 'apollo-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:3000/graphql'\n});\n\nconst cache = new InMemoryCache();\n// 导出 ApolloClient graphQL客户端\nexport default new ApolloClient({\n  link: httpLink,\n  cache\n});\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>修改<code>main.js</code>安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）</li>\n</ol>\n</blockquote>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nimport apolloClient from './apolloClient'\nimport './registerServiceWorker'\nimport VueApollo from 'vue-apollo';\n\nVue.config.productionTip = false\n\nconst apolloProvider = new VueApollo({\n  defaultClient: apolloClient\n})\nVue.use(VueApollo);\nnew Vue({\n  router,\n  store,\n  apolloProvider,\n  render: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<blockquote>\n<p>6.在组件中使用（需要配合graphQL服务端）</p>\n</blockquote>\n<p>服务端源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ol>\n<li>首先打开<code>views</code>目录下的<code>Home.vue</code> 文件</li>\n</ol>\n<p>在vue文件的JS部分做如下修改</p>\n<pre><code>&lt;script&gt;\n// @ is an alias to /src\nimport gql from &quot;graphql-tag&quot;;\nexport default {\n  name: &quot;home&quot;,\n  computed: {\n    loading() {\n      return this.$apollo.loading;\n    }\n  },\n  data() {\n    return {\n      hello: &quot;&quot;\n    };\n  },\n  mounted() {\n    console.log(this.$apollo.loading, this.$apollo.data);\n  },\n  apollo: {\n    hello: {\n      query: gql`\n        query getUserInfo($id: Int!) {\n          hello\n          userInfo(id: $id) {\n            name\n            age\n            gender\n            id\n          }\n        }\n      `,\n      variables: {\n        id: 10001\n      }\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>运行项目</li>\n</ol>\n<p>运行如下命令</p>\n<pre><code>yarn run serve\n</code></pre>\n<p>然后打开游览器访问<code>localhost:8080</code>可以看到如下结果</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16-1.png\" alt></p>\n<h5><span id=\"最后附上源代码文件地址-github\">最后附上源代码文件地址 </span></h5>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67\" alt></p>\n<blockquote>\n<ol>\n<li>为了快速搭建，首先我们安装vue-cli@3.x</li>\n</ol>\n</blockquote>\n<pre><code> sudo npm install -g @vue/cli\n yarn global add @vue/cli\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>我们快速搭建一个Vue-SPA项目</li>\n</ol>\n</blockquote>\n<pre><code>  mkdir learn_vue_with_graphql\n  cd learn_vue_with_graphql\n  vue create vue-ssr-graphql\n  # 按照你自己的需求选择插件\n  # 安装完毕后，进入vue-ssr-graphql目录\n  cd vue-ssr-graphql\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>安装关于在vue中使用graphQL的一些包</li>\n</ol>\n</blockquote>\n<pre><code>npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<p>或者</p>\n<pre><code>yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>在项目<code>src</code> 目录下创建<code>apolloClient.js</code>文件</li>\n</ol>\n</blockquote>\n<pre><code>import { ApolloClient } from 'apollo-client';\nimport { HttpLink } from 'apollo-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:3000/graphql'\n});\n\nconst cache = new InMemoryCache();\n// 导出 ApolloClient graphQL客户端\nexport default new ApolloClient({\n  link: httpLink,\n  cache\n});\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>修改<code>main.js</code>安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）</li>\n</ol>\n</blockquote>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nimport apolloClient from './apolloClient'\nimport './registerServiceWorker'\nimport VueApollo from 'vue-apollo';\n\nVue.config.productionTip = false\n\nconst apolloProvider = new VueApollo({\n  defaultClient: apolloClient\n})\nVue.use(VueApollo);\nnew Vue({\n  router,\n  store,\n  apolloProvider,\n  render: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<blockquote>\n<p>6.在组件中使用（需要配合graphQL服务端）</p>\n</blockquote>\n<p>服务端源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ol>\n<li>首先打开<code>views</code>目录下的<code>Home.vue</code> 文件</li>\n</ol>\n<p>在vue文件的JS部分做如下修改</p>\n<pre><code>&lt;script&gt;\n// @ is an alias to /src\nimport gql from &quot;graphql-tag&quot;;\nexport default {\n  name: &quot;home&quot;,\n  computed: {\n    loading() {\n      return this.$apollo.loading;\n    }\n  },\n  data() {\n    return {\n      hello: &quot;&quot;\n    };\n  },\n  mounted() {\n    console.log(this.$apollo.loading, this.$apollo.data);\n  },\n  apollo: {\n    hello: {\n      query: gql`\n        query getUserInfo($id: Int!) {\n          hello\n          userInfo(id: $id) {\n            name\n            age\n            gender\n            id\n          }\n        }\n      `,\n      variables: {\n        id: 10001\n      }\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>运行项目</li>\n</ol>\n<p>运行如下命令</p>\n<pre><code>yarn run serve\n</code></pre>\n<p>然后打开游览器访问<code>localhost:8080</code>可以看到如下结果</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16-1.png\" alt></p>\n<h5>最后附上源代码文件地址 <a href=\"https://github.com/maliaoMJ/vue-graphQL-template\" target=\"_blank\" rel=\"noopener\">github</a></h5>\n"},{"title":"JavaScript数据结构与算法-树","catalog":true,"url":"214.html","id":"214","date":"2019-03-13T11:09:28.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是树？\n\n树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: ![](http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png) 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。\n\n#### 2.二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。\n\n#### 3\\. 手动实现一个BST(二叉搜索树)\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/12121212.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/1111.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/22222222.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/5555555.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/777777.png)\n\n    // BST 二叉搜索树\n    class TreeNode {\n        constructor(key){\n           this.key = key;\n           this.left =null;\n           this.right = null;\n        }\n    }\n    // 插入节点 辅助函数\n    function insertNode(node,newNode){\n        if(node.key > newNode.key){\n            if(node.left === null){\n                node.left = newNode\n            }else{\n              insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right === null){\n                node.right = newNode\n            }else{\n                insertNode(node.right,newNode);\n            }\n        }\n    }\n    // 中序遍历 辅助函数\n    function inOrderTraverseNode(node,callback){\n       if(node!== null){\n           inOrderTraverseNode(node.left,callback);\n           callback(node.key);\n           inOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 先序遍历 辅助函数\n    function preOrderTraverseNode(node,callback){\n       if(node !==null){\n           callback(node.key);\n           preOrderTraverseNode(node.left,callback);\n           preOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 后续遍历 辅助函数\n    function postOrderTraverseNode(node,callback){\n       if(node !== null){\n           postOrderTraverseNode(node.left, callback);\n           postOrderTraverseNode(node.right, callback);\n           callback(node.key);\n       }\n    }\n    // 最小节点辅助函数\n    function minNode(node){\n        while(node && node.left !==null){\n            node = node.left;\n        }\n        return node.key;\n    }\n    // 最大节点辅助函数\n    function maxNode(node){\n        while(node && node.right !==null){\n            node = node.right;\n        }\n        return node.key;\n    }\n    // 搜索辅助函数\n    function serachNode(node,key){\n        if(node === null){\n            return false;\n        }else{\n            if(key < node.key){\n                return serachNode(node.left,key);\n            }else if(key > node.key){\n                return serachNode(node.right,key);\n            }else{\n                return true;\n            }\n        }\n    }\n    // 删除辅助函数\n    function removeNode(node, key) {\n        if (node === null) {\n            return null;\n        }\n        if (key < node.key) {\n            node.left = removeNode(node.left, key);\n            return node;\n        } else if (key > node.key) {\n            node.right = removeNode(node.right, key);\n            return node;\n        } else { //键等于node.key\n            //第一种情况——一个叶节点\n            if (node.left === null && node.right === null) {\n                node = null;\n                return node;\n            }\n            //第二种情况——一个只有一个子节点的节点 \n            if (node.left === null) {\n                node = node.right;\n                return node;\n            } else if (node.right === null) {\n                node = node.left;\n                return node;\n            }\n            //第三种情况——一个有两个子节点的节点\n            var aux = findMinNode(node.right);\n            node.key = aux.key; //\n            node.right = removeNode(node.right, aux.key);\n            return node;\n        }\n    };\n    // callback 辅助函数\n    function printNode(value){\n       console.log(value);\n    }\n    class BinarySearchTree {\n        constructor(){\n            this.root = null;\n        }\n        // 插入几点\n        insert(key){\n            let newNode = new TreeNode(key);\n            if(this.root === null){\n                this.root = newNode;\n            }else{\n                insertNode(this.root,newNode)\n            }\n        }\n        // 中序遍历 callback 对节点操作回掉函数\n        inOrderTraverse(callback){\n            inOrderTraverseNode(this.root, callback);\n        }\n        //先序遍历\n        preOrderTraverse(callback){\n            preOrderTraverseNode(this.root,callback);\n        }\n        // 后序遍历\n        postOrderTraverse(callback){\n           postOrderTraverseNode(this.root,callback);\n        }\n        // 最小值\n        min(){\n            return minNode(this.root);\n        }\n        // 最大值\n        max(){\n            return maxNode(this.root);\n        }\n        // 搜索\n        serarch(key){\n            return serachNode(this.root,key);\n        }\n        // 删除节点\n        remove(key){\n            root = removeNode(root, key);\n        }\n    }\n    \n    var tree = new BinarySearchTree();\n    tree.insert(11);\n    tree.insert(7);\n    tree.insert(15);\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(9);\n    tree.insert(8);\n    tree.insert(10);\n    tree.insert(13);\n    tree.insert(12);\n    tree.insert(14);\n    tree.insert(20);\n    tree.insert(18);\n    tree.insert(25);\n    tree.insert(6);\n    console.log(tree);\n    console.log('--------------------中序遍历-------------');\n    console.log(tree.inOrderTraverse(printNode));\n    console.log('--------------------先序遍历-------------');\n    console.log(tree.preOrderTraverse(printNode));\n    console.log('--------------------后序遍历-------------');\n    console.log(tree.postOrderTraverse(printNode));\n    console.log('--------------------最小值-------------');\n    console.log(tree.min());\n    console.log('--------------------最大值-------------');\n    console.log(tree.max());\n    \n    console.log('--------------------搜索-------------');\n    console.log(tree.serarch(100));\n    <!----------------------中序遍历--------------->\n    <!--3-->\n    <!--5-->\n    <!--6-->\n    <!--7-->\n    <!--8-->\n    <!--9-->\n    <!--10-->\n    <!--11-->\n    <!--12-->\n    <!--13-->\n    <!--14-->\n    <!--15-->\n    <!--18-->\n    <!--20-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------先序遍历--------------->\n    <!--11-->\n    <!--7-->\n    <!--5-->\n    <!--3-->\n    <!--6-->\n    <!--9-->\n    <!--8-->\n    <!--10-->\n    <!--15-->\n    <!--13-->\n    <!--12-->\n    <!--14-->\n    <!--20-->\n    <!--18-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------后序遍历--------------->\n    <!--3-->\n    <!--6-->\n    <!--5-->\n    <!--8-->\n    <!--10-->\n    <!--9-->\n    <!--7-->\n    <!--12-->\n    <!--14-->\n    <!--13-->\n    <!--18-->\n    <!--25-->\n    <!--20-->\n    <!--15-->\n    <!--11-->\n    <!--undefined-->\n    <!----------------------最小值--------------->\n    <!--3-->\n    <!----------------------最大值--------------->\n    <!--25-->\n    <!----------------------搜索--------------->\n    <!--false-->","source":"_posts/JavaScript数据结构与算法-树.md","raw":"---\ntitle: JavaScript数据结构与算法-树\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 214.html\nid: 214\ncategories:\n  - 数据结构\ndate: 2019-03-13 19:09:28\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是树？\n\n树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: ![](http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png) 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。\n\n#### 2.二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。\n\n#### 3\\. 手动实现一个BST(二叉搜索树)\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/12121212.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/1111.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/22222222.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/5555555.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/777777.png)\n\n    // BST 二叉搜索树\n    class TreeNode {\n        constructor(key){\n           this.key = key;\n           this.left =null;\n           this.right = null;\n        }\n    }\n    // 插入节点 辅助函数\n    function insertNode(node,newNode){\n        if(node.key > newNode.key){\n            if(node.left === null){\n                node.left = newNode\n            }else{\n              insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right === null){\n                node.right = newNode\n            }else{\n                insertNode(node.right,newNode);\n            }\n        }\n    }\n    // 中序遍历 辅助函数\n    function inOrderTraverseNode(node,callback){\n       if(node!== null){\n           inOrderTraverseNode(node.left,callback);\n           callback(node.key);\n           inOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 先序遍历 辅助函数\n    function preOrderTraverseNode(node,callback){\n       if(node !==null){\n           callback(node.key);\n           preOrderTraverseNode(node.left,callback);\n           preOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 后续遍历 辅助函数\n    function postOrderTraverseNode(node,callback){\n       if(node !== null){\n           postOrderTraverseNode(node.left, callback);\n           postOrderTraverseNode(node.right, callback);\n           callback(node.key);\n       }\n    }\n    // 最小节点辅助函数\n    function minNode(node){\n        while(node && node.left !==null){\n            node = node.left;\n        }\n        return node.key;\n    }\n    // 最大节点辅助函数\n    function maxNode(node){\n        while(node && node.right !==null){\n            node = node.right;\n        }\n        return node.key;\n    }\n    // 搜索辅助函数\n    function serachNode(node,key){\n        if(node === null){\n            return false;\n        }else{\n            if(key < node.key){\n                return serachNode(node.left,key);\n            }else if(key > node.key){\n                return serachNode(node.right,key);\n            }else{\n                return true;\n            }\n        }\n    }\n    // 删除辅助函数\n    function removeNode(node, key) {\n        if (node === null) {\n            return null;\n        }\n        if (key < node.key) {\n            node.left = removeNode(node.left, key);\n            return node;\n        } else if (key > node.key) {\n            node.right = removeNode(node.right, key);\n            return node;\n        } else { //键等于node.key\n            //第一种情况——一个叶节点\n            if (node.left === null && node.right === null) {\n                node = null;\n                return node;\n            }\n            //第二种情况——一个只有一个子节点的节点 \n            if (node.left === null) {\n                node = node.right;\n                return node;\n            } else if (node.right === null) {\n                node = node.left;\n                return node;\n            }\n            //第三种情况——一个有两个子节点的节点\n            var aux = findMinNode(node.right);\n            node.key = aux.key; //\n            node.right = removeNode(node.right, aux.key);\n            return node;\n        }\n    };\n    // callback 辅助函数\n    function printNode(value){\n       console.log(value);\n    }\n    class BinarySearchTree {\n        constructor(){\n            this.root = null;\n        }\n        // 插入几点\n        insert(key){\n            let newNode = new TreeNode(key);\n            if(this.root === null){\n                this.root = newNode;\n            }else{\n                insertNode(this.root,newNode)\n            }\n        }\n        // 中序遍历 callback 对节点操作回掉函数\n        inOrderTraverse(callback){\n            inOrderTraverseNode(this.root, callback);\n        }\n        //先序遍历\n        preOrderTraverse(callback){\n            preOrderTraverseNode(this.root,callback);\n        }\n        // 后序遍历\n        postOrderTraverse(callback){\n           postOrderTraverseNode(this.root,callback);\n        }\n        // 最小值\n        min(){\n            return minNode(this.root);\n        }\n        // 最大值\n        max(){\n            return maxNode(this.root);\n        }\n        // 搜索\n        serarch(key){\n            return serachNode(this.root,key);\n        }\n        // 删除节点\n        remove(key){\n            root = removeNode(root, key);\n        }\n    }\n    \n    var tree = new BinarySearchTree();\n    tree.insert(11);\n    tree.insert(7);\n    tree.insert(15);\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(9);\n    tree.insert(8);\n    tree.insert(10);\n    tree.insert(13);\n    tree.insert(12);\n    tree.insert(14);\n    tree.insert(20);\n    tree.insert(18);\n    tree.insert(25);\n    tree.insert(6);\n    console.log(tree);\n    console.log('--------------------中序遍历-------------');\n    console.log(tree.inOrderTraverse(printNode));\n    console.log('--------------------先序遍历-------------');\n    console.log(tree.preOrderTraverse(printNode));\n    console.log('--------------------后序遍历-------------');\n    console.log(tree.postOrderTraverse(printNode));\n    console.log('--------------------最小值-------------');\n    console.log(tree.min());\n    console.log('--------------------最大值-------------');\n    console.log(tree.max());\n    \n    console.log('--------------------搜索-------------');\n    console.log(tree.serarch(100));\n    <!----------------------中序遍历--------------->\n    <!--3-->\n    <!--5-->\n    <!--6-->\n    <!--7-->\n    <!--8-->\n    <!--9-->\n    <!--10-->\n    <!--11-->\n    <!--12-->\n    <!--13-->\n    <!--14-->\n    <!--15-->\n    <!--18-->\n    <!--20-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------先序遍历--------------->\n    <!--11-->\n    <!--7-->\n    <!--5-->\n    <!--3-->\n    <!--6-->\n    <!--9-->\n    <!--8-->\n    <!--10-->\n    <!--15-->\n    <!--13-->\n    <!--12-->\n    <!--14-->\n    <!--20-->\n    <!--18-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------后序遍历--------------->\n    <!--3-->\n    <!--6-->\n    <!--5-->\n    <!--8-->\n    <!--10-->\n    <!--9-->\n    <!--7-->\n    <!--12-->\n    <!--14-->\n    <!--13-->\n    <!--18-->\n    <!--25-->\n    <!--20-->\n    <!--15-->\n    <!--11-->\n    <!--undefined-->\n    <!----------------------最小值--------------->\n    <!--3-->\n    <!----------------------最大值--------------->\n    <!--25-->\n    <!----------------------搜索--------------->\n    <!--false-->","slug":"JavaScript数据结构与算法-树","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6j004iw72sesrb1zrk","content":"<h4><span id=\"1-什么是树\">1. 什么是树？</span></h4>\n<p>树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png\" alt> 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。</p>\n<h4><span id=\"2二叉树和二叉搜索树\">2.二叉树和二叉搜索树</span></h4>\n<p>二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。</p>\n<h4><span id=\"3-手动实现一个bst二叉搜索树\">3. 手动实现一个BST(二叉搜索树)</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/12121212.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/1111.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/22222222.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/5555555.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/777777.png\" alt></p>\n<pre><code>// BST 二叉搜索树\nclass TreeNode {\n    constructor(key){\n       this.key = key;\n       this.left =null;\n       this.right = null;\n    }\n}\n// 插入节点 辅助函数\nfunction insertNode(node,newNode){\n    if(node.key &gt; newNode.key){\n        if(node.left === null){\n            node.left = newNode\n        }else{\n          insertNode(node.left,newNode)\n        }\n    }else{\n        if(node.right === null){\n            node.right = newNode\n        }else{\n            insertNode(node.right,newNode);\n        }\n    }\n}\n// 中序遍历 辅助函数\nfunction inOrderTraverseNode(node,callback){\n   if(node!== null){\n       inOrderTraverseNode(node.left,callback);\n       callback(node.key);\n       inOrderTraverseNode(node.right,callback);\n   }\n}\n// 先序遍历 辅助函数\nfunction preOrderTraverseNode(node,callback){\n   if(node !==null){\n       callback(node.key);\n       preOrderTraverseNode(node.left,callback);\n       preOrderTraverseNode(node.right,callback);\n   }\n}\n// 后续遍历 辅助函数\nfunction postOrderTraverseNode(node,callback){\n   if(node !== null){\n       postOrderTraverseNode(node.left, callback);\n       postOrderTraverseNode(node.right, callback);\n       callback(node.key);\n   }\n}\n// 最小节点辅助函数\nfunction minNode(node){\n    while(node &amp;&amp; node.left !==null){\n        node = node.left;\n    }\n    return node.key;\n}\n// 最大节点辅助函数\nfunction maxNode(node){\n    while(node &amp;&amp; node.right !==null){\n        node = node.right;\n    }\n    return node.key;\n}\n// 搜索辅助函数\nfunction serachNode(node,key){\n    if(node === null){\n        return false;\n    }else{\n        if(key &lt; node.key){\n            return serachNode(node.left,key);\n        }else if(key &gt; node.key){\n            return serachNode(node.right,key);\n        }else{\n            return true;\n        }\n    }\n}\n// 删除辅助函数\nfunction removeNode(node, key) {\n    if (node === null) {\n        return null;\n    }\n    if (key &lt; node.key) {\n        node.left = removeNode(node.left, key);\n        return node;\n    } else if (key &gt; node.key) {\n        node.right = removeNode(node.right, key);\n        return node;\n    } else { //键等于node.key\n        //第一种情况——一个叶节点\n        if (node.left === null &amp;&amp; node.right === null) {\n            node = null;\n            return node;\n        }\n        //第二种情况——一个只有一个子节点的节点 \n        if (node.left === null) {\n            node = node.right;\n            return node;\n        } else if (node.right === null) {\n            node = node.left;\n            return node;\n        }\n        //第三种情况——一个有两个子节点的节点\n        var aux = findMinNode(node.right);\n        node.key = aux.key; //\n        node.right = removeNode(node.right, aux.key);\n        return node;\n    }\n};\n// callback 辅助函数\nfunction printNode(value){\n   console.log(value);\n}\nclass BinarySearchTree {\n    constructor(){\n        this.root = null;\n    }\n    // 插入几点\n    insert(key){\n        let newNode = new TreeNode(key);\n        if(this.root === null){\n            this.root = newNode;\n        }else{\n            insertNode(this.root,newNode)\n        }\n    }\n    // 中序遍历 callback 对节点操作回掉函数\n    inOrderTraverse(callback){\n        inOrderTraverseNode(this.root, callback);\n    }\n    //先序遍历\n    preOrderTraverse(callback){\n        preOrderTraverseNode(this.root,callback);\n    }\n    // 后序遍历\n    postOrderTraverse(callback){\n       postOrderTraverseNode(this.root,callback);\n    }\n    // 最小值\n    min(){\n        return minNode(this.root);\n    }\n    // 最大值\n    max(){\n        return maxNode(this.root);\n    }\n    // 搜索\n    serarch(key){\n        return serachNode(this.root,key);\n    }\n    // 删除节点\n    remove(key){\n        root = removeNode(root, key);\n    }\n}\n\nvar tree = new BinarySearchTree();\ntree.insert(11);\ntree.insert(7);\ntree.insert(15);\ntree.insert(5);\ntree.insert(3);\ntree.insert(9);\ntree.insert(8);\ntree.insert(10);\ntree.insert(13);\ntree.insert(12);\ntree.insert(14);\ntree.insert(20);\ntree.insert(18);\ntree.insert(25);\ntree.insert(6);\nconsole.log(tree);\nconsole.log('--------------------中序遍历-------------');\nconsole.log(tree.inOrderTraverse(printNode));\nconsole.log('--------------------先序遍历-------------');\nconsole.log(tree.preOrderTraverse(printNode));\nconsole.log('--------------------后序遍历-------------');\nconsole.log(tree.postOrderTraverse(printNode));\nconsole.log('--------------------最小值-------------');\nconsole.log(tree.min());\nconsole.log('--------------------最大值-------------');\nconsole.log(tree.max());\n\nconsole.log('--------------------搜索-------------');\nconsole.log(tree.serarch(100));\n&lt;!----------------------中序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--5--&gt;\n&lt;!--6--&gt;\n&lt;!--7--&gt;\n&lt;!--8--&gt;\n&lt;!--9--&gt;\n&lt;!--10--&gt;\n&lt;!--11--&gt;\n&lt;!--12--&gt;\n&lt;!--13--&gt;\n&lt;!--14--&gt;\n&lt;!--15--&gt;\n&lt;!--18--&gt;\n&lt;!--20--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------先序遍历---------------&gt;\n&lt;!--11--&gt;\n&lt;!--7--&gt;\n&lt;!--5--&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--9--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--15--&gt;\n&lt;!--13--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--20--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------后序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--5--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--9--&gt;\n&lt;!--7--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--13--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--20--&gt;\n&lt;!--15--&gt;\n&lt;!--11--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------最小值---------------&gt;\n&lt;!--3--&gt;\n&lt;!----------------------最大值---------------&gt;\n&lt;!--25--&gt;\n&lt;!----------------------搜索---------------&gt;\n&lt;!--false--&gt;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是树？</h4>\n<p>树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png\" alt> 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。</p>\n<h4>2.二叉树和二叉搜索树</h4>\n<p>二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。</p>\n<h4>3. 手动实现一个BST(二叉搜索树)</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/12121212.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/1111.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/22222222.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/5555555.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/777777.png\" alt></p>\n<pre><code>// BST 二叉搜索树\nclass TreeNode {\n    constructor(key){\n       this.key = key;\n       this.left =null;\n       this.right = null;\n    }\n}\n// 插入节点 辅助函数\nfunction insertNode(node,newNode){\n    if(node.key &gt; newNode.key){\n        if(node.left === null){\n            node.left = newNode\n        }else{\n          insertNode(node.left,newNode)\n        }\n    }else{\n        if(node.right === null){\n            node.right = newNode\n        }else{\n            insertNode(node.right,newNode);\n        }\n    }\n}\n// 中序遍历 辅助函数\nfunction inOrderTraverseNode(node,callback){\n   if(node!== null){\n       inOrderTraverseNode(node.left,callback);\n       callback(node.key);\n       inOrderTraverseNode(node.right,callback);\n   }\n}\n// 先序遍历 辅助函数\nfunction preOrderTraverseNode(node,callback){\n   if(node !==null){\n       callback(node.key);\n       preOrderTraverseNode(node.left,callback);\n       preOrderTraverseNode(node.right,callback);\n   }\n}\n// 后续遍历 辅助函数\nfunction postOrderTraverseNode(node,callback){\n   if(node !== null){\n       postOrderTraverseNode(node.left, callback);\n       postOrderTraverseNode(node.right, callback);\n       callback(node.key);\n   }\n}\n// 最小节点辅助函数\nfunction minNode(node){\n    while(node &amp;&amp; node.left !==null){\n        node = node.left;\n    }\n    return node.key;\n}\n// 最大节点辅助函数\nfunction maxNode(node){\n    while(node &amp;&amp; node.right !==null){\n        node = node.right;\n    }\n    return node.key;\n}\n// 搜索辅助函数\nfunction serachNode(node,key){\n    if(node === null){\n        return false;\n    }else{\n        if(key &lt; node.key){\n            return serachNode(node.left,key);\n        }else if(key &gt; node.key){\n            return serachNode(node.right,key);\n        }else{\n            return true;\n        }\n    }\n}\n// 删除辅助函数\nfunction removeNode(node, key) {\n    if (node === null) {\n        return null;\n    }\n    if (key &lt; node.key) {\n        node.left = removeNode(node.left, key);\n        return node;\n    } else if (key &gt; node.key) {\n        node.right = removeNode(node.right, key);\n        return node;\n    } else { //键等于node.key\n        //第一种情况——一个叶节点\n        if (node.left === null &amp;&amp; node.right === null) {\n            node = null;\n            return node;\n        }\n        //第二种情况——一个只有一个子节点的节点 \n        if (node.left === null) {\n            node = node.right;\n            return node;\n        } else if (node.right === null) {\n            node = node.left;\n            return node;\n        }\n        //第三种情况——一个有两个子节点的节点\n        var aux = findMinNode(node.right);\n        node.key = aux.key; //\n        node.right = removeNode(node.right, aux.key);\n        return node;\n    }\n};\n// callback 辅助函数\nfunction printNode(value){\n   console.log(value);\n}\nclass BinarySearchTree {\n    constructor(){\n        this.root = null;\n    }\n    // 插入几点\n    insert(key){\n        let newNode = new TreeNode(key);\n        if(this.root === null){\n            this.root = newNode;\n        }else{\n            insertNode(this.root,newNode)\n        }\n    }\n    // 中序遍历 callback 对节点操作回掉函数\n    inOrderTraverse(callback){\n        inOrderTraverseNode(this.root, callback);\n    }\n    //先序遍历\n    preOrderTraverse(callback){\n        preOrderTraverseNode(this.root,callback);\n    }\n    // 后序遍历\n    postOrderTraverse(callback){\n       postOrderTraverseNode(this.root,callback);\n    }\n    // 最小值\n    min(){\n        return minNode(this.root);\n    }\n    // 最大值\n    max(){\n        return maxNode(this.root);\n    }\n    // 搜索\n    serarch(key){\n        return serachNode(this.root,key);\n    }\n    // 删除节点\n    remove(key){\n        root = removeNode(root, key);\n    }\n}\n\nvar tree = new BinarySearchTree();\ntree.insert(11);\ntree.insert(7);\ntree.insert(15);\ntree.insert(5);\ntree.insert(3);\ntree.insert(9);\ntree.insert(8);\ntree.insert(10);\ntree.insert(13);\ntree.insert(12);\ntree.insert(14);\ntree.insert(20);\ntree.insert(18);\ntree.insert(25);\ntree.insert(6);\nconsole.log(tree);\nconsole.log('--------------------中序遍历-------------');\nconsole.log(tree.inOrderTraverse(printNode));\nconsole.log('--------------------先序遍历-------------');\nconsole.log(tree.preOrderTraverse(printNode));\nconsole.log('--------------------后序遍历-------------');\nconsole.log(tree.postOrderTraverse(printNode));\nconsole.log('--------------------最小值-------------');\nconsole.log(tree.min());\nconsole.log('--------------------最大值-------------');\nconsole.log(tree.max());\n\nconsole.log('--------------------搜索-------------');\nconsole.log(tree.serarch(100));\n&lt;!----------------------中序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--5--&gt;\n&lt;!--6--&gt;\n&lt;!--7--&gt;\n&lt;!--8--&gt;\n&lt;!--9--&gt;\n&lt;!--10--&gt;\n&lt;!--11--&gt;\n&lt;!--12--&gt;\n&lt;!--13--&gt;\n&lt;!--14--&gt;\n&lt;!--15--&gt;\n&lt;!--18--&gt;\n&lt;!--20--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------先序遍历---------------&gt;\n&lt;!--11--&gt;\n&lt;!--7--&gt;\n&lt;!--5--&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--9--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--15--&gt;\n&lt;!--13--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--20--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------后序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--5--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--9--&gt;\n&lt;!--7--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--13--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--20--&gt;\n&lt;!--15--&gt;\n&lt;!--11--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------最小值---------------&gt;\n&lt;!--3--&gt;\n&lt;!----------------------最大值---------------&gt;\n&lt;!--25--&gt;\n&lt;!----------------------搜索---------------&gt;\n&lt;!--false--&gt;</code></pre>\n"},{"title":"TypeScript 学习第三章 TypeScript基本类型","catalog":true,"date":"2019-08-16T12:07:25.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/item/201508/23/20150823200229_GuUiP.jpeg","_content":"\n# 基础类型\n\nTypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 `boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false\n```\n\n## 数字\n\n和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 20\nlet hexLiteral: number = 0x14\nlet binaryLiteral: number = 0b10100\nlet octalLiteral: number = 0o24\n```\n\n## 字符串\n\nJavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 `string` 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（`\"`）或单引号（`'`）表示字符串。\n\n```typescript\nlet name: string = 'bob'\nname = 'smith'\n```\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ``` ` ```），并且以 `${ expr }` 这种形式嵌入表达式\n\n```typescript\nlet name: string = `Yee`\nlet age: number = 37\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`\n```\n\n这与下面定义 `sentence` 的方式效果相同：\n\n```typescript\nlet sentence: string = 'Hello, my name is ' + name + '.\\n\\n' +\n    'I\\'ll be ' + (age + 1) + ' years old next month.'\n```\n\n## 数组\n\nTypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3]\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3]\n```\n\n## 元祖 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。\n\n```typescript\nlet x: [string, number]\nx = ['hello', 10] // OK\nx = [10, 'hello'] // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)) // OK\nconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法\n```\n\n当访问一个越界的元素，会使用联合类型替代：\n\n```typescript\nx[3] = 'world' // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true // Error, 布尔不是(string | number)类型\n```\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n## 枚举\n\n`enum` 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green\n```\n\n默认情况下，从 `0` 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1` 开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]\n\nconsole.log(colorName)  // 显示'Green'因为上面代码里它的值是2\n```\n\n## any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any` 类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4\nnotSure = 'maybe a string instead'\nnotSure = false // 也可以是个 boolean\n```\n\n在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，`any` 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n```\n\n## void\n\n某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：\n\n```typescript\nfunction warnUser(): void {\n  console.log('This is my warning message')\n}\n\n```\n\n声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`：\n\n```typescript\nlet unusable: void = undefined\n```\n\n## null 和 undefined\n\nTypeScript 里，`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`。 和 `void` 相似，它们的本身的类型用处不是很大：\n\n```typescript\nlet u: undefined = undefined\nlet n: null = null\n```\n\n默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n\n然而，当你指定了 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。 再次说明，稍后我们会介绍联合类型。\n\n## never\n\n`never` 类型表示的是那些永不存在的值的类型。 例如， `never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n\n`never` 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 `never` 的子类型或可以赋值给`never` 类型（除了 `never` 本身之外）。 即使 `any` 也不可以赋值给 `never`。\n\n下面是一些返回 `never` 类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n```\n\n## object\n\n`object` 表示非原始类型，也就是除 `number`，`string`，`boolean`，`symbol`，`null`或`undefined` 之外的类型。\n\n使用 `object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。例如：\n\n```typescript\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // OK\ncreate(null) // OK\n\ncreate(42) // Error\ncreate('string') // Error\ncreate(false) // Error\ncreate(undefined) // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (<string>someValue).length\n```\n\n另一个为 `as` 语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (someValue as string).length\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 `as` 语法断言是被允许的。\n\n\n\n\n","source":"_posts/TypeScript 学习第三章 TypeScript基本类型.md","raw":"---\ntitle: TypeScript 学习第三章 TypeScript基本类型\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-16 20:07:25\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/item/201508/23/20150823200229_GuUiP.jpeg\"\n---\n\n# 基础类型\n\nTypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 `boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false\n```\n\n## 数字\n\n和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 20\nlet hexLiteral: number = 0x14\nlet binaryLiteral: number = 0b10100\nlet octalLiteral: number = 0o24\n```\n\n## 字符串\n\nJavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 `string` 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（`\"`）或单引号（`'`）表示字符串。\n\n```typescript\nlet name: string = 'bob'\nname = 'smith'\n```\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ``` ` ```），并且以 `${ expr }` 这种形式嵌入表达式\n\n```typescript\nlet name: string = `Yee`\nlet age: number = 37\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`\n```\n\n这与下面定义 `sentence` 的方式效果相同：\n\n```typescript\nlet sentence: string = 'Hello, my name is ' + name + '.\\n\\n' +\n    'I\\'ll be ' + (age + 1) + ' years old next month.'\n```\n\n## 数组\n\nTypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3]\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3]\n```\n\n## 元祖 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。\n\n```typescript\nlet x: [string, number]\nx = ['hello', 10] // OK\nx = [10, 'hello'] // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)) // OK\nconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法\n```\n\n当访问一个越界的元素，会使用联合类型替代：\n\n```typescript\nx[3] = 'world' // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true // Error, 布尔不是(string | number)类型\n```\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n## 枚举\n\n`enum` 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green\n```\n\n默认情况下，从 `0` 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1` 开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]\n\nconsole.log(colorName)  // 显示'Green'因为上面代码里它的值是2\n```\n\n## any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any` 类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4\nnotSure = 'maybe a string instead'\nnotSure = false // 也可以是个 boolean\n```\n\n在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，`any` 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n```\n\n## void\n\n某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：\n\n```typescript\nfunction warnUser(): void {\n  console.log('This is my warning message')\n}\n\n```\n\n声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`：\n\n```typescript\nlet unusable: void = undefined\n```\n\n## null 和 undefined\n\nTypeScript 里，`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`。 和 `void` 相似，它们的本身的类型用处不是很大：\n\n```typescript\nlet u: undefined = undefined\nlet n: null = null\n```\n\n默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n\n然而，当你指定了 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。 再次说明，稍后我们会介绍联合类型。\n\n## never\n\n`never` 类型表示的是那些永不存在的值的类型。 例如， `never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n\n`never` 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 `never` 的子类型或可以赋值给`never` 类型（除了 `never` 本身之外）。 即使 `any` 也不可以赋值给 `never`。\n\n下面是一些返回 `never` 类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n```\n\n## object\n\n`object` 表示非原始类型，也就是除 `number`，`string`，`boolean`，`symbol`，`null`或`undefined` 之外的类型。\n\n使用 `object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。例如：\n\n```typescript\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // OK\ncreate(null) // OK\n\ncreate(42) // Error\ncreate('string') // Error\ncreate(false) // Error\ncreate(undefined) // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (<string>someValue).length\n```\n\n另一个为 `as` 语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (someValue as string).length\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 `as` 语法断言是被允许的。\n\n\n\n\n","slug":"TypeScript 学习第三章 TypeScript基本类型","published":1,"updated":"2019-08-14T15:01:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6k004jw72sy5me5zck","content":"<h1><span id=\"基础类型\">基础类型</span></h1>\n<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h2><span id=\"布尔值\">布尔值</span></h2>\n<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"数字\">数字</span></h2>\n<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0x14</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b10100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o24</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"字符串\">字符串</span></h2>\n<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">'bob'</span></span><br><span class=\"line\">name = <span class=\"string\">'smith'</span></span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <figure class=\"highlight plain\"><figcaption><span>```），并且以 `$&#123; expr &#125;` 这种形式嵌入表达式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```typescript</span><br><span class=\"line\">let name: string = `Yee`</span><br><span class=\"line\">let age: number = 37</span><br><span class=\"line\">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">I&apos;ll be $&#123; age + 1 &#125; years old next month.`</span><br></pre></td></tr></table></figure></p>\n<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.\\n\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'I\\'ll be '</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">' years old next month.'</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"数组\">数组</span></h2>\n<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h2><span id=\"元祖-tuple\">元祖 Tuple</span></h2>\n<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\">x = [<span class=\"string\">'hello'</span>, <span class=\"number\">10</span>] <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">'hello'</span>] <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">'world'</span> <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()) <span class=\"comment\">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h2><span id=\"枚举\">枚举</span></h2>\n<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName)  <span class=\"comment\">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"any\">any</span></h2>\n<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span></span><br><span class=\"line\">notSure = <span class=\"string\">'maybe a string instead'</span></span><br><span class=\"line\">notSure = <span class=\"literal\">false</span> <span class=\"comment\">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">'free'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"void\">void</span></h2>\n<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is my warning message'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"null-和-undefined\">null 和 undefined</span></h2>\n<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>\n<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>\n<h2><span id=\"never\">never</span></h2>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>\n<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n<p>下面是一些返回 <code>never</code> 类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"object\">object</span></h2>\n<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>\n<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: object | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">&#123; prop: 0 &#125;</span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">null</span></span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">42</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">'<span class=\"built_in\">string</span>'</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">false</span></span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">undefined</span></span>) // <span class=\"title\">Error</span></span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"类型断言\">类型断言</span></h2>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure>\n<p>另一个为 <code>as</code> 语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>基础类型</h1>\n<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h2>布尔值</h2>\n<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2>数字</h2>\n<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0x14</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b10100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o24</span></span><br></pre></td></tr></table></figure>\n<h2>字符串</h2>\n<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">'bob'</span></span><br><span class=\"line\">name = <span class=\"string\">'smith'</span></span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <figure class=\"highlight plain\"><figcaption><span>```），并且以 `$&#123; expr &#125;` 这种形式嵌入表达式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```typescript</span><br><span class=\"line\">let name: string = `Yee`</span><br><span class=\"line\">let age: number = 37</span><br><span class=\"line\">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">I&apos;ll be $&#123; age + 1 &#125; years old next month.`</span><br></pre></td></tr></table></figure></p>\n<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.\\n\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'I\\'ll be '</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">' years old next month.'</span></span><br></pre></td></tr></table></figure>\n<h2>数组</h2>\n<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h2>元祖 Tuple</h2>\n<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\">x = [<span class=\"string\">'hello'</span>, <span class=\"number\">10</span>] <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">'hello'</span>] <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">'world'</span> <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()) <span class=\"comment\">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h2>枚举</h2>\n<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName)  <span class=\"comment\">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h2>any</h2>\n<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span></span><br><span class=\"line\">notSure = <span class=\"string\">'maybe a string instead'</span></span><br><span class=\"line\">notSure = <span class=\"literal\">false</span> <span class=\"comment\">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">'free'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2>void</h2>\n<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is my warning message'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h2>null 和 undefined</h2>\n<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>\n<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>\n<h2>never</h2>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>\n<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n<p>下面是一些返回 <code>never</code> 类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>object</h2>\n<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>\n<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: object | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">&#123; prop: 0 &#125;</span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">null</span></span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">42</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">'<span class=\"built_in\">string</span>'</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">false</span></span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">undefined</span></span>) // <span class=\"title\">Error</span></span></span><br></pre></td></tr></table></figure>\n<h2>类型断言</h2>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure>\n<p>另一个为 <code>as</code> 语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>\n"},{"title":"TypeScript 学习第七章 TypeScript 变量声明","catalog":true,"date":"2019-08-20T03:49:52.000Z","subtitle":null,"header-img":"http://www.downxia.com/uploadfiles/2015/1007/20151007031916598.jpg","_content":"\n# 变量声明\n\n`let` 和 `const` 是 JavaScript 里相对较新的变量声明方式。`let` 在很多方面与 `var` 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。`const` 是对 `let` 的一个增强，它能阻止对一个变量再次赋值。\n\n因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 `let` 和 `const`。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 `var`。\n\n 如果你已经对 `var` 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n## var 声明\n\n在 ES5 的时代，我们都是通过 `var` 关键字定义JavaScript 变量：\n\n```javascript\nvar a = 10\n```\n\n大家都能理解，这里定义了一个名为 `a` 值为 `10` 的变量。\n\n我们也可以在函数内部定义变量：\n\n```javascript\nfunction f() {\n  var message = 'Hello World!'\n\n  return message\n}\n```\n\n并且我们也可以在其它函数内部访问相同的变量：\n\n```javascript\nfunction f() {\n  var a = 10\n  return function g() {\n    var b = a + 1\n    return b\n  }\n}\n\nvar g = f()\ng() // returns 11\n```\n\n上面的例子是一个典型的闭包场景，`g` 可以获取到 `f` 函数里定义的 `a` 变量。 每当 `g` 被调用时，它都可以访问到 `f` 里的 `a` 变量。 即使当 `g` 在 `f` 已经执行完后才被调用，它仍然可以访问 `a`。\n\n### 作用域规则\n\n`var` 声明有些奇怪的作用域规则。 看下面的例子：\n\n```javascript\nfunction f(shouldInitialize) {\n  if (shouldInitialize) {\n    var x = 10\n  }\n\n  return x\n}\n\nf(true)  // returns '10'\nf(false) // returns 'undefined'\n```\n\n有些同学可能要多看几遍这个例子。 变量 `x` 是定义在 `if` 语句里面，但是我们却可以在语句的外面访问它。 这是因为 `var` 声明的作用域是函数作用域，函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```javascript\nfunction sumMatrix(matrix) {\n  var sum = 0\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i]\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n  \n  return sum\n}\n```\n\n这里很容易看出一些问题，里层的 `for` 循环会覆盖变量 `i`，因为所有 `i` 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 捕获变量怪异之处\n\n猜一下下面的代码会返回什么：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n答案是，`setTimeout` 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：\n\n``` javascript\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n> 我们传给 `setTimeout` 的每一个函数表达式实际上都引用了相同作用域里的同一个 `i`。\n\n让我们花点时间思考一下这是为什么。 `setTimeout` 在若干毫秒后执行一个函数，并且是在 `for` 循环结束后。`for` 循环结束后，`i` 的值为 `10`。 所以当函数被调用的时候，它会打印出 `10`。\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 `i` 的值：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i)\n    }, 100 * i)\n  })(i)\n}\n```\n\n这种奇怪的形式我们已经司空见惯了。 参数 `i` 会覆盖 `for` 循环里的 `i`，但是因为我们起了同样的名字，所以我们不用怎么改 `for` 循环体里的代码。\n\n## let 声明\n\n现在你已经知道了 `var` 存在一些问题，这恰好说明了为什么用 `let` 语句来声明变量。 除了名字不同外， `let` 与 `var` 的写法一致：\n\n```javascript\nlet hello = 'Hello!'\n```\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 块作用域\n\n当用 `let` 声明一个变量，它使用的是块作用域。 不同于使用 `var` 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 `for` 循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n  let a = 100\n\n  if (input) {\n    // OK: 仍然能访问到 a\n    let b = a + 1\n    return b\n  }\n\n  // Error: 'b' 在这里不存在\n  return b\n}\n```\n\n这里我们定义了 2 个变量 `a` 和 `b`。 `a` 的作用域是 `f` 函数体内，而 `b` 的作用域是 `if` 语句块里。\n\n在 `catch` 语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n  throw 'Oh no!';\n}\ncatch (e) {\n  console.log('Catch it.')\n}\n\n// Error: 'e' 在这里不存在\nconsole.log(e)\n```\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于*暂时性死区*。 它只是用来说明我们不能在 `let` 语句之前访问它们，幸运的是 `TypeScript` 可以告诉我们这些信息。\n\n```typescript\na++ // TS2448: Block-scoped variable 'a' used before its declaration.\nlet a\n```\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。\n\n```typescript\nfunction foo() {\n  // okay to capture 'a'\n  return a\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo()\n\nlet a\n```\n\n关于*暂时性死区*的更多信息，查看这里 [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)。\n\n\n### 重定义及屏蔽\n\n我们提过使用 `var` 声明时，它不在乎你声明多少次；你只会得到 1 个。\n\n```javascript\nfunction f(x) {\n  var x\n  var x\n\n  if (true) {\n    var x\n  }\n}\n```\n\n在上面的例子里，所有 `x` 的声明实际上都引用一个相同的`x`，并且这是完全有效的代码，但这经常会成为 `bug` 的来源。幸运的是 `let` 的声明就不会这么宽松了。\n\n```typescript\nlet x = 10\nlet x = 20 // 错误，不能在 1 个作用域里多次声明 x\n```\n\n并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n  let x = 100 // Error: 干扰参数声明\n}\n\nfunction g() {\n  let x = 100\n  var x = 100 // Error: 不能同时具有 x 的两个声明\n}\n```\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100\n    return x\n  }\n\n  return x\n}\n\nf(false, 0) // returns 0\nf(true, 0)  // returns 100\n```\n\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 `let` 重写之前的 `sumMatrix` 函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0\n  for (let i = 0; i < matrix.length; i++) {\n    let currentRow = matrix[i]\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n\n  return sum\n}\n```\n\n这个版本的循环能得到正确的结果，因为内层循环的 `i` 可以屏蔽掉外层循环的 `i`。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。\n\n### 块级作用域变量的获取\n\n每次进入一个作用域时，`let` 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n回想一下前面 `setTimeout` 的例子，我们最后需要使用立即执行的函数表达式来获取每次 `for` 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 `TypeScript` 里这样做了。\n\n当 `let` 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 `setTimeout` 例子里我们仅使用 `let` 声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10 ; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n会输出与预料一致的结果：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n## const 声明\n\n`const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9\n```\n\n它们与 `let` 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 `let` 相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n\n```typescript\nconst numLivesForCat = 9\nconst kitty = {\n  name: 'Kitty',\n  numLives: numLivesForCat\n}\n\n// Error\nkitty = {\n  name: 'Tommy',\n  numLives: numLivesForCat\n};\n\n// OK\nkitty.name = 'Jerry'\nkitty.numLives--\n```\n\n除非你使用特殊的方法去避免，实际上 `const` 变量的内部状态是可修改的。 幸运的是，`TypeScript` 允许你将对象的成员设置成只读的。接口一章有详细说明。\n\n## let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用 `const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 `const` 也可以让我们更容易的推测数据的流动。\n\n## 解构\n\n### 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2]\nlet [first, second] = input\nconsole.log(first) // outputs 1\nconsole.log(second) // outputs 2\n```\n\n这创建了 2 个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nlet first = input[0]\nlet second = input[1]\n```\n\n作用于函数参数：\n\n```typescript\nlet input: [number, number] = [1, 2]\n\nfunction f([first, second]: [number, number]) {\n  console.log(first)\n  console.log(second)\n}\n\nf(input)\n```\n\n你可以在数组里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\nconsole.log(rest) // outputs [ 2, 3, 4 ]\n```\n\n你也可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\n```\n\n或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4]\n```\n\n### 对象解构\n\n你也可以解构对象：\n\n```typescript\nlet o = {\n    a: 'foo',\n    b: 12,\n    c: 'bar'\n}\nlet { a, b } = o\n\n```\n\n这通过 `o.a` 和 `o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n\n你可以在对象里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o\nlet total = passthrough.b + passthrough.c.length\n```\n\n### 属性重命名\n\n你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o\n```\n\n这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 `\"a 作为 newName1\"`。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a\nlet newName2 = o.b\n```\n\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。\n\n```typescript\nlet {a, b}: {a: string, b: number} = o\n```\n\n### 默认值\n\n默认值可以让你在属性为 `undefined` 时使用缺省值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n  let { a, b = 1001 } = wholeObject\n}\n```\n\n现在，即使 `b` 为 `undefined` ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n### 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a = '', b = 0 } = {}): void {\n  // ...\n}\nf()\n```\n\n> 上面的代码是一个类型推断的例子，将在后续章节介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: '' }): void {\n  // ...\n}\nf({ a: 'yes' }) // OK, 默认 b = 0\nf() // OK, 默认 a: '', b = 0\nf({}) // Error, 一旦传入参数则 a 是必须的\n```\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。\n\n## 展开\n\n```typescript\nlet first = [1, 2]\nlet second = [3, 4]\nlet bothPlus = [0, ...first, ...second, 5]\n```\n这会令 `bothPlus` 的值为 `[0, 1, 2, 3, 4, 5]`。 展开操作创建了 `first` 和 `second的` 一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { ...defaults, food: 'rich' }\n```\n\nsearch的值为 `{ food: 'rich', price: '$10', ambiance: 'noisy' }`。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { food: 'rich', ...defaults }\n```\n\n那么，`defaults` 里的 `food` 属性会重写 `food: 'rich'`，在这里这并不是我们想要的结果。\n","source":"_posts/TypeScript 学习第七章 TypeScript变量声明.md","raw":"---\ntitle: TypeScript 学习第七章 TypeScript 变量声明\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-20 11:49:52\nsubtitle:\nheader-img: \"http://www.downxia.com/uploadfiles/2015/1007/20151007031916598.jpg\"\n---\n\n# 变量声明\n\n`let` 和 `const` 是 JavaScript 里相对较新的变量声明方式。`let` 在很多方面与 `var` 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。`const` 是对 `let` 的一个增强，它能阻止对一个变量再次赋值。\n\n因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 `let` 和 `const`。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 `var`。\n\n 如果你已经对 `var` 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n## var 声明\n\n在 ES5 的时代，我们都是通过 `var` 关键字定义JavaScript 变量：\n\n```javascript\nvar a = 10\n```\n\n大家都能理解，这里定义了一个名为 `a` 值为 `10` 的变量。\n\n我们也可以在函数内部定义变量：\n\n```javascript\nfunction f() {\n  var message = 'Hello World!'\n\n  return message\n}\n```\n\n并且我们也可以在其它函数内部访问相同的变量：\n\n```javascript\nfunction f() {\n  var a = 10\n  return function g() {\n    var b = a + 1\n    return b\n  }\n}\n\nvar g = f()\ng() // returns 11\n```\n\n上面的例子是一个典型的闭包场景，`g` 可以获取到 `f` 函数里定义的 `a` 变量。 每当 `g` 被调用时，它都可以访问到 `f` 里的 `a` 变量。 即使当 `g` 在 `f` 已经执行完后才被调用，它仍然可以访问 `a`。\n\n### 作用域规则\n\n`var` 声明有些奇怪的作用域规则。 看下面的例子：\n\n```javascript\nfunction f(shouldInitialize) {\n  if (shouldInitialize) {\n    var x = 10\n  }\n\n  return x\n}\n\nf(true)  // returns '10'\nf(false) // returns 'undefined'\n```\n\n有些同学可能要多看几遍这个例子。 变量 `x` 是定义在 `if` 语句里面，但是我们却可以在语句的外面访问它。 这是因为 `var` 声明的作用域是函数作用域，函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```javascript\nfunction sumMatrix(matrix) {\n  var sum = 0\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i]\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n  \n  return sum\n}\n```\n\n这里很容易看出一些问题，里层的 `for` 循环会覆盖变量 `i`，因为所有 `i` 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 捕获变量怪异之处\n\n猜一下下面的代码会返回什么：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n答案是，`setTimeout` 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：\n\n``` javascript\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n> 我们传给 `setTimeout` 的每一个函数表达式实际上都引用了相同作用域里的同一个 `i`。\n\n让我们花点时间思考一下这是为什么。 `setTimeout` 在若干毫秒后执行一个函数，并且是在 `for` 循环结束后。`for` 循环结束后，`i` 的值为 `10`。 所以当函数被调用的时候，它会打印出 `10`。\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 `i` 的值：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i)\n    }, 100 * i)\n  })(i)\n}\n```\n\n这种奇怪的形式我们已经司空见惯了。 参数 `i` 会覆盖 `for` 循环里的 `i`，但是因为我们起了同样的名字，所以我们不用怎么改 `for` 循环体里的代码。\n\n## let 声明\n\n现在你已经知道了 `var` 存在一些问题，这恰好说明了为什么用 `let` 语句来声明变量。 除了名字不同外， `let` 与 `var` 的写法一致：\n\n```javascript\nlet hello = 'Hello!'\n```\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 块作用域\n\n当用 `let` 声明一个变量，它使用的是块作用域。 不同于使用 `var` 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 `for` 循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n  let a = 100\n\n  if (input) {\n    // OK: 仍然能访问到 a\n    let b = a + 1\n    return b\n  }\n\n  // Error: 'b' 在这里不存在\n  return b\n}\n```\n\n这里我们定义了 2 个变量 `a` 和 `b`。 `a` 的作用域是 `f` 函数体内，而 `b` 的作用域是 `if` 语句块里。\n\n在 `catch` 语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n  throw 'Oh no!';\n}\ncatch (e) {\n  console.log('Catch it.')\n}\n\n// Error: 'e' 在这里不存在\nconsole.log(e)\n```\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于*暂时性死区*。 它只是用来说明我们不能在 `let` 语句之前访问它们，幸运的是 `TypeScript` 可以告诉我们这些信息。\n\n```typescript\na++ // TS2448: Block-scoped variable 'a' used before its declaration.\nlet a\n```\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。\n\n```typescript\nfunction foo() {\n  // okay to capture 'a'\n  return a\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo()\n\nlet a\n```\n\n关于*暂时性死区*的更多信息，查看这里 [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)。\n\n\n### 重定义及屏蔽\n\n我们提过使用 `var` 声明时，它不在乎你声明多少次；你只会得到 1 个。\n\n```javascript\nfunction f(x) {\n  var x\n  var x\n\n  if (true) {\n    var x\n  }\n}\n```\n\n在上面的例子里，所有 `x` 的声明实际上都引用一个相同的`x`，并且这是完全有效的代码，但这经常会成为 `bug` 的来源。幸运的是 `let` 的声明就不会这么宽松了。\n\n```typescript\nlet x = 10\nlet x = 20 // 错误，不能在 1 个作用域里多次声明 x\n```\n\n并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n  let x = 100 // Error: 干扰参数声明\n}\n\nfunction g() {\n  let x = 100\n  var x = 100 // Error: 不能同时具有 x 的两个声明\n}\n```\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100\n    return x\n  }\n\n  return x\n}\n\nf(false, 0) // returns 0\nf(true, 0)  // returns 100\n```\n\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 `let` 重写之前的 `sumMatrix` 函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0\n  for (let i = 0; i < matrix.length; i++) {\n    let currentRow = matrix[i]\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n\n  return sum\n}\n```\n\n这个版本的循环能得到正确的结果，因为内层循环的 `i` 可以屏蔽掉外层循环的 `i`。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。\n\n### 块级作用域变量的获取\n\n每次进入一个作用域时，`let` 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n回想一下前面 `setTimeout` 的例子，我们最后需要使用立即执行的函数表达式来获取每次 `for` 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 `TypeScript` 里这样做了。\n\n当 `let` 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 `setTimeout` 例子里我们仅使用 `let` 声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10 ; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n会输出与预料一致的结果：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n## const 声明\n\n`const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9\n```\n\n它们与 `let` 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 `let` 相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n\n```typescript\nconst numLivesForCat = 9\nconst kitty = {\n  name: 'Kitty',\n  numLives: numLivesForCat\n}\n\n// Error\nkitty = {\n  name: 'Tommy',\n  numLives: numLivesForCat\n};\n\n// OK\nkitty.name = 'Jerry'\nkitty.numLives--\n```\n\n除非你使用特殊的方法去避免，实际上 `const` 变量的内部状态是可修改的。 幸运的是，`TypeScript` 允许你将对象的成员设置成只读的。接口一章有详细说明。\n\n## let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用 `const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 `const` 也可以让我们更容易的推测数据的流动。\n\n## 解构\n\n### 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2]\nlet [first, second] = input\nconsole.log(first) // outputs 1\nconsole.log(second) // outputs 2\n```\n\n这创建了 2 个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nlet first = input[0]\nlet second = input[1]\n```\n\n作用于函数参数：\n\n```typescript\nlet input: [number, number] = [1, 2]\n\nfunction f([first, second]: [number, number]) {\n  console.log(first)\n  console.log(second)\n}\n\nf(input)\n```\n\n你可以在数组里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\nconsole.log(rest) // outputs [ 2, 3, 4 ]\n```\n\n你也可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\n```\n\n或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4]\n```\n\n### 对象解构\n\n你也可以解构对象：\n\n```typescript\nlet o = {\n    a: 'foo',\n    b: 12,\n    c: 'bar'\n}\nlet { a, b } = o\n\n```\n\n这通过 `o.a` 和 `o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n\n你可以在对象里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o\nlet total = passthrough.b + passthrough.c.length\n```\n\n### 属性重命名\n\n你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o\n```\n\n这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 `\"a 作为 newName1\"`。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a\nlet newName2 = o.b\n```\n\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。\n\n```typescript\nlet {a, b}: {a: string, b: number} = o\n```\n\n### 默认值\n\n默认值可以让你在属性为 `undefined` 时使用缺省值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n  let { a, b = 1001 } = wholeObject\n}\n```\n\n现在，即使 `b` 为 `undefined` ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n### 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a = '', b = 0 } = {}): void {\n  // ...\n}\nf()\n```\n\n> 上面的代码是一个类型推断的例子，将在后续章节介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: '' }): void {\n  // ...\n}\nf({ a: 'yes' }) // OK, 默认 b = 0\nf() // OK, 默认 a: '', b = 0\nf({}) // Error, 一旦传入参数则 a 是必须的\n```\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。\n\n## 展开\n\n```typescript\nlet first = [1, 2]\nlet second = [3, 4]\nlet bothPlus = [0, ...first, ...second, 5]\n```\n这会令 `bothPlus` 的值为 `[0, 1, 2, 3, 4, 5]`。 展开操作创建了 `first` 和 `second的` 一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { ...defaults, food: 'rich' }\n```\n\nsearch的值为 `{ food: 'rich', price: '$10', ambiance: 'noisy' }`。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { food: 'rich', ...defaults }\n```\n\n那么，`defaults` 里的 `food` 属性会重写 `food: 'rich'`，在这里这并不是我们想要的结果。\n","slug":"TypeScript 学习第七章 TypeScript变量声明","published":1,"updated":"2019-08-17T11:11:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6l004lw72sj3o0eawp","content":"<h1><span id=\"变量声明\">变量声明</span></h1>\n<p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p>\n<p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p>\n<p>如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n<h2><span id=\"var-声明\">var 声明</span></h2>\n<p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义JavaScript 变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p>\n<p>我们也可以在函数内部定义变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> message</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且我们也可以在其它函数内部访问相同的变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f()</span><br><span class=\"line\">g() <span class=\"comment\">// returns 11</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p>\n<h3><span id=\"作用域规则\">作用域规则</span></h3>\n<p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>)  <span class=\"comment\">// returns '10'</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>) <span class=\"comment\">// returns 'undefined'</span></span><br></pre></td></tr></table></figure>\n<p>有些同学可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p>\n<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>\n<h3><span id=\"捕获变量怪异之处\">捕获变量怪异之处</span></h3>\n<p>猜一下下面的代码会返回什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p>\n</blockquote>\n<p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p>\n<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p>\n<h2><span id=\"let-声明\">let 声明</span></h2>\n<p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">'Hello!'</span></span><br></pre></td></tr></table></figure>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n<h3><span id=\"块作用域\">块作用域</span></h3>\n<p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// OK: 仍然能访问到 a</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Error: 'b' 在这里不存在</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p>\n<p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'Oh no!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch it.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: 'e' 在这里不存在</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e)</span><br></pre></td></tr></table></figure>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++ <span class=\"comment\">// TS2448: Block-scoped variable 'a' used before its declaration.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// okay to capture 'a'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在'a'被声明前调用'foo'</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>关于<em>暂时性死区</em>的更多信息，查看这里 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\" target=\"_blank\" rel=\"noopener\">Mozilla Developer Network</a>。</p>\n<h3><span id=\"重定义及屏蔽\">重定义及屏蔽</span></h3>\n<p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span> <span class=\"comment\">// 错误，不能在 1 个作用域里多次声明 x</span></span><br></pre></td></tr></table></figure>\n<p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 干扰参数声明</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 不能同时具有 x 的两个声明</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>) <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>)  <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p>\n<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p>\n<h3><span id=\"块级作用域变量的获取\">块级作用域变量的获取</span></h3>\n<p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n<p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p>\n<p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出与预料一致的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"const-声明\">const 声明</span></h2>\n<p><code>const</code> 声明是声明变量的另一种方式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p>\n<p>这很好理解，它们引用的值是不可变的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kitty'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tommy'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">'Jerry'</span></span><br><span class=\"line\">kitty.numLives--</span><br></pre></td></tr></table></figure>\n<p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p>\n<h2><span id=\"let-vs-const\">let vs. const</span></h2>\n<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p>\n<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p>\n<h2><span id=\"解构\">解构</span></h2>\n<h3><span id=\"解构数组\">解构数组</span></h3>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second) <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n<p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = input[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = input[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>作用于函数参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(first)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(input)</span><br></pre></td></tr></table></figure>\n<p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest) <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>你也可以忽略你不关心的尾随元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n<p>或其它元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<h3><span id=\"对象解构\">对象解构</span></h3>\n<p>你也可以解构对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">    b: <span class=\"number\">12</span>,</span><br><span class=\"line\">    c: <span class=\"string\">'bar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p>\n<p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length</span><br></pre></td></tr></table></figure>\n<h3><span id=\"属性重命名\">属性重命名</span></h3>\n<p>你也可以给属性以不同的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a: newName1, b: newName2 &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b</span><br></pre></td></tr></table></figure>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125;: &#123;a: <span class=\"built_in\">string</span>, b: <span class=\"built_in\">number</span>&#125; = o</span><br></pre></td></tr></table></figure>\n<h3><span id=\"默认值\">默认值</span></h3>\n<p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>\n<h3><span id=\"函数声明\">函数声明</span></h3>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a = '', b = 0 &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p>\n</blockquote>\n<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = 0 &#125; = &#123; a: '' &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; a: <span class=\"string\">'yes'</span> &#125;) <span class=\"comment\">// OK, 默认 b = 0</span></span><br><span class=\"line\">f() <span class=\"comment\">// OK, 默认 a: '', b = 0</span></span><br><span class=\"line\">f(&#123;&#125;) <span class=\"comment\">// Error, 一旦传入参数则 a 是必须的</span></span><br></pre></td></tr></table></figure>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p>\n<h2><span id=\"展开\">展开</span></h2>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p>\n<p>你还可以展开对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, food: <span class=\"string\">'rich'</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>search的值为 <code>{ food: 'rich', price: '$10', ambiance: 'noisy' }</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; food: <span class=\"string\">'rich'</span>, ...defaults &#125;</span><br></pre></td></tr></table></figure>\n<p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: 'rich'</code>，在这里这并不是我们想要的结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>变量声明</h1>\n<p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p>\n<p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p>\n<p>如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n<h2>var 声明</h2>\n<p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义JavaScript 变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p>\n<p>我们也可以在函数内部定义变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> message</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且我们也可以在其它函数内部访问相同的变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f()</span><br><span class=\"line\">g() <span class=\"comment\">// returns 11</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p>\n<h3>作用域规则</h3>\n<p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>)  <span class=\"comment\">// returns '10'</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>) <span class=\"comment\">// returns 'undefined'</span></span><br></pre></td></tr></table></figure>\n<p>有些同学可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p>\n<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>\n<h3>捕获变量怪异之处</h3>\n<p>猜一下下面的代码会返回什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p>\n</blockquote>\n<p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p>\n<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p>\n<h2>let 声明</h2>\n<p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">'Hello!'</span></span><br></pre></td></tr></table></figure>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n<h3>块作用域</h3>\n<p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// OK: 仍然能访问到 a</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Error: 'b' 在这里不存在</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p>\n<p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'Oh no!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch it.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: 'e' 在这里不存在</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e)</span><br></pre></td></tr></table></figure>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++ <span class=\"comment\">// TS2448: Block-scoped variable 'a' used before its declaration.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// okay to capture 'a'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在'a'被声明前调用'foo'</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>关于<em>暂时性死区</em>的更多信息，查看这里 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\" target=\"_blank\" rel=\"noopener\">Mozilla Developer Network</a>。</p>\n<h3>重定义及屏蔽</h3>\n<p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span> <span class=\"comment\">// 错误，不能在 1 个作用域里多次声明 x</span></span><br></pre></td></tr></table></figure>\n<p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 干扰参数声明</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 不能同时具有 x 的两个声明</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>) <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>)  <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p>\n<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p>\n<h3>块级作用域变量的获取</h3>\n<p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n<p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p>\n<p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出与预料一致的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h2>const 声明</h2>\n<p><code>const</code> 声明是声明变量的另一种方式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p>\n<p>这很好理解，它们引用的值是不可变的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kitty'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tommy'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">'Jerry'</span></span><br><span class=\"line\">kitty.numLives--</span><br></pre></td></tr></table></figure>\n<p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p>\n<h2>let vs. const</h2>\n<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p>\n<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p>\n<h2>解构</h2>\n<h3>解构数组</h3>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second) <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n<p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = input[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = input[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>作用于函数参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(first)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(input)</span><br></pre></td></tr></table></figure>\n<p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest) <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>你也可以忽略你不关心的尾随元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n<p>或其它元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<h3>对象解构</h3>\n<p>你也可以解构对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">    b: <span class=\"number\">12</span>,</span><br><span class=\"line\">    c: <span class=\"string\">'bar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p>\n<p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length</span><br></pre></td></tr></table></figure>\n<h3>属性重命名</h3>\n<p>你也可以给属性以不同的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a: newName1, b: newName2 &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b</span><br></pre></td></tr></table></figure>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125;: &#123;a: <span class=\"built_in\">string</span>, b: <span class=\"built_in\">number</span>&#125; = o</span><br></pre></td></tr></table></figure>\n<h3>默认值</h3>\n<p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>\n<h3>函数声明</h3>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a = '', b = 0 &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p>\n</blockquote>\n<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = 0 &#125; = &#123; a: '' &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; a: <span class=\"string\">'yes'</span> &#125;) <span class=\"comment\">// OK, 默认 b = 0</span></span><br><span class=\"line\">f() <span class=\"comment\">// OK, 默认 a: '', b = 0</span></span><br><span class=\"line\">f(&#123;&#125;) <span class=\"comment\">// Error, 一旦传入参数则 a 是必须的</span></span><br></pre></td></tr></table></figure>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p>\n<h2>展开</h2>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p>\n<p>你还可以展开对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, food: <span class=\"string\">'rich'</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>search的值为 <code>{ food: 'rich', price: '$10', ambiance: 'noisy' }</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; food: <span class=\"string\">'rich'</span>, ...defaults &#125;</span><br></pre></td></tr></table></figure>\n<p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: 'rich'</code>，在这里这并不是我们想要的结果。</p>\n"},{"title":"TypeScript 学习第九章 TypeScript泛型","catalog":true,"date":"2019-08-22T10:54:42.000Z","subtitle":null,"header-img":"http://attach.bbs.miui.com/forum/201408/22/105929p5qdodm5qm4mfjf6.jpg","_content":"\n# 泛型\n\n软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n## 基础示例\n\n下面来创建第一个使用泛型的例子：`identity` 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 `echo` 命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\n```typescript\nfunction identity(arg: number): number {\n  return arg\n}\n```\n\n或者，我们使用 `any` 类型来定义函数：\n\n```typescript\nfunction identity(arg: any): any {\n  return arg\n}\n```\n\n使用 `any` 类型会导致这个函数可以接收任何类型的 `arg` 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了*类型变量*，它是一种特殊的变量，只用于表示类型而不是值。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n我们给 `identity` 添加了类型变量 `T`。 `T` 帮助我们捕获用户传入的类型（比如：`number`），之后我们就可以使用这个类型。 之后我们再次使用了 `T` 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的 `identity` 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 `any`，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\n```typescript\nlet output = identity<string>('myString')\n```\n\n这里我们明确的指定了 `T` 是 `string` 类型，并做为一个参数传给函数，使用了 `<>` 括起来而不是 `()`。\n\n第二种方法更普遍。利用了*类型推论* -- 即编译器会根据传入的参数自动地帮助我们确定 `T` 的类型：\n\n```typescript\nlet output = identity('myString')\n```\n\n注意我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看 `myString` 的值，然后把 `T` 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 `T` 的类型，在一些复杂的情况下，这是可能出现的。\n\n## 使用泛型变量\n\n使用泛型创建像 `identity` 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前 `identity` 例子：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n如果我们想打印出 `arg` 的长度。 我们很可能会这样做：\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n如果这么做，编译器会报错说我们使用了 `arg` 的 `.length` 属性，但是没有地方指明 `arg` 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 `.length` 属性的。\n\n现在假设我们想操作 `T` 类型的数组而不直接是 `T`。由于我们操作的是数组，所以 `.length` 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length)\n  return arg\n}\n```\n\n你可以这样理解 `loggingIdentity` 的类型：泛型函数 `loggingIdentity`，接收类型参数 `T` 和参数 `arg`，它是个元素类型是 `T` 的数组，并返回元素类型是`T` 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 `T` 的的类型为 `number`。 这可以让我们把泛型变量 `T` 当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n\n## 泛型类型\n\n上一节，我们创建了 `identity` 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <T>(arg: T) => T = identity\n```\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <U>(arg: U) => U = identity\n```\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity\n```\n\n这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n  <T>(arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn = identity\n```\n\n我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： `Dictionary<string>` 而不只是` Dictionary`）。这样接口里的其它成员也能知道这个参数的类型了。\n\n\n```typescript\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity\n```\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 `GenericIdentityFn` 的时候，还得传入一个类型参数来指定泛型类型（这里是：`number`），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n## 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（ `<>`）括起泛型类型，跟在类名后面。\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T\n  add: (x: T, y: T) => T\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function(x, y) {\n  return x + y \n}\n```\n\n`GenericNumber` 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 `number` 类型。 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>()\nstringNumeric.zeroValue = ''\nstringNumeric.add = function(x, y) { \n  return x + y\n}\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))\n```\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在[类](/chapter2/class)那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n## 泛型约束\n\n我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 `loggingIdentity` 例子中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 `length` 属性，所以就报错了。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n相比于操作 `any` 所有类型，我们想要限制函数去处理任意带有 `.length` 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 `T` 的约束要求。\n\n我们定义一个接口来描述约束条件，创建一个包含 `.length` 属性的接口，使用这个接口和 `extends` 关键字来实现约束：\n\n```typescript\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length) // OK\n  return arg\n}\n```\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\n```typescript\nloggingIdentity(3);  // Error\n```\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\n```typescript\nloggingIdentity({length: 10, value: 3}) // OK\n```\n\n### 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 `obj` 上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T> (obj: T, key: K ) {\n  return obj[key]\n}\n\nlet x = {a: 1, b: 2, c: 3, d: 4}\n\ngetProperty(x, 'a') // okay\ngetProperty(x, 'm') // error\n```\n\n","source":"_posts/TypeScript 学习第九章 TypeScript泛型.md","raw":"---\ntitle: TypeScript 学习第九章 TypeScript泛型\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-22 18:54:42\nsubtitle:\nheader-img: \"http://attach.bbs.miui.com/forum/201408/22/105929p5qdodm5qm4mfjf6.jpg\"\n---\n\n# 泛型\n\n软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n## 基础示例\n\n下面来创建第一个使用泛型的例子：`identity` 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 `echo` 命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\n```typescript\nfunction identity(arg: number): number {\n  return arg\n}\n```\n\n或者，我们使用 `any` 类型来定义函数：\n\n```typescript\nfunction identity(arg: any): any {\n  return arg\n}\n```\n\n使用 `any` 类型会导致这个函数可以接收任何类型的 `arg` 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了*类型变量*，它是一种特殊的变量，只用于表示类型而不是值。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n我们给 `identity` 添加了类型变量 `T`。 `T` 帮助我们捕获用户传入的类型（比如：`number`），之后我们就可以使用这个类型。 之后我们再次使用了 `T` 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的 `identity` 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 `any`，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\n```typescript\nlet output = identity<string>('myString')\n```\n\n这里我们明确的指定了 `T` 是 `string` 类型，并做为一个参数传给函数，使用了 `<>` 括起来而不是 `()`。\n\n第二种方法更普遍。利用了*类型推论* -- 即编译器会根据传入的参数自动地帮助我们确定 `T` 的类型：\n\n```typescript\nlet output = identity('myString')\n```\n\n注意我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看 `myString` 的值，然后把 `T` 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 `T` 的类型，在一些复杂的情况下，这是可能出现的。\n\n## 使用泛型变量\n\n使用泛型创建像 `identity` 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前 `identity` 例子：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n如果我们想打印出 `arg` 的长度。 我们很可能会这样做：\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n如果这么做，编译器会报错说我们使用了 `arg` 的 `.length` 属性，但是没有地方指明 `arg` 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 `.length` 属性的。\n\n现在假设我们想操作 `T` 类型的数组而不直接是 `T`。由于我们操作的是数组，所以 `.length` 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length)\n  return arg\n}\n```\n\n你可以这样理解 `loggingIdentity` 的类型：泛型函数 `loggingIdentity`，接收类型参数 `T` 和参数 `arg`，它是个元素类型是 `T` 的数组，并返回元素类型是`T` 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 `T` 的的类型为 `number`。 这可以让我们把泛型变量 `T` 当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n\n## 泛型类型\n\n上一节，我们创建了 `identity` 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <T>(arg: T) => T = identity\n```\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <U>(arg: U) => U = identity\n```\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity\n```\n\n这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n  <T>(arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn = identity\n```\n\n我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： `Dictionary<string>` 而不只是` Dictionary`）。这样接口里的其它成员也能知道这个参数的类型了。\n\n\n```typescript\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity\n```\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 `GenericIdentityFn` 的时候，还得传入一个类型参数来指定泛型类型（这里是：`number`），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n## 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（ `<>`）括起泛型类型，跟在类名后面。\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T\n  add: (x: T, y: T) => T\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function(x, y) {\n  return x + y \n}\n```\n\n`GenericNumber` 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 `number` 类型。 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>()\nstringNumeric.zeroValue = ''\nstringNumeric.add = function(x, y) { \n  return x + y\n}\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))\n```\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在[类](/chapter2/class)那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n## 泛型约束\n\n我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 `loggingIdentity` 例子中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 `length` 属性，所以就报错了。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n相比于操作 `any` 所有类型，我们想要限制函数去处理任意带有 `.length` 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 `T` 的约束要求。\n\n我们定义一个接口来描述约束条件，创建一个包含 `.length` 属性的接口，使用这个接口和 `extends` 关键字来实现约束：\n\n```typescript\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length) // OK\n  return arg\n}\n```\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\n```typescript\nloggingIdentity(3);  // Error\n```\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\n```typescript\nloggingIdentity({length: 10, value: 3}) // OK\n```\n\n### 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 `obj` 上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T> (obj: T, key: K ) {\n  return obj[key]\n}\n\nlet x = {a: 1, b: 2, c: 3, d: 4}\n\ngetProperty(x, 'a') // okay\ngetProperty(x, 'm') // error\n```\n\n","slug":"TypeScript 学习第九章 TypeScript泛型","published":1,"updated":"2019-08-17T11:09:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6n004nw72s6kd8w1tr","content":"<h1><span id=\"泛型\">泛型</span></h1>\n<p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>\n<p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>\n<h2><span id=\"基础示例\">基础示例</span></h2>\n<p>下面来创建第一个使用泛型的例子：<code>identity</code> 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code> 命令。</p>\n<p>不用泛型的话，这个函数可能是下面这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者，我们使用 <code>any</code> 类型来定义函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 <code>arg</code> 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>\n<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了<em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们给 <code>identity</code> 添加了类型变量 <code>T</code>。 <code>T</code> 帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code> 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。</p>\n<p>我们把这个版本的 <code>identity</code> 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>\n<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>这里我们明确的指定了 <code>T</code> 是 <code>string</code> 类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code> 括起来而不是 <code>()</code>。</p>\n<p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code> 的值，然后把 <code>T</code> 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code> 的类型，在一些复杂的情况下，这是可能出现的。</p>\n<h2><span id=\"使用泛型变量\">使用泛型变量</span></h2>\n<p>使用泛型创建像 <code>identity</code> 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>\n<p>看下之前 <code>identity</code> 例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想打印出 <code>arg</code> 的长度。 我们很可能会这样做：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这么做，编译器会报错说我们使用了 <code>arg</code> 的 <code>.length</code> 属性，但是没有地方指明 <code>arg</code> 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code> 属性的。</p>\n<p>现在假设我们想操作 <code>T</code> 类型的数组而不直接是 <code>T</code>。由于我们操作的是数组，所以 <code>.length</code> 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T[]</span>): <span class=\"title\">T</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以这样理解 <code>loggingIdentity</code> 的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code> 和参数 <code>arg</code>，它是个元素类型是 <code>T</code> 的数组，并返回元素类型是<code>T</code> 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code> 的的类型为 <code>number</code>。 这可以让我们把泛型变量 <code>T</code> 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>\n<h2><span id=\"泛型类型\">泛型类型</span></h2>\n<p>上一节，我们创建了 <code>identity</code> 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>\n<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;T&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></table></figure>\n<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;U&gt;<span class=\"function\">(<span class=\"params\">arg: U</span>) =&gt;</span> U = identity</span><br></pre></td></tr></table></figure>\n<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity</span><br></pre></td></tr></table></figure>\n<p>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn &#123;</span><br><span class=\"line\">  &lt;T&gt;(arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></table></figure>\n<p>我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是<code>Dictionary</code>）。这样接口里的其它成员也能知道这个参数的类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class=\"line\">  (arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn&lt;<span class=\"built_in\">number</span>&gt; = identity</span><br></pre></td></tr></table></figure>\n<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>\n<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>\n<h2><span id=\"泛型类\">泛型类</span></h2>\n<p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class=\"line\">  zeroValue: T</span><br><span class=\"line\">  add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">number</span>&gt;()</span><br><span class=\"line\">myGenericNumber.zeroValue = <span class=\"number\">0</span></span><br><span class=\"line\">myGenericNumber.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>GenericNumber</code> 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 <code>number</code> 类型。 也可以使用字符串或其它更复杂的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">string</span>&gt;()</span><br><span class=\"line\">stringNumeric.zeroValue = <span class=\"string\">''</span></span><br><span class=\"line\">stringNumeric.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class=\"string\">'test'</span>))</span><br></pre></td></tr></table></figure>\n<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>\n<p>我们在<a href=\"/chapter2/class\">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>\n<h2><span id=\"泛型约束\">泛型约束</span></h2>\n<p>我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 <code>length</code> 属性，所以就报错了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p>\n<p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lengthwise &#123;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Lengthwise</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length) <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(<span class=\"number\">3</span>);  <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(&#123;length: <span class=\"number\">10</span>, value: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"在泛型约束中使用类型参数\">在泛型约束中使用类型参数</span></h3>\n<p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt; (<span class=\"params\">obj: T, key: K </span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123;a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span>, d: <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'a'</span>) <span class=\"comment\">// okay</span></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'m'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>泛型</h1>\n<p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>\n<p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>\n<h2>基础示例</h2>\n<p>下面来创建第一个使用泛型的例子：<code>identity</code> 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code> 命令。</p>\n<p>不用泛型的话，这个函数可能是下面这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者，我们使用 <code>any</code> 类型来定义函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 <code>arg</code> 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>\n<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了<em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们给 <code>identity</code> 添加了类型变量 <code>T</code>。 <code>T</code> 帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code> 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。</p>\n<p>我们把这个版本的 <code>identity</code> 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>\n<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>这里我们明确的指定了 <code>T</code> 是 <code>string</code> 类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code> 括起来而不是 <code>()</code>。</p>\n<p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code> 的值，然后把 <code>T</code> 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code> 的类型，在一些复杂的情况下，这是可能出现的。</p>\n<h2>使用泛型变量</h2>\n<p>使用泛型创建像 <code>identity</code> 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>\n<p>看下之前 <code>identity</code> 例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想打印出 <code>arg</code> 的长度。 我们很可能会这样做：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这么做，编译器会报错说我们使用了 <code>arg</code> 的 <code>.length</code> 属性，但是没有地方指明 <code>arg</code> 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code> 属性的。</p>\n<p>现在假设我们想操作 <code>T</code> 类型的数组而不直接是 <code>T</code>。由于我们操作的是数组，所以 <code>.length</code> 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T[]</span>): <span class=\"title\">T</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以这样理解 <code>loggingIdentity</code> 的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code> 和参数 <code>arg</code>，它是个元素类型是 <code>T</code> 的数组，并返回元素类型是<code>T</code> 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code> 的的类型为 <code>number</code>。 这可以让我们把泛型变量 <code>T</code> 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>\n<h2>泛型类型</h2>\n<p>上一节，我们创建了 <code>identity</code> 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>\n<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;T&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></table></figure>\n<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;U&gt;<span class=\"function\">(<span class=\"params\">arg: U</span>) =&gt;</span> U = identity</span><br></pre></td></tr></table></figure>\n<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity</span><br></pre></td></tr></table></figure>\n<p>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn &#123;</span><br><span class=\"line\">  &lt;T&gt;(arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></table></figure>\n<p>我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是<code>Dictionary</code>）。这样接口里的其它成员也能知道这个参数的类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class=\"line\">  (arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn&lt;<span class=\"built_in\">number</span>&gt; = identity</span><br></pre></td></tr></table></figure>\n<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>\n<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>\n<h2>泛型类</h2>\n<p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class=\"line\">  zeroValue: T</span><br><span class=\"line\">  add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">number</span>&gt;()</span><br><span class=\"line\">myGenericNumber.zeroValue = <span class=\"number\">0</span></span><br><span class=\"line\">myGenericNumber.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>GenericNumber</code> 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 <code>number</code> 类型。 也可以使用字符串或其它更复杂的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">string</span>&gt;()</span><br><span class=\"line\">stringNumeric.zeroValue = <span class=\"string\">''</span></span><br><span class=\"line\">stringNumeric.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class=\"string\">'test'</span>))</span><br></pre></td></tr></table></figure>\n<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>\n<p>我们在<a href=\"/chapter2/class\">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>\n<h2>泛型约束</h2>\n<p>我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 <code>length</code> 属性，所以就报错了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p>\n<p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lengthwise &#123;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Lengthwise</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length) <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(<span class=\"number\">3</span>);  <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(&#123;length: <span class=\"number\">10</span>, value: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<h3>在泛型约束中使用类型参数</h3>\n<p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt; (<span class=\"params\">obj: T, key: K </span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123;a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span>, d: <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'a'</span>) <span class=\"comment\">// okay</span></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'m'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n"},{"title":"TypeScript 学习第十章 TypeScript 高级类型","catalog":true,"date":"2019-08-24T15:39:42.000Z","subtitle":null,"header-img":"http://hbimg.b0.upaiyun.com/41b12ee52728b42d69cbcc29bf4af166b18860fa49c77-CvohEM_fw658","_content":"\n# 高级类型\n\n## 交叉类型\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，`Person & Loggable` 同时是 `Person` 和 `Loggable`。 就是说这个类型的对象同时拥有了这两种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：\n\n```typescript\nfunction extend<T, U> (first: T, second: U): T & U {\n  let result = {} as T & U\n  for (let id in first) {\n    result[id] = first[id] as any\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      result[id] = second[id] as any\n    }\n  }\n  return result\n}\n\nclass Person {\n  constructor (public name: string) {\n  }\n}\n\ninterface Loggable {\n  log (): void\n}\n\nclass ConsoleLogger implements Loggable {\n  log () {\n    // ...\n  }\n}\n\nvar jim = extend(new Person('Jim'), new ConsoleLogger())\nvar n = jim.name\njim.log()\n```\n\n## 联合类型\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 `number` 或 `string` 类型的参数。 例如下面的函数：\n\n```typescript\nfunction padLeft(value: string, padding: any) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n\npadLeft('Hello world', 4) // returns \"    Hello world\"\n\n```\n\n`padLeft` 存在一个问题，`padding` 参数的类型指定成了 `any`。 这就是说我们可以传入一个既不是 `number` 也不是 `string` 类型的参数，但是 TypeScript 却不报错。\n\n```typescript\nlet indentedString = padLeft('Hello world', true) // 编译阶段通过，运行时报错\n```\n\n为了解决这个问题，我们可以使用 联合类型做为 `padding` 的参数：\n\n```typescript\nfunction padLeft(value: string, padding: string | number) {\n  // ...\n}\n\nlet indentedString = padLeft('Hello world', true) // 编译阶段报错\n```\n\n联合类型表示一个值可以是几种类型之一。我们用竖线（`|`）分隔每个类型，所以 `number | string` 表示一个值可以是 `number` 或 `string`。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\n```typescript\ninterface Bird {\n  fly()\n  layEggs()\n}\n\ninterface Fish {\n  swim()\n  layEggs()\n}\n\nfunction getSmallPet(): Fish | Bird {\n  // ...\n}\n\nlet pet = getSmallPet()\npet.layEggs() // okay\npet.swim()    // error\n```\n\n这里的联合类型可能有点复杂：如果一个值的类型是 `A | B`，我们能够确定的是它包含了 `A` 和 `B` 中共有的成员。这个例子里，`Fish` 具有一个 `swim` 方法，我们不能确定一个 `Bird | Fish` 类型的变量是否有 `swim`方法。 如果变量在运行时是 `Bird` 类型，那么调用 `pet.swim()` 就出错了。\n\n## 类型保护\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 `Fish` 或者是 `Bird` 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\nlet pet = getSmallPet()\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n  pet.swim()\n} else if (pet.fly) {\n  pet.fly()\n}\n```\n\n为了让这段代码工作，我们要使用类型断言：\n\n```typescript\nlet pet = getSmallPet()\n\nif ((pet as Fish).swim) {\n  (pet as Fish).swim()\n} else {\n  (pet as Bird).fly()\n}\n```\n\n### 用户自定义的类型保护\n\n这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 `pet` 的类型的话就好了。\n\nTypeScript 里的*类型保护*机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个*类型谓词*：\n\n```typescript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined\n}\n```\n\n在这个例子里，`pet is Fish` 就是类型谓词。谓词为 `parameterName is Type` 这种形式， `parameterName` 必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用 `isFish` 时，`TypeScript` 会将变量缩减为那个具体的类型。\n\n```typescript\nif (isFish(pet)) {\n  pet.swim()\n}\nelse {\n  pet.fly()\n}\n```\n\n注意 `TypeScript` 不仅知道在 `if` 分支里 `pet` 是 `Fish` 类型；它还清楚在 `else` 分支里，一定不是 Fish类型而是 `Bird` 类型。\n\n### typeof 类型保护\n\n现在我们回过头来看看怎么使用联合类型书写 `padLeft` 代码。我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber (x: any):x is string {\n  return typeof x === 'number'\n}\n\nfunction isString (x: any): x is string {\n  return typeof x === 'string'\n}\n\nfunction padLeft (value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (isString(padding)) {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 `typeof x === 'number' `抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\n\n```typescript\nfunction padLeft (value: string, padding: string | number) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n这些 `typeof` 类型保护只有两种形式能被识别：`typeof v === \"typename\"` 和 `typeof v !== \"typename\"`， `\"typename\"`必须是 `\"number\"`， `\"string\"`，`\"boolean\"` 或 `\"symbol\"`。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。\n\n### instanceof 类型保护\n\n如果你已经阅读了 `typeof` 类型保护并且对 JavaScript 里的 `instanceof` 操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\n`instanceof` 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：\n\n```typescript\nclass Bird {\n  fly () {\n    console.log('bird fly')\n  }\n\n  layEggs () {\n    console.log('bird lay eggs')\n  }\n}\n\nclass Fish {\n  swim () {\n    console.log('fish swim')\n  }\n\n  layEggs () {\n    console.log('fish lay eggs')\n  }\n}\n\nfunction getRandomPet () {\n  return Math.random() > 0.5 ? new Bird() : new Fish()\n}\n\nlet pet = getRandomPet()\n\nif (pet instanceof Bird) {\n  pet.fly()\n}\nif (pet instanceof Fish) {\n  pet.swim()\n}\n```\n\n## 可以为 null 的类型\n\nTypeScript 具有两种特殊的类型，`null` 和 `undefined`，它们分别具有值 `null` 和 `undefined`。我们在[基础类型](/chapter2/type)一节里已经做过简要说明。 默认情况下，类型检查器认为 `null` 与 `undefined` 可以赋值给任何类型。 `null` 与 `undefined` 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。`null`的发明者，Tony Hoare，称它为[价值亿万美金的错误](https://en.wikipedia.org/wiki/Null_pointer#History)。\n\n`--strictNullChecks` 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 `null` 或 `undefined`。 你可以使用联合类型明确的包含它们：\n\n```typescript\nlet s = 'foo'\ns = null // 错误, 'null'不能赋值给'string'\nlet sn: string | null = 'bar'\nsn = null // 可以\n\nsn = undefined // error, 'undefined'不能赋值给'string | null'\n```\n\n注意，按照 JavaScript 的语义，TypeScript 会把 `null` 和 `undefined` 区别对待。`string | null`，`string | undefined` 和 `string | undefined | null` 是不同的类型。\n\n### 可选参数和可选属性\n\n使用了 `--strictNullChecks`，可选参数会被自动地加上 `| undefined`:\n\n```typescript\nfunction f(x: number, y?: number) {\n  return x + (y || 0)\n}\nf(1, 2)\nf(1)\nf(1, undefined)\nf(1, null) // error, 'null' 不能赋值给 'number | undefined'\n```\n\n可选属性也会有同样的处理：\n\n```typescript\nclass C {\n  a: number\n  b?: number\n}\nlet c = new C()\nc.a = 12\nc.a = undefined // error, 'undefined' 不能赋值给 'number'\nc.b = 13\nc.b = undefined // ok\nc.b = null // error, 'null' 不能赋值给 'number | undefined'\n```\n\n### 类型保护和类型断言\n\n由于可以为 `null` 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 `null`。幸运地是这与在 `JavaScript` 里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n  if (sn === null) {\n    return 'default'\n  } else {\n    return sn\n  }\n}\n```\n\n这里很明显地去除了 `null`，你也可以使用短路运算符：\n\n```typescript\nfunction f(sn: string | null): string {\n  return sn || 'default'\n}\n```\n\n如果编译器不能够去除 `null` 或 `undefined`，你可以使用类型断言手动去除。语法是添加 `!` 后缀： `identifier!` 从 `identifier` 的类型里去除了 `null` 和 `undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charAt(0) + '.  the ' + epithet // error, 'name' 可能为 null\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charAt(0) + '.  the ' + epithet // ok\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nbroken(null)\n\n```\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的 `null`（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 `name` 的类型。\n\n## 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = 'ease-in' | 'ease-out' | 'ease-in-out'\n\nclass UIElement {\n  animate (dx: number, dy: number, easing: Easing) {\n    if (easing === 'ease-in') {\n      // ...\n    } else if (easing === 'ease-out') {\n    } else if (easing === 'ease-in-out') {\n    } else {\n      // error! 不能传入 null 或者 undefined.\n    }\n  }\n}\n\nlet button = new UIElement()\nbutton.animate(0, 0, 'ease-in')\nbutton.animate(0, 0, 'uneasy') // error\n\n```\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\n```\nArgument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n```\n\n\n","source":"_posts/TypeScript 学习第十章 TypeScript高级类型.md","raw":"---\ntitle: TypeScript 学习第十章 TypeScript 高级类型\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-24 23:39:42\nsubtitle:\nheader-img: \"http://hbimg.b0.upaiyun.com/41b12ee52728b42d69cbcc29bf4af166b18860fa49c77-CvohEM_fw658\"\n---\n\n# 高级类型\n\n## 交叉类型\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，`Person & Loggable` 同时是 `Person` 和 `Loggable`。 就是说这个类型的对象同时拥有了这两种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：\n\n```typescript\nfunction extend<T, U> (first: T, second: U): T & U {\n  let result = {} as T & U\n  for (let id in first) {\n    result[id] = first[id] as any\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      result[id] = second[id] as any\n    }\n  }\n  return result\n}\n\nclass Person {\n  constructor (public name: string) {\n  }\n}\n\ninterface Loggable {\n  log (): void\n}\n\nclass ConsoleLogger implements Loggable {\n  log () {\n    // ...\n  }\n}\n\nvar jim = extend(new Person('Jim'), new ConsoleLogger())\nvar n = jim.name\njim.log()\n```\n\n## 联合类型\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 `number` 或 `string` 类型的参数。 例如下面的函数：\n\n```typescript\nfunction padLeft(value: string, padding: any) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n\npadLeft('Hello world', 4) // returns \"    Hello world\"\n\n```\n\n`padLeft` 存在一个问题，`padding` 参数的类型指定成了 `any`。 这就是说我们可以传入一个既不是 `number` 也不是 `string` 类型的参数，但是 TypeScript 却不报错。\n\n```typescript\nlet indentedString = padLeft('Hello world', true) // 编译阶段通过，运行时报错\n```\n\n为了解决这个问题，我们可以使用 联合类型做为 `padding` 的参数：\n\n```typescript\nfunction padLeft(value: string, padding: string | number) {\n  // ...\n}\n\nlet indentedString = padLeft('Hello world', true) // 编译阶段报错\n```\n\n联合类型表示一个值可以是几种类型之一。我们用竖线（`|`）分隔每个类型，所以 `number | string` 表示一个值可以是 `number` 或 `string`。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\n```typescript\ninterface Bird {\n  fly()\n  layEggs()\n}\n\ninterface Fish {\n  swim()\n  layEggs()\n}\n\nfunction getSmallPet(): Fish | Bird {\n  // ...\n}\n\nlet pet = getSmallPet()\npet.layEggs() // okay\npet.swim()    // error\n```\n\n这里的联合类型可能有点复杂：如果一个值的类型是 `A | B`，我们能够确定的是它包含了 `A` 和 `B` 中共有的成员。这个例子里，`Fish` 具有一个 `swim` 方法，我们不能确定一个 `Bird | Fish` 类型的变量是否有 `swim`方法。 如果变量在运行时是 `Bird` 类型，那么调用 `pet.swim()` 就出错了。\n\n## 类型保护\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 `Fish` 或者是 `Bird` 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\nlet pet = getSmallPet()\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n  pet.swim()\n} else if (pet.fly) {\n  pet.fly()\n}\n```\n\n为了让这段代码工作，我们要使用类型断言：\n\n```typescript\nlet pet = getSmallPet()\n\nif ((pet as Fish).swim) {\n  (pet as Fish).swim()\n} else {\n  (pet as Bird).fly()\n}\n```\n\n### 用户自定义的类型保护\n\n这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 `pet` 的类型的话就好了。\n\nTypeScript 里的*类型保护*机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个*类型谓词*：\n\n```typescript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined\n}\n```\n\n在这个例子里，`pet is Fish` 就是类型谓词。谓词为 `parameterName is Type` 这种形式， `parameterName` 必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用 `isFish` 时，`TypeScript` 会将变量缩减为那个具体的类型。\n\n```typescript\nif (isFish(pet)) {\n  pet.swim()\n}\nelse {\n  pet.fly()\n}\n```\n\n注意 `TypeScript` 不仅知道在 `if` 分支里 `pet` 是 `Fish` 类型；它还清楚在 `else` 分支里，一定不是 Fish类型而是 `Bird` 类型。\n\n### typeof 类型保护\n\n现在我们回过头来看看怎么使用联合类型书写 `padLeft` 代码。我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber (x: any):x is string {\n  return typeof x === 'number'\n}\n\nfunction isString (x: any): x is string {\n  return typeof x === 'string'\n}\n\nfunction padLeft (value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (isString(padding)) {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 `typeof x === 'number' `抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\n\n```typescript\nfunction padLeft (value: string, padding: string | number) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n这些 `typeof` 类型保护只有两种形式能被识别：`typeof v === \"typename\"` 和 `typeof v !== \"typename\"`， `\"typename\"`必须是 `\"number\"`， `\"string\"`，`\"boolean\"` 或 `\"symbol\"`。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。\n\n### instanceof 类型保护\n\n如果你已经阅读了 `typeof` 类型保护并且对 JavaScript 里的 `instanceof` 操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\n`instanceof` 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：\n\n```typescript\nclass Bird {\n  fly () {\n    console.log('bird fly')\n  }\n\n  layEggs () {\n    console.log('bird lay eggs')\n  }\n}\n\nclass Fish {\n  swim () {\n    console.log('fish swim')\n  }\n\n  layEggs () {\n    console.log('fish lay eggs')\n  }\n}\n\nfunction getRandomPet () {\n  return Math.random() > 0.5 ? new Bird() : new Fish()\n}\n\nlet pet = getRandomPet()\n\nif (pet instanceof Bird) {\n  pet.fly()\n}\nif (pet instanceof Fish) {\n  pet.swim()\n}\n```\n\n## 可以为 null 的类型\n\nTypeScript 具有两种特殊的类型，`null` 和 `undefined`，它们分别具有值 `null` 和 `undefined`。我们在[基础类型](/chapter2/type)一节里已经做过简要说明。 默认情况下，类型检查器认为 `null` 与 `undefined` 可以赋值给任何类型。 `null` 与 `undefined` 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。`null`的发明者，Tony Hoare，称它为[价值亿万美金的错误](https://en.wikipedia.org/wiki/Null_pointer#History)。\n\n`--strictNullChecks` 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 `null` 或 `undefined`。 你可以使用联合类型明确的包含它们：\n\n```typescript\nlet s = 'foo'\ns = null // 错误, 'null'不能赋值给'string'\nlet sn: string | null = 'bar'\nsn = null // 可以\n\nsn = undefined // error, 'undefined'不能赋值给'string | null'\n```\n\n注意，按照 JavaScript 的语义，TypeScript 会把 `null` 和 `undefined` 区别对待。`string | null`，`string | undefined` 和 `string | undefined | null` 是不同的类型。\n\n### 可选参数和可选属性\n\n使用了 `--strictNullChecks`，可选参数会被自动地加上 `| undefined`:\n\n```typescript\nfunction f(x: number, y?: number) {\n  return x + (y || 0)\n}\nf(1, 2)\nf(1)\nf(1, undefined)\nf(1, null) // error, 'null' 不能赋值给 'number | undefined'\n```\n\n可选属性也会有同样的处理：\n\n```typescript\nclass C {\n  a: number\n  b?: number\n}\nlet c = new C()\nc.a = 12\nc.a = undefined // error, 'undefined' 不能赋值给 'number'\nc.b = 13\nc.b = undefined // ok\nc.b = null // error, 'null' 不能赋值给 'number | undefined'\n```\n\n### 类型保护和类型断言\n\n由于可以为 `null` 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 `null`。幸运地是这与在 `JavaScript` 里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n  if (sn === null) {\n    return 'default'\n  } else {\n    return sn\n  }\n}\n```\n\n这里很明显地去除了 `null`，你也可以使用短路运算符：\n\n```typescript\nfunction f(sn: string | null): string {\n  return sn || 'default'\n}\n```\n\n如果编译器不能够去除 `null` 或 `undefined`，你可以使用类型断言手动去除。语法是添加 `!` 后缀： `identifier!` 从 `identifier` 的类型里去除了 `null` 和 `undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charAt(0) + '.  the ' + epithet // error, 'name' 可能为 null\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charAt(0) + '.  the ' + epithet // ok\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nbroken(null)\n\n```\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的 `null`（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 `name` 的类型。\n\n## 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = 'ease-in' | 'ease-out' | 'ease-in-out'\n\nclass UIElement {\n  animate (dx: number, dy: number, easing: Easing) {\n    if (easing === 'ease-in') {\n      // ...\n    } else if (easing === 'ease-out') {\n    } else if (easing === 'ease-in-out') {\n    } else {\n      // error! 不能传入 null 或者 undefined.\n    }\n  }\n}\n\nlet button = new UIElement()\nbutton.animate(0, 0, 'ease-in')\nbutton.animate(0, 0, 'uneasy') // error\n\n```\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\n```\nArgument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n```\n\n\n","slug":"TypeScript 学习第十章 TypeScript高级类型","published":1,"updated":"2019-08-17T11:15:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6o004qw72snyr3ymo9","content":"<h1><span id=\"高级类型\">高级类型</span></h1>\n<h2><span id=\"交叉类型\">交叉类型</span></h2>\n<p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p>\n<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; (<span class=\"params\">first: T, second: U</span>): <span class=\"title\">T</span> &amp; <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T &amp; U</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">    result[id] = first[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class=\"line\">      result[id] = second[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Loggable &#123;</span><br><span class=\"line\">  log (): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> ConsoleLogger <span class=\"keyword\">implements</span> Loggable &#123;</span><br><span class=\"line\">  log () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jim = extend(<span class=\"keyword\">new</span> Person(<span class=\"string\">'Jim'</span>), <span class=\"keyword\">new</span> ConsoleLogger())</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = jim.name</span><br><span class=\"line\">jim.log()</span><br></pre></td></tr></table></figure>\n<h2><span id=\"联合类型\">联合类型</span></h2>\n<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"number\">4</span>) <span class=\"comment\">// returns \"    Hello world\"</span></span><br></pre></td></tr></table></figure>\n<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段报错</span></span><br></pre></td></tr></table></figure>\n<p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p>\n<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\">pet.layEggs() <span class=\"comment\">// okay</span></span><br><span class=\"line\">pet.swim()    <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p>\n<h2><span id=\"类型保护\">类型保护</span></h2>\n<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code>Fish</code> 或者是 <code>Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一个成员访问都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet.swim) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.fly) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了让这段代码工作，我们要使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((pet <span class=\"keyword\">as</span> Fish).swim) &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Fish).swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Bird).fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"用户自定义的类型保护\">用户自定义的类型保护</span></h3>\n<p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p>\n<p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> Fish).swim !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>\n<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isFish(pet)) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分支里，一定不是 Fish类型而是 <code>Bird</code> 类型。</p>\n<h3><span id=\"typeof-类型保护\">typeof 类型保护</span></h3>\n<p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>):<span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === 'number'</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>\n<h3><span id=\"instanceof-类型保护\">instanceof 类型保护</span></h3>\n<p>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>\n<p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Bird &#123;</span><br><span class=\"line\">  fly () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird fly'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Fish &#123;</span><br><span class=\"line\">  swim () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish swim'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPet</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">0.5</span> ? <span class=\"keyword\">new</span> Bird() : <span class=\"keyword\">new</span> Fish()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getRandomPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Bird) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Fish) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"可以为-null-的类型\">可以为 null 的类型</span></h2>\n<p>TypeScript 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code>，它们分别具有值 <code>null</code> 和 <code>undefined</code>。我们在<a href=\"/chapter2/type\">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code>null</code>的发明者，Tony Hoare，称它为<a href=\"https://en.wikipedia.org/wiki/Null_pointer#History\" target=\"_blank\" rel=\"noopener\">价值亿万美金的错误</a>。</p>\n<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。 你可以使用联合类型明确的包含它们：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'foo'</span></span><br><span class=\"line\">s = <span class=\"literal\">null</span> <span class=\"comment\">// 错误, 'null'不能赋值给'string'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span> = <span class=\"string\">'bar'</span></span><br><span class=\"line\">sn = <span class=\"literal\">null</span> <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\">sn = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined'不能赋值给'string | null'</span></span><br></pre></td></tr></table></figure>\n<p>注意，按照 JavaScript 的语义，TypeScript 会把 <code>null</code> 和 <code>undefined</code> 区别对待。<code>string | null</code>，<code>string | undefined</code> 和 <code>string | undefined | null</code> 是不同的类型。</p>\n<h3><span id=\"可选参数和可选属性\">可选参数和可选属性</span></h3>\n<p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y?: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + (y || <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">null</span>) <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<p>可选属性也会有同样的处理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">  a: <span class=\"built_in\">number</span></span><br><span class=\"line\">  b?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C()</span><br><span class=\"line\">c.a = <span class=\"number\">12</span></span><br><span class=\"line\">c.a = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined' 不能赋值给 'number'</span></span><br><span class=\"line\">c.b = <span class=\"number\">13</span></span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span> <span class=\"comment\">// ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span> <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"类型保护和类型断言\">类型保护和类型断言</span></h3>\n<p>由于可以为 <code>null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sn === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'default'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很明显地去除了 <code>null</code>，你也可以使用短路运算符：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sn || <span class=\"string\">'default'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">broken</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// error, 'name' 可能为 null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name!.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// ok</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">broken(<span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>\n<h2><span id=\"字符串字面量类型\">字符串字面量类型</span></h2>\n<p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">'ease-in'</span> | <span class=\"string\">'ease-out'</span> | <span class=\"string\">'ease-in-out'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> UIElement &#123;</span><br><span class=\"line\">  animate (dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// error! 不能传入 null 或者 undefined.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement()</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'ease-in'</span>)</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'uneasy'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>高级类型</h1>\n<h2>交叉类型</h2>\n<p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p>\n<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; (<span class=\"params\">first: T, second: U</span>): <span class=\"title\">T</span> &amp; <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T &amp; U</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">    result[id] = first[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class=\"line\">      result[id] = second[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Loggable &#123;</span><br><span class=\"line\">  log (): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> ConsoleLogger <span class=\"keyword\">implements</span> Loggable &#123;</span><br><span class=\"line\">  log () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jim = extend(<span class=\"keyword\">new</span> Person(<span class=\"string\">'Jim'</span>), <span class=\"keyword\">new</span> ConsoleLogger())</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = jim.name</span><br><span class=\"line\">jim.log()</span><br></pre></td></tr></table></figure>\n<h2>联合类型</h2>\n<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"number\">4</span>) <span class=\"comment\">// returns \"    Hello world\"</span></span><br></pre></td></tr></table></figure>\n<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段报错</span></span><br></pre></td></tr></table></figure>\n<p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p>\n<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\">pet.layEggs() <span class=\"comment\">// okay</span></span><br><span class=\"line\">pet.swim()    <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p>\n<h2>类型保护</h2>\n<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code>Fish</code> 或者是 <code>Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一个成员访问都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet.swim) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.fly) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了让这段代码工作，我们要使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((pet <span class=\"keyword\">as</span> Fish).swim) &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Fish).swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Bird).fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>用户自定义的类型保护</h3>\n<p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p>\n<p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> Fish).swim !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>\n<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isFish(pet)) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分支里，一定不是 Fish类型而是 <code>Bird</code> 类型。</p>\n<h3>typeof 类型保护</h3>\n<p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>):<span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === 'number'</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>\n<h3>instanceof 类型保护</h3>\n<p>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>\n<p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Bird &#123;</span><br><span class=\"line\">  fly () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird fly'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Fish &#123;</span><br><span class=\"line\">  swim () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish swim'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPet</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">0.5</span> ? <span class=\"keyword\">new</span> Bird() : <span class=\"keyword\">new</span> Fish()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getRandomPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Bird) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Fish) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>可以为 null 的类型</h2>\n<p>TypeScript 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code>，它们分别具有值 <code>null</code> 和 <code>undefined</code>。我们在<a href=\"/chapter2/type\">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code>null</code>的发明者，Tony Hoare，称它为<a href=\"https://en.wikipedia.org/wiki/Null_pointer#History\" target=\"_blank\" rel=\"noopener\">价值亿万美金的错误</a>。</p>\n<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。 你可以使用联合类型明确的包含它们：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'foo'</span></span><br><span class=\"line\">s = <span class=\"literal\">null</span> <span class=\"comment\">// 错误, 'null'不能赋值给'string'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span> = <span class=\"string\">'bar'</span></span><br><span class=\"line\">sn = <span class=\"literal\">null</span> <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\">sn = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined'不能赋值给'string | null'</span></span><br></pre></td></tr></table></figure>\n<p>注意，按照 JavaScript 的语义，TypeScript 会把 <code>null</code> 和 <code>undefined</code> 区别对待。<code>string | null</code>，<code>string | undefined</code> 和 <code>string | undefined | null</code> 是不同的类型。</p>\n<h3>可选参数和可选属性</h3>\n<p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y?: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + (y || <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">null</span>) <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<p>可选属性也会有同样的处理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">  a: <span class=\"built_in\">number</span></span><br><span class=\"line\">  b?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C()</span><br><span class=\"line\">c.a = <span class=\"number\">12</span></span><br><span class=\"line\">c.a = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined' 不能赋值给 'number'</span></span><br><span class=\"line\">c.b = <span class=\"number\">13</span></span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span> <span class=\"comment\">// ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span> <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<h3>类型保护和类型断言</h3>\n<p>由于可以为 <code>null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sn === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'default'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很明显地去除了 <code>null</code>，你也可以使用短路运算符：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sn || <span class=\"string\">'default'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">broken</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// error, 'name' 可能为 null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name!.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// ok</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">broken(<span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>\n<h2>字符串字面量类型</h2>\n<p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">'ease-in'</span> | <span class=\"string\">'ease-out'</span> | <span class=\"string\">'ease-in-out'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> UIElement &#123;</span><br><span class=\"line\">  animate (dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// error! 不能传入 null 或者 undefined.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement()</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'ease-in'</span>)</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'uneasy'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos;</span><br></pre></td></tr></table></figure>\n"},{"title":"TypeScript 学习第四章 TypeScript函数","catalog":true,"date":"2019-08-17T02:07:25.000Z","subtitle":null,"header-img":"http://10wallpaper.com/wallpaper/1680x1050/1508/Iron_man_hulkbuster_in_avengers-Movie_HD_Wallpaper_1680x1050.jpg","_content":"\n# 函数\n\n函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。\n\n## 基本示例\n\n和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：\n\n```javascript\n// 命名函数\nfunction add(x, y) {\n  return x + y\n}\n\n// 匿名函数\nlet myAdd = function(x, y) { \n  return x + y;\n}\n```\n\n在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。\n\n```javascript\nlet z = 100\n\nfunction addToZ(x, y) {\n  return x + y + z\n}\n```\n\n## 函数类型\n\n### 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\n```typescript\nfunction add(x: number, y: number): number {\n  return x + y\n}\n\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n```\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。\n\n### 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\n```typescript\nlet myAdd: (x: number, y: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n\n```\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：\n\n```typescript\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n```\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(`=>`)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 `void` 而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。\n\n### 推断类型\n\n尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：\n\n```typescript\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x, y) {\n  return x + y\n}\n```\n\n这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n## 可选参数和默认参数\n\nTypeScript 里的每个函数参数都是必须的。 这不是指不能传递 `null` 或 `undefined` 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + ' ' + lastName;\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', 'Sr.');  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams');         // OK\n```\n\nJavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 `undefined`。 在TypeScript 里我们可以在参数名旁使用 `?` 实现可选参数的功能。 比如，我们想让 `lastName` 是可选的：\n\n```typescript\nfunction buildName(firstName: string, lastName?: string): string {\n  if (lastName)\n    return firstName + ' ' + lastName\n  else\n    return firstName\n}\n\nlet result1 = buildName('Bob');  // 现在正常了\nlet result2 = buildName('Bob', 'Adams', 'Sr.')  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')  // OK\n```\n\n可选参数必须跟在必须参数后面。 如果上例我们想让 `firstName` 是可选的，那么就必须调整它们的位置，把 `firstName` 放在后面。\n\n在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 `undefined` 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把`lastName` 的默认值设置为 `\"Smith\"`。\n\n```typescript\nfunction buildName(firstName: string, lastName = 'Smith'): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // 返回 \"Bob Smith\"\nlet result2 = buildName('Bob', undefined)     // 正常, 同样 \"Bob Smith\"\nlet result3 = buildName('Bob', 'Adams', 'Sr.')  // 错误, 参数过多\nlet result4 = buildName('Bob', 'Adams')        // OK\n```\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 `undefined` 值来获得默认值。 例如，我们重写最后一个例子，让 `firstName` 是带默认值的参数：\n\n```typescript\nfunction buildName(firstName = 'Will', lastName: string): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', \"Sr.\")  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')         // OK， 返回 \"Bob Adams\"\nlet result4 = buildName(undefined, 'Adams')     // OK，  返回 \"Will Adams\"\n```\n\n### 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 `arguments` 来访问所有传入的参数。\n\n在 TypeScript 里，你可以把所有参数收集到一个变量里：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie')\n```\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ `...`）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName\n```\n\n## this\n\n学习如何在 JavaScript 里正确使用 `this` 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 `this` 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 `this` 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 [Understanding JavaScript Function Invocation and \"this\"](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)。 Yehuda 的文章详细的阐述了 `this` 的内部工作原理，因此我们这里只做简单介绍。\n\n### this 和箭头函数\n\nJavaScript里，`this` 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    return function() {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n可以看到 `createCardPicker` 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 `createCardPicker` 返回的函数里的 `this` 被设置成了 `global` 而不是 `deck` 对象。 因为我们只是独立的调用了 `cardPicker()`。 顶级的非方法式调用会将 `this` 视为 `global`。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的`this`。 这样的话，无论之后怎么使用它，都会引用绑定的`deck` 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 `this` 值，而不是调用时的值：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    // 注意：这里使用箭头函数\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n### this 参数\n在上述的例子中 `this.suits[pickedSuit]` 的类型为 `any`，这是因为 `this` 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 `this` 参数。 `this` 参数是个假的参数，它出现在参数列表的最前面：\n\n```typescript\nfunction f(this: void) {\n  // 确保“this”在此独立函数中不可用\n}\n```\n\n让我们往例子里添加一些接口，`Card` 和 `Deck`，让类型重用能够变得清晰简单些：\n\n```typescript\ninterface Card {\n  suit: string\n  card: number\n}\n\ninterface Deck {\n  suits: string[]\n  cards: number[]\n\n  createCardPicker (this: Deck): () => Card\n}\n\nlet deck: Deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  // NOTE: 函数现在显式指定其被调用方必须是 deck 类型\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n现在 TypeScrip t知道 `createCardPicker` 期望在某个 `Deck` 对象上调用。也就是说 `this` 是 `Deck` 类型的，而非 `any`。\n\n### this 参数在回调函数里\n\n你可以也看到过在回调函数里的 `this` 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，`this` 将为 `undefined`。 稍做改动，你就可以通过 `this` 参数来避免错误。 首先，库函数的作者要指定 `this` 的类型：\n\n```typescript\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void\n}\n```\n\n`this: void` 意味着 `addClickListener` 期望传入的 `onclick` 方法不需要 `this`\n\n```typescript\ninterface UIElement {\n  addClickListener (onclick: (this: void, e: Event) => void): void\n}\n\nclass Handler {\n  type: string\n\n  onClickBad (this: Handler, e: Event) {\n    this.type = e.type\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad) // error!\n\n```\n \n指定了 `this` 类型后，你显式声明 `onClickBad` 必须在 `Handler` 的实例上调用。 然后 TypeScript 会检测到 `addClickListener` 要求函数带有 `this: void`。 改变 `this` 类型来修复这个错误：\n\n```typescript\nclass Handler {\n  type: string;\n\n  onClickBad (this: void, e: Event) {\n    console.log('clicked!')\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad)\n```\n\n因为 `onClickGood` 指定了 `this` 类型为 `void`，因此传递 `addClickListener` 是合法的。 当然了，这也意味着不能使用 `this.info`。 如果你两者都想要，你不得不使用箭头函数了：\n\n```typescript\nclass Handler {\n  type: string\n  onClickGood = (e: Event) => {\n    this.type = e.type \n  }\n}\n```\n\n这是可行的因为箭头函数不会捕获 `this`，所以你总是可以把它们传给期望 `this: void` 的函数。\n\n## 重载\n\nJavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n`pickCard` 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 `pickCard` 函数。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x: {suit: string; card: number }[]): number\nfunction pickCard(x: number): {suit: string; card: number }\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n这样改变后，重载的 `pickCard` 函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，`function pickCard(x): any` 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 `pickCard` 会产生错误。\n","source":"_posts/TypeScript 学习第四章 TypeScript函数.md","raw":"---\ntitle: TypeScript 学习第四章 TypeScript函数\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-17 10:07:25\nsubtitle:\nheader-img: \"http://10wallpaper.com/wallpaper/1680x1050/1508/Iron_man_hulkbuster_in_avengers-Movie_HD_Wallpaper_1680x1050.jpg\"\n---\n\n# 函数\n\n函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。\n\n## 基本示例\n\n和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：\n\n```javascript\n// 命名函数\nfunction add(x, y) {\n  return x + y\n}\n\n// 匿名函数\nlet myAdd = function(x, y) { \n  return x + y;\n}\n```\n\n在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。\n\n```javascript\nlet z = 100\n\nfunction addToZ(x, y) {\n  return x + y + z\n}\n```\n\n## 函数类型\n\n### 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\n```typescript\nfunction add(x: number, y: number): number {\n  return x + y\n}\n\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n```\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。\n\n### 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\n```typescript\nlet myAdd: (x: number, y: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n\n```\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：\n\n```typescript\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n```\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(`=>`)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 `void` 而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。\n\n### 推断类型\n\n尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：\n\n```typescript\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x, y) {\n  return x + y\n}\n```\n\n这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n## 可选参数和默认参数\n\nTypeScript 里的每个函数参数都是必须的。 这不是指不能传递 `null` 或 `undefined` 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + ' ' + lastName;\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', 'Sr.');  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams');         // OK\n```\n\nJavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 `undefined`。 在TypeScript 里我们可以在参数名旁使用 `?` 实现可选参数的功能。 比如，我们想让 `lastName` 是可选的：\n\n```typescript\nfunction buildName(firstName: string, lastName?: string): string {\n  if (lastName)\n    return firstName + ' ' + lastName\n  else\n    return firstName\n}\n\nlet result1 = buildName('Bob');  // 现在正常了\nlet result2 = buildName('Bob', 'Adams', 'Sr.')  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')  // OK\n```\n\n可选参数必须跟在必须参数后面。 如果上例我们想让 `firstName` 是可选的，那么就必须调整它们的位置，把 `firstName` 放在后面。\n\n在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 `undefined` 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把`lastName` 的默认值设置为 `\"Smith\"`。\n\n```typescript\nfunction buildName(firstName: string, lastName = 'Smith'): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // 返回 \"Bob Smith\"\nlet result2 = buildName('Bob', undefined)     // 正常, 同样 \"Bob Smith\"\nlet result3 = buildName('Bob', 'Adams', 'Sr.')  // 错误, 参数过多\nlet result4 = buildName('Bob', 'Adams')        // OK\n```\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 `undefined` 值来获得默认值。 例如，我们重写最后一个例子，让 `firstName` 是带默认值的参数：\n\n```typescript\nfunction buildName(firstName = 'Will', lastName: string): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', \"Sr.\")  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')         // OK， 返回 \"Bob Adams\"\nlet result4 = buildName(undefined, 'Adams')     // OK，  返回 \"Will Adams\"\n```\n\n### 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 `arguments` 来访问所有传入的参数。\n\n在 TypeScript 里，你可以把所有参数收集到一个变量里：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie')\n```\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ `...`）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName\n```\n\n## this\n\n学习如何在 JavaScript 里正确使用 `this` 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 `this` 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 `this` 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 [Understanding JavaScript Function Invocation and \"this\"](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)。 Yehuda 的文章详细的阐述了 `this` 的内部工作原理，因此我们这里只做简单介绍。\n\n### this 和箭头函数\n\nJavaScript里，`this` 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    return function() {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n可以看到 `createCardPicker` 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 `createCardPicker` 返回的函数里的 `this` 被设置成了 `global` 而不是 `deck` 对象。 因为我们只是独立的调用了 `cardPicker()`。 顶级的非方法式调用会将 `this` 视为 `global`。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的`this`。 这样的话，无论之后怎么使用它，都会引用绑定的`deck` 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 `this` 值，而不是调用时的值：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    // 注意：这里使用箭头函数\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n### this 参数\n在上述的例子中 `this.suits[pickedSuit]` 的类型为 `any`，这是因为 `this` 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 `this` 参数。 `this` 参数是个假的参数，它出现在参数列表的最前面：\n\n```typescript\nfunction f(this: void) {\n  // 确保“this”在此独立函数中不可用\n}\n```\n\n让我们往例子里添加一些接口，`Card` 和 `Deck`，让类型重用能够变得清晰简单些：\n\n```typescript\ninterface Card {\n  suit: string\n  card: number\n}\n\ninterface Deck {\n  suits: string[]\n  cards: number[]\n\n  createCardPicker (this: Deck): () => Card\n}\n\nlet deck: Deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  // NOTE: 函数现在显式指定其被调用方必须是 deck 类型\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n现在 TypeScrip t知道 `createCardPicker` 期望在某个 `Deck` 对象上调用。也就是说 `this` 是 `Deck` 类型的，而非 `any`。\n\n### this 参数在回调函数里\n\n你可以也看到过在回调函数里的 `this` 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，`this` 将为 `undefined`。 稍做改动，你就可以通过 `this` 参数来避免错误。 首先，库函数的作者要指定 `this` 的类型：\n\n```typescript\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void\n}\n```\n\n`this: void` 意味着 `addClickListener` 期望传入的 `onclick` 方法不需要 `this`\n\n```typescript\ninterface UIElement {\n  addClickListener (onclick: (this: void, e: Event) => void): void\n}\n\nclass Handler {\n  type: string\n\n  onClickBad (this: Handler, e: Event) {\n    this.type = e.type\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad) // error!\n\n```\n \n指定了 `this` 类型后，你显式声明 `onClickBad` 必须在 `Handler` 的实例上调用。 然后 TypeScript 会检测到 `addClickListener` 要求函数带有 `this: void`。 改变 `this` 类型来修复这个错误：\n\n```typescript\nclass Handler {\n  type: string;\n\n  onClickBad (this: void, e: Event) {\n    console.log('clicked!')\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad)\n```\n\n因为 `onClickGood` 指定了 `this` 类型为 `void`，因此传递 `addClickListener` 是合法的。 当然了，这也意味着不能使用 `this.info`。 如果你两者都想要，你不得不使用箭头函数了：\n\n```typescript\nclass Handler {\n  type: string\n  onClickGood = (e: Event) => {\n    this.type = e.type \n  }\n}\n```\n\n这是可行的因为箭头函数不会捕获 `this`，所以你总是可以把它们传给期望 `this: void` 的函数。\n\n## 重载\n\nJavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n`pickCard` 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 `pickCard` 函数。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x: {suit: string; card: number }[]): number\nfunction pickCard(x: number): {suit: string; card: number }\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n这样改变后，重载的 `pickCard` 函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，`function pickCard(x): any` 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 `pickCard` 会产生错误。\n","slug":"TypeScript 学习第四章 TypeScript函数","published":1,"updated":"2019-08-17T11:06:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6q004tw72sk7pbzukw","content":"<h1><span id=\"函数\">函数</span></h1>\n<p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p>\n<h2><span id=\"基本示例\">基本示例</span></h2>\n<p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p>\n<p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addToZ</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y + z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"函数类型\">函数类型</span></h2>\n<h3><span id=\"为函数定义类型\">为函数定义类型</span></h3>\n<p>让我们为上面那个函数添加类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p>\n<h3><span id=\"书写完整函数类型\">书写完整函数类型</span></h3>\n<p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>\n<p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code> 而不能留空。</p>\n<p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。</p>\n<h3><span id=\"推断类型\">推断类型</span></h3>\n<p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p>\n<h2><span id=\"可选参数和默认参数\">可选参数和默认参数</span></h2>\n<p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>);  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>);         <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lastName)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>);  <span class=\"comment\">// 现在正常了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)  <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>可选参数必须跟在必须参数后面。 如果上例我们想让 <code>firstName</code> 是可选的，那么就必须调整它们的位置，把 <code>firstName</code> 放在后面。</p>\n<p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把<code>lastName</code> 的默认值设置为 <code>&quot;Smith&quot;</code>。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = 'Smith'</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// 返回 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"literal\">undefined</span>)     <span class=\"comment\">// 正常, 同样 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// 错误, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)        <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code> 是带默认值的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName = 'Will', lastName: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">\"Sr.\"</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)         <span class=\"comment\">// OK， 返回 \"Bob Adams\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"literal\">undefined</span>, <span class=\"string\">'Adams'</span>)     <span class=\"comment\">// OK，  返回 \"Will Adams\"</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"剩余参数\">剩余参数</span></h3>\n<p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p>\n<p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employeeName = buildName(<span class=\"string\">'Joseph'</span>, <span class=\"string\">'Samuel'</span>, <span class=\"string\">'Lucas'</span>, <span class=\"string\">'MacKinzie'</span>)</span><br></pre></td></tr></table></figure>\n<p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>\n<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fname: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">string</span>[]</span>) =&gt;</span> <span class=\"built_in\">string</span> = buildName</span><br></pre></td></tr></table></figure>\n<h2><span id=\"this\">this</span></h2>\n<p>学习如何在 JavaScript 里正确使用 <code>this</code> 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 <code>this</code> 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 <code>this</code> 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 <a href=\"http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\" target=\"_blank\" rel=\"noopener\">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda 的文章详细的阐述了 <code>this</code> 的内部工作原理，因此我们这里只做简单介绍。</p>\n<h3><span id=\"this-和箭头函数\">this 和箭头函数</span></h3>\n<p>JavaScript里，<code>this</code> 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>\n<p>下面看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>createCardPicker</code> 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 <code>createCardPicker</code> 返回的函数里的 <code>this</code> 被设置成了 <code>global</code> 而不是 <code>deck</code> 对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code> 视为 <code>global</code>。</p>\n<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的<code>deck</code> 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 <code>this</code> 值，而不是调用时的值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：这里使用箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"this-参数\">this 参数</span></h3>\n<p>在上述的例子中 <code>this.suits[pickedSuit]</code> 的类型为 <code>any</code>，这是因为 <code>this</code> 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code> 参数。 <code>this</code> 参数是个假的参数，它出现在参数列表的最前面：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保“this”在此独立函数中不可用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">  suit: <span class=\"built_in\">string</span></span><br><span class=\"line\">  card: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">  suits: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  cards: <span class=\"built_in\">number</span>[]</span><br><span class=\"line\"></span><br><span class=\"line\">  createCardPicker (<span class=\"keyword\">this</span>: Deck): <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> Card</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 函数现在显式指定其被调用方必须是 deck 类型</span></span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"keyword\">this</span>: Deck</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>现在 TypeScrip t知道 <code>createCardPicker</code> 期望在某个 <code>Deck</code> 对象上调用。也就是说 <code>this</code> 是 <code>Deck</code> 类型的，而非 <code>any</code>。</p>\n<h3><span id=\"this-参数在回调函数里\">this 参数在回调函数里</span></h3>\n<p>你可以也看到过在回调函数里的 <code>this</code> 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，<code>this</code> 将为 <code>undefined</code>。 稍做改动，你就可以通过 <code>this</code> 参数来避免错误。 首先，库函数的作者要指定 <code>this</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener(onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>this: void</code> 意味着 <code>addClickListener</code> 期望传入的 <code>onclick</code> 方法不需要 <code>this</code></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener (onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: Handler, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad) <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>指定了 <code>this</code> 类型后，你显式声明 <code>onClickBad</code> 必须在 <code>Handler</code> 的实例上调用。 然后 TypeScript 会检测到 <code>addClickListener</code> 要求函数带有 <code>this: void</code>。 改变 <code>this</code> 类型来修复这个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'clicked!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>onClickGood</code> 指定了 <code>this</code> 类型为 <code>void</code>，因此传递 <code>addClickListener</code> 是合法的。 当然了，这也意味着不能使用 <code>this.info</code>。 如果你两者都想要，你不得不使用箭头函数了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  onClickGood = <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是可行的因为箭头函数不会捕获 <code>this</code>，所以你总是可以把它们传给期望 <code>this: void</code> 的函数。</p>\n<h2><span id=\"重载\">重载</span></h2>\n<p>JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p><code>pickCard</code> 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p>\n<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: &#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span> &#125;[]</span>): <span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): </span>&#123;<span class=\"title\">suit</span>: <span class=\"title\">string</span></span>; card: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p>这样改变后，重载的 <code>pickCard</code> 函数在调用的时候会进行正确的类型检查。</p>\n<p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>\n<p>注意，<code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 <code>pickCard</code> 会产生错误。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>函数</h1>\n<p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p>\n<h2>基本示例</h2>\n<p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p>\n<p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addToZ</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y + z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>函数类型</h2>\n<h3>为函数定义类型</h3>\n<p>让我们为上面那个函数添加类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p>\n<h3>书写完整函数类型</h3>\n<p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>\n<p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code> 而不能留空。</p>\n<p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。</p>\n<h3>推断类型</h3>\n<p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p>\n<h2>可选参数和默认参数</h2>\n<p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>);  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>);         <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lastName)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>);  <span class=\"comment\">// 现在正常了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)  <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>可选参数必须跟在必须参数后面。 如果上例我们想让 <code>firstName</code> 是可选的，那么就必须调整它们的位置，把 <code>firstName</code> 放在后面。</p>\n<p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把<code>lastName</code> 的默认值设置为 <code>&quot;Smith&quot;</code>。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = 'Smith'</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// 返回 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"literal\">undefined</span>)     <span class=\"comment\">// 正常, 同样 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// 错误, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)        <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code> 是带默认值的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName = 'Will', lastName: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">\"Sr.\"</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)         <span class=\"comment\">// OK， 返回 \"Bob Adams\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"literal\">undefined</span>, <span class=\"string\">'Adams'</span>)     <span class=\"comment\">// OK，  返回 \"Will Adams\"</span></span><br></pre></td></tr></table></figure>\n<h3>剩余参数</h3>\n<p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p>\n<p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employeeName = buildName(<span class=\"string\">'Joseph'</span>, <span class=\"string\">'Samuel'</span>, <span class=\"string\">'Lucas'</span>, <span class=\"string\">'MacKinzie'</span>)</span><br></pre></td></tr></table></figure>\n<p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>\n<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fname: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">string</span>[]</span>) =&gt;</span> <span class=\"built_in\">string</span> = buildName</span><br></pre></td></tr></table></figure>\n<h2>this</h2>\n<p>学习如何在 JavaScript 里正确使用 <code>this</code> 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 <code>this</code> 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 <code>this</code> 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 <a href=\"http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\" target=\"_blank\" rel=\"noopener\">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda 的文章详细的阐述了 <code>this</code> 的内部工作原理，因此我们这里只做简单介绍。</p>\n<h3>this 和箭头函数</h3>\n<p>JavaScript里，<code>this</code> 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>\n<p>下面看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>createCardPicker</code> 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 <code>createCardPicker</code> 返回的函数里的 <code>this</code> 被设置成了 <code>global</code> 而不是 <code>deck</code> 对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code> 视为 <code>global</code>。</p>\n<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的<code>deck</code> 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 <code>this</code> 值，而不是调用时的值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：这里使用箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<h3>this 参数</h3>\n<p>在上述的例子中 <code>this.suits[pickedSuit]</code> 的类型为 <code>any</code>，这是因为 <code>this</code> 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code> 参数。 <code>this</code> 参数是个假的参数，它出现在参数列表的最前面：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保“this”在此独立函数中不可用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">  suit: <span class=\"built_in\">string</span></span><br><span class=\"line\">  card: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">  suits: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  cards: <span class=\"built_in\">number</span>[]</span><br><span class=\"line\"></span><br><span class=\"line\">  createCardPicker (<span class=\"keyword\">this</span>: Deck): <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> Card</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 函数现在显式指定其被调用方必须是 deck 类型</span></span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"keyword\">this</span>: Deck</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>现在 TypeScrip t知道 <code>createCardPicker</code> 期望在某个 <code>Deck</code> 对象上调用。也就是说 <code>this</code> 是 <code>Deck</code> 类型的，而非 <code>any</code>。</p>\n<h3>this 参数在回调函数里</h3>\n<p>你可以也看到过在回调函数里的 <code>this</code> 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，<code>this</code> 将为 <code>undefined</code>。 稍做改动，你就可以通过 <code>this</code> 参数来避免错误。 首先，库函数的作者要指定 <code>this</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener(onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>this: void</code> 意味着 <code>addClickListener</code> 期望传入的 <code>onclick</code> 方法不需要 <code>this</code></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener (onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: Handler, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad) <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>指定了 <code>this</code> 类型后，你显式声明 <code>onClickBad</code> 必须在 <code>Handler</code> 的实例上调用。 然后 TypeScript 会检测到 <code>addClickListener</code> 要求函数带有 <code>this: void</code>。 改变 <code>this</code> 类型来修复这个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'clicked!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>onClickGood</code> 指定了 <code>this</code> 类型为 <code>void</code>，因此传递 <code>addClickListener</code> 是合法的。 当然了，这也意味着不能使用 <code>this.info</code>。 如果你两者都想要，你不得不使用箭头函数了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  onClickGood = <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是可行的因为箭头函数不会捕获 <code>this</code>，所以你总是可以把它们传给期望 <code>this: void</code> 的函数。</p>\n<h2>重载</h2>\n<p>JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p><code>pickCard</code> 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p>\n<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: &#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span> &#125;[]</span>): <span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): </span>&#123;<span class=\"title\">suit</span>: <span class=\"title\">string</span></span>; card: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p>这样改变后，重载的 <code>pickCard</code> 函数在调用的时候会进行正确的类型检查。</p>\n<p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>\n<p>注意，<code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 <code>pickCard</code> 会产生错误。</p>\n"},{"title":"微信小程序开发技术选型分享","catalog":true,"url":"117.html","id":"117","date":"2019-02-21T04:28:11.000Z","subtitle":null,"header-img":null,"_content":"\n微信小程序开发技术分享:anchor:\n===================\n\n![](http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg)\n\n##### 目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。\n\n### 什么是Taro?\n\n多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。\n\n### 为什么要用Taro?\n\n当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.jpg)\n\n### Taro与其它框架进行对比\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png) ![image](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png)\n\n对比分析\n\n微信小程序\n\nmpuve\n\nwepy\n\nTaro\n\n语法规范\n\n小程序规范\n\nVue.js规范\n\n类Vue.js规范\n\nReact规范\n\n模板系统\n\n字符串模板\n\n字符串模板\n\n字符串模板\n\nJSX\n\n类型系统\n\n不支持\n\n业务代码\n\n业务代码\n\n业务代码 \\+ JSX\n\n组件规范\n\n小程序组件\n\nHTML标签+小程序组件\n\n小程序组件\n\n小程序组件\n\n样式规范\n\nwxss\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\n组件化\n\n小程序组件化\n\nVue组件化\n\n自定义组件化\n\nReact组件化\n\n多端复用\n\n复用，不存在的\n\nH5,APP(Weex)等\n\n没看到有介绍\n\nH5,APP(ReactNative)等\n\n自动构建\n\n无\n\nwebpack\n\n内部构建系统\n\nwebpack+内部构建系统\n\n开发要求\n\n全新学习\n\n熟悉Vue语法即可\n\n熟悉Vue+wepy语法\n\n熟悉React语法\n\n数据流管理\n\n无\n\nVuex\n\nRedux\n\nRedux+React-thunk\n\n> 从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。\n\n### Taro框架设计思想 [具体细节请看官网](https://nervjs.github.io/taro/)\n\n> 图片来源于网络 ![image](http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png)\n\n### Taro特性\n\n*   React 语法风格\n*   快速开发微信小程序\n    *   支持使用 npm/yarn 安装管理第三方依赖\n    *   支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置\n    *   支持使用 CSS 预编译器，例如 Sass 等\n    *   支持使用 Redux进行状态管理\n    *   小程序API优化，异步API Promise化等等\n*   支持多端开发转化\n\n> ### 开发配置\n\n*   环境配置\n    *   sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)\n    *   npm init lavectorApp && cd lavctorApp && npm run dev:weapp/h5\n    *   用微信开发者工具添加项目打开dist目录即可\n*   页面设计尺寸配置\n    *   Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改\n    *   Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位\n*   编辑器\n    *   建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网....\n\n> ### 如何引用fontAwesome字体文件\n\n比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 [查看](https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css) 如何使用： \\`\\`\\`javascript import Taro, { Component } from '@tarojs/taro'; import { View, Icon, Image } from '@tarojs/components'; import 'your/path/fontawesome.css' //引用图片 import img from 'your/path/image.png' export default class Icon extends Taro.Component { ...... render(){ <View className='icon_box'> <Icon className='fa fa-home'/> <Image src={img} /> </View> } } \\`\\`\\`\n\n> ### 页面配置\n\n    //是不是跟小程序入口配置文件差不多?\n    config = {\n    // pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n        pages: [\n          'pages/book/book',\n          'pages/detail/detail',\n          'pages/user/user',\n          'pages/index/index'\n        ],\n        window: {\n          backgroundTextStyle: 'light',\n          navigationBarBackgroundColor: '#f55002',\n          navigationBarTitleText: '首页',\n          navigationBarTextStyle: 'light',\n          enablePullDownRefresh: false,\n          onReachBottomDistance: 30,\n          backgroundColor: '#f55002'\n        },\n        tabBar: {\n          backgroundColor: '#eee',\n          selectedColor: '#f55002',\n          color: '#aaa',\n          borderStyle: '#f55002',\n          list: [\n            {\n              pagePath: 'pages/index/index',\n              iconPath: './static/images/home_default.png',\n              selectedIconPath: './static/images/home_selected.png',\n              text: '首页'\n            },\n            {\n              pagePath: 'pages/book/book',\n              iconPath: './static/images/book_default.png',\n              selectedIconPath: './static/images/book_selected.png',\n              text: '书架'\n            },\n            {\n              pagePath: 'pages/user/user',\n              text: '我的',\n              iconPath: './static/images/user_default.png',\n              selectedIconPath: './static/images/user_selected.png'\n            }\n          ]\n        },\n        networkTimeout: {\n          request: 6000,\n          downloadFile: 10000\n        },\n        debug: true\n      };\n    \n    \n\n> ### 消息机制\n> \n> > #### Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~\n\n    import Taro, {Events} from '@tarojs/taro'\n    const events = new Events()\n    // 监听一个事件，接受参数\n    events.on('eventName', (arg) => {\n      // doSth\n    })\n    // 监听同个事件，同时绑定多个handler\n    events.on('eventName', handler1)\n    events.on('eventName', handler2)\n    events.on('eventName', handler3)\n    // 触发一个事件，传参\n    events.trigger('eventName', arg)\n    // 触发事件，传入多个参数\n    events.trigger('eventName', arg1, arg2, ...)\n    // 取消监听一个事件\n    events.off('eventName')\n    // 取消监听一个事件某个handler\n    events.off('eventName', handler1)\n    // 取消监听所有事件\n    events.off()\n    \n\n同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例\n\n    import Taro from '@tarojs/taro'\n    \n    Taro.eventCenter.on\n    Taro.eventCenter.trigger\n    Taro.eventCenter.off\n    \n\n> ### :checkered_flag: 组件和页面的定义\n\n``javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { <!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--> backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ <!--DOM 只能写在render函数中--> const test = `test` return ( <!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--> <View className='lavectorApp' style='background:#fff'> <Text>hello Lavector<Text> <Text>{test}</Text> // Taro中所有的事件都要以On 开头 <Button onClick={this.toOtherPage.bind(this,'params')}>To Other Page</Button> </View> ); } }``\n\n> ### 配合使用Redux\n> \n> > ##### 在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件\n> > \n> > npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger\n\n    // src/store/index.js\n    import { createStore, applyMiddleware } from 'redux'\n    import thunkMiddleware from 'redux-thunk'\n    import { createLogger } from 'redux-logger'\n    import rootReducer from '../reducers'\n    \n    const middlewares = [\n      thunkMiddleware,\n      createLogger()\n    ]\n    \n    export default function configStore () {\n      const store = createStore(rootReducer, applyMiddleware(...middlewares))\n      return store\n    }\n    \n\n入口文件app.js\n\n    // src/app.js\n    import Taro, { Component } from '@tarojs/taro'\n    import { Provider } from '@tarojs/redux'\n    \n    import configStore from './store'\n    import Index from './pages/index'\n    \n    import './app.scss'\n    \n    const store = configStore()\n    \n    class App extends Component {\n      config = {\n        pages: [\n          'pages/index/index'\n        ],\n        window: {\n          navigationBarTitleText: 'Test'\n        }\n      }\n    \n      render() {\n        return (\n          <Provider store={store}>\n            <Index />\n          </Provider>\n        )\n      }\n    }\n    \n    Taro.render(<App />, document.getElementById('app'))\n    \n    \n\n> 然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)\n\n补充 JSX语法支持程度\n============\n\n*   不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）\n*   不能在包含 JSX 元素的 map 循环中使用 if 表达式\n*   不能使用 Array#map 之外的方法操作 JSX 数组\n*   不能在 JSX 参数中使用匿名函数\n*   暂不支持在 render() 之外的方法定义 JSX\n*   不允许在 JSX 参数(props)中传入 JSX 元素\n*   不能在 JSX 参数中使用对象展开符*   不支持无状态组件\n\n### 结束语\n\n无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。\n\n> 以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网[京东Taro](https://nervjs.github.io/taro/)\n\n### 可能你需要学习的：\n\n【Mpvue】(http://mpvue.com/) 【Mpvue资源合集】(https://github.com/mpvue/awesome-mpvue) 【Taro】(https://nervjs.github.io/taro/) 【Vuejs】(https://cn.vuejs.org/) 【Redux】(http://www.redux.org.cn/)","source":"_posts/微信小程序开发技术选型分享.md","raw":"---\ntitle: 微信小程序开发技术选型分享\ncatalog: true\nurl: 117.html\nid: 117\ncategories:\n  - 微信小程序\ndate: 2019-02-21 12:28:11\nsubtitle:\nheader-img:\ntags:\n---\n\n微信小程序开发技术分享:anchor:\n===================\n\n![](http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg)\n\n##### 目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。\n\n### 什么是Taro?\n\n多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。\n\n### 为什么要用Taro?\n\n当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.jpg)\n\n### Taro与其它框架进行对比\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png) ![image](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png)\n\n对比分析\n\n微信小程序\n\nmpuve\n\nwepy\n\nTaro\n\n语法规范\n\n小程序规范\n\nVue.js规范\n\n类Vue.js规范\n\nReact规范\n\n模板系统\n\n字符串模板\n\n字符串模板\n\n字符串模板\n\nJSX\n\n类型系统\n\n不支持\n\n业务代码\n\n业务代码\n\n业务代码 \\+ JSX\n\n组件规范\n\n小程序组件\n\nHTML标签+小程序组件\n\n小程序组件\n\n小程序组件\n\n样式规范\n\nwxss\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\n组件化\n\n小程序组件化\n\nVue组件化\n\n自定义组件化\n\nReact组件化\n\n多端复用\n\n复用，不存在的\n\nH5,APP(Weex)等\n\n没看到有介绍\n\nH5,APP(ReactNative)等\n\n自动构建\n\n无\n\nwebpack\n\n内部构建系统\n\nwebpack+内部构建系统\n\n开发要求\n\n全新学习\n\n熟悉Vue语法即可\n\n熟悉Vue+wepy语法\n\n熟悉React语法\n\n数据流管理\n\n无\n\nVuex\n\nRedux\n\nRedux+React-thunk\n\n> 从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。\n\n### Taro框架设计思想 [具体细节请看官网](https://nervjs.github.io/taro/)\n\n> 图片来源于网络 ![image](http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png)\n\n### Taro特性\n\n*   React 语法风格\n*   快速开发微信小程序\n    *   支持使用 npm/yarn 安装管理第三方依赖\n    *   支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置\n    *   支持使用 CSS 预编译器，例如 Sass 等\n    *   支持使用 Redux进行状态管理\n    *   小程序API优化，异步API Promise化等等\n*   支持多端开发转化\n\n> ### 开发配置\n\n*   环境配置\n    *   sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)\n    *   npm init lavectorApp && cd lavctorApp && npm run dev:weapp/h5\n    *   用微信开发者工具添加项目打开dist目录即可\n*   页面设计尺寸配置\n    *   Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改\n    *   Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位\n*   编辑器\n    *   建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网....\n\n> ### 如何引用fontAwesome字体文件\n\n比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 [查看](https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css) 如何使用： \\`\\`\\`javascript import Taro, { Component } from '@tarojs/taro'; import { View, Icon, Image } from '@tarojs/components'; import 'your/path/fontawesome.css' //引用图片 import img from 'your/path/image.png' export default class Icon extends Taro.Component { ...... render(){ <View className='icon_box'> <Icon className='fa fa-home'/> <Image src={img} /> </View> } } \\`\\`\\`\n\n> ### 页面配置\n\n    //是不是跟小程序入口配置文件差不多?\n    config = {\n    // pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n        pages: [\n          'pages/book/book',\n          'pages/detail/detail',\n          'pages/user/user',\n          'pages/index/index'\n        ],\n        window: {\n          backgroundTextStyle: 'light',\n          navigationBarBackgroundColor: '#f55002',\n          navigationBarTitleText: '首页',\n          navigationBarTextStyle: 'light',\n          enablePullDownRefresh: false,\n          onReachBottomDistance: 30,\n          backgroundColor: '#f55002'\n        },\n        tabBar: {\n          backgroundColor: '#eee',\n          selectedColor: '#f55002',\n          color: '#aaa',\n          borderStyle: '#f55002',\n          list: [\n            {\n              pagePath: 'pages/index/index',\n              iconPath: './static/images/home_default.png',\n              selectedIconPath: './static/images/home_selected.png',\n              text: '首页'\n            },\n            {\n              pagePath: 'pages/book/book',\n              iconPath: './static/images/book_default.png',\n              selectedIconPath: './static/images/book_selected.png',\n              text: '书架'\n            },\n            {\n              pagePath: 'pages/user/user',\n              text: '我的',\n              iconPath: './static/images/user_default.png',\n              selectedIconPath: './static/images/user_selected.png'\n            }\n          ]\n        },\n        networkTimeout: {\n          request: 6000,\n          downloadFile: 10000\n        },\n        debug: true\n      };\n    \n    \n\n> ### 消息机制\n> \n> > #### Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~\n\n    import Taro, {Events} from '@tarojs/taro'\n    const events = new Events()\n    // 监听一个事件，接受参数\n    events.on('eventName', (arg) => {\n      // doSth\n    })\n    // 监听同个事件，同时绑定多个handler\n    events.on('eventName', handler1)\n    events.on('eventName', handler2)\n    events.on('eventName', handler3)\n    // 触发一个事件，传参\n    events.trigger('eventName', arg)\n    // 触发事件，传入多个参数\n    events.trigger('eventName', arg1, arg2, ...)\n    // 取消监听一个事件\n    events.off('eventName')\n    // 取消监听一个事件某个handler\n    events.off('eventName', handler1)\n    // 取消监听所有事件\n    events.off()\n    \n\n同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例\n\n    import Taro from '@tarojs/taro'\n    \n    Taro.eventCenter.on\n    Taro.eventCenter.trigger\n    Taro.eventCenter.off\n    \n\n> ### :checkered_flag: 组件和页面的定义\n\n``javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { <!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--> backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ <!--DOM 只能写在render函数中--> const test = `test` return ( <!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--> <View className='lavectorApp' style='background:#fff'> <Text>hello Lavector<Text> <Text>{test}</Text> // Taro中所有的事件都要以On 开头 <Button onClick={this.toOtherPage.bind(this,'params')}>To Other Page</Button> </View> ); } }``\n\n> ### 配合使用Redux\n> \n> > ##### 在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件\n> > \n> > npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger\n\n    // src/store/index.js\n    import { createStore, applyMiddleware } from 'redux'\n    import thunkMiddleware from 'redux-thunk'\n    import { createLogger } from 'redux-logger'\n    import rootReducer from '../reducers'\n    \n    const middlewares = [\n      thunkMiddleware,\n      createLogger()\n    ]\n    \n    export default function configStore () {\n      const store = createStore(rootReducer, applyMiddleware(...middlewares))\n      return store\n    }\n    \n\n入口文件app.js\n\n    // src/app.js\n    import Taro, { Component } from '@tarojs/taro'\n    import { Provider } from '@tarojs/redux'\n    \n    import configStore from './store'\n    import Index from './pages/index'\n    \n    import './app.scss'\n    \n    const store = configStore()\n    \n    class App extends Component {\n      config = {\n        pages: [\n          'pages/index/index'\n        ],\n        window: {\n          navigationBarTitleText: 'Test'\n        }\n      }\n    \n      render() {\n        return (\n          <Provider store={store}>\n            <Index />\n          </Provider>\n        )\n      }\n    }\n    \n    Taro.render(<App />, document.getElementById('app'))\n    \n    \n\n> 然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)\n\n补充 JSX语法支持程度\n============\n\n*   不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）\n*   不能在包含 JSX 元素的 map 循环中使用 if 表达式\n*   不能使用 Array#map 之外的方法操作 JSX 数组\n*   不能在 JSX 参数中使用匿名函数\n*   暂不支持在 render() 之外的方法定义 JSX\n*   不允许在 JSX 参数(props)中传入 JSX 元素\n*   不能在 JSX 参数中使用对象展开符*   不支持无状态组件\n\n### 结束语\n\n无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。\n\n> 以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网[京东Taro](https://nervjs.github.io/taro/)\n\n### 可能你需要学习的：\n\n【Mpvue】(http://mpvue.com/) 【Mpvue资源合集】(https://github.com/mpvue/awesome-mpvue) 【Taro】(https://nervjs.github.io/taro/) 【Vuejs】(https://cn.vuejs.org/) 【Redux】(http://www.redux.org.cn/)","slug":"微信小程序开发技术选型分享","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6r004ww72s15skex84","content":"<h1><span id=\"微信小程序开发技术分享anchor\">微信小程序开发技术分享:anchor:</span></h1>\n<p><img src=\"http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg\" alt></p>\n<h5><span id=\"目前编写微信小程序的技术有如下微信开发者工具自带的一套开发技术基于腾讯的wepy框架美团的mpvue京东的taro这四个开发小程序技术目前是应用最为广泛的-今天最主要介绍的是来自京东凹凸团队的taro框架\">目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。</span></h5>\n<h3><span id=\"什么是taro\">什么是Taro?</span></h3>\n<p>多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。</p>\n<h3><span id=\"为什么要用taro\">为什么要用Taro?</span></h3>\n<p>当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.jpg\" alt></p>\n<h3><span id=\"taro与其它框架进行对比\">Taro与其它框架进行对比</span></h3>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png\" alt=\"image\"></p>\n<p>对比分析</p>\n<p>微信小程序</p>\n<p>mpuve</p>\n<p>wepy</p>\n<p>Taro</p>\n<p>语法规范</p>\n<p>小程序规范</p>\n<p>Vue.js规范</p>\n<p>类Vue.js规范</p>\n<p>React规范</p>\n<p>模板系统</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>JSX</p>\n<p>类型系统</p>\n<p>不支持</p>\n<p>业务代码</p>\n<p>业务代码</p>\n<p>业务代码 + JSX</p>\n<p>组件规范</p>\n<p>小程序组件</p>\n<p>HTML标签+小程序组件</p>\n<p>小程序组件</p>\n<p>小程序组件</p>\n<p>样式规范</p>\n<p>wxss</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>组件化</p>\n<p>小程序组件化</p>\n<p>Vue组件化</p>\n<p>自定义组件化</p>\n<p>React组件化</p>\n<p>多端复用</p>\n<p>复用，不存在的</p>\n<p>H5,APP(Weex)等</p>\n<p>没看到有介绍</p>\n<p>H5,APP(ReactNative)等</p>\n<p>自动构建</p>\n<p>无</p>\n<p>webpack</p>\n<p>内部构建系统</p>\n<p>webpack+内部构建系统</p>\n<p>开发要求</p>\n<p>全新学习</p>\n<p>熟悉Vue语法即可</p>\n<p>熟悉Vue+wepy语法</p>\n<p>熟悉React语法</p>\n<p>数据流管理</p>\n<p>无</p>\n<p>Vuex</p>\n<p>Redux</p>\n<p>Redux+React-thunk</p>\n<blockquote>\n<p>从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。</p>\n</blockquote>\n<h3><span id=\"taro框架设计思想-具体细节请看官网\">Taro框架设计思想 </span></h3>\n<blockquote>\n<p>图片来源于网络 <img src=\"http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png\" alt=\"image\"></p>\n</blockquote>\n<h3><span id=\"taro特性\">Taro特性</span></h3>\n<ul>\n<li>React 语法风格</li>\n<li>快速开发微信小程序\n<ul>\n<li>支持使用 npm/yarn 安装管理第三方依赖</li>\n<li>支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置</li>\n<li>支持使用 CSS 预编译器，例如 Sass 等</li>\n<li>支持使用 Redux进行状态管理</li>\n<li>小程序API优化，异步API Promise化等等</li>\n</ul>\n</li>\n<li>支持多端开发转化</li>\n</ul>\n<blockquote>\n<h3><span id=\"开发配置\">开发配置</span></h3>\n</blockquote>\n<ul>\n<li>环境配置\n<ul>\n<li>sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)</li>\n<li>npm init lavectorApp &amp;&amp; cd lavctorApp &amp;&amp; npm run dev:weapp/h5</li>\n<li>用微信开发者工具添加项目打开dist目录即可</li>\n</ul>\n</li>\n<li>页面设计尺寸配置\n<ul>\n<li>Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改</li>\n<li>Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位</li>\n</ul>\n</li>\n<li>编辑器\n<ul>\n<li>建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网…</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h3><span id=\"如何引用fontawesome字体文件\">如何引用fontAwesome字体文件</span></h3>\n</blockquote>\n<p>比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 <a href=\"https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css\" target=\"_blank\" rel=\"noopener\">查看</a> 如何使用： ```javascript import Taro, { Component } from ‘@tarojs/taro’; import { View, Icon, Image } from ‘@tarojs/components’; import ‘your/path/fontawesome.css’ //引用图片 import img from ‘your/path/image.png’ export default class Icon extends Taro.Component { … render(){ <view classname=\"icon_box\"> <icon classname=\"fa fa-home\"> <image src=\"{img}\"> </image></icon></view> } } ```</p>\n<blockquote>\n<h3><span id=\"页面配置\">页面配置</span></h3>\n</blockquote>\n<pre><code>//是不是跟小程序入口配置文件差不多?\nconfig = {\n// pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n    pages: [\n      'pages/book/book',\n      'pages/detail/detail',\n      'pages/user/user',\n      'pages/index/index'\n    ],\n    window: {\n      backgroundTextStyle: 'light',\n      navigationBarBackgroundColor: '#f55002',\n      navigationBarTitleText: '首页',\n      navigationBarTextStyle: 'light',\n      enablePullDownRefresh: false,\n      onReachBottomDistance: 30,\n      backgroundColor: '#f55002'\n    },\n    tabBar: {\n      backgroundColor: '#eee',\n      selectedColor: '#f55002',\n      color: '#aaa',\n      borderStyle: '#f55002',\n      list: [\n        {\n          pagePath: 'pages/index/index',\n          iconPath: './static/images/home_default.png',\n          selectedIconPath: './static/images/home_selected.png',\n          text: '首页'\n        },\n        {\n          pagePath: 'pages/book/book',\n          iconPath: './static/images/book_default.png',\n          selectedIconPath: './static/images/book_selected.png',\n          text: '书架'\n        },\n        {\n          pagePath: 'pages/user/user',\n          text: '我的',\n          iconPath: './static/images/user_default.png',\n          selectedIconPath: './static/images/user_selected.png'\n        }\n      ]\n    },\n    networkTimeout: {\n      request: 6000,\n      downloadFile: 10000\n    },\n    debug: true\n  };\n</code></pre>\n<blockquote>\n<h3><span id=\"消息机制\">消息机制</span></h3>\n<blockquote>\n<h4><span id=\"taro-提供了-taroevents-来实现消息机制使用时需要实例化它看完文档感觉跟vue的global-event-bus很像-可以用作非父子组件间的通讯应用场景看业务需求~\">Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~</span></h4>\n</blockquote>\n</blockquote>\n<pre><code>import Taro, {Events} from '@tarojs/taro'\nconst events = new Events()\n// 监听一个事件，接受参数\nevents.on('eventName', (arg) =&gt; {\n  // doSth\n})\n// 监听同个事件，同时绑定多个handler\nevents.on('eventName', handler1)\nevents.on('eventName', handler2)\nevents.on('eventName', handler3)\n// 触发一个事件，传参\nevents.trigger('eventName', arg)\n// 触发事件，传入多个参数\nevents.trigger('eventName', arg1, arg2, ...)\n// 取消监听一个事件\nevents.off('eventName')\n// 取消监听一个事件某个handler\nevents.off('eventName', handler1)\n// 取消监听所有事件\nevents.off()\n</code></pre>\n<p>同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例</p>\n<pre><code>import Taro from '@tarojs/taro'\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n</code></pre>\n<blockquote>\n<h3><span id=\"checkered_flag-组件和页面的定义\">:checkered_flag: 组件和页面的定义</span></h3>\n</blockquote>\n<p><code>javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { &lt;!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--&gt; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ &lt;!--DOM 只能写在render函数中--&gt; const test = `test` return ( &lt;!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--&gt; &lt;View className='lavectorApp' style='background:#fff'&gt; &lt;Text&gt;hello Lavector&lt;Text&gt; &lt;Text&gt;{test}&lt;/Text&gt; // Taro中所有的事件都要以On 开头 &lt;Button onClick={this.toOtherPage.bind(this,'params')}&gt;To Other Page&lt;/Button&gt; &lt;/View&gt; ); } }</code></p>\n<blockquote>\n<h3><span id=\"配合使用redux\">配合使用Redux</span></h3>\n<blockquote>\n<h5><span id=\"在-taro-中可以自由地使用-react-生态中非常流行的数据流管理工具-redux-来解决复杂项目的数据管理问题-而为了更方便地使用-redux-taro-提供了与-react-redux-api-几乎一致的包-tarojsredux-来让开发人员获得更加良好的开发体验-首先要安装-reduxtarojsredux和tarojsredux-h5以及一些需要用到的redux中间件\">在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件</span></h5>\n<p>npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger</p>\n</blockquote>\n</blockquote>\n<pre><code>// src/store/index.js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport rootReducer from '../reducers'\n\nconst middlewares = [\n  thunkMiddleware,\n  createLogger()\n]\n\nexport default function configStore () {\n  const store = createStore(rootReducer, applyMiddleware(...middlewares))\n  return store\n}\n</code></pre>\n<p>入口文件app.js</p>\n<pre><code>// src/app.js\nimport Taro, { Component } from '@tarojs/taro'\nimport { Provider } from '@tarojs/redux'\n\nimport configStore from './store'\nimport Index from './pages/index'\n\nimport './app.scss'\n\nconst store = configStore()\n\nclass App extends Component {\n  config = {\n    pages: [\n      'pages/index/index'\n    ],\n    window: {\n      navigationBarTitleText: 'Test'\n    }\n  }\n\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;Index /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n\nTaro.render(&lt;App /&gt;, document.getElementById('app'))\n</code></pre>\n<blockquote>\n<p>然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)</p>\n</blockquote>\n<h1><span id=\"补充-jsx语法支持程度\">补充 JSX语法支持程度</span></h1>\n<ul>\n<li>不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）</li>\n<li>不能在包含 JSX 元素的 map 循环中使用 if 表达式</li>\n<li>不能使用 Array#map 之外的方法操作 JSX 数组</li>\n<li>不能在 JSX 参数中使用匿名函数</li>\n<li>暂不支持在 render() 之外的方法定义 JSX</li>\n<li>不允许在 JSX 参数(props)中传入 JSX 元素</li>\n<li>不能在 JSX 参数中使用对象展开符*   不支持无状态组件</li>\n</ul>\n<h3><span id=\"结束语\">结束语</span></h3>\n<p>无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。</p>\n<blockquote>\n<p>以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">京东Taro</a></p>\n</blockquote>\n<h3><span id=\"可能你需要学习的\">可能你需要学习的：</span></h3>\n<p>【Mpvue】(<a href=\"http://mpvue.com/\" target=\"_blank\" rel=\"noopener\">http://mpvue.com/</a>) 【Mpvue资源合集】(<a href=\"https://github.com/mpvue/awesome-mpvue\" target=\"_blank\" rel=\"noopener\">https://github.com/mpvue/awesome-mpvue</a>) 【Taro】(<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">https://nervjs.github.io/taro/</a>) 【Vuejs】(<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/</a>) 【Redux】(<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.redux.org.cn/</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>微信小程序开发技术分享:anchor:</h1>\n<p><img src=\"http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg\" alt></p>\n<h5>目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。</h5>\n<h3>什么是Taro?</h3>\n<p>多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。</p>\n<h3>为什么要用Taro?</h3>\n<p>当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.jpg\" alt></p>\n<h3>Taro与其它框架进行对比</h3>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png\" alt=\"image\"></p>\n<p>对比分析</p>\n<p>微信小程序</p>\n<p>mpuve</p>\n<p>wepy</p>\n<p>Taro</p>\n<p>语法规范</p>\n<p>小程序规范</p>\n<p>Vue.js规范</p>\n<p>类Vue.js规范</p>\n<p>React规范</p>\n<p>模板系统</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>JSX</p>\n<p>类型系统</p>\n<p>不支持</p>\n<p>业务代码</p>\n<p>业务代码</p>\n<p>业务代码 + JSX</p>\n<p>组件规范</p>\n<p>小程序组件</p>\n<p>HTML标签+小程序组件</p>\n<p>小程序组件</p>\n<p>小程序组件</p>\n<p>样式规范</p>\n<p>wxss</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>组件化</p>\n<p>小程序组件化</p>\n<p>Vue组件化</p>\n<p>自定义组件化</p>\n<p>React组件化</p>\n<p>多端复用</p>\n<p>复用，不存在的</p>\n<p>H5,APP(Weex)等</p>\n<p>没看到有介绍</p>\n<p>H5,APP(ReactNative)等</p>\n<p>自动构建</p>\n<p>无</p>\n<p>webpack</p>\n<p>内部构建系统</p>\n<p>webpack+内部构建系统</p>\n<p>开发要求</p>\n<p>全新学习</p>\n<p>熟悉Vue语法即可</p>\n<p>熟悉Vue+wepy语法</p>\n<p>熟悉React语法</p>\n<p>数据流管理</p>\n<p>无</p>\n<p>Vuex</p>\n<p>Redux</p>\n<p>Redux+React-thunk</p>\n<blockquote>\n<p>从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。</p>\n</blockquote>\n<h3>Taro框架设计思想 <a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">具体细节请看官网</a></h3>\n<blockquote>\n<p>图片来源于网络 <img src=\"http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png\" alt=\"image\"></p>\n</blockquote>\n<h3>Taro特性</h3>\n<ul>\n<li>React 语法风格</li>\n<li>快速开发微信小程序\n<ul>\n<li>支持使用 npm/yarn 安装管理第三方依赖</li>\n<li>支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置</li>\n<li>支持使用 CSS 预编译器，例如 Sass 等</li>\n<li>支持使用 Redux进行状态管理</li>\n<li>小程序API优化，异步API Promise化等等</li>\n</ul>\n</li>\n<li>支持多端开发转化</li>\n</ul>\n<blockquote>\n<h3>开发配置</h3>\n</blockquote>\n<ul>\n<li>环境配置\n<ul>\n<li>sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)</li>\n<li>npm init lavectorApp &amp;&amp; cd lavctorApp &amp;&amp; npm run dev:weapp/h5</li>\n<li>用微信开发者工具添加项目打开dist目录即可</li>\n</ul>\n</li>\n<li>页面设计尺寸配置\n<ul>\n<li>Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改</li>\n<li>Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位</li>\n</ul>\n</li>\n<li>编辑器\n<ul>\n<li>建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网…</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h3>如何引用fontAwesome字体文件</h3>\n</blockquote>\n<p>比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 <a href=\"https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css\" target=\"_blank\" rel=\"noopener\">查看</a> 如何使用： ```javascript import Taro, { Component } from ‘@tarojs/taro’; import { View, Icon, Image } from ‘@tarojs/components’; import ‘your/path/fontawesome.css’ //引用图片 import img from ‘your/path/image.png’ export default class Icon extends Taro.Component { … render(){ <view classname=\"icon_box\"> <icon classname=\"fa fa-home\"> <image src=\"{img}\"> </image></icon></view> } } ```</p>\n<blockquote>\n<h3>页面配置</h3>\n</blockquote>\n<pre><code>//是不是跟小程序入口配置文件差不多?\nconfig = {\n// pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n    pages: [\n      'pages/book/book',\n      'pages/detail/detail',\n      'pages/user/user',\n      'pages/index/index'\n    ],\n    window: {\n      backgroundTextStyle: 'light',\n      navigationBarBackgroundColor: '#f55002',\n      navigationBarTitleText: '首页',\n      navigationBarTextStyle: 'light',\n      enablePullDownRefresh: false,\n      onReachBottomDistance: 30,\n      backgroundColor: '#f55002'\n    },\n    tabBar: {\n      backgroundColor: '#eee',\n      selectedColor: '#f55002',\n      color: '#aaa',\n      borderStyle: '#f55002',\n      list: [\n        {\n          pagePath: 'pages/index/index',\n          iconPath: './static/images/home_default.png',\n          selectedIconPath: './static/images/home_selected.png',\n          text: '首页'\n        },\n        {\n          pagePath: 'pages/book/book',\n          iconPath: './static/images/book_default.png',\n          selectedIconPath: './static/images/book_selected.png',\n          text: '书架'\n        },\n        {\n          pagePath: 'pages/user/user',\n          text: '我的',\n          iconPath: './static/images/user_default.png',\n          selectedIconPath: './static/images/user_selected.png'\n        }\n      ]\n    },\n    networkTimeout: {\n      request: 6000,\n      downloadFile: 10000\n    },\n    debug: true\n  };\n</code></pre>\n<blockquote>\n<h3>消息机制</h3>\n<blockquote>\n<h4>Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~</h4>\n</blockquote>\n</blockquote>\n<pre><code>import Taro, {Events} from '@tarojs/taro'\nconst events = new Events()\n// 监听一个事件，接受参数\nevents.on('eventName', (arg) =&gt; {\n  // doSth\n})\n// 监听同个事件，同时绑定多个handler\nevents.on('eventName', handler1)\nevents.on('eventName', handler2)\nevents.on('eventName', handler3)\n// 触发一个事件，传参\nevents.trigger('eventName', arg)\n// 触发事件，传入多个参数\nevents.trigger('eventName', arg1, arg2, ...)\n// 取消监听一个事件\nevents.off('eventName')\n// 取消监听一个事件某个handler\nevents.off('eventName', handler1)\n// 取消监听所有事件\nevents.off()\n</code></pre>\n<p>同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例</p>\n<pre><code>import Taro from '@tarojs/taro'\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n</code></pre>\n<blockquote>\n<h3>:checkered_flag: 组件和页面的定义</h3>\n</blockquote>\n<p><code>javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { &lt;!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--&gt; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ &lt;!--DOM 只能写在render函数中--&gt; const test = `test` return ( &lt;!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--&gt; &lt;View className='lavectorApp' style='background:#fff'&gt; &lt;Text&gt;hello Lavector&lt;Text&gt; &lt;Text&gt;{test}&lt;/Text&gt; // Taro中所有的事件都要以On 开头 &lt;Button onClick={this.toOtherPage.bind(this,'params')}&gt;To Other Page&lt;/Button&gt; &lt;/View&gt; ); } }</code></p>\n<blockquote>\n<h3>配合使用Redux</h3>\n<blockquote>\n<h5>在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件</h5>\n<p>npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger</p>\n</blockquote>\n</blockquote>\n<pre><code>// src/store/index.js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport rootReducer from '../reducers'\n\nconst middlewares = [\n  thunkMiddleware,\n  createLogger()\n]\n\nexport default function configStore () {\n  const store = createStore(rootReducer, applyMiddleware(...middlewares))\n  return store\n}\n</code></pre>\n<p>入口文件app.js</p>\n<pre><code>// src/app.js\nimport Taro, { Component } from '@tarojs/taro'\nimport { Provider } from '@tarojs/redux'\n\nimport configStore from './store'\nimport Index from './pages/index'\n\nimport './app.scss'\n\nconst store = configStore()\n\nclass App extends Component {\n  config = {\n    pages: [\n      'pages/index/index'\n    ],\n    window: {\n      navigationBarTitleText: 'Test'\n    }\n  }\n\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;Index /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n\nTaro.render(&lt;App /&gt;, document.getElementById('app'))\n</code></pre>\n<blockquote>\n<p>然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)</p>\n</blockquote>\n<h1>补充 JSX语法支持程度</h1>\n<ul>\n<li>不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）</li>\n<li>不能在包含 JSX 元素的 map 循环中使用 if 表达式</li>\n<li>不能使用 Array#map 之外的方法操作 JSX 数组</li>\n<li>不能在 JSX 参数中使用匿名函数</li>\n<li>暂不支持在 render() 之外的方法定义 JSX</li>\n<li>不允许在 JSX 参数(props)中传入 JSX 元素</li>\n<li>不能在 JSX 参数中使用对象展开符*   不支持无状态组件</li>\n</ul>\n<h3>结束语</h3>\n<p>无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。</p>\n<blockquote>\n<p>以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">京东Taro</a></p>\n</blockquote>\n<h3>可能你需要学习的：</h3>\n<p>【Mpvue】(<a href=\"http://mpvue.com/\" target=\"_blank\" rel=\"noopener\">http://mpvue.com/</a>) 【Mpvue资源合集】(<a href=\"https://github.com/mpvue/awesome-mpvue\" target=\"_blank\" rel=\"noopener\">https://github.com/mpvue/awesome-mpvue</a>) 【Taro】(<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">https://nervjs.github.io/taro/</a>) 【Vuejs】(<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/</a>) 【Redux】(<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.redux.org.cn/</a>)</p>\n"},{"title":"ThreeJS学习 第一章 创建一个场景","catalog":true,"date":"2019-08-05T08:37:05.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/item/201608/06/20160806232840_WZCjT.jpeg","_content":"\n#### 1.创建基本的页面结构\n\n> 从Threejs官网下载Three.js 到本地并且引入此文件。 [下载地址](https://threejs.org/build/three.js)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n  // TODO\n</script>\n</html>\n\n\n```\n\n#### 2. 创建一个简单的场景\n\n> 为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。\n\n```javascript\n   // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n\n```\n\n我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。\n\n第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。\n\n接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。\n\n接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。\n\n除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。\n\n如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。\n\n最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。\n\n#### 3. 创建一个立方体\n\n```javascript\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n\n```\n要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。\n\n接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。\n\n第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。\n\n默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n\n\n#### 4. 渲染创建的场景，使立方体动起来\n\n```javascript\n      // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n\n```\n\n现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。\n\n在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。\n\n#### 5.结果\n\n![结果图片](https://s2.ax1x.com/2019/08/05/e2WEXF.png)\n\n> 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n    // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1,)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n    // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n</script>\n</html>\n\n```","source":"_posts/第一章 TheeJS 创建场景.md","raw":"---\ntitle: ThreeJS学习 第一章 创建一个场景\ncatalog: true\ntags:\n  - HTML\n  - JavaScript\n  - Threejs\ncategories:\n  - ThreeJS\ndate: 2019-08-05 16:37:05\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/item/201608/06/20160806232840_WZCjT.jpeg\"\n---\n\n#### 1.创建基本的页面结构\n\n> 从Threejs官网下载Three.js 到本地并且引入此文件。 [下载地址](https://threejs.org/build/three.js)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n  // TODO\n</script>\n</html>\n\n\n```\n\n#### 2. 创建一个简单的场景\n\n> 为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。\n\n```javascript\n   // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n\n```\n\n我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。\n\n第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。\n\n接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。\n\n接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。\n\n除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。\n\n如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。\n\n最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。\n\n#### 3. 创建一个立方体\n\n```javascript\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n\n```\n要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。\n\n接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。\n\n第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。\n\n默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n\n\n#### 4. 渲染创建的场景，使立方体动起来\n\n```javascript\n      // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n\n```\n\n现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。\n\n在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。\n\n#### 5.结果\n\n![结果图片](https://s2.ax1x.com/2019/08/05/e2WEXF.png)\n\n> 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n    // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1,)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n    // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n</script>\n</html>\n\n```","slug":"第一章 TheeJS 创建场景","published":1,"updated":"2019-08-14T13:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r6s004zw72sc7degrou","content":"<h4><span id=\"1创建基本的页面结构\">1.创建基本的页面结构</span></h4>\n<blockquote>\n<p>从Threejs官网下载Three.js 到本地并且引入此文件。 <a href=\"https://threejs.org/build/three.js\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// TODO</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"2-创建一个简单的场景\">2. 创建一个简单的场景</span></h4>\n<blockquote>\n<p>为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个场景</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个相机</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个渲染器</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span><br><span class=\"line\"> <span class=\"comment\">// 设定渲染的区域</span></span><br><span class=\"line\"> renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span><br><span class=\"line\"> <span class=\"comment\">// 添加DOM</span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span><br></pre></td></tr></table></figure>\n<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</p>\n<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>\n<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>\n<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>\n<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>\n<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</canvas></p>\n<p>最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</canvas></p>\n<h4><span id=\"3-创建一个立方体\">3. 创建一个立方体</span></h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个几何体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个材质</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个网格和正方体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span><br><span class=\"line\"><span class=\"comment\">// 将建立的模型放入场景中</span></span><br><span class=\"line\">scene.add( cube )</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span><br><span class=\"line\">camera.position.z = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。</p>\n<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。</p>\n<p>第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>\n<p>默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>\n<h4><span id=\"4-渲染创建的场景使立方体动起来\">4. 渲染创建的场景，使立方体动起来</span></h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 渲染动画</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    requestAnimationFrame(animate)</span><br><span class=\"line\">    cube.rotation.x += <span class=\"number\">0.01</span></span><br><span class=\"line\">    cube.rotation.y += <span class=\"number\">0.01</span></span><br><span class=\"line\">    renderer.render(scene,camera)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用动画，渲染界面</span></span><br><span class=\"line\">animate()</span><br></pre></td></tr></table></figure>\n<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>\n<p>在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。</p>\n<h4><span id=\"5结果\">5.结果</span></h4>\n<p><img src=\"https://s2.ax1x.com/2019/08/05/e2WEXF.png\" alt=\"结果图片\"></p>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个场景</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个相机</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个渲染器</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 设定渲染的区域</span></span></span><br><span class=\"line\"><span class=\"javascript\">    renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 添加DOM</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个几何体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个材质</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个网格和正方体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将建立的模型放入场景中</span></span></span><br><span class=\"line\"><span class=\"undefined\">    scene.add( cube )</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span></span><br><span class=\"line\"><span class=\"undefined\">    camera.position.z = 5</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 渲染动画</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        requestAnimationFrame(animate)</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.x += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.y += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        renderer.render(scene,camera)</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用动画，渲染界面</span></span></span><br><span class=\"line\"><span class=\"undefined\">    animate()</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4>1.创建基本的页面结构</h4>\n<blockquote>\n<p>从Threejs官网下载Three.js 到本地并且引入此文件。 <a href=\"https://threejs.org/build/three.js\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// TODO</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4>2. 创建一个简单的场景</h4>\n<blockquote>\n<p>为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个场景</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个相机</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个渲染器</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span><br><span class=\"line\"> <span class=\"comment\">// 设定渲染的区域</span></span><br><span class=\"line\"> renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span><br><span class=\"line\"> <span class=\"comment\">// 添加DOM</span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span><br></pre></td></tr></table></figure>\n<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</p>\n<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>\n<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>\n<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>\n<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>\n<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</canvas></p>\n<p>最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</canvas></p>\n<h4>3. 创建一个立方体</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个几何体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个材质</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个网格和正方体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span><br><span class=\"line\"><span class=\"comment\">// 将建立的模型放入场景中</span></span><br><span class=\"line\">scene.add( cube )</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span><br><span class=\"line\">camera.position.z = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。</p>\n<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。</p>\n<p>第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>\n<p>默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>\n<h4>4. 渲染创建的场景，使立方体动起来</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 渲染动画</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    requestAnimationFrame(animate)</span><br><span class=\"line\">    cube.rotation.x += <span class=\"number\">0.01</span></span><br><span class=\"line\">    cube.rotation.y += <span class=\"number\">0.01</span></span><br><span class=\"line\">    renderer.render(scene,camera)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用动画，渲染界面</span></span><br><span class=\"line\">animate()</span><br></pre></td></tr></table></figure>\n<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>\n<p>在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。</p>\n<h4>5.结果</h4>\n<p><img src=\"https://s2.ax1x.com/2019/08/05/e2WEXF.png\" alt=\"结果图片\"></p>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个场景</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个相机</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个渲染器</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 设定渲染的区域</span></span></span><br><span class=\"line\"><span class=\"javascript\">    renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 添加DOM</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个几何体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个材质</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个网格和正方体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将建立的模型放入场景中</span></span></span><br><span class=\"line\"><span class=\"undefined\">    scene.add( cube )</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span></span><br><span class=\"line\"><span class=\"undefined\">    camera.position.z = 5</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 渲染动画</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        requestAnimationFrame(animate)</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.x += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.y += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        renderer.render(scene,camera)</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用动画，渲染界面</span></span></span><br><span class=\"line\"><span class=\"undefined\">    animate()</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"TypeScript 学习第六章 TypeScript 类Class","catalog":true,"date":"2019-08-19T09:39:02.000Z","subtitle":null,"header-img":"http://img-download.pchome.net/download/1k1/8w/2j/oixa3f-13nt.jpg@0e_0o_960w_600h_90q.src","_content":"\n# 类\n\n对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。\n\n## 基本示例\n\n下面看一个使用类的例子：\n\n```typescript\nclass Greeter {\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter = new Greeter('world')\n```\n\n如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 `Greeter` 类。这个类有 3 个成员：一个叫做 `greeting` 的属性，一个构造函数和一个 `greet` 方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了 `this`。 它表示我们访问的是类的成员。\n\n最后一行，我们使用 `new` 构造了 `Greeter` 类的一个实例。它会调用之前定义的构造函数，创建一个 `Greeter` 类型的新对象，并执行构造函数初始化它。\n\n## 继承\n\n在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\n```typescript\nclass Animal {\n  move(distance: number = 0) {\n    console.log(`Animal moved ${distance}m.`)\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log('Woof! Woof!')\n  }\n}\n\nconst dog = new Dog()\ndog.bark()\ndog.move(10)\n```\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，`Dog` 是一个 派生类，它派生自 `Animal` 基类，通过 `extends` 关键字。 派生类通常被称作*子类*，基类通常被称作*超类*。\n\n因为 `Dog` 继承了 `Animal` 的功能，因此我们可以创建一个 `Dog` 的实例，它能够 `bark()` 和 `move()`。\n\n下面我们来看个更加复杂的例子。\n\n```typescript\nclass Animal {\n  name: string\n  constructor(name: string) { \n    this.name = name\n  }\n  move(distance: number = 0) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) { \n    super(name)\n  }\n  move(distance: number = 5) {\n    console.log('Slithering...')\n    super.move(distance)\n  }\n}\n\nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 45) {\n    console.log('Galloping...')\n    super.move(distance)\n  }\n}\n\nlet sam = new Snake('Sammy')\nlet tom: Animal = new Horse('Tommy')\n\nsam.move()\ntom.move(34)\n```\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用 `extends` 关键字创建了 Animal的两个子类：`Horse` 和 `Snake`。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 `super()`，它会执行基类的构造函数。 而且，在构造函数里访问 `this` 的属性之前，我们 一定要调用 `super()`。 这个是 TypeScript 强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。`Snake`类和 `Horse` 类都创建了 `move` 方法，它们重写了从 `Animal` 继承来的 `move` 方法，使得 `move` 方法根据不同的类而具有不同的功能。注意，即使 `tom` 被声明为 `Animal` 类型，但因为它的值是 `Horse`，调用 `tom.move(34)` 时，它会调用 `Horse` 里重写的方法。\n\n```\nSlithering...\nSammy moved 5m.\nGalloping...\nTommy moved 34m.\n```\n\n## 公共，私有与受保护的修饰符\n\n### 默认为 public\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 `public` 来做修饰；例如，C# 要求必须明确地使用 `public` 指定成员是可见的。 在 TypeScript 里，成员都默认为 `public`。\n\n你也可以明确的将一个成员标记成 `public`。 我们可以用下面的方式来重写上面的 `Animal` 类：\n\n```typescript\nclass Animal {\n  public name: string\n  public constructor(name: string) {\n    this.name = name\n  }\n  public move(distance: number) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n```\n\n### 理解 private\n\n当成员被标记成 `private` 时，它就不能在声明它的类的外部访问。比如：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nnew Animal('Cat').name // 错误: 'name' 是私有的.\n```\n\nTypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有 `private` 或 `protected` 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 `private` 成员，那么只有当另外一个类型中也存在这样一个 `private` 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 `protected` 成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Rhino extends Animal {\n  constructor() { \n    super('Rhino')\n  }\n}\n\nclass Employee {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nlet animal = new Animal('Goat')\nlet rhino = new Rhino()\nlet employee = new Employee('Bob')\n\nanimal = rhino\nanimal = employee // 错误: Animal 与 Employee 不兼容.\n```\n\n这个例子中有 `Animal` 和 `Rhino` 两个类， `Rhino` 是 `Animal` 类的子类。 还有一个 `Employee` 类，其类型看上去与 `Animal` 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 `Animal` 和 `Rhino` 共享了来自 `Animal` 里的私有成员定义 `private name: string`，因此它们是兼容的。然而 `Employee` 却不是这样。当把 `Employee` 赋值给 `Animal` 的时候，得到一个错误，说它们的类型不兼容。尽管 `Employee` 里也有一个私有成员 `name`，但它明显不是 `Animal` 里面定义的那个。\n\n### 理解 protected\n\n`protected` 修饰符与 `private` 修饰符的行为很相似，但有一点不同，`protected`成员在派生类中仍然可以访问。例如：\n\n```typescript\nclass Person {\n  protected name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n  \n  getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nconsole.log(howard.getElevatorPitch())\nconsole.log(howard.name) // error\n```\n\n注意，我们不能在 `Person` 类外使用 `name`，但是我们仍然可以通过 `Employee` 类的实例方法访问，因为 `Employee` 是由 `Person`  派生而来的。\n\n构造函数也可以被标记成 `protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：\n\n```typescript\nclass Person {\n  protected name: string\n  protected constructor(name: string) {\n    this.name = name\n  }\n}\n\n// Employee 能够继承 Person\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nlet john = new Person('John') // 错误: 'Person' 的构造函数是被保护的.\n```\n\n## readonly 修饰符\n\n你可以使用 `readonly` 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\n```typescript\nclass Person {\n  readonly name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet john = new Person('John')\njohn.name = 'peter'\n```\n\n### 参数属性\n\n在上面的例子中，我们必须在 `Person` 类里定义一个只读成员 `name` 和一个参数为 `name` 的构造函数，并且立刻将 `name` 的值赋给 `this.name`，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 `Person` 类的修改版，使用了参数属性：\n\n```typescript\nclass Person {\n  constructor(readonly name: string) {\n  }\n}\n```\n\n注意看我们是如何舍弃参数 `name`，仅在构造函数里使用 `readonly name: string` 参数来创建和初始化 `name` 成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 `private` 限定一个参数属性会声明并初始化一个私有成员；对于 `public` 和 `protected` 来说也是一样。\n\n## 存取器\n\n`TypeScript` 支持通过 `getters/setters` 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用 `get` 和 `set`。 首先，我们从一个没有使用存取器的例子开始。\n\n```typescript\nclass Employee {\n  fullName: string\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以设置 `fullName`，因为它是 `public` 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。\n\n下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 `fullName` 的直接访问改成了可以检查密码的 `set` 方法。 我们也加了一个 `get` 方法，让上面的例子仍然可以工作。\n\n```typescript\nlet passcode = 'secret passcode'\n\nclass Employee {\n  private _fullName: string\n\n  get fullName(): string {\n    return this._fullName\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == 'secret passcode') {\n      this._fullName = newName\n    }\n    else {\n      console.log('Error: Unauthorized update of employee!')\n    }\n  }\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`。这在从代码生成 `.d.ts` 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n## 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 `static` 定义 `origin`，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 `origin` 前面加上类名。 如同在实例属性上使用 `this.xxx` 来访问属性一样，这里我们使用 `Grid.xxx` 来访问静态属性。\n\n```typescript\nclass Grid {\n  static origin = {x: 0, y: 0}\n\n  scale: number\n\n  constructor (scale: number) {\n    this.scale = scale\n  }\n\n  calculateDistanceFromOrigin(point: {x: number; y: number}) {\n    let xDist = point.x - Grid.origin.x\n    let yDist = point.y - Grid.origin.y\n    return Math.sqrt(xDist * xDist + yDist * yDist) * this.scale\n  }\n}\n\nlet grid1 = new Grid(1.0)  // 1x scale\nlet grid2 = new Grid(5.0)  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 3, y: 4}))\nconsole.log(grid2.calculateDistanceFromOrigin({x: 3, y: 4}))\n```\n\n## 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 `abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\n```typescript\nabstract class Animal {\n  abstract makeSound(): void\n  move(): void {\n    console.log('roaming the earth...')\n  }\n}\n```\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 `abstract` 关键字并且可以包含访问修饰符。\n\n```typescript\nabstract class Department {\n  name: string\n\n  constructor(name: string) {\n     this.name = name\n  }\n\n  printName(): void {\n    console.log('Department name: ' + this.name)\n  }\n\n  abstract printMeeting(): void // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n  constructor() {\n    super('Accounting and Auditing') // 在派生类的构造函数中必须调用 super()\n  }\n\n  printMeeting(): void {\n    console.log('The Accounting Department meets each Monday at 10am.')\n  }\n\n  generateReports(): void {\n    console.log('Generating accounting reports...')\n  }\n}\n\nlet department: Department // 允许创建一个对抽象类型的引用\ndepartment = new Department() // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName()\ndepartment.printMeeting()\ndepartment.generateReports() // 错误: 方法在声明的抽象类中不存在\n```\n\n## 高级技巧\n\n### 构造函数\n\n当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的*实例*的类型。\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter('world')\nconsole.log(greeter.greet())\n```\n\n这里，我们写了 `let greeter: Greeter`，意思是 `Greeter` 类的实例的类型是 `Greeter`。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做*构造函数的值*。 这个函数会在我们使用 `new` 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：\n\n```javascript\nvar Greeter = /** @class */ (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n  Greeter.prototype.greet = function () {\n    return 'Hello, ' + this.greeting;\n  };\n  Greeter.standardGreeting = 'Hello, there';\n  return Greeter;\n}());\nvar greeter;\ngreeter = new Greeter('world');\nconsole.log(greeter.greet());\n```\n\n上面的代码里，`var Greeter` 将被构造函数赋值。 当我们调用 `new` 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有*实例部分*与*静态部分*这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  \n  greeting: string\n\n  constructor(message?: string) {\n    this.greeting = message\n  }\n\n  greet() {\n    if (this.greeting) {\n      return 'Hello, ' + this.greeting\n    } else {\n      return Greeter.standardGreeting\n    }\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter()\nconsole.log(greeter.greet())\n\nlet greeterMaker: typeof Greeter = Greeter\ngreeterMaker.standardGreeting = 'Hey there'\n\nlet greeter2: Greeter = new greeterMaker()\nconsole.log(greeter2.greet())\n```\n\n这个例子里， `greeter1` 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做 `greeterMaker` 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 `typeof Greeter`，意思是取 `Greeter` 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 `Greeter` 标识符的类型\"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 `greeterMaker` 上使用 `new`，创建 `Greeter` 的实例。\n\n### 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\n```typescript\nclass Point {\n  x: number\n  y: number\n}\n\ninterface Point3d extends Point {\n  z: number\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3}\n```\n\n\n","source":"_posts/TypeScript 学习第六章 TypeScript类.md","raw":"---\ntitle: TypeScript 学习第六章 TypeScript 类Class\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-19 17:39:02\nsubtitle:\nheader-img: \"http://img-download.pchome.net/download/1k1/8w/2j/oixa3f-13nt.jpg@0e_0o_960w_600h_90q.src\"\n---\n\n# 类\n\n对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。\n\n## 基本示例\n\n下面看一个使用类的例子：\n\n```typescript\nclass Greeter {\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter = new Greeter('world')\n```\n\n如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 `Greeter` 类。这个类有 3 个成员：一个叫做 `greeting` 的属性，一个构造函数和一个 `greet` 方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了 `this`。 它表示我们访问的是类的成员。\n\n最后一行，我们使用 `new` 构造了 `Greeter` 类的一个实例。它会调用之前定义的构造函数，创建一个 `Greeter` 类型的新对象，并执行构造函数初始化它。\n\n## 继承\n\n在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\n```typescript\nclass Animal {\n  move(distance: number = 0) {\n    console.log(`Animal moved ${distance}m.`)\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log('Woof! Woof!')\n  }\n}\n\nconst dog = new Dog()\ndog.bark()\ndog.move(10)\n```\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，`Dog` 是一个 派生类，它派生自 `Animal` 基类，通过 `extends` 关键字。 派生类通常被称作*子类*，基类通常被称作*超类*。\n\n因为 `Dog` 继承了 `Animal` 的功能，因此我们可以创建一个 `Dog` 的实例，它能够 `bark()` 和 `move()`。\n\n下面我们来看个更加复杂的例子。\n\n```typescript\nclass Animal {\n  name: string\n  constructor(name: string) { \n    this.name = name\n  }\n  move(distance: number = 0) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) { \n    super(name)\n  }\n  move(distance: number = 5) {\n    console.log('Slithering...')\n    super.move(distance)\n  }\n}\n\nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 45) {\n    console.log('Galloping...')\n    super.move(distance)\n  }\n}\n\nlet sam = new Snake('Sammy')\nlet tom: Animal = new Horse('Tommy')\n\nsam.move()\ntom.move(34)\n```\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用 `extends` 关键字创建了 Animal的两个子类：`Horse` 和 `Snake`。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 `super()`，它会执行基类的构造函数。 而且，在构造函数里访问 `this` 的属性之前，我们 一定要调用 `super()`。 这个是 TypeScript 强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。`Snake`类和 `Horse` 类都创建了 `move` 方法，它们重写了从 `Animal` 继承来的 `move` 方法，使得 `move` 方法根据不同的类而具有不同的功能。注意，即使 `tom` 被声明为 `Animal` 类型，但因为它的值是 `Horse`，调用 `tom.move(34)` 时，它会调用 `Horse` 里重写的方法。\n\n```\nSlithering...\nSammy moved 5m.\nGalloping...\nTommy moved 34m.\n```\n\n## 公共，私有与受保护的修饰符\n\n### 默认为 public\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 `public` 来做修饰；例如，C# 要求必须明确地使用 `public` 指定成员是可见的。 在 TypeScript 里，成员都默认为 `public`。\n\n你也可以明确的将一个成员标记成 `public`。 我们可以用下面的方式来重写上面的 `Animal` 类：\n\n```typescript\nclass Animal {\n  public name: string\n  public constructor(name: string) {\n    this.name = name\n  }\n  public move(distance: number) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n```\n\n### 理解 private\n\n当成员被标记成 `private` 时，它就不能在声明它的类的外部访问。比如：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nnew Animal('Cat').name // 错误: 'name' 是私有的.\n```\n\nTypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有 `private` 或 `protected` 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 `private` 成员，那么只有当另外一个类型中也存在这样一个 `private` 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 `protected` 成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Rhino extends Animal {\n  constructor() { \n    super('Rhino')\n  }\n}\n\nclass Employee {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nlet animal = new Animal('Goat')\nlet rhino = new Rhino()\nlet employee = new Employee('Bob')\n\nanimal = rhino\nanimal = employee // 错误: Animal 与 Employee 不兼容.\n```\n\n这个例子中有 `Animal` 和 `Rhino` 两个类， `Rhino` 是 `Animal` 类的子类。 还有一个 `Employee` 类，其类型看上去与 `Animal` 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 `Animal` 和 `Rhino` 共享了来自 `Animal` 里的私有成员定义 `private name: string`，因此它们是兼容的。然而 `Employee` 却不是这样。当把 `Employee` 赋值给 `Animal` 的时候，得到一个错误，说它们的类型不兼容。尽管 `Employee` 里也有一个私有成员 `name`，但它明显不是 `Animal` 里面定义的那个。\n\n### 理解 protected\n\n`protected` 修饰符与 `private` 修饰符的行为很相似，但有一点不同，`protected`成员在派生类中仍然可以访问。例如：\n\n```typescript\nclass Person {\n  protected name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n  \n  getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nconsole.log(howard.getElevatorPitch())\nconsole.log(howard.name) // error\n```\n\n注意，我们不能在 `Person` 类外使用 `name`，但是我们仍然可以通过 `Employee` 类的实例方法访问，因为 `Employee` 是由 `Person`  派生而来的。\n\n构造函数也可以被标记成 `protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：\n\n```typescript\nclass Person {\n  protected name: string\n  protected constructor(name: string) {\n    this.name = name\n  }\n}\n\n// Employee 能够继承 Person\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nlet john = new Person('John') // 错误: 'Person' 的构造函数是被保护的.\n```\n\n## readonly 修饰符\n\n你可以使用 `readonly` 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\n```typescript\nclass Person {\n  readonly name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet john = new Person('John')\njohn.name = 'peter'\n```\n\n### 参数属性\n\n在上面的例子中，我们必须在 `Person` 类里定义一个只读成员 `name` 和一个参数为 `name` 的构造函数，并且立刻将 `name` 的值赋给 `this.name`，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 `Person` 类的修改版，使用了参数属性：\n\n```typescript\nclass Person {\n  constructor(readonly name: string) {\n  }\n}\n```\n\n注意看我们是如何舍弃参数 `name`，仅在构造函数里使用 `readonly name: string` 参数来创建和初始化 `name` 成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 `private` 限定一个参数属性会声明并初始化一个私有成员；对于 `public` 和 `protected` 来说也是一样。\n\n## 存取器\n\n`TypeScript` 支持通过 `getters/setters` 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用 `get` 和 `set`。 首先，我们从一个没有使用存取器的例子开始。\n\n```typescript\nclass Employee {\n  fullName: string\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以设置 `fullName`，因为它是 `public` 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。\n\n下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 `fullName` 的直接访问改成了可以检查密码的 `set` 方法。 我们也加了一个 `get` 方法，让上面的例子仍然可以工作。\n\n```typescript\nlet passcode = 'secret passcode'\n\nclass Employee {\n  private _fullName: string\n\n  get fullName(): string {\n    return this._fullName\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == 'secret passcode') {\n      this._fullName = newName\n    }\n    else {\n      console.log('Error: Unauthorized update of employee!')\n    }\n  }\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`。这在从代码生成 `.d.ts` 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n## 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 `static` 定义 `origin`，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 `origin` 前面加上类名。 如同在实例属性上使用 `this.xxx` 来访问属性一样，这里我们使用 `Grid.xxx` 来访问静态属性。\n\n```typescript\nclass Grid {\n  static origin = {x: 0, y: 0}\n\n  scale: number\n\n  constructor (scale: number) {\n    this.scale = scale\n  }\n\n  calculateDistanceFromOrigin(point: {x: number; y: number}) {\n    let xDist = point.x - Grid.origin.x\n    let yDist = point.y - Grid.origin.y\n    return Math.sqrt(xDist * xDist + yDist * yDist) * this.scale\n  }\n}\n\nlet grid1 = new Grid(1.0)  // 1x scale\nlet grid2 = new Grid(5.0)  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 3, y: 4}))\nconsole.log(grid2.calculateDistanceFromOrigin({x: 3, y: 4}))\n```\n\n## 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 `abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\n```typescript\nabstract class Animal {\n  abstract makeSound(): void\n  move(): void {\n    console.log('roaming the earth...')\n  }\n}\n```\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 `abstract` 关键字并且可以包含访问修饰符。\n\n```typescript\nabstract class Department {\n  name: string\n\n  constructor(name: string) {\n     this.name = name\n  }\n\n  printName(): void {\n    console.log('Department name: ' + this.name)\n  }\n\n  abstract printMeeting(): void // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n  constructor() {\n    super('Accounting and Auditing') // 在派生类的构造函数中必须调用 super()\n  }\n\n  printMeeting(): void {\n    console.log('The Accounting Department meets each Monday at 10am.')\n  }\n\n  generateReports(): void {\n    console.log('Generating accounting reports...')\n  }\n}\n\nlet department: Department // 允许创建一个对抽象类型的引用\ndepartment = new Department() // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName()\ndepartment.printMeeting()\ndepartment.generateReports() // 错误: 方法在声明的抽象类中不存在\n```\n\n## 高级技巧\n\n### 构造函数\n\n当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的*实例*的类型。\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter('world')\nconsole.log(greeter.greet())\n```\n\n这里，我们写了 `let greeter: Greeter`，意思是 `Greeter` 类的实例的类型是 `Greeter`。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做*构造函数的值*。 这个函数会在我们使用 `new` 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：\n\n```javascript\nvar Greeter = /** @class */ (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n  Greeter.prototype.greet = function () {\n    return 'Hello, ' + this.greeting;\n  };\n  Greeter.standardGreeting = 'Hello, there';\n  return Greeter;\n}());\nvar greeter;\ngreeter = new Greeter('world');\nconsole.log(greeter.greet());\n```\n\n上面的代码里，`var Greeter` 将被构造函数赋值。 当我们调用 `new` 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有*实例部分*与*静态部分*这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  \n  greeting: string\n\n  constructor(message?: string) {\n    this.greeting = message\n  }\n\n  greet() {\n    if (this.greeting) {\n      return 'Hello, ' + this.greeting\n    } else {\n      return Greeter.standardGreeting\n    }\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter()\nconsole.log(greeter.greet())\n\nlet greeterMaker: typeof Greeter = Greeter\ngreeterMaker.standardGreeting = 'Hey there'\n\nlet greeter2: Greeter = new greeterMaker()\nconsole.log(greeter2.greet())\n```\n\n这个例子里， `greeter1` 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做 `greeterMaker` 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 `typeof Greeter`，意思是取 `Greeter` 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 `Greeter` 标识符的类型\"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 `greeterMaker` 上使用 `new`，创建 `Greeter` 的实例。\n\n### 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\n```typescript\nclass Point {\n  x: number\n  y: number\n}\n\ninterface Point3d extends Point {\n  z: number\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3}\n```\n\n\n","slug":"TypeScript 学习第六章 TypeScript类","published":1,"updated":"2019-08-17T11:10:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r73005hw72skl54490w","content":"<h1><span id=\"类\">类</span></h1>\n<p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p>\n<h2><span id=\"基本示例\">基本示例</span></h2>\n<p>下面看一个使用类的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 <code>Greeter</code> 类。这个类有 3 个成员：一个叫做 <code>greeting</code> 的属性，一个构造函数和一个 <code>greet</code> 方法。</p>\n<p>你会注意到，我们在引用任何一个类成员的时候都用了 <code>this</code>。 它表示我们访问的是类的成员。</p>\n<p>最后一行，我们使用 <code>new</code> 构造了 <code>Greeter</code> 类的一个实例。它会调用之前定义的构造函数，创建一个 <code>Greeter</code> 类型的新对象，并执行构造函数初始化它。</p>\n<h2><span id=\"继承\">继承</span></h2>\n<p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Animal moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  bark() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Woof! Woof!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog = <span class=\"keyword\">new</span> Dog()</span><br><span class=\"line\">dog.bark()</span><br><span class=\"line\">dog.move(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p>\n<p>因为 <code>Dog</code> 继承了 <code>Animal</code> 的功能，因此我们可以创建一个 <code>Dog</code> 的实例，它能够 <code>bark()</code> 和 <code>move()</code>。</p>\n<p>下面我们来看个更加复杂的例子。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Snake <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Slithering...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Horse <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Galloping...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">'Sammy'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">'Tommy'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move()</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 <code>extends</code> 关键字创建了 Animal的两个子类：<code>Horse</code> 和 <code>Snake</code>。</p>\n<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code> 的属性之前，我们 一定要调用 <code>super()</code>。 这个是 TypeScript 强制执行的一条重要规则。</p>\n<p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和 <code>Horse</code> 类都创建了 <code>move</code> 方法，它们重写了从 <code>Animal</code> 继承来的 <code>move</code> 方法，使得 <code>move</code> 方法根据不同的类而具有不同的功能。注意，即使 <code>tom</code> 被声明为 <code>Animal</code> 类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code> 时，它会调用 <code>Horse</code> 里重写的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slithering...</span><br><span class=\"line\">Sammy moved 5m.</span><br><span class=\"line\">Galloping...</span><br><span class=\"line\">Tommy moved 34m.</span><br></pre></td></tr></table></figure>\n<h2><span id=\"公共私有与受保护的修饰符\">公共，私有与受保护的修饰符</span></h2>\n<h3><span id=\"默认为-public\">默认为 public</span></h3>\n<p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p>\n<p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> move(distance: <span class=\"built_in\">number</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"理解-private\">理解 private</span></h3>\n<p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal(<span class=\"string\">'Cat'</span>).name <span class=\"comment\">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>\n<p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code> 成员也使用这个规则。</p>\n<p>下面来看一个例子，更好地说明了这一点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Rhino <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Rhino'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'Goat'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino()</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Bob'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino</span><br><span class=\"line\">animal = employee <span class=\"comment\">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure>\n<p>这个例子中有 <code>Animal</code> 和 <code>Rhino</code> 两个类， <code>Rhino</code> 是 <code>Animal</code> 类的子类。 还有一个 <code>Employee</code> 类，其类型看上去与 <code>Animal</code> 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code> 和 <code>Rhino</code> 共享了来自 <code>Animal</code> 里的私有成员定义 <code>private name: string</code>，因此它们是兼容的。然而 <code>Employee</code> 却不是这样。当把 <code>Employee</code> 赋值给 <code>Animal</code> 的时候，得到一个错误，说它们的类型不兼容。尽管 <code>Employee</code> 里也有一个私有成员 <code>name</code>，但它明显不是 <code>Animal</code> 里面定义的那个。</p>\n<h3><span id=\"理解-protected\">理解 protected</span></h3>\n<p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch())</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.name) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>注意，我们不能在 <code>Person</code> 类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code> 类的实例方法访问，因为 <code>Employee</code> 是由 <code>Person</code>  派生而来的。</p>\n<p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Employee 能够继承 Person</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>) <span class=\"comment\">// 错误: 'Person' 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"readonly-修饰符\">readonly 修饰符</span></h2>\n<p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  readonly name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>)</span><br><span class=\"line\">john.name = <span class=\"string\">'peter'</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"参数属性\">参数属性</span></h3>\n<p>在上面的例子中，我们必须在 <code>Person</code> 类里定义一个只读成员 <code>name</code> 和一个参数为 <code>name</code> 的构造函数，并且立刻将 <code>name</code> 的值赋给 <code>this.name</code>，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Person</code> 类的修改版，使用了参数属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">readonly name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意看我们是如何舍弃参数 <code>name</code>，仅在构造函数里使用 <code>readonly name: string</code> 参数来创建和初始化 <code>name</code> 成员。 我们把声明和赋值合并至一处。</p>\n<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</p>\n<h2><span id=\"存取器\">存取器</span></h2>\n<p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>\n<p>下面来看如何把一个简单的类改写成使用 <code>get</code> 和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以设置 <code>fullName</code>，因为它是 <code>public</code> 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。</p>\n<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 <code>fullName</code> 的直接访问改成了可以检查密码的 <code>set</code> 方法。 我们也加了一个 <code>get</code> 方法，让上面的例子仍然可以工作。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">'secret passcode'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> fullName(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._fullName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> fullName(newName: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode == <span class=\"string\">'secret passcode'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._fullName = newName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Error: Unauthorized update of employee!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>\n<p>对于存取器有下面几点需要注意的：</p>\n<p>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>\n<h2><span id=\"静态属性\">静态属性</span></h2>\n<p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code> 定义 <code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code> 前面加上类名。 如同在实例属性上使用 <code>this.xxx</code> 来访问属性一样，这里我们使用 <code>Grid.xxx</code> 来访问静态属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Grid &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> origin = &#123;x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  scale: <span class=\"built_in\">number</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">scale: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scale = scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  calculateDistanceFromOrigin(point: &#123;x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xDist = point.x - Grid.origin.x</span><br><span class=\"line\">    <span class=\"keyword\">let</span> yDist = point.y - Grid.origin.y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) * <span class=\"keyword\">this</span>.scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">1.0</span>)  <span class=\"comment\">// 1x scale</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid2 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">5.0</span>)  <span class=\"comment\">// 5x scale</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"抽象类\">抽象类</span></h2>\n<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> makeSound(): <span class=\"built_in\">void</span></span><br><span class=\"line\">  move(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'roaming the earth...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Department &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printName(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Department name: '</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> printMeeting(): <span class=\"built_in\">void</span> <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> AccountingDepartment <span class=\"keyword\">extends</span> Department &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Accounting and Auditing'</span>) <span class=\"comment\">// 在派生类的构造函数中必须调用 super()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printMeeting(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The Accounting Department meets each Monday at 10am.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  generateReports(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Generating accounting reports...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department <span class=\"comment\">// 允许创建一个对抽象类型的引用</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> Department() <span class=\"comment\">// 错误: 不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment() <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName()</span><br><span class=\"line\">department.printMeeting()</span><br><span class=\"line\">department.generateReports() <span class=\"comment\">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"高级技巧\">高级技巧</span></h2>\n<h3><span id=\"构造函数\">构造函数</span></h3>\n<p>当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的<em>实例</em>的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure>\n<p>这里，我们写了 <code>let greeter: Greeter</code>，意思是 <code>Greeter</code> 类的实例的类型是 <code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>\n<p>我们也创建了一个叫做<em>构造函数的值</em>。 这个函数会在我们使用 <code>new</code> 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Greeter = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeter</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Greeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Greeter.standardGreeting = <span class=\"string\">'Hello, there'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Greeter;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n<p>上面的代码里，<code>var Greeter</code> 将被构造函数赋值。 当我们调用 <code>new</code> 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p>\n<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.greeting) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Greeter.standardGreeting</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeterMaker: <span class=\"keyword\">typeof</span> Greeter = Greeter</span><br><span class=\"line\">greeterMaker.standardGreeting = <span class=\"string\">'Hey there'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter2: Greeter = <span class=\"keyword\">new</span> greeterMaker()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter2.greet())</span><br></pre></td></tr></table></figure>\n<p>这个例子里， <code>greeter1</code> 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p>\n<p>再之后，我们直接使用类。 我们创建了一个叫做 <code>greeterMaker</code> 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 <code>typeof Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，“告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 <code>greeterMaker</code> 上使用 <code>new</code>，创建 <code>Greeter</code> 的实例。</p>\n<h3><span id=\"把类当做接口使用\">把类当做接口使用</span></h3>\n<p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Point &#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Point3d <span class=\"keyword\">extends</span> Point &#123;</span><br><span class=\"line\">  z: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123;x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>, z: <span class=\"number\">3</span>&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>类</h1>\n<p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p>\n<h2>基本示例</h2>\n<p>下面看一个使用类的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 <code>Greeter</code> 类。这个类有 3 个成员：一个叫做 <code>greeting</code> 的属性，一个构造函数和一个 <code>greet</code> 方法。</p>\n<p>你会注意到，我们在引用任何一个类成员的时候都用了 <code>this</code>。 它表示我们访问的是类的成员。</p>\n<p>最后一行，我们使用 <code>new</code> 构造了 <code>Greeter</code> 类的一个实例。它会调用之前定义的构造函数，创建一个 <code>Greeter</code> 类型的新对象，并执行构造函数初始化它。</p>\n<h2>继承</h2>\n<p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Animal moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  bark() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Woof! Woof!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog = <span class=\"keyword\">new</span> Dog()</span><br><span class=\"line\">dog.bark()</span><br><span class=\"line\">dog.move(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p>\n<p>因为 <code>Dog</code> 继承了 <code>Animal</code> 的功能，因此我们可以创建一个 <code>Dog</code> 的实例，它能够 <code>bark()</code> 和 <code>move()</code>。</p>\n<p>下面我们来看个更加复杂的例子。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Snake <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Slithering...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Horse <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Galloping...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">'Sammy'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">'Tommy'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move()</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 <code>extends</code> 关键字创建了 Animal的两个子类：<code>Horse</code> 和 <code>Snake</code>。</p>\n<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code> 的属性之前，我们 一定要调用 <code>super()</code>。 这个是 TypeScript 强制执行的一条重要规则。</p>\n<p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和 <code>Horse</code> 类都创建了 <code>move</code> 方法，它们重写了从 <code>Animal</code> 继承来的 <code>move</code> 方法，使得 <code>move</code> 方法根据不同的类而具有不同的功能。注意，即使 <code>tom</code> 被声明为 <code>Animal</code> 类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code> 时，它会调用 <code>Horse</code> 里重写的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slithering...</span><br><span class=\"line\">Sammy moved 5m.</span><br><span class=\"line\">Galloping...</span><br><span class=\"line\">Tommy moved 34m.</span><br></pre></td></tr></table></figure>\n<h2>公共，私有与受保护的修饰符</h2>\n<h3>默认为 public</h3>\n<p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p>\n<p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> move(distance: <span class=\"built_in\">number</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>理解 private</h3>\n<p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal(<span class=\"string\">'Cat'</span>).name <span class=\"comment\">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>\n<p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code> 成员也使用这个规则。</p>\n<p>下面来看一个例子，更好地说明了这一点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Rhino <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Rhino'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'Goat'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino()</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Bob'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino</span><br><span class=\"line\">animal = employee <span class=\"comment\">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure>\n<p>这个例子中有 <code>Animal</code> 和 <code>Rhino</code> 两个类， <code>Rhino</code> 是 <code>Animal</code> 类的子类。 还有一个 <code>Employee</code> 类，其类型看上去与 <code>Animal</code> 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code> 和 <code>Rhino</code> 共享了来自 <code>Animal</code> 里的私有成员定义 <code>private name: string</code>，因此它们是兼容的。然而 <code>Employee</code> 却不是这样。当把 <code>Employee</code> 赋值给 <code>Animal</code> 的时候，得到一个错误，说它们的类型不兼容。尽管 <code>Employee</code> 里也有一个私有成员 <code>name</code>，但它明显不是 <code>Animal</code> 里面定义的那个。</p>\n<h3>理解 protected</h3>\n<p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch())</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.name) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>注意，我们不能在 <code>Person</code> 类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code> 类的实例方法访问，因为 <code>Employee</code> 是由 <code>Person</code>  派生而来的。</p>\n<p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Employee 能够继承 Person</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>) <span class=\"comment\">// 错误: 'Person' 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure>\n<h2>readonly 修饰符</h2>\n<p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  readonly name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>)</span><br><span class=\"line\">john.name = <span class=\"string\">'peter'</span></span><br></pre></td></tr></table></figure>\n<h3>参数属性</h3>\n<p>在上面的例子中，我们必须在 <code>Person</code> 类里定义一个只读成员 <code>name</code> 和一个参数为 <code>name</code> 的构造函数，并且立刻将 <code>name</code> 的值赋给 <code>this.name</code>，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Person</code> 类的修改版，使用了参数属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">readonly name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意看我们是如何舍弃参数 <code>name</code>，仅在构造函数里使用 <code>readonly name: string</code> 参数来创建和初始化 <code>name</code> 成员。 我们把声明和赋值合并至一处。</p>\n<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</p>\n<h2>存取器</h2>\n<p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>\n<p>下面来看如何把一个简单的类改写成使用 <code>get</code> 和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以设置 <code>fullName</code>，因为它是 <code>public</code> 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。</p>\n<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 <code>fullName</code> 的直接访问改成了可以检查密码的 <code>set</code> 方法。 我们也加了一个 <code>get</code> 方法，让上面的例子仍然可以工作。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">'secret passcode'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> fullName(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._fullName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> fullName(newName: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode == <span class=\"string\">'secret passcode'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._fullName = newName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Error: Unauthorized update of employee!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>\n<p>对于存取器有下面几点需要注意的：</p>\n<p>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>\n<h2>静态属性</h2>\n<p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code> 定义 <code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code> 前面加上类名。 如同在实例属性上使用 <code>this.xxx</code> 来访问属性一样，这里我们使用 <code>Grid.xxx</code> 来访问静态属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Grid &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> origin = &#123;x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  scale: <span class=\"built_in\">number</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">scale: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scale = scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  calculateDistanceFromOrigin(point: &#123;x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xDist = point.x - Grid.origin.x</span><br><span class=\"line\">    <span class=\"keyword\">let</span> yDist = point.y - Grid.origin.y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) * <span class=\"keyword\">this</span>.scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">1.0</span>)  <span class=\"comment\">// 1x scale</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid2 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">5.0</span>)  <span class=\"comment\">// 5x scale</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br></pre></td></tr></table></figure>\n<h2>抽象类</h2>\n<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> makeSound(): <span class=\"built_in\">void</span></span><br><span class=\"line\">  move(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'roaming the earth...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Department &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printName(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Department name: '</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> printMeeting(): <span class=\"built_in\">void</span> <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> AccountingDepartment <span class=\"keyword\">extends</span> Department &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Accounting and Auditing'</span>) <span class=\"comment\">// 在派生类的构造函数中必须调用 super()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printMeeting(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The Accounting Department meets each Monday at 10am.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  generateReports(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Generating accounting reports...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department <span class=\"comment\">// 允许创建一个对抽象类型的引用</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> Department() <span class=\"comment\">// 错误: 不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment() <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName()</span><br><span class=\"line\">department.printMeeting()</span><br><span class=\"line\">department.generateReports() <span class=\"comment\">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n<h2>高级技巧</h2>\n<h3>构造函数</h3>\n<p>当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的<em>实例</em>的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure>\n<p>这里，我们写了 <code>let greeter: Greeter</code>，意思是 <code>Greeter</code> 类的实例的类型是 <code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>\n<p>我们也创建了一个叫做<em>构造函数的值</em>。 这个函数会在我们使用 <code>new</code> 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Greeter = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeter</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Greeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Greeter.standardGreeting = <span class=\"string\">'Hello, there'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Greeter;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n<p>上面的代码里，<code>var Greeter</code> 将被构造函数赋值。 当我们调用 <code>new</code> 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p>\n<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.greeting) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Greeter.standardGreeting</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeterMaker: <span class=\"keyword\">typeof</span> Greeter = Greeter</span><br><span class=\"line\">greeterMaker.standardGreeting = <span class=\"string\">'Hey there'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter2: Greeter = <span class=\"keyword\">new</span> greeterMaker()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter2.greet())</span><br></pre></td></tr></table></figure>\n<p>这个例子里， <code>greeter1</code> 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p>\n<p>再之后，我们直接使用类。 我们创建了一个叫做 <code>greeterMaker</code> 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 <code>typeof Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，“告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 <code>greeterMaker</code> 上使用 <code>new</code>，创建 <code>Greeter</code> 的实例。</p>\n<h3>把类当做接口使用</h3>\n<p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Point &#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Point3d <span class=\"keyword\">extends</span> Point &#123;</span><br><span class=\"line\">  z: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123;x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>, z: <span class=\"number\">3</span>&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"TypeScript 学习第五章 TypeScript接口","catalog":true,"date":"2019-08-18T06:09:25.000Z","subtitle":null,"header-img":"http://img2.imgtn.bdimg.com/it/u=1658727450,3910645464&fm=26&gp=0.jpg","_content":"\n\n# 接口\n\nTypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n## 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\n```typescript\nfunction printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = { size: 10, label: 'Size 10 Object' }\nprintLabel(myObj)\n```\n\n类型检查器会查看 `printLabel` 的调用。`printLabel` 有一个参数，并要求这个对象参数有一个名为 `label` 类型为 `string` 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个`label` 属性且类型为 `string`：\n\n```typescript\ninterface LabelledValue {\n  label: string\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = {size: 10, label: 'Size 10 Object'}\nprintLabel(myObj)\n```\n\n`LabelledValue` 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 `label` 属性且类型为`string` 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 `printLabel` 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n## 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n  color?: string\n  width?: number\n}\n\nfunction createSquare (config: SquareConfig): Square {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\nlet mySquare = createSquare({color: 'black'})\n```\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 `?` 符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 `createSquare` 里的 `color` 属性名拼错，就会得到一个错误提示：\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n   color?: string;\n   width?: number;\n}\n \nfunction createSquare(config: SquareConfig): Square {\n   let newSquare = {color: 'white', area: 100}\n   if (config.clor) {\n     // Error: 属性 'clor' 不存在于类型 'SquareConfig' 中\n     newSquare.color = config.clor\n   }\n   if (config.width) {\n     newSquare.area = config.width * config.width\n   }\n   return newSquare\n }\n \n let mySquare = createSquare({color: 'black'})\n```\n\n## 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly` 来指定只读属性:\n\n```typescript\ninterface Point {\n  readonly x: number\n  readonly y: number\n}\n```\n\n你可以通过赋值一个对象字面量来构造一个 `Point`。 赋值后，`x` 和 `y` 再也不能被改变了。\n\n```typescript\nlet p1: Point = { x: 10, y: 20 }\np1.x = 5 // error!\n```\n\nTypeScript 具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n```typescript\nlet a: number[] = [1, 2, 3, 4]\nlet ro: ReadonlyArray<number> = a\nro[0] = 12 // error!\nro.push(5) // error!\nro.length = 100 // error!\na = ro // error!\n```\n\n上面代码的最后一行，可以看到就算把整个 `ReadonlyArray` 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\n```typescript\na = ro as number[]\n```\n\n### readonly vs const\n\n最简单判断该用 `readonly` 还是 `const` 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用 `readonly`。\n\n## 额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript 让我们传入 `{ size: number; label: string; }` 到仅期望得到 `{ label: string; }` 的函数里, 并且我们已经学过了可选属性。\n\n然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 `createSquare` 例子来说：\n\n```typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare (config: SquareConfig): { color: string; area: number } {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\n\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n注意传入 `createSquare` 的参数拼写为 `colour` 而不是 `color`。 在 JavaScript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为 `width` 属性是兼容的，不存在 `color` 属性，而且额外的 `colour` 属性是无意义的。\n\n然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n```typescript\n// error: 'colour' 不存在于类型 'SquareConfig' 中\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\n```typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig)\n```\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 `SquareConfig` 带有上面定义的类型的 `color` 和 `width` 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n\n```typescript\ninterface SquareConfig {\n  color?: string\n  width?: number\n  [propName: string]: any\n}\n```\n\n我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig` 可以有任意数量的属性，并且只要它们不是 `color` 和 `width`，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 `squareOptions` 不会经过额外属性检查，所以编译器不会报错。\n\n```typescript\nlet squareOptions = { colour: 'red', width: 100 }\nlet mySquare = createSquare(squareOptions)\n```\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 `color` 或 `colour` 属性到 `createSquare`，你应该修改 `SquareConfig` 定义来体现出这一点。\n\n\n## 函数类型\n\n接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean\n}\n```\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(source: string, subString: string): boolean {\n  let result = source.search(subString);\n  return result > -1\n}\n```\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1\n}\n```\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  `SearchFunc` 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 `false` 和 `true`）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 `SearchFunc` 接口中的定义不匹配。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src, sub) {\n  let result = src.search(sub)\n  return result > -1\n}\n```\n\n## 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 `a[10]` 或 `ageMap['daniel']`。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```typescript\ninterface StringArray {\n  [index: number]: string\n}\n\nlet myArray: StringArray\nmyArray = ['Bob', 'Fred']\n\nlet myStr: string = myArray[0]\n```\n\n上面例子里，我们定义了 `StringArray` 接口，它具有索引签名。 这个索引签名表示了当用 `number` 去索引 `StringArray` 时会得到 `string` 类型的返回值。\n\nTypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 `number` 来索引时，JavaScript 会将它转换成`string` 然后再去索引对象。 也就是说用 `100`（一个 `number`）去索引等同于使用`'100'`（一个 `string` ）去索引，因此两者需要保持一致。\n\n```typescript\nclass Animal {\n  name: string\n}\nclass Dog extends Animal {\n  breed: string\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n  [x: number]: Animal\n  [x: string]: Dog\n}\n```\n\n字符串索引签名能够很好的描述 `dictionary` 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 `obj.property` 和 `obj['property']` 两种形式都可以。 下面的例子里， `name` 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\n```typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\n```typescript\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = ['Alice', 'Bob'];\nmyArray[2] = 'Mallory'; // error!\n```\n\n## 类类型\n\n### 实现接口\n\n与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的 `setTime` 方法一样：\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n  setTime(d: Date)\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  setTime(d: Date) {\n    this.currentTime = d\n  }\n  constructor(h: number, m: number) { }\n}\n```\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number)\n}\n\n// error\nclass Clock implements ClockConstructor {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。`constructor` 存在于类的静态部分，所以不在检查的范围内。\n\n看下面的例子，我们定义了两个接口，  `ClockConstructor` 为构造函数所用和 `ClockInterface` 为实例方法所用。 为了方便我们定义一个构造函数 `createClock`，它用传入的类型创建实例。\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface\n}\ninterface ClockInterface {\n  tick()\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n  return new ctor(hour, minute)\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('beep beep')\n  }\n}\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('tick tock')\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17)\nlet analog = createClock(AnalogClock, 7, 32)\n```\n\n因为 `createClock` 的第一个参数是 `ClockConstructor` 类型，在 `createClock(AnalogClock, 7, 32)` 里，会检查 `AnalogClock` 是否符合构造函数签名。\n\n\n## 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface Square extends Shape {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\n```\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface PenStroke {\n  penWidth: number\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\nsquare.penWidth = 5.0\n```\n\n## 混合类型\n\n先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\n```typescript\ninterface Counter {\n  (start: number): string\n  interval: number\n  reset(): void\n}\n\nfunction getCounter(): Counter {\n  let counter = (function (start: number) { }) as Counter\n  counter.interval = 123\n  counter.reset = function () { }\n  return counter\n}\n\nlet c = getCounter()\nc(10)\nc.reset()\nc.interval = 5.0\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 `axios` 库就是一个很好的例子。\n\n## 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 `private` 和 `protected` 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：\n\n```typescript\nclass Control {\n  private state: any\n}\n\ninterface SelectableControl extends Control {\n  select(): void\n}\n\nclass Button extends Control implements SelectableControl {\n  select() { }\n}\n\nclass TextBox extends Control {\n  select() { }\n}\n\n// Error：“ImageC”类型缺少“state”属性。\nclass ImageC implements SelectableControl {\n  select() { }\n}\n```\n在上面的例子里，`SelectableControl` 包含了 `Control` 的所有成员，包括私有成员 `state`。 因为 `state` 是私有成员，所以只能够是 `Control` 的子类们才能实现 `SelectableControl` 接口。 因为只有 `Control` 的子类才能够拥有一个声明于`Control` 的私有成员 `state`，这对私有成员的兼容性是必需的。\n\n在 `Control` 类内部，是允许通过 `SelectableControl` 的实例来访问私有成员 `state` 的。 实际上，`SelectableControl` 接口和拥有 `select` 方法的 `Control` 类是一样的。`Button`和 `TextBox` 类是 `SelectableControl` 的子类（因为它们都继承自`Control` 并有 `select` 方法），但 `ImageC` 类并不是这样的。\n\n","source":"_posts/TypeScript 学习第五章 TypeScript接口.md","raw":"---\ntitle: TypeScript 学习第五章 TypeScript接口\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-18 14:09:25\nsubtitle:\nheader-img: \"http://img2.imgtn.bdimg.com/it/u=1658727450,3910645464&fm=26&gp=0.jpg\"\n---\n\n\n# 接口\n\nTypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n## 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\n```typescript\nfunction printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = { size: 10, label: 'Size 10 Object' }\nprintLabel(myObj)\n```\n\n类型检查器会查看 `printLabel` 的调用。`printLabel` 有一个参数，并要求这个对象参数有一个名为 `label` 类型为 `string` 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个`label` 属性且类型为 `string`：\n\n```typescript\ninterface LabelledValue {\n  label: string\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = {size: 10, label: 'Size 10 Object'}\nprintLabel(myObj)\n```\n\n`LabelledValue` 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 `label` 属性且类型为`string` 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 `printLabel` 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n## 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n  color?: string\n  width?: number\n}\n\nfunction createSquare (config: SquareConfig): Square {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\nlet mySquare = createSquare({color: 'black'})\n```\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 `?` 符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 `createSquare` 里的 `color` 属性名拼错，就会得到一个错误提示：\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n   color?: string;\n   width?: number;\n}\n \nfunction createSquare(config: SquareConfig): Square {\n   let newSquare = {color: 'white', area: 100}\n   if (config.clor) {\n     // Error: 属性 'clor' 不存在于类型 'SquareConfig' 中\n     newSquare.color = config.clor\n   }\n   if (config.width) {\n     newSquare.area = config.width * config.width\n   }\n   return newSquare\n }\n \n let mySquare = createSquare({color: 'black'})\n```\n\n## 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly` 来指定只读属性:\n\n```typescript\ninterface Point {\n  readonly x: number\n  readonly y: number\n}\n```\n\n你可以通过赋值一个对象字面量来构造一个 `Point`。 赋值后，`x` 和 `y` 再也不能被改变了。\n\n```typescript\nlet p1: Point = { x: 10, y: 20 }\np1.x = 5 // error!\n```\n\nTypeScript 具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n```typescript\nlet a: number[] = [1, 2, 3, 4]\nlet ro: ReadonlyArray<number> = a\nro[0] = 12 // error!\nro.push(5) // error!\nro.length = 100 // error!\na = ro // error!\n```\n\n上面代码的最后一行，可以看到就算把整个 `ReadonlyArray` 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\n```typescript\na = ro as number[]\n```\n\n### readonly vs const\n\n最简单判断该用 `readonly` 还是 `const` 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用 `readonly`。\n\n## 额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript 让我们传入 `{ size: number; label: string; }` 到仅期望得到 `{ label: string; }` 的函数里, 并且我们已经学过了可选属性。\n\n然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 `createSquare` 例子来说：\n\n```typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare (config: SquareConfig): { color: string; area: number } {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\n\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n注意传入 `createSquare` 的参数拼写为 `colour` 而不是 `color`。 在 JavaScript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为 `width` 属性是兼容的，不存在 `color` 属性，而且额外的 `colour` 属性是无意义的。\n\n然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n```typescript\n// error: 'colour' 不存在于类型 'SquareConfig' 中\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\n```typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig)\n```\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 `SquareConfig` 带有上面定义的类型的 `color` 和 `width` 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n\n```typescript\ninterface SquareConfig {\n  color?: string\n  width?: number\n  [propName: string]: any\n}\n```\n\n我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig` 可以有任意数量的属性，并且只要它们不是 `color` 和 `width`，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 `squareOptions` 不会经过额外属性检查，所以编译器不会报错。\n\n```typescript\nlet squareOptions = { colour: 'red', width: 100 }\nlet mySquare = createSquare(squareOptions)\n```\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 `color` 或 `colour` 属性到 `createSquare`，你应该修改 `SquareConfig` 定义来体现出这一点。\n\n\n## 函数类型\n\n接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean\n}\n```\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(source: string, subString: string): boolean {\n  let result = source.search(subString);\n  return result > -1\n}\n```\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1\n}\n```\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  `SearchFunc` 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 `false` 和 `true`）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 `SearchFunc` 接口中的定义不匹配。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src, sub) {\n  let result = src.search(sub)\n  return result > -1\n}\n```\n\n## 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 `a[10]` 或 `ageMap['daniel']`。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```typescript\ninterface StringArray {\n  [index: number]: string\n}\n\nlet myArray: StringArray\nmyArray = ['Bob', 'Fred']\n\nlet myStr: string = myArray[0]\n```\n\n上面例子里，我们定义了 `StringArray` 接口，它具有索引签名。 这个索引签名表示了当用 `number` 去索引 `StringArray` 时会得到 `string` 类型的返回值。\n\nTypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 `number` 来索引时，JavaScript 会将它转换成`string` 然后再去索引对象。 也就是说用 `100`（一个 `number`）去索引等同于使用`'100'`（一个 `string` ）去索引，因此两者需要保持一致。\n\n```typescript\nclass Animal {\n  name: string\n}\nclass Dog extends Animal {\n  breed: string\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n  [x: number]: Animal\n  [x: string]: Dog\n}\n```\n\n字符串索引签名能够很好的描述 `dictionary` 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 `obj.property` 和 `obj['property']` 两种形式都可以。 下面的例子里， `name` 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\n```typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\n```typescript\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = ['Alice', 'Bob'];\nmyArray[2] = 'Mallory'; // error!\n```\n\n## 类类型\n\n### 实现接口\n\n与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的 `setTime` 方法一样：\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n  setTime(d: Date)\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  setTime(d: Date) {\n    this.currentTime = d\n  }\n  constructor(h: number, m: number) { }\n}\n```\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number)\n}\n\n// error\nclass Clock implements ClockConstructor {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。`constructor` 存在于类的静态部分，所以不在检查的范围内。\n\n看下面的例子，我们定义了两个接口，  `ClockConstructor` 为构造函数所用和 `ClockInterface` 为实例方法所用。 为了方便我们定义一个构造函数 `createClock`，它用传入的类型创建实例。\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface\n}\ninterface ClockInterface {\n  tick()\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n  return new ctor(hour, minute)\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('beep beep')\n  }\n}\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('tick tock')\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17)\nlet analog = createClock(AnalogClock, 7, 32)\n```\n\n因为 `createClock` 的第一个参数是 `ClockConstructor` 类型，在 `createClock(AnalogClock, 7, 32)` 里，会检查 `AnalogClock` 是否符合构造函数签名。\n\n\n## 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface Square extends Shape {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\n```\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface PenStroke {\n  penWidth: number\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\nsquare.penWidth = 5.0\n```\n\n## 混合类型\n\n先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\n```typescript\ninterface Counter {\n  (start: number): string\n  interval: number\n  reset(): void\n}\n\nfunction getCounter(): Counter {\n  let counter = (function (start: number) { }) as Counter\n  counter.interval = 123\n  counter.reset = function () { }\n  return counter\n}\n\nlet c = getCounter()\nc(10)\nc.reset()\nc.interval = 5.0\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 `axios` 库就是一个很好的例子。\n\n## 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 `private` 和 `protected` 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：\n\n```typescript\nclass Control {\n  private state: any\n}\n\ninterface SelectableControl extends Control {\n  select(): void\n}\n\nclass Button extends Control implements SelectableControl {\n  select() { }\n}\n\nclass TextBox extends Control {\n  select() { }\n}\n\n// Error：“ImageC”类型缺少“state”属性。\nclass ImageC implements SelectableControl {\n  select() { }\n}\n```\n在上面的例子里，`SelectableControl` 包含了 `Control` 的所有成员，包括私有成员 `state`。 因为 `state` 是私有成员，所以只能够是 `Control` 的子类们才能实现 `SelectableControl` 接口。 因为只有 `Control` 的子类才能够拥有一个声明于`Control` 的私有成员 `state`，这对私有成员的兼容性是必需的。\n\n在 `Control` 类内部，是允许通过 `SelectableControl` 的实例来访问私有成员 `state` 的。 实际上，`SelectableControl` 接口和拥有 `select` 方法的 `Control` 类是一样的。`Button`和 `TextBox` 类是 `SelectableControl` 的子类（因为它们都继承自`Control` 并有 `select` 方法），但 `ImageC` 类并不是这样的。\n\n","slug":"TypeScript 学习第五章 TypeScript接口","published":1,"updated":"2019-08-17T11:07:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzfg6r74005iw72sdpndzfeo","content":"<h1><span id=\"接口\">接口</span></h1>\n<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<h2><span id=\"接口初探\">接口初探</span></h2>\n<p>下面通过一个简单示例来观察接口是如何工作的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: &#123; label: <span class=\"built_in\">string</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span> &#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p>类型检查器会查看 <code>printLabel</code> 的调用。<code>printLabel</code> 有一个参数，并要求这个对象参数有一个名为 <code>label</code> 类型为 <code>string</code> 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。</p>\n<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code> 属性且类型为 <code>string</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span>&#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p><code>LabelledValue</code> 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 <code>label</code> 属性且类型为<code>string</code> 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code> 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>\n<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<h2><span id=\"可选属性\">可选属性</span></h2>\n<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p>\n<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code> 里的 <code>color</code> 属性名拼错，就会得到一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">   color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">   width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.clor) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Error: 属性 'clor' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\">     newSquare.color = config.clor</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">     newSquare.area = config.width * config.width</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"只读属性\">只读属性</span></h2>\n<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">  readonly x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  readonly y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以通过赋值一个对象字面量来构造一个 <code>Point</code>。 赋值后，<code>x</code> 和 <code>y</code> 再也不能被改变了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; x: <span class=\"number\">10</span>, y: <span class=\"number\">20</span> &#125;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span> <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = a</span><br><span class=\"line\">ro[<span class=\"number\">0</span>] = <span class=\"number\">12</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.push(<span class=\"number\">5</span>) <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.length = <span class=\"number\">100</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">a = ro <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的最后一行，可以看到就算把整个 <code>ReadonlyArray</code> 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = ro <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>[]</span><br></pre></td></tr></table></figure>\n<h3><span id=\"readonly-vs-const\">readonly vs const</span></h3>\n<p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p>\n<h2><span id=\"额外的属性检查\">额外的属性检查</span></h2>\n<p>我们在第一个例子里使用了接口，TypeScript 让我们传入 <code>{ size: number; label: string; }</code> 到仅期望得到 <code>{ label: string; }</code> 的函数里, 并且我们已经学过了可选属性。</p>\n<p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code> 例子来说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>注意传入 <code>createSquare</code> 的参数拼写为 <code>colour</code> 而不是 <code>color</code>。 在 JavaScript 里，这会默默地失败。</p>\n<p>你可能会争辩这个程序已经正确地类型化了，因为 <code>width</code> 属性是兼容的，不存在 <code>color</code> 属性，而且额外的 <code>colour</code> 属性是无意义的。</p>\n<p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// error: 'colour' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; width: <span class=\"number\">100</span>, opacity: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig)</span><br></pre></td></tr></table></figure>\n<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code> 带有上面定义的类型的 <code>color</code> 和 <code>width</code> 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> 和 <code>width</code>，那么就无所谓它们的类型是什么。</p>\n<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code> 不会经过额外属性检查，所以编译器不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions)</span><br></pre></td></tr></table></figure>\n<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code> 或 <code>colour</code> 属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code> 定义来体现出这一点。</p>\n<h2><span id=\"函数类型\">函数类型</span></h2>\n<p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>\n<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src: <span class=\"built_in\">string</span>, sub: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  <code>SearchFunc</code> 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code> 和 <code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code> 接口中的定义不匹配。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src, sub</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"可索引的类型\">可索引的类型</span></h2>\n<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap['daniel']</code>。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray</span><br><span class=\"line\">myArray = [<span class=\"string\">'Bob'</span>, <span class=\"string\">'Fred'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>上面例子里，我们定义了 <code>StringArray</code> 接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引 <code>StringArray</code> 时会得到 <code>string</code> 类型的返回值。</p>\n<p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code> 来索引时，JavaScript 会将它转换成<code>string</code> 然后再去索引对象。 也就是说用 <code>100</code>（一个 <code>number</code>）去索引等同于使用<code>'100'</code>（一个 <code>string</code> ）去索引，因此两者需要保持一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  breed: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotOkay &#123;</span><br><span class=\"line\">  [x: <span class=\"built_in\">number</span>]: Animal</span><br><span class=\"line\">  [x: <span class=\"built_in\">string</span>]: Dog</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串索引签名能够很好的描述 <code>dictionary</code> 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj['property']</code> 两种形式都可以。 下面的例子里， <code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NumberDictionary &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;    <span class=\"comment\">// 可以，length是number类型</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>       <span class=\"comment\">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyStringArray &#123;</span><br><span class=\"line\">  readonly [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: ReadonlyStringArray = [<span class=\"string\">'Alice'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">'Mallory'</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"类类型\">类类型</span></h2>\n<h3><span id=\"实现接口\">实现接口</span></h3>\n<p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentTime = d</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>\n<h3><span id=\"类静态部分与实例部分的区别\">类静态部分与实例部分的区别</span></h3>\n<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockConstructor &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p>\n<p>看下面的例子，我们定义了两个接口，  <code>ClockConstructor</code> 为构造函数所用和 <code>ClockInterface</code> 为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>): ClockInterface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  tick()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> DigitalClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'beep beep'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> AnalogClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'tick tock'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名。</p>\n<h2><span id=\"继承接口\">继承接口</span></h2>\n<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">  penWidth: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"混合类型\">混合类型</span></h2>\n<p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>\n<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">  (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span></span><br><span class=\"line\">  interval: <span class=\"built_in\">number</span></span><br><span class=\"line\">  reset(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> counter = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;) <span class=\"keyword\">as</span> Counter</span><br><span class=\"line\">  counter.interval = <span class=\"number\">123</span></span><br><span class=\"line\">  counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> counter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter()</span><br><span class=\"line\">c(<span class=\"number\">10</span>)</span><br><span class=\"line\">c.reset()</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 <code>axios</code> 库就是一个很好的例子。</p>\n<h2><span id=\"接口继承类\">接口继承类</span></h2>\n<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>\n<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error：“ImageC”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> ImageC <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员，包括私有成员 <code>state</code>。 因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口。 因为只有 <code>Control</code> 的子类才能够拥有一个声明于<code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。</p>\n<p>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。 实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code>和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类（因为它们都继承自<code>Control</code> 并有 <code>select</code> 方法），但 <code>ImageC</code> 类并不是这样的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>接口</h1>\n<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<h2>接口初探</h2>\n<p>下面通过一个简单示例来观察接口是如何工作的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: &#123; label: <span class=\"built_in\">string</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span> &#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p>类型检查器会查看 <code>printLabel</code> 的调用。<code>printLabel</code> 有一个参数，并要求这个对象参数有一个名为 <code>label</code> 类型为 <code>string</code> 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。</p>\n<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code> 属性且类型为 <code>string</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span>&#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p><code>LabelledValue</code> 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 <code>label</code> 属性且类型为<code>string</code> 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code> 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>\n<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<h2>可选属性</h2>\n<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p>\n<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code> 里的 <code>color</code> 属性名拼错，就会得到一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">   color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">   width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.clor) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Error: 属性 'clor' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\">     newSquare.color = config.clor</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">     newSquare.area = config.width * config.width</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h2>只读属性</h2>\n<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">  readonly x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  readonly y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以通过赋值一个对象字面量来构造一个 <code>Point</code>。 赋值后，<code>x</code> 和 <code>y</code> 再也不能被改变了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; x: <span class=\"number\">10</span>, y: <span class=\"number\">20</span> &#125;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span> <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = a</span><br><span class=\"line\">ro[<span class=\"number\">0</span>] = <span class=\"number\">12</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.push(<span class=\"number\">5</span>) <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.length = <span class=\"number\">100</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">a = ro <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的最后一行，可以看到就算把整个 <code>ReadonlyArray</code> 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = ro <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>[]</span><br></pre></td></tr></table></figure>\n<h3>readonly vs const</h3>\n<p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p>\n<h2>额外的属性检查</h2>\n<p>我们在第一个例子里使用了接口，TypeScript 让我们传入 <code>{ size: number; label: string; }</code> 到仅期望得到 <code>{ label: string; }</code> 的函数里, 并且我们已经学过了可选属性。</p>\n<p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code> 例子来说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>注意传入 <code>createSquare</code> 的参数拼写为 <code>colour</code> 而不是 <code>color</code>。 在 JavaScript 里，这会默默地失败。</p>\n<p>你可能会争辩这个程序已经正确地类型化了，因为 <code>width</code> 属性是兼容的，不存在 <code>color</code> 属性，而且额外的 <code>colour</code> 属性是无意义的。</p>\n<p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// error: 'colour' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; width: <span class=\"number\">100</span>, opacity: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig)</span><br></pre></td></tr></table></figure>\n<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code> 带有上面定义的类型的 <code>color</code> 和 <code>width</code> 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> 和 <code>width</code>，那么就无所谓它们的类型是什么。</p>\n<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code> 不会经过额外属性检查，所以编译器不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions)</span><br></pre></td></tr></table></figure>\n<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code> 或 <code>colour</code> 属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code> 定义来体现出这一点。</p>\n<h2>函数类型</h2>\n<p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>\n<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src: <span class=\"built_in\">string</span>, sub: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  <code>SearchFunc</code> 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code> 和 <code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code> 接口中的定义不匹配。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src, sub</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>可索引的类型</h2>\n<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap['daniel']</code>。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray</span><br><span class=\"line\">myArray = [<span class=\"string\">'Bob'</span>, <span class=\"string\">'Fred'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>上面例子里，我们定义了 <code>StringArray</code> 接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引 <code>StringArray</code> 时会得到 <code>string</code> 类型的返回值。</p>\n<p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code> 来索引时，JavaScript 会将它转换成<code>string</code> 然后再去索引对象。 也就是说用 <code>100</code>（一个 <code>number</code>）去索引等同于使用<code>'100'</code>（一个 <code>string</code> ）去索引，因此两者需要保持一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  breed: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotOkay &#123;</span><br><span class=\"line\">  [x: <span class=\"built_in\">number</span>]: Animal</span><br><span class=\"line\">  [x: <span class=\"built_in\">string</span>]: Dog</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串索引签名能够很好的描述 <code>dictionary</code> 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj['property']</code> 两种形式都可以。 下面的例子里， <code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NumberDictionary &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;    <span class=\"comment\">// 可以，length是number类型</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>       <span class=\"comment\">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyStringArray &#123;</span><br><span class=\"line\">  readonly [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: ReadonlyStringArray = [<span class=\"string\">'Alice'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">'Mallory'</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<h2>类类型</h2>\n<h3>实现接口</h3>\n<p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentTime = d</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>\n<h3>类静态部分与实例部分的区别</h3>\n<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockConstructor &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p>\n<p>看下面的例子，我们定义了两个接口，  <code>ClockConstructor</code> 为构造函数所用和 <code>ClockInterface</code> 为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>): ClockInterface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  tick()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> DigitalClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'beep beep'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> AnalogClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'tick tock'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名。</p>\n<h2>继承接口</h2>\n<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">  penWidth: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<h2>混合类型</h2>\n<p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>\n<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">  (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span></span><br><span class=\"line\">  interval: <span class=\"built_in\">number</span></span><br><span class=\"line\">  reset(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> counter = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;) <span class=\"keyword\">as</span> Counter</span><br><span class=\"line\">  counter.interval = <span class=\"number\">123</span></span><br><span class=\"line\">  counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> counter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter()</span><br><span class=\"line\">c(<span class=\"number\">10</span>)</span><br><span class=\"line\">c.reset()</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 <code>axios</code> 库就是一个很好的例子。</p>\n<h2>接口继承类</h2>\n<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>\n<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error：“ImageC”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> ImageC <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员，包括私有成员 <code>state</code>。 因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口。 因为只有 <code>Control</code> 的子类才能够拥有一个声明于<code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。</p>\n<p>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。 实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code>和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类（因为它们都继承自<code>Control</code> 并有 <code>select</code> 方法），但 <code>ImageC</code> 类并不是这样的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjzfg6r3w0001w72sn7yafu7t","category_id":"cjzfg6r430005w72sr3prjqu5","_id":"cjzfg6r4o000gw72saqf6a2ko"},{"post_id":"cjzfg6r410003w72s327649wk","category_id":"cjzfg6r430005w72sr3prjqu5","_id":"cjzfg6r4r000lw72s6tb1ol37"},{"post_id":"cjzfg6r450007w72sbkdvtga4","category_id":"cjzfg6r4n000fw72sh46x1551","_id":"cjzfg6r4u000sw72slbobh5is"},{"post_id":"cjzfg6r4q000kw72ss1dgrqyn","category_id":"cjzfg6r4n000fw72sh46x1551","_id":"cjzfg6r4v000ww72suf0z8not"},{"post_id":"cjzfg6r470009w72slsglxwcb","category_id":"cjzfg6r4r000nw72s9t7leazu","_id":"cjzfg6r4x000zw72stp2vdtt5"},{"post_id":"cjzfg6r4t000rw72sq1aq2216","category_id":"cjzfg6r4n000fw72sh46x1551","_id":"cjzfg6r4y0012w72s69673l3t"},{"post_id":"cjzfg6r49000aw72stgxo9za2","category_id":"cjzfg6r4r000nw72s9t7leazu","_id":"cjzfg6r4z0016w72s5qi2lzyt"},{"post_id":"cjzfg6r4x0011w72sw1gtzhxt","category_id":"cjzfg6r430005w72sr3prjqu5","_id":"cjzfg6r52001cw72sygw5kyck"},{"post_id":"cjzfg6r4c000dw72sia380sh0","category_id":"cjzfg6r4n000fw72sh46x1551","_id":"cjzfg6r54001fw72sf9k9ssnv"},{"post_id":"cjzfg6r4y0014w72sd7bgo8d7","category_id":"cjzfg6r4r000nw72s9t7leazu","_id":"cjzfg6r56001jw72sfilz6nk2"},{"post_id":"cjzfg6r4m000ew72sepo36urk","category_id":"cjzfg6r4n000fw72sh46x1551","_id":"cjzfg6r57001mw72sakx7eosn"},{"post_id":"cjzfg6r4p000iw72s6u98rf74","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r59001qw72sabpmh4gv"},{"post_id":"cjzfg6r4s000pw72sljkt9eao","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r5c001ww72sm8fl92xp"},{"post_id":"cjzfg6r4v000vw72smh7yxoz6","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r5e0022w72so39cldpo"},{"post_id":"cjzfg6r4w000xw72svvnm9b39","category_id":"cjzfg6r5b001vw72sssaryt5e","_id":"cjzfg6r5g0028w72sdy1r6d95"},{"post_id":"cjzfg6r5e0023w72srzfxl52p","category_id":"cjzfg6r4r000nw72s9t7leazu","_id":"cjzfg6r5g002bw72s3ndah9b4"},{"post_id":"cjzfg6r500018w72sehdjwszq","category_id":"cjzfg6r5f0024w72ss33ab84e","_id":"cjzfg6r5h002cw72smzwmmb55"},{"post_id":"cjzfg6r52001bw72s3irsshg7","category_id":"cjzfg6r5g0029w72s65sjuzy9","_id":"cjzfg6r5i002hw72s1kuninaj"},{"post_id":"cjzfg6r53001ew72srg6c5djc","category_id":"cjzfg6r5h002dw72segz08ap2","_id":"cjzfg6r5k002lw72sljcmgh80"},{"post_id":"cjzfg6r55001iw72s58fhukul","category_id":"cjzfg6r5j002jw72swiug9hcq","_id":"cjzfg6r5n002rw72svihdyor7"},{"post_id":"cjzfg6r56001lw72stybu89dd","category_id":"cjzfg6r5j002jw72swiug9hcq","_id":"cjzfg6r5o002uw72sdegpt9qi"},{"post_id":"cjzfg6r58001ow72s21vlb5kj","category_id":"cjzfg6r5j002jw72swiug9hcq","_id":"cjzfg6r5p002zw72sjxuq2nqa"},{"post_id":"cjzfg6r59001rw72so2amxzx2","category_id":"cjzfg6r5j002jw72swiug9hcq","_id":"cjzfg6r5q0033w72s485l8kup"},{"post_id":"cjzfg6r5b001uw72s8xp7nsbw","category_id":"cjzfg6r5p002yw72sd5b6d8xv","_id":"cjzfg6r5r0037w72smxt6olvi"},{"post_id":"cjzfg6r5c001yw72saxax7j7q","category_id":"cjzfg6r5j002jw72swiug9hcq","_id":"cjzfg6r5s003bw72sv1souyxa"},{"post_id":"cjzfg6r5d0021w72sagnlw0y9","category_id":"cjzfg6r5j002jw72swiug9hcq","_id":"cjzfg6r5s003dw72swdqfwdfx"},{"post_id":"cjzfg6r6j004iw72sesrb1zrk","category_id":"cjzfg6r4n000fw72sh46x1551","_id":"cjzfg6r6o004ow72sy98iaqg3"},{"post_id":"cjzfg6r6k004jw72sy5me5zck","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r6p004rw72szx9f72tc"},{"post_id":"cjzfg6r6l004lw72sj3o0eawp","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r6q004uw72schhizced"},{"post_id":"cjzfg6r6n004nw72s6kd8w1tr","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r6r004xw72ssxdagz23"},{"post_id":"cjzfg6r6o004qw72snyr3ymo9","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r6s0050w72sak2b6vpw"},{"post_id":"cjzfg6r6q004tw72sk7pbzukw","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r6t0053w72sloewtf5u"},{"post_id":"cjzfg6r6r004ww72s15skex84","category_id":"cjzfg6r6t0051w72s4uztdxg8","_id":"cjzfg6r6w005bw72s682eqx7u"},{"post_id":"cjzfg6r6s004zw72sc7degrou","category_id":"cjzfg6r6v0057w72stvgnkvt3","_id":"cjzfg6r6w005ew72s2l2snpie"},{"post_id":"cjzfg6r73005hw72skl54490w","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r75005lw72scjhbzejm"},{"post_id":"cjzfg6r74005iw72sdpndzfeo","category_id":"cjzfg6r53001dw72s3wrtr4gd","_id":"cjzfg6r76005nw72sya3zcgej"}],"PostTag":[{"post_id":"cjzfg6r3w0001w72sn7yafu7t","tag_id":"cjzfg6r450006w72su26zcrq9","_id":"cjzfg6r4q000jw72sys6xaw7g"},{"post_id":"cjzfg6r3w0001w72sn7yafu7t","tag_id":"cjzfg6r4a000cw72sfl8koct8","_id":"cjzfg6r4r000mw72se0s5mp31"},{"post_id":"cjzfg6r410003w72s327649wk","tag_id":"cjzfg6r450006w72su26zcrq9","_id":"cjzfg6r4t000qw72s1j6z5tr7"},{"post_id":"cjzfg6r450007w72sbkdvtga4","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r4y0013w72sxi6w02y2"},{"post_id":"cjzfg6r450007w72sbkdvtga4","tag_id":"cjzfg6r4u000uw72ssgrnqt2y","_id":"cjzfg6r4z0017w72s78ja2495"},{"post_id":"cjzfg6r470009w72slsglxwcb","tag_id":"cjzfg6r4x0010w72svr1osehp","_id":"cjzfg6r51001aw72sciw8kc92"},{"post_id":"cjzfg6r49000aw72stgxo9za2","tag_id":"cjzfg6r4x0010w72svr1osehp","_id":"cjzfg6r55001hw72sld7bb2nt"},{"post_id":"cjzfg6r4c000dw72sia380sh0","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r5a001tw72sqjmz90vt"},{"post_id":"cjzfg6r4c000dw72sia380sh0","tag_id":"cjzfg6r4u000uw72ssgrnqt2y","_id":"cjzfg6r5c001xw72s6nhg7x6a"},{"post_id":"cjzfg6r5b001uw72s8xp7nsbw","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r5d0020w72s83h3us0n"},{"post_id":"cjzfg6r4m000ew72sepo36urk","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r5f0026w72snitvrokz"},{"post_id":"cjzfg6r4m000ew72sepo36urk","tag_id":"cjzfg6r4u000uw72ssgrnqt2y","_id":"cjzfg6r5g0027w72swkdkv9v7"},{"post_id":"cjzfg6r4p000iw72s6u98rf74","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r5i002fw72sje6rt0nz"},{"post_id":"cjzfg6r4p000iw72s6u98rf74","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r5i002gw72sw5jqo6zi"},{"post_id":"cjzfg6r4q000kw72ss1dgrqyn","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r5m002nw72s71sr8drp"},{"post_id":"cjzfg6r4q000kw72ss1dgrqyn","tag_id":"cjzfg6r4u000uw72ssgrnqt2y","_id":"cjzfg6r5m002ow72s0vuq833e"},{"post_id":"cjzfg6r4s000pw72sljkt9eao","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r5o002vw72sam0hzsw2"},{"post_id":"cjzfg6r4s000pw72sljkt9eao","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r5o002ww72sp6ysb235"},{"post_id":"cjzfg6r4t000rw72sq1aq2216","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r5p0030w72s3ynslmj1"},{"post_id":"cjzfg6r4t000rw72sq1aq2216","tag_id":"cjzfg6r4u000uw72ssgrnqt2y","_id":"cjzfg6r5p0031w72s01q2ltkd"},{"post_id":"cjzfg6r4v000vw72smh7yxoz6","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r5r0038w72so24fw5jb"},{"post_id":"cjzfg6r4v000vw72smh7yxoz6","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r5r0039w72s9085ylw9"},{"post_id":"cjzfg6r4w000xw72svvnm9b39","tag_id":"cjzfg6r5q0035w72st9fa3gkv","_id":"cjzfg6r5s003fw72sh5lqrawe"},{"post_id":"cjzfg6r4w000xw72svvnm9b39","tag_id":"cjzfg6r5r003aw72seddu390g","_id":"cjzfg6r5t003gw72sow0jp79d"},{"post_id":"cjzfg6r4w000xw72svvnm9b39","tag_id":"cjzfg6r5s003cw72sues18w0y","_id":"cjzfg6r5t003iw72s8vtj6ima"},{"post_id":"cjzfg6r4x0011w72sw1gtzhxt","tag_id":"cjzfg6r450006w72su26zcrq9","_id":"cjzfg6r5t003kw72s8fk48erg"},{"post_id":"cjzfg6r4x0011w72sw1gtzhxt","tag_id":"cjzfg6r5s003ew72s88lklxfi","_id":"cjzfg6r5u003lw72sbrpnv79w"},{"post_id":"cjzfg6r4x0011w72sw1gtzhxt","tag_id":"cjzfg6r5t003hw72sjzisa87e","_id":"cjzfg6r5u003nw72sv92pzmun"},{"post_id":"cjzfg6r4y0014w72sd7bgo8d7","tag_id":"cjzfg6r4x0010w72svr1osehp","_id":"cjzfg6r5u003ow72sz77ootre"},{"post_id":"cjzfg6r4y0014w72sd7bgo8d7","tag_id":"cjzfg6r5t003jw72sprogmi97","_id":"cjzfg6r5v003qw72sk9ewxb04"},{"post_id":"cjzfg6r53001ew72srg6c5djc","tag_id":"cjzfg6r5u003mw72s9lijildv","_id":"cjzfg6r5v003rw72s1juldp4y"},{"post_id":"cjzfg6r55001iw72s58fhukul","tag_id":"cjzfg6r5u003pw72sz5nznagt","_id":"cjzfg6r5w003vw72s4f9lte4m"},{"post_id":"cjzfg6r55001iw72s58fhukul","tag_id":"cjzfg6r5v003sw72s2tcops77","_id":"cjzfg6r5w003ww72sc6ccu8he"},{"post_id":"cjzfg6r55001iw72s58fhukul","tag_id":"cjzfg6r5v003tw72snkrlevqh","_id":"cjzfg6r5x003yw72sy6v80f28"},{"post_id":"cjzfg6r56001lw72stybu89dd","tag_id":"cjzfg6r5v003uw72sqditd583","_id":"cjzfg6r5x0040w72sfqtuhr1l"},{"post_id":"cjzfg6r56001lw72stybu89dd","tag_id":"cjzfg6r5v003sw72s2tcops77","_id":"cjzfg6r5y0041w72smpuyfcjq"},{"post_id":"cjzfg6r56001lw72stybu89dd","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r5y0043w72snhxk6wqv"},{"post_id":"cjzfg6r58001ow72s21vlb5kj","tag_id":"cjzfg6r5v003sw72s2tcops77","_id":"cjzfg6r5y0044w72sgib5wfp4"},{"post_id":"cjzfg6r59001rw72so2amxzx2","tag_id":"cjzfg6r5v003sw72s2tcops77","_id":"cjzfg6r600047w72scvg52ohd"},{"post_id":"cjzfg6r59001rw72so2amxzx2","tag_id":"cjzfg6r5v003tw72snkrlevqh","_id":"cjzfg6r600048w72scfqtlw5f"},{"post_id":"cjzfg6r59001rw72so2amxzx2","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r60004aw72syv66heut"},{"post_id":"cjzfg6r5c001yw72saxax7j7q","tag_id":"cjzfg6r5v003sw72s2tcops77","_id":"cjzfg6r61004bw72s5lmam3mv"},{"post_id":"cjzfg6r5d0021w72sagnlw0y9","tag_id":"cjzfg6r5v003sw72s2tcops77","_id":"cjzfg6r61004dw72sizozch9c"},{"post_id":"cjzfg6r5e0023w72srzfxl52p","tag_id":"cjzfg6r4x0010w72svr1osehp","_id":"cjzfg6r62004fw72shar1i1nj"},{"post_id":"cjzfg6r5e0023w72srzfxl52p","tag_id":"cjzfg6r5t003jw72sprogmi97","_id":"cjzfg6r62004gw72sopyxjtcc"},{"post_id":"cjzfg6r5e0023w72srzfxl52p","tag_id":"cjzfg6r61004ew72s1h1xx0hn","_id":"cjzfg6r62004hw72symc8jvgs"},{"post_id":"cjzfg6r6j004iw72sesrb1zrk","tag_id":"cjzfg6r4r000ow72ssgsxvmgc","_id":"cjzfg6r6l004kw72sbqalm2ha"},{"post_id":"cjzfg6r6j004iw72sesrb1zrk","tag_id":"cjzfg6r4u000uw72ssgrnqt2y","_id":"cjzfg6r6n004mw72sw53r1hxv"},{"post_id":"cjzfg6r6k004jw72sy5me5zck","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r6o004pw72simo06a5a"},{"post_id":"cjzfg6r6k004jw72sy5me5zck","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r6p004sw72sz2eouykz"},{"post_id":"cjzfg6r6l004lw72sj3o0eawp","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r6r004vw72s8m41a03g"},{"post_id":"cjzfg6r6l004lw72sj3o0eawp","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r6s004yw72sxdtypddd"},{"post_id":"cjzfg6r6n004nw72s6kd8w1tr","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r6t0052w72sp6eo5cy2"},{"post_id":"cjzfg6r6n004nw72s6kd8w1tr","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r6v0055w72sxdokbnkk"},{"post_id":"cjzfg6r6o004qw72snyr3ymo9","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r6v0056w72sgyio0qlo"},{"post_id":"cjzfg6r6o004qw72snyr3ymo9","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r6v0058w72sk0a0f0sg"},{"post_id":"cjzfg6r6q004tw72sk7pbzukw","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r6w005aw72s4thxupdu"},{"post_id":"cjzfg6r6q004tw72sk7pbzukw","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r6w005cw72sok58zxma"},{"post_id":"cjzfg6r6s004zw72sc7degrou","tag_id":"cjzfg6r6u0054w72so10069w8","_id":"cjzfg6r6w005dw72ss7ufzuiz"},{"post_id":"cjzfg6r6s004zw72sc7degrou","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r6w005fw72syp7ju8fr"},{"post_id":"cjzfg6r6s004zw72sc7degrou","tag_id":"cjzfg6r6v0059w72s9jpvc1ks","_id":"cjzfg6r6w005gw72sxglbatsx"},{"post_id":"cjzfg6r73005hw72skl54490w","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r75005jw72sllchsgjf"},{"post_id":"cjzfg6r73005hw72skl54490w","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r75005kw72sfu3zzj7q"},{"post_id":"cjzfg6r74005iw72sdpndzfeo","tag_id":"cjzfg6r5f0025w72sgehq06p8","_id":"cjzfg6r76005mw72s91dn889n"},{"post_id":"cjzfg6r74005iw72sdpndzfeo","tag_id":"cjzfg6r5g002aw72sz8yde1ec","_id":"cjzfg6r76005ow72sroz4yurx"}],"Tag":[{"name":"Docker","_id":"cjzfg6r450006w72su26zcrq9"},{"name":"WordPress","_id":"cjzfg6r4a000cw72sfl8koct8"},{"name":"javascript","_id":"cjzfg6r4r000ow72ssgsxvmgc"},{"name":"数据结构","_id":"cjzfg6r4u000uw72ssgrnqt2y"},{"name":"graphql","_id":"cjzfg6r4x0010w72svr1osehp"},{"name":"JavaScript","_id":"cjzfg6r5f0025w72sgehq06p8"},{"name":"TypeScript","_id":"cjzfg6r5g002aw72sz8yde1ec"},{"name":"Vue","_id":"cjzfg6r5q0035w72st9fa3gkv"},{"name":"Weex","_id":"cjzfg6r5r003aw72seddu390g"},{"name":"微信小程序","_id":"cjzfg6r5s003cw72sues18w0y"},{"name":"git","_id":"cjzfg6r5s003ew72s88lklxfi"},{"name":"gitlab","_id":"cjzfg6r5t003hw72sjzisa87e"},{"name":"nodejs","_id":"cjzfg6r5t003jw72sprogmi97"},{"name":"http","_id":"cjzfg6r5u003mw72s9lijildv"},{"name":"CSS3","_id":"cjzfg6r5u003pw72sz5nznagt"},{"name":"Frontend Interview","_id":"cjzfg6r5v003sw72s2tcops77"},{"name":"html","_id":"cjzfg6r5v003tw72snkrlevqh"},{"name":"ES6","_id":"cjzfg6r5v003uw72sqditd583"},{"name":"vuejs","_id":"cjzfg6r61004ew72s1h1xx0hn"},{"name":"HTML","_id":"cjzfg6r6u0054w72so10069w8"},{"name":"Threejs","_id":"cjzfg6r6v0059w72s9jpvc1ks"}]}}