{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/BuiltInComponents/1.gif","path":"img/BuiltInComponents/1.gif","modified":1,"renderable":0},{"_id":"source/img/BuiltInComponents/2.gif","path":"img/BuiltInComponents/2.gif","modified":1,"renderable":0},{"_id":"source/img/BuiltInComponents/3.png","path":"img/BuiltInComponents/3.png","modified":1,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":1,"renderable":0},{"_id":"source/img/avatar/alipay.jpg","path":"img/avatar/alipay.jpg","modified":1,"renderable":0},{"_id":"source/img/complie/1.png","path":"img/complie/1.png","modified":1,"renderable":0},{"_id":"source/img/avatar/wechat.jpg","path":"img/avatar/wechat.jpg","modified":1,"renderable":0},{"_id":"source/img/complie/2.png","path":"img/complie/2.png","modified":1,"renderable":0},{"_id":"source/img/complie/3.png","path":"img/complie/3.png","modified":1,"renderable":0},{"_id":"source/img/complie/5.png","path":"img/complie/5.png","modified":1,"renderable":0},{"_id":"source/img/complie/4.png","path":"img/complie/4.png","modified":1,"renderable":0},{"_id":"source/img/complie/8.jpg","path":"img/complie/8.jpg","modified":1,"renderable":0},{"_id":"source/img/complie/6.png","path":"img/complie/6.png","modified":1,"renderable":0},{"_id":"source/img/complie/7.png","path":"img/complie/7.png","modified":1,"renderable":0},{"_id":"source/img/filter/1.jpg","path":"img/filter/1.jpg","modified":1,"renderable":0},{"_id":"source/img/filter/2.jpg","path":"img/filter/2.jpg","modified":1,"renderable":0},{"_id":"source/img/filter/3.jpg","path":"img/filter/3.jpg","modified":1,"renderable":0},{"_id":"source/img/filter/4.jpg","path":"img/filter/4.jpg","modified":1,"renderable":0},{"_id":"source/img/lifecycle/7.png","path":"img/lifecycle/7.png","modified":1,"renderable":0},{"_id":"source/img/reactive/1.png","path":"img/reactive/1.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/10.png","path":"img/virtualDOM/10.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/11.png","path":"img/virtualDOM/11.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/12.png","path":"img/virtualDOM/12.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/13.png","path":"img/virtualDOM/13.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/14.png","path":"img/virtualDOM/14.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/15.png","path":"img/virtualDOM/15.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/2.png","path":"img/virtualDOM/2.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/4.png","path":"img/virtualDOM/4.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/5.png","path":"img/virtualDOM/5.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/6.png","path":"img/virtualDOM/6.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/8.png","path":"img/virtualDOM/8.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/9.png","path":"img/virtualDOM/9.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/7.jpg","path":"img/virtualDOM/7.jpg","modified":1,"renderable":0},{"_id":"themes/carlos/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"source/img/instanceMethods/1.jpg","path":"img/instanceMethods/1.jpg","modified":1,"renderable":0},{"_id":"source/img/lifecycle/2.png","path":"img/lifecycle/2.png","modified":1,"renderable":0},{"_id":"source/img/lifecycle/3.png","path":"img/lifecycle/3.png","modified":1,"renderable":0},{"_id":"source/img/lifecycle/4.png","path":"img/lifecycle/4.png","modified":1,"renderable":0},{"_id":"source/img/lifecycle/5.png","path":"img/lifecycle/5.png","modified":1,"renderable":0},{"_id":"source/img/lifecycle/6.png","path":"img/lifecycle/6.png","modified":1,"renderable":0},{"_id":"source/img/reactive/2.png","path":"img/reactive/2.png","modified":1,"renderable":0},{"_id":"source/img/reactive/3.jpg","path":"img/reactive/3.jpg","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/1.png","path":"img/virtualDOM/1.png","modified":1,"renderable":0},{"_id":"source/img/virtualDOM/3.png","path":"img/virtualDOM/3.png","modified":1,"renderable":0},{"_id":"themes/carlos/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/carlos/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":1,"renderable":0},{"_id":"themes/carlos/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/carlos/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"source/img/lifecycle/1.jpg","path":"img/lifecycle/1.jpg","modified":1,"renderable":0},{"_id":"themes/carlos/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":1,"renderable":0},{"_id":"source/img/lifecycle/8.png","path":"img/lifecycle/8.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/BuiltInComponents/4.gif","path":"img/BuiltInComponents/4.gif","modified":1,"renderable":0},{"_id":"source/img/start/1.png","path":"img/start/1.png","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1564997520509},{"_id":"source/CNAME","hash":"6d05053964eda7371ae3fdd373dae51cf5d3f413","modified":1564997520509},{"_id":"source/.DS_Store","hash":"5cbb0948f71fa6f790d02b3fe9491499c7e2a39b","modified":1577763264301},{"_id":"themes/carlos/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1564997520889},{"_id":"themes/carlos/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1564997520888},{"_id":"source/_posts/Docker 中如何安装WordPress.md","hash":"a5d0db018071fdeaf6384e44dd8dfbb1c7bbc207","modified":1577761225865},{"_id":"source/_posts/Docker 学习笔记 如何安装Docker.md","hash":"a30b02dbd6453c4f799c6373f14a1cf884f0d159","modified":1577761225865},{"_id":"source/_posts/GraphQL 简介.md","hash":"75bc3cc11f9a77afc2aeefef65258656924a1395","modified":1577761225866},{"_id":"source/_posts/JavaScript数据结构与算法-字典和哈希表.md","hash":"cc8ab6a384939e4b732f3e2356851b5ada4bad1b","modified":1577761225866},{"_id":"source/_posts/JavaScript数据结构与算法-栈（Stack）.md","hash":"be51b8102b8d27ed7699f981eb38db2bb29b1abf","modified":1577761225867},{"_id":"source/_posts/JavaScript数据结构与算法-树.md","hash":"f9ed48d679f6878b3699e87161bb486e784d239b","modified":1577761225867},{"_id":"source/_posts/JavaScript数据结构与算法-链表（LinkedList）.md","hash":"0ef74c71d3e559cba2d625e93ea88b92bfac3ee6","modified":1577761225867},{"_id":"source/_posts/JavaScript数据结构与算法-集合.md","hash":"ca36cb3e02b16dd40735bed8eba458e7a576164e","modified":1577761225867},{"_id":"source/_posts/JavaScript数据结构与算法队列（Queue）.md","hash":"c6bda3f42e3e46d2a1cf53a2c65dc6d0ad8060b9","modified":1577761225867},{"_id":"source/_posts/.DS_Store","hash":"4328dd4da2a0735ec9639e8dcf43fc9e60e7df47","modified":1577761803278},{"_id":"source/_posts/TypeScript 学习第三章 TypeScript基本类型.md","hash":"692325edde5f186c3477f584aca383ea000b7cd1","modified":1577761225868},{"_id":"source/_posts/TypeScript 学习第九章 TypeScript泛型.md","hash":"62c12bbb37e53f9c288b9f1b316627a15b35f05f","modified":1577761225869},{"_id":"source/_posts/TypeScript 学习第二章 编写第一个 TypeScript.md","hash":"d583cd24b784a5bfc0aea2b791b14ecbc31f5e82","modified":1577761225869},{"_id":"source/_posts/TypeScript 学习第七章 TypeScript变量声明.md","hash":"9ecab484a034338b4884b266a5111ecfb9c6836f","modified":1577761225868},{"_id":"source/_posts/TypeScript 学习第五章 TypeScript接口.md","hash":"ccbf243fa493b8b6ae315f5b54f8b420da429fb5","modified":1577761225869},{"_id":"source/_posts/TypeScript 学习第八章 TypeScript类型推断.md","hash":"c97ef4e43e13020cd4767c4b484c7a2f42ca6cc2","modified":1577761225870},{"_id":"source/_posts/GraphQL入门之GraphQL的查询.md","hash":"2896cdc6d10de79dadfbeaa415f798647b6a5773","modified":1577761225866},{"_id":"source/_posts/TypeScript 学习第一章 初识TypeScript.md","hash":"d65e1b71944efe2a604d2b82b749aa10e392a075","modified":1577761225868},{"_id":"source/_posts/TypeScript 学习第六章 TypeScript类.md","hash":"06dacdb1487d16fd9e8b17b4114664fa035b62a0","modified":1577761225870},{"_id":"source/_posts/TypeScript 学习第十章 TypeScript高级类型.md","hash":"122eb1e2884b302e25f6a46c69ec25e480a47edc","modified":1577761225871},{"_id":"source/_posts/TypeScript 学习第四章 TypeScript函数.md","hash":"36d8c46598d1ded5bbc1f6e4e01c9ba46ece425a","modified":1577761225871},{"_id":"source/_posts/Uni-App 基于Vue技术栈方向跨端技术实践.md","hash":"811e5d515c36cbaf0ce806ade65613c07266271f","modified":1577761225871},{"_id":"source/_posts/Vue 源码阅读 模板编译（一）.md","hash":"dcca401ff305cd73493531c24bac61072b3f806a","modified":1577762731876},{"_id":"source/_posts/Vue 源码阅读 模板编译（七）.md","hash":"3c31b534417e7da63186fe48b848489f2565624f","modified":1577762670890},{"_id":"source/_posts/Vue 源码阅读 模板编译（三）.md","hash":"36dee81adcdbdb7013c2f6b405aeb2a794f9b32d","modified":1577762701822},{"_id":"source/_posts/Vue 源码阅读 模板编译（二）.md","hash":"b07b3db3769996512835e5f900f109c27b566c47","modified":1577762585320},{"_id":"source/_posts/Vue 源码阅读 模板编译（五）.md","hash":"36323fb003f129b3cee0fd160c337aa27248904d","modified":1577762049546},{"_id":"source/_posts/Vue 源码阅读 模板编译（六）.md","hash":"f460f22e0908a9e5b646e9bd39b7524c98121ddd","modified":1577762051723},{"_id":"source/_posts/Vue 源码阅读 深入响应式原理(一).md","hash":"cb86470df5aef6c213de2a3585e3d70ac1c61e85","modified":1577762032665},{"_id":"source/_posts/Vue 源码阅读 深入响应式原理(三).md","hash":"1a193fc48e7fa2653bd2de6e6bce0fda6fe1e5ef","modified":1577762782353},{"_id":"source/_posts/Vue 源码阅读 深入响应式原理(二).md","hash":"4537bcd44171409e523629d222e60216a1c04d3a","modified":1577762851960},{"_id":"source/_posts/Vue 源码阅读 生命周期（一）.md","hash":"9fc895c7320a3e0e8bdeca5d155ccc6b369dc377","modified":1577961882049},{"_id":"source/_posts/Vue 源码阅读 生命周期（三）.md","hash":"34c279257fcc1b699b15a295ea0dd1129c74081d","modified":1577961872252},{"_id":"source/_posts/Vue 源码阅读 生命周期（二）.md","hash":"aaf61a5d0c38e8fd812e9b7f73bda1f4c2a26137","modified":1577961859955},{"_id":"source/_posts/Vue 源码阅读 虚拟DOM （一）.md","hash":"3a934f44c42bb9ef08cc01f744055ffe88f9f1e5","modified":1577762847417},{"_id":"source/_posts/Vue 源码阅读 虚拟DOM （三）.md","hash":"c452336a97c797d3c4fe6d0f7d42aa23730a6923","modified":1577762779998},{"_id":"source/_posts/Vue 源码阅读 虚拟DOM （二）.md","hash":"68d1c36bb4f275dbaf055fa224fb6f100b49c89e","modified":1577762854102},{"_id":"source/_posts/Vue 源码阅读 虚拟DOM （四）.md","hash":"c4ac40c60cf3d080c1ed8f31dba8273b81027b72","modified":1577762839498},{"_id":"source/_posts/Vue 源码阅读开始 第一篇 .md","hash":"05363ef81807823162198b887179e1d3841291be","modified":1577761950017},{"_id":"source/_posts/centOS中利用Docker安装gitlab.md","hash":"24da1cc9ebf0a36b429f1700c8da1e8459412133","modified":1577761225872},{"_id":"source/_posts/graphQL 如和在客户端调用.md","hash":"04ed731505e3ba9b9f580f0e331683afa59b58f0","modified":1577761225872},{"_id":"source/_posts/前端面试系列 — HMTL基础篇.md","hash":"3557fedafac5b51e7e2276f3e7fcab471a0d1792","modified":1577761225872},{"_id":"source/_posts/前端面试系列 — 布局篇.md","hash":"cde6b572e5f9a0de01f72f314a3411a968ce1440","modified":1577761225873},{"_id":"source/_posts/前端面试系列- CSS基础篇.md","hash":"d03034efbb1bee374236a7611efe0fe560cbf651","modified":1577761225873},{"_id":"source/_posts/前端面试系列-HTTP常考点.md","hash":"e72785bda53cc4b95b50d4e296472d6b8fa624ce","modified":1577761225874},{"_id":"source/_posts/前端面试系列-JS基础数据类型.md","hash":"117b966c2f8428d0ee3ed466b4ff56dfc86f3d27","modified":1577761225874},{"_id":"source/_posts/前端面试系列-JavaScript 数组.md","hash":"4ab0ba7506c3eb572de4e5c24e66a8b705d03216","modified":1577761225875},{"_id":"source/_posts/前端面试系列-JavaScript中的this指向问题.md","hash":"8efaadf5b1cc49d8840586d3f1d0367397fd8d8c","modified":1577761225875},{"_id":"source/_posts/前端面试系列-JavaScript继承.md","hash":"095911c2e083cb38e9c66420558aaffa16f0ba9c","modified":1577761225876},{"_id":"source/_posts/前端面试系列-前端跨域常用的几种方式.md","hash":"42a3780bb357e5bc300c4c63bce0e80750fac06e","modified":1577761225877},{"_id":"source/_posts/前端面试系列-游览器中的事件.md","hash":"cd5a025a0e4ac8feb9efaff703ec3659731f0090","modified":1577761225877},{"_id":"source/_posts/如何在Vue SPA中集成GraphQL.md","hash":"730fd59babdf590ec1e2b240c3f989ae4d5da095","modified":1577761225878},{"_id":"source/_posts/微信小程序开发技术选型分享.md","hash":"c39a7378fd22753d6ed79f85a3fa61f02fc0735d","modified":1577761225878},{"_id":"source/_posts/第一章 TheeJS 创建场景.md","hash":"244e57ee56c7024c6f6c995c2b6662b56b2c3d20","modified":1577761225878},{"_id":"source/_posts/阅读Vue Composition API了解Vue3的设计 （上篇）.md","hash":"ea1edab08a8bef9328cece8ac8609d3da96a66d2","modified":1577761225879},{"_id":"source/_posts/阅读Vue Composition API了解Vue3的设计 （下篇）.md","hash":"2202c6dd4b195ddaa45bbd28ef6778dbae26ceb0","modified":1577762201169},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1564997520520},{"_id":"source/img/.DS_Store","hash":"2e4738fd34baf7cb7ec8f4fd4d03cab569967e2f","modified":1577762572153},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1564997520884},{"_id":"source/about/index.md","hash":"f6cf3c985f5ab95b11f2d409829fe7b1cf12b5f3","modified":1577762432083},{"_id":"themes/carlos/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1564997520890},{"_id":"themes/carlos/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1564997520893},{"_id":"themes/carlos/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1564997520896},{"_id":"themes/carlos/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1564997520893},{"_id":"themes/carlos/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1564997520898},{"_id":"themes/carlos/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1564997520903},{"_id":"themes/carlos/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1564997520899},{"_id":"themes/carlos/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1564997520905},{"_id":"themes/carlos/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1564997520907},{"_id":"themes/carlos/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1564997520915},{"_id":"themes/carlos/layout/archive.ejs","hash":"a990910af3d5e402c27ffdc7e3f8831ffc3a88e2","modified":1564997520916},{"_id":"themes/carlos/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1564997520903},{"_id":"themes/carlos/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1564997520916},{"_id":"themes/carlos/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1564997520916},{"_id":"themes/carlos/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1564997520917},{"_id":"themes/carlos/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1564997520918},{"_id":"themes/carlos/layout/post.ejs","hash":"03107af08fec9a00f65d6692b01a419054dbf80e","modified":1564997520919},{"_id":"themes/carlos/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1564997520926},{"_id":"source/img/BuiltInComponents/1.gif","hash":"db435b94b7e6c0d3ede2d7f716fc3f736e2d1a2d","modified":1577758885347},{"_id":"source/img/BuiltInComponents/2.gif","hash":"b84755a18b46e184f2273fa6a635f84b080f1cd6","modified":1577758885347},{"_id":"source/img/BuiltInComponents/3.png","hash":"1ffde8d6f8e06e87f78076c0fb78a27b470bbb25","modified":1577758885347},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1564997520532},{"_id":"source/img/avatar/alipay.jpg","hash":"1a748a29b0634999ee26512f696b7b7249eb5a1c","modified":1564997520561},{"_id":"source/img/complie/1.png","hash":"a290de776571373f5e44b70551ed8ed1c3d28b6b","modified":1577758885352},{"_id":"source/img/avatar/wechat.jpg","hash":"3db1455b6616a182a7ef46773ef9750f1ec84831","modified":1564997520575},{"_id":"source/img/complie/2.png","hash":"359ec20394f23b81232bac8d91a4411923bfc472","modified":1577758885352},{"_id":"source/img/complie/3.png","hash":"fb4c95f3f67fc071a3a4da0c36bc2dc18a48635d","modified":1577758885352},{"_id":"source/img/complie/5.png","hash":"050882cdef8bf641bf809d4e391aec7c3216dce9","modified":1577758885353},{"_id":"source/img/complie/4.png","hash":"d0cfaca2f2011b7e241cc416847faf5265201773","modified":1577758885352},{"_id":"source/img/complie/8.jpg","hash":"ed6ba3c2541797cb0050487c9106e6c90f7c2977","modified":1577758885354},{"_id":"source/img/complie/6.png","hash":"2e28c722f540cfabc26f3a2551e6f0d43227ffc1","modified":1577758885353},{"_id":"source/img/complie/7.png","hash":"340a8f7b53a53900486abbb0f916d4d13ee58e9c","modified":1577758885353},{"_id":"source/img/filter/1.jpg","hash":"ea35b498b820162c6c1ed3f6645cbfd8a5cf1276","modified":1577758885354},{"_id":"source/img/filter/2.jpg","hash":"8a5ea5c6c730dc4430397018d5b2719382486908","modified":1577758885354},{"_id":"source/img/filter/3.jpg","hash":"cb1e1d43cc3ccac966cb372372730391d6adb611","modified":1577758885354},{"_id":"source/img/filter/4.jpg","hash":"6af64ba2f2995bde855cc68dbfdef1c687eb740f","modified":1577758885355},{"_id":"source/img/lifecycle/7.png","hash":"bdc54efb7428d499d9b7e999b6b68b53e0925ace","modified":1577758885362},{"_id":"source/img/reactive/1.png","hash":"b78ee4724d49b12df356b0271ee6b636cb8374bd","modified":1577758885362},{"_id":"source/img/virtualDOM/10.png","hash":"ef46dfee005fe2f44dce6f27150a683f33b5792f","modified":1577758885370},{"_id":"source/img/virtualDOM/11.png","hash":"07b5dd6fa83fab5fa7d14f5fe29ba3ce6060ac3c","modified":1577758885370},{"_id":"source/img/virtualDOM/12.png","hash":"8fd8f06f2c164789fc74e6db83a4f8a27370374d","modified":1577758885371},{"_id":"source/img/virtualDOM/13.png","hash":"e12e18aa0777329162b5b9aa58799d1cffde5731","modified":1577758885371},{"_id":"source/img/virtualDOM/14.png","hash":"0972d3e08ef5ab006fd9b466789abbc69f1452e0","modified":1577758885372},{"_id":"source/img/virtualDOM/15.png","hash":"bcf6727230a6a6a10af9f89ea7cb15f070a6a14e","modified":1577758885372},{"_id":"source/img/virtualDOM/2.png","hash":"24c6b0bd8912fbbfc845ce1fbcb3e8f17ecac4ac","modified":1577758885372},{"_id":"source/img/virtualDOM/4.png","hash":"7c84540b59f3875a19f2987207332f323f01ad6d","modified":1577758885373},{"_id":"source/img/virtualDOM/5.png","hash":"49f54c05de7d0fd5e68e74ef3a48aaa773577515","modified":1577758885373},{"_id":"source/img/virtualDOM/6.png","hash":"8abb089b0cab166c3b756c280b51955dcfcb7ec8","modified":1577758885374},{"_id":"source/img/virtualDOM/8.png","hash":"8a984c69de25c6191c533cb856126d48d2310c33","modified":1577758885375},{"_id":"source/img/virtualDOM/9.png","hash":"6cb2204e7403ad8a00daa7c723b3339c0155bcae","modified":1577758885376},{"_id":"source/img/virtualDOM/7.jpg","hash":"49682fd3f897c7bfa09209ed344a23c54b4d7824","modified":1577758885375},{"_id":"themes/carlos/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1564997520927},{"_id":"themes/carlos/source/css/beantech.css","hash":"f2aeda0e7bb732c0c16f77afb482f78b14dc42b7","modified":1564997520928},{"_id":"themes/carlos/source/css/beantech.min.css","hash":"b57004e24164568c938ad14d2c9f4df4b44a7e6c","modified":1564997520929},{"_id":"themes/carlos/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1564997520935},{"_id":"themes/carlos/source/css/hux-blog.min.css","hash":"eba8a9219b55d1f30c78927d6583ef03be5715f0","modified":1564997520936},{"_id":"themes/carlos/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1564997520939},{"_id":"themes/carlos/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1564997520939},{"_id":"themes/carlos/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1564997520935},{"_id":"themes/carlos/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1564997520939},{"_id":"themes/carlos/source/css/widget.styl","hash":"9940278d0b3cf92bdcf9cead877bb3a3338d1f23","modified":1564997520940},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1564997520948},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1564997520942},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1564997520949},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1564997520949},{"_id":"themes/carlos/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1564997520950},{"_id":"themes/carlos/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1564997520951},{"_id":"themes/carlos/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1564997520951},{"_id":"themes/carlos/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1564997520957},{"_id":"themes/carlos/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1564997520959},{"_id":"themes/carlos/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1564997520960},{"_id":"themes/carlos/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1564997520960},{"_id":"themes/carlos/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1564997520914},{"_id":"themes/carlos/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1564997520913},{"_id":"themes/carlos/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1564997520914},{"_id":"themes/carlos/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1564997520914},{"_id":"themes/carlos/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1564997520914},{"_id":"themes/carlos/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1564997520915},{"_id":"themes/carlos/layout/_partial/footer.ejs","hash":"f6197dccef7904fb7c2401e62d3219fab6f5ece0","modified":1564997520908},{"_id":"themes/carlos/layout/_partial/head.ejs","hash":"720349195a5ea7b610a82ce3ce74298fb2bc7347","modified":1564997520909},{"_id":"themes/carlos/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1564997520909},{"_id":"themes/carlos/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1564997520909},{"_id":"themes/carlos/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1564997520910},{"_id":"themes/carlos/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1564997520910},{"_id":"themes/carlos/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1564997520912},{"_id":"source/img/instanceMethods/1.jpg","hash":"39c858e09ba48b6ee0e802b25d8cf16a92d9b525","modified":1577758885356},{"_id":"source/img/lifecycle/2.png","hash":"462be13b9ac240c52782d685f825baf90271bafb","modified":1577758885359},{"_id":"source/img/lifecycle/3.png","hash":"8734e172c954b214aef5ee70139f179792243fa1","modified":1577758885359},{"_id":"source/img/lifecycle/4.png","hash":"2076a9458eaed0d74a34d37cae500625770aad9c","modified":1577758885360},{"_id":"source/img/lifecycle/5.png","hash":"648c4bf21657b9e840c7c14dd90f80859d683fcb","modified":1577758885361},{"_id":"source/img/lifecycle/6.png","hash":"262b1a83809b951d7313c8d341024bdf5a3a2212","modified":1577758885361},{"_id":"source/img/reactive/2.png","hash":"7cb485ff76211d8aefd1b8a9898ad9390b5e6932","modified":1577758885363},{"_id":"source/img/reactive/3.jpg","hash":"3155b6b150da068a075d8dab111f324d08da6df4","modified":1577758885363},{"_id":"source/img/virtualDOM/1.png","hash":"3e3878d7076c31376d0e15d77db65e32ec939628","modified":1577758885370},{"_id":"source/img/virtualDOM/3.png","hash":"d236c2ae0b800ce70109435829ec6279d3c4ca03","modified":1577758885373},{"_id":"themes/carlos/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1564997520933},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1564997520947},{"_id":"themes/carlos/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1564997520950},{"_id":"themes/carlos/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1564997520957},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1564997520690},{"_id":"themes/carlos/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1564997520932},{"_id":"themes/carlos/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1564997520938},{"_id":"themes/carlos/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1564997520938},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1564997520713},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1564997520741},{"_id":"source/img/lifecycle/1.jpg","hash":"0815632419332ab4df6fc1816ebac18fc16582ab","modified":1577758885358},{"_id":"themes/carlos/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1564997520954},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1564997520543},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1564997520531},{"_id":"source/img/lifecycle/8.png","hash":"55c96d032a68b4217ca1950ef55210377bbc7c42","modified":1577959188463},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1564997520806},{"_id":"source/img/BuiltInComponents/4.gif","hash":"fa850148389b1670ffef2f2bfeea856f2620e35e","modified":1577758885351},{"_id":"source/img/start/1.png","hash":"57cfe02f2c67601665879380deaa87ca98c71ca7","modified":1577758885369},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1564997520884},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1564997520557},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1564997520761},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1564997520847},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1564997520684},{"_id":"public/post-sitemap.xml","hash":"88ce04473044c666f9ee7d1ad9095c5306dbe269","modified":1577961981451},{"_id":"public/page-sitemap.xml","hash":"02a69012a91502f3cd6e80708e745cc68115220b","modified":1577961981452},{"_id":"public/category-sitemap.xml","hash":"2a2440dbb2126d59a698108d8cfad027c3f9a4db","modified":1577961983135},{"_id":"public/tag-sitemap.xml","hash":"389530ba0618c53ae5be85108699a5e6a840d305","modified":1577961983136},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1577961983502},{"_id":"public/sitemap.xml","hash":"90b980d33757380d3681f7a16d8b8079f3f5954b","modified":1577961983502},{"_id":"public/404.html","hash":"ed9675479a33dc24708f9b03487e07575e32bee0","modified":1577961983552},{"_id":"public/tags/index.html","hash":"b575ca4d51e151fe46c789423ca922bc7d72fe2c","modified":1577961983552},{"_id":"public/Vue/Vue 源码阅读 生命周期（三）/index.html","hash":"688354d6abfbc50daef4e4f9f811c9d6b4d25fd6","modified":1577961983552},{"_id":"public/Vue/Vue 源码阅读 生命周期（二）/index.html","hash":"e5793b73e38b72b91f4b056089ad197c2f18895b","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 生命周期（一）/index.html","hash":"005094e87a64665b1cb1c0117f673abb92ff8467","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 虚拟DOM （四）/index.html","hash":"2f62f94038e5898f50fc500690f8f6ed33a8279a","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 虚拟DOM （三）/index.html","hash":"907a33ad1f4baef9109591aad9e6dc0e936a67e6","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 虚拟DOM （二）/index.html","hash":"106088a7a03f732269a313e993bfb61c6e4c2883","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 虚拟DOM （一）/index.html","hash":"a885e685341329656e1b7e9329b8be5ac09c5ae3","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 模板编译（七）/index.html","hash":"0030d7c10ad5f23946110cb6550592fc16333c49","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 模板编译（六）/index.html","hash":"bddca6f9728fbcda9f4b414399886f07dd33fef9","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 模板编译（五）/index.html","hash":"86f91ce8ff8b3c4a5dd363fedc7eeca9ddd42da8","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 模板编译（二）/index.html","hash":"67764d40e68e0ca1fde70d81635382afc5317c79","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 模板编译（三）/index.html","hash":"5a96bd2783ac48d6c52bc29753c964cbcc275ab6","modified":1577961983553},{"_id":"public/Vue/Vue 源码阅读 模板编译（一）/index.html","hash":"e414c5cbfdfb118891b9276b67abf46724431d4f","modified":1577961983554},{"_id":"public/Vue/Vue 源码阅读 深入响应式原理(三)/index.html","hash":"6ec15837c3a99a8f21dca5767643d9c4305f2508","modified":1577961983554},{"_id":"public/Vue/Vue 源码阅读 深入响应式原理(二)/index.html","hash":"2a71fdf3f354e4698326a7ae8523a2ffb4cd261a","modified":1577961983554},{"_id":"public/Vue/Vue 源码阅读 深入响应式原理(一)/index.html","hash":"35dfb8784005f7838f119e39c82cb6a02470f1b8","modified":1577961983554},{"_id":"public/Vue/Vue 源码阅读开始 第一篇 /index.html","hash":"ffcf6f2d07389e926083c80c3339a662b908deb6","modified":1577961983554},{"_id":"public/Vue/阅读Vue Composition API了解Vue3的设计 （下篇）/index.html","hash":"0391f7db691cc888e8d11c245e8d84e326457be9","modified":1577961983554},{"_id":"public/Vue/阅读Vue Composition API了解Vue3的设计 （上篇）/index.html","hash":"50f71f500c1a31015df86e1fdc5873467430502b","modified":1577961983554},{"_id":"public/TypeScript/TypeScript 学习第十章 TypeScript高级类型/index.html","hash":"496c530d3b440e7f86a776b0d1535dbac473ae85","modified":1577961983554},{"_id":"public/TypeScript/TypeScript 学习第九章 TypeScript泛型/index.html","hash":"52eab98528c3d4a6dbddf5a798335435f9d0e6d5","modified":1577961983554},{"_id":"public/TypeScript/TypeScript 学习第八章 TypeScript类型推断/index.html","hash":"6b8326f49ecff0b9bffa24bf3e5c1707b68706ba","modified":1577961983554},{"_id":"public/TypeScript/TypeScript 学习第七章 TypeScript变量声明/index.html","hash":"e21cfca7536b1186bc6b34a757d8c1a5b88ee892","modified":1577961983554},{"_id":"public/TypeScript/TypeScript 学习第六章 TypeScript类/index.html","hash":"e3f52a16da57a1bea19b5aecc2196102510c7eb6","modified":1577961983554},{"_id":"public/TypeScript/TypeScript 学习第五章 TypeScript接口/index.html","hash":"2975e3aceb3d83d2a947e9c8406006f2d1695fd6","modified":1577961983555},{"_id":"public/TypeScript/TypeScript 学习第四章 TypeScript函数/index.html","hash":"8b3ed6e59c5d649af46f78d52486f9ab82dcd480","modified":1577961983555},{"_id":"public/TypeScript/TypeScript 学习第三章 TypeScript基本类型/index.html","hash":"9fbef90b9412689fe9d999ed538b65ccdcf1a5d2","modified":1577961983555},{"_id":"public/TypeScript/TypeScript 学习第二章 编写第一个 TypeScript/index.html","hash":"997e45ff35fe70acc7d17779be8cb5c5fd565b7e","modified":1577961983555},{"_id":"public/TypeScript/TypeScript 学习第一章 初识TypeScript/index.html","hash":"578f516bbe1b7ecac3e77146085e711513382ffb","modified":1577961983555},{"_id":"public/ThreeJS/第一章 TheeJS 创建场景/index.html","hash":"bda6dd162eaf60d285dce4c6f4b25104269fac63","modified":1577961983555},{"_id":"public/Vue/Uni-App 基于Vue技术栈方向跨端技术实践/index.html","hash":"5100a8db774868ffc4d74bfccb6e7e99b80528ac","modified":1577961983555},{"_id":"public/数据结构/JavaScript数据结构与算法-树/index.html","hash":"986828fb5dcb26992549af6f2154edc55cd18952","modified":1577961983555},{"_id":"public/数据结构/JavaScript数据结构与算法-字典和哈希表/index.html","hash":"2fb32361a2ab3c2b1dbe6c9fed34d7993de32e75","modified":1577961983555},{"_id":"public/数据结构/JavaScript数据结构与算法-集合/index.html","hash":"34ca08be6649cf6b2fb929f5cea6737617cd1caf","modified":1577961983556},{"_id":"public/数据结构/JavaScript数据结构与算法-链表（LinkedList）/index.html","hash":"a44408c650b1d31a660a9118af5fef51a51dddf1","modified":1577961983556},{"_id":"public/数据结构/JavaScript数据结构与算法队列（Queue）/index.html","hash":"5104864541fdb71fa689612cb3f90ca95435d4c3","modified":1577961983556},{"_id":"public/数据结构/JavaScript数据结构与算法-栈（Stack）/index.html","hash":"27d95136adc28f2c778dfe54ea0000039a4f4c72","modified":1577961983556},{"_id":"public/JavaScript/前端面试系列-JavaScript继承/index.html","hash":"1737b3227d4b66f26663aa17e2c5b13d229c31a8","modified":1577961983556},{"_id":"public/HTTP/前端面试系列-HTTP常考点/index.html","hash":"8717b0923e5f228deb4d26c274d67d78e58498df","modified":1577961983556},{"_id":"public/前端面试/前端面试系列-JavaScript 数组/index.html","hash":"bc8724eeecdbcf603d7300d455898d3885ad2a8e","modified":1577961983556},{"_id":"public/前端面试/前端面试系列- CSS基础篇/index.html","hash":"ffbd525a4f3510cb1b20b6fae28a362f3a099930","modified":1577961983556},{"_id":"public/前端面试/前端面试系列-JavaScript中的this指向问题/index.html","hash":"9008f8978a8e92912b3473dbb7d3aeabe41f9c9b","modified":1577961983556},{"_id":"public/前端面试/前端面试系列-游览器中的事件/index.html","hash":"a215c4c30fa6d288f89a721a44027c28d984a91c","modified":1577961983556},{"_id":"public/前端面试/前端面试系列-前端跨域常用的几种方式/index.html","hash":"e78bbf715d0c0698efb408ff6425701a4aa1cbf1","modified":1577961983557},{"_id":"public/前端面试/前端面试系列-JS基础数据类型/index.html","hash":"f29987149bdf7170af6335f7a157045d2eb67563","modified":1577961983557},{"_id":"public/CSS3/前端面试系列 — 布局篇/index.html","hash":"2fffffc5d4098640477563e819533bb69163e0a4","modified":1577961983557},{"_id":"public/HTML5/前端面试系列 — HMTL基础篇/index.html","hash":"2240ddf2c98191a0642ac64f73a6820dfd3bf42d","modified":1577961983557},{"_id":"public/微信小程序/微信小程序开发技术选型分享/index.html","hash":"060ca6fbb08102730f194297b2e6b5499487adac","modified":1577961983557},{"_id":"public/docker/Docker 学习笔记 如何安装Docker/index.html","hash":"ecf899a764aae801ded15cefd810e3af5f1c3da5","modified":1577961983557},{"_id":"public/docker/centOS中利用Docker安装gitlab/index.html","hash":"fe9a258a0302f6e2771b907750353c38f3c239e5","modified":1577961983557},{"_id":"public/GraphQL/如何在Vue SPA中集成GraphQL/index.html","hash":"0be2519d2f03b08f2a8b402d2c174d8fbc7a269c","modified":1577961983557},{"_id":"public/GraphQL/graphQL 如和在客户端调用/index.html","hash":"c533f5c82e81d30b42fdbad2fa72522a851648c6","modified":1577961983557},{"_id":"public/GraphQL/GraphQL入门之GraphQL的查询/index.html","hash":"33992ec160bfd5bc2968d97b9dfaea24b4917d0f","modified":1577961983557},{"_id":"public/docker/Docker 中如何安装WordPress/index.html","hash":"f11a22b4186a4e5029ddb95af246811492e42950","modified":1577961983557},{"_id":"public/GraphQL/GraphQL 简介/index.html","hash":"791cd74f6d614d3d6963b05a7a58c217584c61a7","modified":1577961983557},{"_id":"public/archive/index.html","hash":"ec607b6775a5aae2ce8f6c00d52edb38291adf5b","modified":1577961983557},{"_id":"public/about/index.html","hash":"68d9192c87fbe34068960a763a82bf08806f1702","modified":1577961983557},{"_id":"public/categories/docker/index.html","hash":"258174fdef22de762fd7cfd8b89a9599be4ec91a","modified":1577961983558},{"_id":"public/categories/数据结构/index.html","hash":"a75843344119599fee655547e0e143dd096f6eba","modified":1577961983558},{"_id":"public/categories/GraphQL/index.html","hash":"a88e87be9072cd4235da73d437aa93a672029868","modified":1577961983558},{"_id":"public/categories/TypeScript/index.html","hash":"3f93d5a09c7e3751a6963a29d3a2598db990d60a","modified":1577961983558},{"_id":"public/categories/Vue/index.html","hash":"918ac572f73f9e61cac76420f21fe0406f48a725","modified":1577961983560},{"_id":"public/categories/Vue/archives/2/index.html","hash":"7e65d89fd6f9dfdef714e115c33dbc04ea2da894","modified":1577961983560},{"_id":"public/categories/HTML5/index.html","hash":"6f87c7c3269d7fcd8ba8a86e467ae4cf95775f19","modified":1577961983560},{"_id":"public/categories/CSS3/index.html","hash":"4c86d773a8e97fb637cf1c0f0edd7c532a74bc6b","modified":1577961983560},{"_id":"public/categories/前端面试/index.html","hash":"93948c247dcda61415a7e1a658c9d2246deff998","modified":1577961983561},{"_id":"public/categories/HTTP/index.html","hash":"1ce4e81a70e4f6f704157542ef17df4c1e3c8897","modified":1577961983561},{"_id":"public/categories/JavaScript/index.html","hash":"7f65ad9824e89b5a3269606fc0a113206417a166","modified":1577961983561},{"_id":"public/categories/微信小程序/index.html","hash":"78a11bf30ff9dc44e1be15339b5f5e41dd797881","modified":1577961983561},{"_id":"public/categories/ThreeJS/index.html","hash":"5c3b2db55e839f1f0085201d32825d3507c75d77","modified":1577961983561},{"_id":"public/archives/index.html","hash":"d500a0a1ac2ac174129c8f7b87f1e950ce9b4570","modified":1577961983561},{"_id":"public/archives/archives/2/index.html","hash":"dbdd01f97559a31e441d9796966a173b6b26332a","modified":1577961983562},{"_id":"public/archives/archives/3/index.html","hash":"de8c156faf04017c8128a715976fb056870491d4","modified":1577961983562},{"_id":"public/archives/archives/4/index.html","hash":"2ee68e8af49bbd82df1bf100ee7cc90b741a4458","modified":1577961983562},{"_id":"public/archives/archives/5/index.html","hash":"4587cec88f1c29448c52072de7e06f34dc648bc2","modified":1577961983562},{"_id":"public/archives/archives/6/index.html","hash":"b40c0fa1e261081fd0f3290f8e0b305748889293","modified":1577961983562},{"_id":"public/archives/2019/index.html","hash":"8e3597167bfd246fe757168bceeed0799046c8c7","modified":1577961983562},{"_id":"public/archives/2019/archives/2/index.html","hash":"370c66e19f9aa30310170ad96badf71ba6175883","modified":1577961983563},{"_id":"public/archives/2019/archives/3/index.html","hash":"279103cced806e5f46141691a634a010287e97cf","modified":1577961983563},{"_id":"public/archives/2019/archives/4/index.html","hash":"dca17e5f10810b91007b4615ef3ef287fe84446d","modified":1577961983563},{"_id":"public/archives/2019/archives/5/index.html","hash":"1300930ebf11f3713073c1439dcffa4e2411e371","modified":1577961983563},{"_id":"public/archives/2019/archives/6/index.html","hash":"ca0d28427852da01aea33292a2b1ab925d93593e","modified":1577961983563},{"_id":"public/archives/2019/02/index.html","hash":"def6f429af67e99a06afdb0c26ae536c00c3835a","modified":1577961983563},{"_id":"public/archives/2019/02/archives/2/index.html","hash":"02a4346b5a95c68c235ad78935153a7b85376548","modified":1577961983563},{"_id":"public/archives/2019/03/index.html","hash":"e4a71ae7dd4f66b3882aa6c72190ea08f45bc8f7","modified":1577961983564},{"_id":"public/archives/2019/04/index.html","hash":"fcd812e607bbdaca15571e605b23b286be3ae367","modified":1577961983565},{"_id":"public/archives/2019/08/index.html","hash":"91351fa18e380a1660aa4a73a5a45a100b9ea51d","modified":1577961983565},{"_id":"public/archives/2019/08/archives/2/index.html","hash":"826f0054250cd4705a479e57e47c7fe7444021e9","modified":1577961983566},{"_id":"public/archives/2019/10/index.html","hash":"3e06eba04159f81ce3f9eb8286fb4b9d2d718728","modified":1577961983566},{"_id":"public/archives/2019/10/archives/2/index.html","hash":"b51672d4997bcd79a17049ff42adc5345289aad2","modified":1577961983566},{"_id":"public/archives/2020/index.html","hash":"e7d5f4a7319cafb2687d41da63576dc5273b1876","modified":1577961983566},{"_id":"public/archives/2020/01/index.html","hash":"96e47b449e187a71a911cb40272b5e244533b910","modified":1577961983566},{"_id":"public/index.html","hash":"5033127513bcad8f409989062d67e19f538e55db","modified":1577961983567},{"_id":"public/archives/2/index.html","hash":"b170524e9384e5ddf609502302ac1a3eef85f960","modified":1577961983567},{"_id":"public/archives/3/index.html","hash":"3493936d7537a2a318d36f45d893ae2bd616cce4","modified":1577961983567},{"_id":"public/archives/4/index.html","hash":"344b709d9a5806f6d1e25e7ed3d88caf74303a0a","modified":1577961983567},{"_id":"public/archives/5/index.html","hash":"b166aa04d158fc065d94e1fcff358af6f3696280","modified":1577961983567},{"_id":"public/archives/6/index.html","hash":"6bdc91570f7e4ecce6c8c410c9e5dd7e9650f907","modified":1577961983567},{"_id":"public/tags/Docker/index.html","hash":"84878aad779432ee1cf1b546bf8574538f981ae8","modified":1577961983567},{"_id":"public/tags/WordPress/index.html","hash":"b35c6e5a6c4ecbe10912d6bb43d03e6c4467662b","modified":1577961983567},{"_id":"public/tags/javascript/index.html","hash":"d29dfe453231f930b32422eb2baa331bfe5f7a86","modified":1577961983567},{"_id":"public/tags/数据结构/index.html","hash":"1004dc169b1c21733e2ce5ca7c06b35c16fb5d42","modified":1577961983568},{"_id":"public/tags/graphql/index.html","hash":"ff5e9b583413894aa3473218783d901ab2d3bd71","modified":1577961983568},{"_id":"public/tags/JavaScript/index.html","hash":"e6f31840edc7dbc13d54842f340ba806bf69cbb7","modified":1577961983568},{"_id":"public/tags/JavaScript/archives/2/index.html","hash":"224ceee368a3357d4289081f953893c3dd078ba6","modified":1577961983568},{"_id":"public/tags/JavaScript/archives/3/index.html","hash":"7b7aff9526ff54b4bca06c5029139fe1c146a2c9","modified":1577961983568},{"_id":"public/tags/TypeScript/index.html","hash":"007eb635661ab9c30c66095da341490fb20bc255","modified":1577961983568},{"_id":"public/tags/TypeScript/archives/2/index.html","hash":"d692131fabadbf02291bcdf15735c0744c552b60","modified":1577961983568},{"_id":"public/tags/Vue源码/index.html","hash":"a91c8c0c6f070ec164aa09cd36433ccd5531c52e","modified":1577961983568},{"_id":"public/tags/Vue源码/archives/2/index.html","hash":"41086c8a47b918b0e7440202d1895cef319cdd99","modified":1577961983569},{"_id":"public/tags/Vue/index.html","hash":"c15a7e10694310366773898ee36ec624970951b2","modified":1577961983569},{"_id":"public/tags/Vue/archives/2/index.html","hash":"50e317804f2a668da580a0a4161400e0b025ffa0","modified":1577961983569},{"_id":"public/tags/Weex/index.html","hash":"8396e1e14df05ffb54305ca671580ac761c9c2e0","modified":1577961983569},{"_id":"public/tags/微信小程序/index.html","hash":"064ff085ada78d4d0ade126ec054c27f99aaa98e","modified":1577961983569},{"_id":"public/tags/git/index.html","hash":"e7a9e9dcc1f5c09e23e87ca18898816fe0f209d7","modified":1577961983569},{"_id":"public/tags/gitlab/index.html","hash":"b23028853cc02f17206d4830c72e41834ebde7af","modified":1577961983569},{"_id":"public/tags/nodejs/index.html","hash":"3e1e5ea5490e80cb09c6acd30c7769980acc7daf","modified":1577961983570},{"_id":"public/tags/CSS3/index.html","hash":"621e6749c05665495a9a2019b657b1a5ef771c0e","modified":1577961983570},{"_id":"public/tags/Frontend-Interview/index.html","hash":"2cf5d5e1c2a4b016a8e237706a1029c78b8ae417","modified":1577961983570},{"_id":"public/tags/html/index.html","hash":"9199d90514175cc9323257c1cc318d35ed315666","modified":1577961983570},{"_id":"public/tags/http/index.html","hash":"7068a46b90d9ffbfcdd421e85e20cefbd3d4a062","modified":1577961983570},{"_id":"public/tags/ES6/index.html","hash":"108e2444f616d58c8812625330e631fd3e63ffc1","modified":1577961983570},{"_id":"public/tags/vuejs/index.html","hash":"837a343fb0b08c3723c7b3f2846f1c13be514e80","modified":1577961983571},{"_id":"public/tags/HTML/index.html","hash":"4450bd773782008603769d1ab2d64a4e1806ae30","modified":1577961983572},{"_id":"public/tags/Threejs/index.html","hash":"f10c423d57097a02d9a6608270ef5a45ad043ab0","modified":1577961983572},{"_id":"public/CNAME","hash":"6d05053964eda7371ae3fdd373dae51cf5d3f413","modified":1577961983595},{"_id":"public/img/BuiltInComponents/1.gif","hash":"db435b94b7e6c0d3ede2d7f716fc3f736e2d1a2d","modified":1577961983595},{"_id":"public/img/BuiltInComponents/2.gif","hash":"b84755a18b46e184f2273fa6a635f84b080f1cd6","modified":1577961983595},{"_id":"public/img/BuiltInComponents/3.png","hash":"1ffde8d6f8e06e87f78076c0fb78a27b470bbb25","modified":1577961983595},{"_id":"public/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1577961983595},{"_id":"public/img/avatar/alipay.jpg","hash":"1a748a29b0634999ee26512f696b7b7249eb5a1c","modified":1577961983595},{"_id":"public/img/complie/1.png","hash":"a290de776571373f5e44b70551ed8ed1c3d28b6b","modified":1577961983595},{"_id":"public/img/avatar/wechat.jpg","hash":"3db1455b6616a182a7ef46773ef9750f1ec84831","modified":1577961983595},{"_id":"public/img/complie/2.png","hash":"359ec20394f23b81232bac8d91a4411923bfc472","modified":1577961983595},{"_id":"public/img/complie/3.png","hash":"fb4c95f3f67fc071a3a4da0c36bc2dc18a48635d","modified":1577961983595},{"_id":"public/img/complie/5.png","hash":"050882cdef8bf641bf809d4e391aec7c3216dce9","modified":1577961983596},{"_id":"public/img/complie/4.png","hash":"d0cfaca2f2011b7e241cc416847faf5265201773","modified":1577961983596},{"_id":"public/img/complie/8.jpg","hash":"ed6ba3c2541797cb0050487c9106e6c90f7c2977","modified":1577961983596},{"_id":"public/img/complie/6.png","hash":"2e28c722f540cfabc26f3a2551e6f0d43227ffc1","modified":1577961983596},{"_id":"public/img/complie/7.png","hash":"340a8f7b53a53900486abbb0f916d4d13ee58e9c","modified":1577961983596},{"_id":"public/img/filter/1.jpg","hash":"ea35b498b820162c6c1ed3f6645cbfd8a5cf1276","modified":1577961983596},{"_id":"public/img/filter/2.jpg","hash":"8a5ea5c6c730dc4430397018d5b2719382486908","modified":1577961983596},{"_id":"public/img/filter/3.jpg","hash":"cb1e1d43cc3ccac966cb372372730391d6adb611","modified":1577961983596},{"_id":"public/img/filter/4.jpg","hash":"6af64ba2f2995bde855cc68dbfdef1c687eb740f","modified":1577961983596},{"_id":"public/img/lifecycle/7.png","hash":"bdc54efb7428d499d9b7e999b6b68b53e0925ace","modified":1577961983596},{"_id":"public/img/reactive/1.png","hash":"b78ee4724d49b12df356b0271ee6b636cb8374bd","modified":1577961983597},{"_id":"public/img/virtualDOM/10.png","hash":"ef46dfee005fe2f44dce6f27150a683f33b5792f","modified":1577961983597},{"_id":"public/img/virtualDOM/11.png","hash":"07b5dd6fa83fab5fa7d14f5fe29ba3ce6060ac3c","modified":1577961983597},{"_id":"public/img/virtualDOM/12.png","hash":"8fd8f06f2c164789fc74e6db83a4f8a27370374d","modified":1577961983597},{"_id":"public/img/virtualDOM/13.png","hash":"e12e18aa0777329162b5b9aa58799d1cffde5731","modified":1577961983597},{"_id":"public/img/virtualDOM/14.png","hash":"0972d3e08ef5ab006fd9b466789abbc69f1452e0","modified":1577961983597},{"_id":"public/img/virtualDOM/15.png","hash":"bcf6727230a6a6a10af9f89ea7cb15f070a6a14e","modified":1577961983597},{"_id":"public/img/virtualDOM/2.png","hash":"24c6b0bd8912fbbfc845ce1fbcb3e8f17ecac4ac","modified":1577961983597},{"_id":"public/img/virtualDOM/4.png","hash":"7c84540b59f3875a19f2987207332f323f01ad6d","modified":1577961983597},{"_id":"public/img/virtualDOM/5.png","hash":"49f54c05de7d0fd5e68e74ef3a48aaa773577515","modified":1577961983597},{"_id":"public/img/virtualDOM/6.png","hash":"8abb089b0cab166c3b756c280b51955dcfcb7ec8","modified":1577961983597},{"_id":"public/img/virtualDOM/8.png","hash":"8a984c69de25c6191c533cb856126d48d2310c33","modified":1577961983597},{"_id":"public/img/virtualDOM/9.png","hash":"6cb2204e7403ad8a00daa7c723b3339c0155bcae","modified":1577961983597},{"_id":"public/img/virtualDOM/7.jpg","hash":"49682fd3f897c7bfa09209ed344a23c54b4d7824","modified":1577961983598},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1577961983598},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1577961983598},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1577961983598},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1577961983598},{"_id":"public/img/lifecycle/2.png","hash":"462be13b9ac240c52782d685f825baf90271bafb","modified":1577961983598},{"_id":"public/img/lifecycle/3.png","hash":"8734e172c954b214aef5ee70139f179792243fa1","modified":1577961983598},{"_id":"public/img/lifecycle/4.png","hash":"2076a9458eaed0d74a34d37cae500625770aad9c","modified":1577961983598},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1577961983599},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1577961983599},{"_id":"public/img/instanceMethods/1.jpg","hash":"39c858e09ba48b6ee0e802b25d8cf16a92d9b525","modified":1577961984025},{"_id":"public/img/lifecycle/5.png","hash":"648c4bf21657b9e840c7c14dd90f80859d683fcb","modified":1577961984027},{"_id":"public/img/lifecycle/6.png","hash":"262b1a83809b951d7313c8d341024bdf5a3a2212","modified":1577961984027},{"_id":"public/img/reactive/2.png","hash":"7cb485ff76211d8aefd1b8a9898ad9390b5e6932","modified":1577961984027},{"_id":"public/img/reactive/3.jpg","hash":"3155b6b150da068a075d8dab111f324d08da6df4","modified":1577961984027},{"_id":"public/img/virtualDOM/1.png","hash":"3e3878d7076c31376d0e15d77db65e32ec939628","modified":1577961984027},{"_id":"public/img/virtualDOM/3.png","hash":"d236c2ae0b800ce70109435829ec6279d3c4ca03","modified":1577961984027},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1577961984027},{"_id":"public/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1577961984027},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1577961984036},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1577961984036},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1577961984036},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1577961984037},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1577961984037},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1577961984037},{"_id":"public/css/widget.css","hash":"6ab0367504355a703f180f10343d2f5558f30fbd","modified":1577961984037},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1577961984037},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1577961984037},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1577961984037},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1577961984037},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1577961984037},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1577961984037},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1577961984037},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1577961984038},{"_id":"public/css/beantech.css","hash":"f2aeda0e7bb732c0c16f77afb482f78b14dc42b7","modified":1577961984056},{"_id":"public/css/beantech.min.css","hash":"b57004e24164568c938ad14d2c9f4df4b44a7e6c","modified":1577961984056},{"_id":"public/css/hux-blog.min.css","hash":"eba8a9219b55d1f30c78927d6583ef03be5715f0","modified":1577961984057},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1577961984066},{"_id":"public/img/lifecycle/1.jpg","hash":"0815632419332ab4df6fc1816ebac18fc16582ab","modified":1577961984072},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1577961984114},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1577961984402},{"_id":"public/img/lifecycle/8.png","hash":"55c96d032a68b4217ca1950ef55210377bbc7c42","modified":1577961984402},{"_id":"public/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1577961984405},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1577961984414},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1577961984428},{"_id":"public/img/start/1.png","hash":"57cfe02f2c67601665879380deaa87ca98c71ca7","modified":1577961984429},{"_id":"public/img/BuiltInComponents/4.gif","hash":"fa850148389b1670ffef2f2bfeea856f2620e35e","modified":1577961984430},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1577961984433},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1577961984449},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1577961984465},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1577961984479},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1577961984479},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1577961984482},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1577961984486},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1577961984490}],"Category":[{"name":"Docker","_id":"ck4wltj4i0005zws69kuyche3"},{"name":"数据结构","_id":"ck4wltj4x000fzws6ofuocx1c"},{"name":"GraphQL","_id":"ck4wltj58000tzws66hnf0tmf"},{"name":"TypeScript","_id":"ck4wltj5f001azws6f5zfzkj3"},{"name":"Vue","_id":"ck4wltj5t0020zws6x93c07y0"},{"name":"HTML5","_id":"ck4wltj6b0033zws6yteh05jv"},{"name":"CSS3","_id":"ck4wltj6c0038zws6kfkjc16w"},{"name":"前端面试","_id":"ck4wltj6d003dzws6t6jkft8s"},{"name":"HTTP","_id":"ck4wltj6f003hzws692q62mbo"},{"name":"JavaScript","_id":"ck4wltj6i003vzws66n6bffpc"},{"name":"微信小程序","_id":"ck4wltj8c007gzws61151k2se"},{"name":"ThreeJS","_id":"ck4wltj8h007nzws6f0n6mywo"}],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-08-05T09:32:00.509Z","updated":"2019-08-05T09:32:00.509Z","path":"404.html","title":"","comments":1,"_id":"ck4wltj270000zws6sr5bjq44","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-08-05T09:32:00.520Z","path":"archive/index.html","_id":"ck4wltj4e0002zws6eom15mpw","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2019-08-05T09:32:00.884Z","updated":"2019-08-05T09:32:00.884Z","path":"tags/index.html","comments":1,"_id":"ck4wltj4g0004zws6hdpqnv0h","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About Me","date":"2019-05-01T02:48:33.000Z","description":"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。","header-img":"/img/header_img/about.jpg","aplayer":true,"fixed":false,"_content":"\n### 一句话\n\n> 吾生也有涯，而知也无涯。\n\n### 关于我\n\n>性格：外表冷淡 内心火热 雷厉风行 幽默\n\n### 兴趣方向\n\n> 前端（Vue、React等）相关生态技术学习。\n\n### 联系我\n>QQ: 1302151931\n>邮箱: lazykids520@gmail.com\n>微信: Carlos776582\n\n### 我的音乐\n> 用户名：八号当铺WTF\n> 数据来源于： 网易云音乐 --> 我喜欢的音乐\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About Me\"\ndate: 2019-05-01 10:48:33\ndescription: \"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: true\nfixed: false\n---\n\n### 一句话\n\n> 吾生也有涯，而知也无涯。\n\n### 关于我\n\n>性格：外表冷淡 内心火热 雷厉风行 幽默\n\n### 兴趣方向\n\n> 前端（Vue、React等）相关生态技术学习。\n\n### 联系我\n>QQ: 1302151931\n>邮箱: lazykids520@gmail.com\n>微信: Carlos776582\n\n### 我的音乐\n> 用户名：八号当铺WTF\n> 数据来源于： 网易云音乐 --> 我喜欢的音乐\n\n","updated":"2019-12-31T03:20:32.083Z","path":"about/index.html","comments":1,"_id":"ck4wltj4l0008zws6gbtowlbn","content":"<h3><span id=\"一句话\">一句话</span></h3>\n<blockquote>\n<p>吾生也有涯，而知也无涯。</p>\n</blockquote>\n<h3><span id=\"关于我\">关于我</span></h3>\n<blockquote>\n<p>性格：外表冷淡 内心火热 雷厉风行 幽默</p>\n</blockquote>\n<h3><span id=\"兴趣方向\">兴趣方向</span></h3>\n<blockquote>\n<p>前端（Vue、React等）相关生态技术学习。</p>\n</blockquote>\n<h3><span id=\"联系我\">联系我</span></h3>\n<blockquote>\n<p>QQ: 1302151931<br>\n邮箱: <a href=\"mailto:lazykids520@gmail.com\" target=\"_blank\" rel=\"noopener\">lazykids520@gmail.com</a><br>\n微信: Carlos776582</p>\n</blockquote>\n<h3><span id=\"我的音乐\">我的音乐</span></h3>\n<blockquote>\n<p>用户名：八号当铺WTF<br>\n数据来源于： 网易云音乐 --&gt; 我喜欢的音乐</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>吾生也有涯，而知也无涯。</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote>\n<p>性格：外表冷淡 内心火热 雷厉风行 幽默</p>\n</blockquote>\n<h3>兴趣方向</h3>\n<blockquote>\n<p>前端（Vue、React等）相关生态技术学习。</p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>QQ: 1302151931<br>\n邮箱: <a href=\"mailto:lazykids520@gmail.com\" target=\"_blank\" rel=\"noopener\">lazykids520@gmail.com</a><br>\n微信: Carlos776582</p>\n</blockquote>\n<h3>我的音乐</h3>\n<blockquote>\n<p>用户名：八号当铺WTF<br>\n数据来源于： 网易云音乐 --&gt; 我喜欢的音乐</p>\n</blockquote>\n"}],"Post":[{"title":"Docker 中如何安装WordPress","catalog":true,"url":"39.html","id":"39","date":"2019-02-18T10:12:44.000Z","subtitle":null,"header-img":null,"_content":"\n### Docker 中如何安装WordPress\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> ##### 1\\. 从dockerHub 中拉取mysql镜像\n\n       docker pull mysql:5.6\n    \n\n当然你也可选用最新的mysql版本\n\n    docker pull mysql\n    \n\n![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&fm=58&bpow=1024&bpoh=1024)\n\n> ##### 2\\. 从dockerHub 中拉取 wordpress镜像\n\n    docker pull wordpress:latest\n    \n\n> ##### 3\\. 创建mysql容器 并且做一些设置\n\n    docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n    \n    \n\n> ##### 4\\. 创建WordPress 容器并且做一些基础配置\n\n    docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n    \n\n> ##### 5\\. 访问localhost:8080 端口进行配置wordpress站点","source":"_posts/Docker 中如何安装WordPress.md","raw":"---\ntitle: Docker 中如何安装WordPress\ncatalog: true\ntags:\n  - Docker\n  - WordPress\nurl: 39.html\nid: 39\ncategories:\n  - Docker\ndate: 2019-02-18 18:12:44\nsubtitle:\nheader-img:\n---\n\n### Docker 中如何安装WordPress\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> ##### 1\\. 从dockerHub 中拉取mysql镜像\n\n       docker pull mysql:5.6\n    \n\n当然你也可选用最新的mysql版本\n\n    docker pull mysql\n    \n\n![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&fm=58&bpow=1024&bpoh=1024)\n\n> ##### 2\\. 从dockerHub 中拉取 wordpress镜像\n\n    docker pull wordpress:latest\n    \n\n> ##### 3\\. 创建mysql容器 并且做一些设置\n\n    docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n    \n    \n\n> ##### 4\\. 创建WordPress 容器并且做一些基础配置\n\n    docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n    \n\n> ##### 5\\. 访问localhost:8080 端口进行配置wordpress站点","slug":"Docker 中如何安装WordPress","published":1,"updated":"2019-12-31T03:00:25.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj490001zws61b3uyy4k","content":"<h3><span id=\"docker-中如何安装wordpress\">Docker 中如何安装WordPress</span></h3>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h5><span id=\"1-从dockerhub-中拉取mysql镜像\">1. 从dockerHub 中拉取mysql镜像</span></h5>\n</blockquote>\n<pre><code>   docker pull mysql:5.6\n</code></pre>\n<p>当然你也可选用最新的mysql版本</p>\n<pre><code>docker pull mysql\n</code></pre>\n<p><img src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&amp;fm=58&amp;bpow=1024&amp;bpoh=1024\" alt></p>\n<blockquote>\n<h5><span id=\"2-从dockerhub-中拉取-wordpress镜像\">2. 从dockerHub 中拉取 wordpress镜像</span></h5>\n</blockquote>\n<pre><code>docker pull wordpress:latest\n</code></pre>\n<blockquote>\n<h5><span id=\"3-创建mysql容器-并且做一些设置\">3. 创建mysql容器 并且做一些设置</span></h5>\n</blockquote>\n<pre><code>docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n</code></pre>\n<blockquote>\n<h5><span id=\"4-创建wordpress-容器并且做一些基础配置\">4. 创建WordPress 容器并且做一些基础配置</span></h5>\n</blockquote>\n<pre><code>docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n</code></pre>\n<blockquote>\n<h5><span id=\"5-访问localhost8080-端口进行配置wordpress站点\">5. 访问localhost:8080 端口进行配置wordpress站点</span></h5>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>Docker 中如何安装WordPress</h3>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h5>1. 从dockerHub 中拉取mysql镜像</h5>\n</blockquote>\n<pre><code>   docker pull mysql:5.6\n</code></pre>\n<p>当然你也可选用最新的mysql版本</p>\n<pre><code>docker pull mysql\n</code></pre>\n<p><img src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&amp;fm=58&amp;bpow=1024&amp;bpoh=1024\" alt></p>\n<blockquote>\n<h5>2. 从dockerHub 中拉取 wordpress镜像</h5>\n</blockquote>\n<pre><code>docker pull wordpress:latest\n</code></pre>\n<blockquote>\n<h5>3. 创建mysql容器 并且做一些设置</h5>\n</blockquote>\n<pre><code>docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n</code></pre>\n<blockquote>\n<h5>4. 创建WordPress 容器并且做一些基础配置</h5>\n</blockquote>\n<pre><code>docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n</code></pre>\n<blockquote>\n<h5>5. 访问localhost:8080 端口进行配置wordpress站点</h5>\n</blockquote>\n"},{"title":"Docker 学习笔记 如何安装Docker","catalog":true,"url":"114.html","id":"114","date":"2019-02-21T03:41:50.000Z","subtitle":null,"header-img":null,"_content":"\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> #### 1.安装环境 CentOS7\n\n      sudo yum install docker\n    \n\n> #### 2.启动Docker\n\n       sudo yum systemctl start docker\n    \n\n> #### 3.搜索镜像\n\n       docker search ubuntu\n    \n\n> #### 4.拉取镜像\n\n    docker pull ubuntu:16.04\n    \n\n> #### 5.docker 权限问题\n> \n> 运行如下命令\n\n     sudo groupadd docker #创建docker用户组\n     sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n     sudo service docker restart # 重启docker服务，退出ssh,重新连接即可","source":"_posts/Docker 学习笔记 如何安装Docker.md","raw":"---\ntitle: Docker 学习笔记 如何安装Docker\ncatalog: true\ntags:\n  - Docker\nurl: 114.html\nid: 114\ncategories:\n  - Docker\ndate: 2019-02-21 11:41:50\nsubtitle:\nheader-img:\n---\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> #### 1.安装环境 CentOS7\n\n      sudo yum install docker\n    \n\n> #### 2.启动Docker\n\n       sudo yum systemctl start docker\n    \n\n> #### 3.搜索镜像\n\n       docker search ubuntu\n    \n\n> #### 4.拉取镜像\n\n    docker pull ubuntu:16.04\n    \n\n> #### 5.docker 权限问题\n> \n> 运行如下命令\n\n     sudo groupadd docker #创建docker用户组\n     sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n     sudo service docker restart # 重启docker服务，退出ssh,重新连接即可","slug":"Docker 学习笔记 如何安装Docker","published":1,"updated":"2019-12-31T03:00:25.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj4f0003zws6ympn3x71","content":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h4><span id=\"1安装环境-centos7\">1.安装环境 CentOS7</span></h4>\n</blockquote>\n<pre><code>  sudo yum install docker\n</code></pre>\n<blockquote>\n<h4><span id=\"2启动docker\">2.启动Docker</span></h4>\n</blockquote>\n<pre><code>   sudo yum systemctl start docker\n</code></pre>\n<blockquote>\n<h4><span id=\"3搜索镜像\">3.搜索镜像</span></h4>\n</blockquote>\n<pre><code>   docker search ubuntu\n</code></pre>\n<blockquote>\n<h4><span id=\"4拉取镜像\">4.拉取镜像</span></h4>\n</blockquote>\n<pre><code>docker pull ubuntu:16.04\n</code></pre>\n<blockquote>\n<h4><span id=\"5docker-权限问题\">5.docker 权限问题</span></h4>\n<p>运行如下命令</p>\n</blockquote>\n<pre><code> sudo groupadd docker #创建docker用户组\n sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n sudo service docker restart # 重启docker服务，退出ssh,重新连接即可</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h4>1.安装环境 CentOS7</h4>\n</blockquote>\n<pre><code>  sudo yum install docker\n</code></pre>\n<blockquote>\n<h4>2.启动Docker</h4>\n</blockquote>\n<pre><code>   sudo yum systemctl start docker\n</code></pre>\n<blockquote>\n<h4>3.搜索镜像</h4>\n</blockquote>\n<pre><code>   docker search ubuntu\n</code></pre>\n<blockquote>\n<h4>4.拉取镜像</h4>\n</blockquote>\n<pre><code>docker pull ubuntu:16.04\n</code></pre>\n<blockquote>\n<h4>5.docker 权限问题</h4>\n<p>运行如下命令</p>\n</blockquote>\n<pre><code> sudo groupadd docker #创建docker用户组\n sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n sudo service docker restart # 重启docker服务，退出ssh,重新连接即可</code></pre>\n"},{"title":"JavaScript数据结构与算法-字典和哈希表","catalog":true,"url":"199.html","id":"199","date":"2019-03-10T07:56:49.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是字典？\n\n集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是\\[键，值\\] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以\\[值，值\\]的形式存储元素，字 典则是以\\[键，值\\]的形式来存储元素。字典也称作映射。\n\n#### 2\\. 手动实现Dirctionary\n\n    // 字典 Dirctionary\n    \n    class Dirctionary {\n        constructor(){\n            this.items = new Map();\n        }\n        set(key,value){\n            this.items.set(key,value);\n        }\n        get(key){\n            return this.items.get(key);\n        }\n        remove(key){\n            this.items.delete(key);\n        }\n        has(key){\n            return this.items.has(key);\n        }\n        size(){\n            return this.items.size();\n        }\n        clear(){\n            this.items = new Map();\n        }\n        values(){\n            const arr = []\n            for(let key of this.items.keys()){\n              arr.push(this.items.get(key));\n            }\n            return arr;\n        }\n    \n    }\n    \n    \n\n#### 3\\. 什么是散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。\n\n#### 4\\. 手动实现一个散列表\n\n    // 散列表\n    \n    var loseloseHashCode = function (key) {\n        var hash = 0;                          \n        for (var i = 0; i < key.length; i++) { \n            hash += key.charCodeAt(i);         \n        }\n        return hash % 37; \n    };\n    function HashTable() {\n        var table = [];\n    \n        this.put = function (key, value) {\n            var position = loseloseHashCode(key);\n            console.log(position + ' - ' + key);\n            table[position] = value; \n        };\n        this.get = function (key) {\n            return table[loseloseHashCode(key)];\n        };\n        this.remove = function (key) {\n            table[loseloseHashCode(key)] = undefined;\n        };\n    }\n    var hash = new HashTable();\n    hash.put('Gandalf', 'gandalf@email.com');\n    hash.put('John', 'johnsnow@email.com');\n    hash.put('Tyrion', 'tyrion@email.com');\n    // 19 - Gandalf\n    // 29 - John\n    // 16 - Tyrion","source":"_posts/JavaScript数据结构与算法-字典和哈希表.md","raw":"---\ntitle: JavaScript数据结构与算法-字典和哈希表\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 199.html\nid: 199\ncategories:\n  - 数据结构\ndate: 2019-03-10 15:56:49\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是字典？\n\n集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是\\[键，值\\] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以\\[值，值\\]的形式存储元素，字 典则是以\\[键，值\\]的形式来存储元素。字典也称作映射。\n\n#### 2\\. 手动实现Dirctionary\n\n    // 字典 Dirctionary\n    \n    class Dirctionary {\n        constructor(){\n            this.items = new Map();\n        }\n        set(key,value){\n            this.items.set(key,value);\n        }\n        get(key){\n            return this.items.get(key);\n        }\n        remove(key){\n            this.items.delete(key);\n        }\n        has(key){\n            return this.items.has(key);\n        }\n        size(){\n            return this.items.size();\n        }\n        clear(){\n            this.items = new Map();\n        }\n        values(){\n            const arr = []\n            for(let key of this.items.keys()){\n              arr.push(this.items.get(key));\n            }\n            return arr;\n        }\n    \n    }\n    \n    \n\n#### 3\\. 什么是散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。\n\n#### 4\\. 手动实现一个散列表\n\n    // 散列表\n    \n    var loseloseHashCode = function (key) {\n        var hash = 0;                          \n        for (var i = 0; i < key.length; i++) { \n            hash += key.charCodeAt(i);         \n        }\n        return hash % 37; \n    };\n    function HashTable() {\n        var table = [];\n    \n        this.put = function (key, value) {\n            var position = loseloseHashCode(key);\n            console.log(position + ' - ' + key);\n            table[position] = value; \n        };\n        this.get = function (key) {\n            return table[loseloseHashCode(key)];\n        };\n        this.remove = function (key) {\n            table[loseloseHashCode(key)] = undefined;\n        };\n    }\n    var hash = new HashTable();\n    hash.put('Gandalf', 'gandalf@email.com');\n    hash.put('John', 'johnsnow@email.com');\n    hash.put('Tyrion', 'tyrion@email.com');\n    // 19 - Gandalf\n    // 29 - John\n    // 16 - Tyrion","slug":"JavaScript数据结构与算法-字典和哈希表","published":1,"updated":"2019-12-31T03:00:25.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj4k0007zws62oe50hqj","content":"<h4><span id=\"1-什么是字典\">1. 什么是字典？</span></h4>\n<p>集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。</p>\n<h4><span id=\"2-手动实现dirctionary\">2. 手动实现Dirctionary</span></h4>\n<pre><code>// 字典 Dirctionary\n\nclass Dirctionary {\n    constructor(){\n        this.items = new Map();\n    }\n    set(key,value){\n        this.items.set(key,value);\n    }\n    get(key){\n        return this.items.get(key);\n    }\n    remove(key){\n        this.items.delete(key);\n    }\n    has(key){\n        return this.items.has(key);\n    }\n    size(){\n        return this.items.size();\n    }\n    clear(){\n        this.items = new Map();\n    }\n    values(){\n        const arr = []\n        for(let key of this.items.keys()){\n          arr.push(this.items.get(key));\n        }\n        return arr;\n    }\n\n}\n</code></pre>\n<h4><span id=\"3-什么是散列表\">3. 什么是散列表</span></h4>\n<p>散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。</p>\n<h4><span id=\"4-手动实现一个散列表\">4. 手动实现一个散列表</span></h4>\n<pre><code>// 散列表\n\nvar loseloseHashCode = function (key) {\n    var hash = 0;                          \n    for (var i = 0; i &lt; key.length; i++) { \n        hash += key.charCodeAt(i);         \n    }\n    return hash % 37; \n};\nfunction HashTable() {\n    var table = [];\n\n    this.put = function (key, value) {\n        var position = loseloseHashCode(key);\n        console.log(position + ' - ' + key);\n        table[position] = value; \n    };\n    this.get = function (key) {\n        return table[loseloseHashCode(key)];\n    };\n    this.remove = function (key) {\n        table[loseloseHashCode(key)] = undefined;\n    };\n}\nvar hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是字典？</h4>\n<p>集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。</p>\n<h4>2. 手动实现Dirctionary</h4>\n<pre><code>// 字典 Dirctionary\n\nclass Dirctionary {\n    constructor(){\n        this.items = new Map();\n    }\n    set(key,value){\n        this.items.set(key,value);\n    }\n    get(key){\n        return this.items.get(key);\n    }\n    remove(key){\n        this.items.delete(key);\n    }\n    has(key){\n        return this.items.has(key);\n    }\n    size(){\n        return this.items.size();\n    }\n    clear(){\n        this.items = new Map();\n    }\n    values(){\n        const arr = []\n        for(let key of this.items.keys()){\n          arr.push(this.items.get(key));\n        }\n        return arr;\n    }\n\n}\n</code></pre>\n<h4>3. 什么是散列表</h4>\n<p>散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。</p>\n<h4>4. 手动实现一个散列表</h4>\n<pre><code>// 散列表\n\nvar loseloseHashCode = function (key) {\n    var hash = 0;                          \n    for (var i = 0; i &lt; key.length; i++) { \n        hash += key.charCodeAt(i);         \n    }\n    return hash % 37; \n};\nfunction HashTable() {\n    var table = [];\n\n    this.put = function (key, value) {\n        var position = loseloseHashCode(key);\n        console.log(position + ' - ' + key);\n        table[position] = value; \n    };\n    this.get = function (key) {\n        return table[loseloseHashCode(key)];\n    };\n    this.remove = function (key) {\n        table[loseloseHashCode(key)] = undefined;\n    };\n}\nvar hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion</code></pre>\n"},{"title":"JavaScript数据结构与算法-栈（Stack）","catalog":true,"url":"181.html","id":"181","date":"2019-03-06T09:51:10.000Z","subtitle":null,"header-img":null,"_content":"\n### JavaScript 数据结构-栈\n\n#### 1\\. 什么是栈？\n\n栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #\n\n#### 2\\. 用JavaScript实现一个简单的栈\n\n    class Stack {\n      constructor() {\n        this.items = []\n      }\n      // 进栈\n      push(item) {\n        this.items.push(item);\n      }\n      // 出栈\n      pop() {\n        return this.items.pop();\n      }\n      // 返回栈顶的元素\n      peek() {\n        return this.items[this.items.length - 1]\n      }\n      // 判断栈是否为空\n      isEmpty() {\n        return this.items.length == 0;\n      }\n      // 移除栈里的所有元素\n      clear() {\n        this.items = []\n      }\n      // 返回栈的长度\n      size() {\n        return this.items.length;\n      },\n      print() {\n          return this.items.toString();\n      }\n    }\n    \n    let stack1 = new Stack();\n    console.log(stack1);  // Stack { items: [] }\n    \n    \n\n#### 3\\. 用栈解决问题\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。\n\n> 1.  十进制转二进制\n\n    function divideBy2(decNumber){\n        let stack = new Stack();\n        let binaryString = \"\";\n        let rem = \"\";\n        while(decNumber > 0){\n            rem = Math.floor(decNumber % 2);\n            stack.push(rem);\n            decNumber = Math.floor(decNumber / 2);\n        }\n        while(!stack.isEmpty()){\n            binaryString += stack.pop().toString() \n        }\n        return binaryString;\n    }\n    console.log(divideBy2(5)); // 101\n    \n\n> 2.  十进制转任意进制\n\n    function baseConverter(decNumber, base) {\n      let stack = new Stack();\n      let binaryString = '';\n      let rem = '';\n      const DIGITS = '0123456789ABCDEF';\n      while (decNumber > 0) {\n        rem = Math.floor(decNumber % base);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    \n      }\n      while (!stack.isEmpty()) {\n        binaryString += DIGITS[stack.pop()]\n      }\n      return binaryString;\n    }\n    console.log(baseConverter(455, 15)); //137EDB825","source":"_posts/JavaScript数据结构与算法-栈（Stack）.md","raw":"---\ntitle: JavaScript数据结构与算法-栈（Stack）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 181.html\nid: 181\ncategories:\n  - 数据结构\ndate: 2019-03-06 17:51:10\nsubtitle:\nheader-img:\n---\n\n### JavaScript 数据结构-栈\n\n#### 1\\. 什么是栈？\n\n栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #\n\n#### 2\\. 用JavaScript实现一个简单的栈\n\n    class Stack {\n      constructor() {\n        this.items = []\n      }\n      // 进栈\n      push(item) {\n        this.items.push(item);\n      }\n      // 出栈\n      pop() {\n        return this.items.pop();\n      }\n      // 返回栈顶的元素\n      peek() {\n        return this.items[this.items.length - 1]\n      }\n      // 判断栈是否为空\n      isEmpty() {\n        return this.items.length == 0;\n      }\n      // 移除栈里的所有元素\n      clear() {\n        this.items = []\n      }\n      // 返回栈的长度\n      size() {\n        return this.items.length;\n      },\n      print() {\n          return this.items.toString();\n      }\n    }\n    \n    let stack1 = new Stack();\n    console.log(stack1);  // Stack { items: [] }\n    \n    \n\n#### 3\\. 用栈解决问题\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。\n\n> 1.  十进制转二进制\n\n    function divideBy2(decNumber){\n        let stack = new Stack();\n        let binaryString = \"\";\n        let rem = \"\";\n        while(decNumber > 0){\n            rem = Math.floor(decNumber % 2);\n            stack.push(rem);\n            decNumber = Math.floor(decNumber / 2);\n        }\n        while(!stack.isEmpty()){\n            binaryString += stack.pop().toString() \n        }\n        return binaryString;\n    }\n    console.log(divideBy2(5)); // 101\n    \n\n> 2.  十进制转任意进制\n\n    function baseConverter(decNumber, base) {\n      let stack = new Stack();\n      let binaryString = '';\n      let rem = '';\n      const DIGITS = '0123456789ABCDEF';\n      while (decNumber > 0) {\n        rem = Math.floor(decNumber % base);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    \n      }\n      while (!stack.isEmpty()) {\n        binaryString += DIGITS[stack.pop()]\n      }\n      return binaryString;\n    }\n    console.log(baseConverter(455, 15)); //137EDB825","slug":"JavaScript数据结构与算法-栈（Stack）","published":1,"updated":"2019-12-31T03:00:25.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj4m0009zws6y3710rj1","content":"<h3><span id=\"javascript-数据结构-栈\">JavaScript 数据结构-栈</span></h3>\n<h4><span id=\"1-什么是栈\">1. 什么是栈？</span></h4>\n<p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #</p>\n<h4><span id=\"2-用javascript实现一个简单的栈\">2. 用JavaScript实现一个简单的栈</span></h4>\n<pre><code>class Stack {\n  constructor() {\n    this.items = []\n  }\n  // 进栈\n  push(item) {\n    this.items.push(item);\n  }\n  // 出栈\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n  // 判断栈是否为空\n  isEmpty() {\n    return this.items.length == 0;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = []\n  }\n  // 返回栈的长度\n  size() {\n    return this.items.length;\n  },\n  print() {\n      return this.items.toString();\n  }\n}\n\nlet stack1 = new Stack();\nconsole.log(stack1);  // Stack { items: [] }\n</code></pre>\n<h4><span id=\"3-用栈解决问题\">3. 用栈解决问题</span></h4>\n<p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。</p>\n<blockquote>\n<ol>\n<li>十进制转二进制</li>\n</ol>\n</blockquote>\n<pre><code>function divideBy2(decNumber){\n    let stack = new Stack();\n    let binaryString = &quot;&quot;;\n    let rem = &quot;&quot;;\n    while(decNumber &gt; 0){\n        rem = Math.floor(decNumber % 2);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    }\n    while(!stack.isEmpty()){\n        binaryString += stack.pop().toString() \n    }\n    return binaryString;\n}\nconsole.log(divideBy2(5)); // 101\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>十进制转任意进制</li>\n</ol>\n</blockquote>\n<pre><code>function baseConverter(decNumber, base) {\n  let stack = new Stack();\n  let binaryString = '';\n  let rem = '';\n  const DIGITS = '0123456789ABCDEF';\n  while (decNumber &gt; 0) {\n    rem = Math.floor(decNumber % base);\n    stack.push(rem);\n    decNumber = Math.floor(decNumber / 2);\n\n  }\n  while (!stack.isEmpty()) {\n    binaryString += DIGITS[stack.pop()]\n  }\n  return binaryString;\n}\nconsole.log(baseConverter(455, 15)); //137EDB825</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3>JavaScript 数据结构-栈</h3>\n<h4>1. 什么是栈？</h4>\n<p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #</p>\n<h4>2. 用JavaScript实现一个简单的栈</h4>\n<pre><code>class Stack {\n  constructor() {\n    this.items = []\n  }\n  // 进栈\n  push(item) {\n    this.items.push(item);\n  }\n  // 出栈\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n  // 判断栈是否为空\n  isEmpty() {\n    return this.items.length == 0;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = []\n  }\n  // 返回栈的长度\n  size() {\n    return this.items.length;\n  },\n  print() {\n      return this.items.toString();\n  }\n}\n\nlet stack1 = new Stack();\nconsole.log(stack1);  // Stack { items: [] }\n</code></pre>\n<h4>3. 用栈解决问题</h4>\n<p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。</p>\n<blockquote>\n<ol>\n<li>十进制转二进制</li>\n</ol>\n</blockquote>\n<pre><code>function divideBy2(decNumber){\n    let stack = new Stack();\n    let binaryString = &quot;&quot;;\n    let rem = &quot;&quot;;\n    while(decNumber &gt; 0){\n        rem = Math.floor(decNumber % 2);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    }\n    while(!stack.isEmpty()){\n        binaryString += stack.pop().toString() \n    }\n    return binaryString;\n}\nconsole.log(divideBy2(5)); // 101\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>十进制转任意进制</li>\n</ol>\n</blockquote>\n<pre><code>function baseConverter(decNumber, base) {\n  let stack = new Stack();\n  let binaryString = '';\n  let rem = '';\n  const DIGITS = '0123456789ABCDEF';\n  while (decNumber &gt; 0) {\n    rem = Math.floor(decNumber % base);\n    stack.push(rem);\n    decNumber = Math.floor(decNumber / 2);\n\n  }\n  while (!stack.isEmpty()) {\n    binaryString += DIGITS[stack.pop()]\n  }\n  return binaryString;\n}\nconsole.log(baseConverter(455, 15)); //137EDB825</code></pre>\n"},{"title":"GraphQL 简介","catalog":true,"url":"12.html","id":"12","date":"2019-02-18T08:12:40.000Z","subtitle":null,"header-img":null,"_content":"\n### GraphQL 简介\n\n![](http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png)\n\n#### 1\\. 什么是GraphQL ?\n\n1.  GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。\n    \n2.  GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。\n    \n3.  GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n    \n\n#### 2\\. GraphQL 有什么特点？\n\n1.  请求的数据，不多不少 \\> 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。\n2.  获取多个资源，只用一个请求。\n3.  描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。\n\n#### 3\\. GraphQL与Restful API 对比\n\n1.  restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。\n2.  restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。\n3.  restful用不同的url来区分资源，graphql用类型区分资源。\n\n#### 4\\. 构建一个GraphQL简单的服务端（Nodejs Express）\n\n1.  定义查询的Schema和类型\n\n       const Schema = buildSchema(\n       `\n        type Query {\n            hello: String\n        }\n       `);\n    \n\n2.  定义查询对应的处理器\n\n    const rootValue = {\n        hello: ()=>{\n            return \"hello graphql!\"\n        }\n    }\n    \n    \n\n3.  结合Schema和对应的处理器\n\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true // 打开graphql语言查询调试图形界面\n    }))\n    \n\n4.  打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句\n\n      nodemon app.js\n    \n\n    query {\n        hello\n    }\n    \n\n> 结果如图 [![](https://i.loli.net/2019/02/18/5c6a69c78a41b.png)](https://i.loli.net/2019/02/18/5c6a69c78a41b.png) 源码文件 app.js\n\n    // npm install express exprss-graphql graphql --save\n    const express = require('express');\n    const graphqlHTTP = require('express-graphql');\n    const { buildSchema } = require('graphql');\n    const app = express();\n    const schema = buildSchema(`\n        type Query {\n            hello: String\n        }\n       `);\n    const rootValue = {hello: () => \"hello graphql\"};\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    app.listen(3000, ()=>{\n        console.log(\"Now browser to localhost:3000/graphql!\");\n    })","source":"_posts/GraphQL 简介.md","raw":"---\ntitle: GraphQL 简介\ncatalog: true\ntags:\n  - graphql\nurl: 12.html\nid: 12\ncategories:\n  - GraphQL\ndate: 2019-02-18 16:12:40\nsubtitle:\nheader-img:\n---\n\n### GraphQL 简介\n\n![](http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png)\n\n#### 1\\. 什么是GraphQL ?\n\n1.  GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。\n    \n2.  GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。\n    \n3.  GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n    \n\n#### 2\\. GraphQL 有什么特点？\n\n1.  请求的数据，不多不少 \\> 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。\n2.  获取多个资源，只用一个请求。\n3.  描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。\n\n#### 3\\. GraphQL与Restful API 对比\n\n1.  restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。\n2.  restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。\n3.  restful用不同的url来区分资源，graphql用类型区分资源。\n\n#### 4\\. 构建一个GraphQL简单的服务端（Nodejs Express）\n\n1.  定义查询的Schema和类型\n\n       const Schema = buildSchema(\n       `\n        type Query {\n            hello: String\n        }\n       `);\n    \n\n2.  定义查询对应的处理器\n\n    const rootValue = {\n        hello: ()=>{\n            return \"hello graphql!\"\n        }\n    }\n    \n    \n\n3.  结合Schema和对应的处理器\n\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true // 打开graphql语言查询调试图形界面\n    }))\n    \n\n4.  打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句\n\n      nodemon app.js\n    \n\n    query {\n        hello\n    }\n    \n\n> 结果如图 [![](https://i.loli.net/2019/02/18/5c6a69c78a41b.png)](https://i.loli.net/2019/02/18/5c6a69c78a41b.png) 源码文件 app.js\n\n    // npm install express exprss-graphql graphql --save\n    const express = require('express');\n    const graphqlHTTP = require('express-graphql');\n    const { buildSchema } = require('graphql');\n    const app = express();\n    const schema = buildSchema(`\n        type Query {\n            hello: String\n        }\n       `);\n    const rootValue = {hello: () => \"hello graphql\"};\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    app.listen(3000, ()=>{\n        console.log(\"Now browser to localhost:3000/graphql!\");\n    })","slug":"GraphQL 简介","published":1,"updated":"2019-12-31T03:00:25.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj4q000azws639vp12y6","content":"<h3><span id=\"graphql-简介\">GraphQL 简介</span></h3>\n<p><img src=\"http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png\" alt></p>\n<h4><span id=\"1-什么是graphql\">1. 什么是GraphQL ?</span></h4>\n<ol>\n<li>\n<p>GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。</p>\n</li>\n<li>\n<p>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</p>\n</li>\n<li>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>\n</li>\n</ol>\n<h4><span id=\"2-graphql-有什么特点\">2. GraphQL 有什么特点？</span></h4>\n<ol>\n<li>请求的数据，不多不少 &gt; 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。</li>\n<li>获取多个资源，只用一个请求。</li>\n<li>描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。</li>\n</ol>\n<h4><span id=\"3-graphql与restful-api-对比\">3. GraphQL与Restful API 对比</span></h4>\n<ol>\n<li>restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。</li>\n<li>restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。</li>\n<li>restful用不同的url来区分资源，graphql用类型区分资源。</li>\n</ol>\n<h4><span id=\"4-构建一个graphql简单的服务端nodejs-express\">4. 构建一个GraphQL简单的服务端（Nodejs Express）</span></h4>\n<ol>\n<li>\n<p>定义查询的Schema和类型</p>\n<p>const Schema = buildSchema(<br>\n<code>type Query { hello: String }</code>);</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>定义查询对应的处理器</p>\n<p>const rootValue = {<br>\nhello: ()=&gt;{<br>\nreturn “hello graphql!”<br>\n}<br>\n}</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>结合Schema和对应的处理器</p>\n<p>app.use(’/graphql’, graphqlHTTP({<br>\nschema,<br>\nrootValue,<br>\ngraphiql: true // 打开graphql语言查询调试图形界面<br>\n}))</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句</p>\n<p>nodemon app.js</p>\n</li>\n</ol>\n<pre><code>query {\n    hello\n}\n</code></pre>\n<blockquote>\n<p>结果如图 <a href=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" alt></a> 源码文件 app.js</p>\n</blockquote>\n<pre><code>// npm install express exprss-graphql graphql --save\nconst express = require('express');\nconst graphqlHTTP = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n    type Query {\n        hello: String\n    }\n   `);\nconst rootValue = {hello: () =&gt; &quot;hello graphql&quot;};\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\napp.listen(3000, ()=&gt;{\n    console.log(&quot;Now browser to localhost:3000/graphql!&quot;);\n})</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3>GraphQL 简介</h3>\n<p><img src=\"http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png\" alt></p>\n<h4>1. 什么是GraphQL ?</h4>\n<ol>\n<li>\n<p>GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。</p>\n</li>\n<li>\n<p>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</p>\n</li>\n<li>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>\n</li>\n</ol>\n<h4>2. GraphQL 有什么特点？</h4>\n<ol>\n<li>请求的数据，不多不少 &gt; 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。</li>\n<li>获取多个资源，只用一个请求。</li>\n<li>描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。</li>\n</ol>\n<h4>3. GraphQL与Restful API 对比</h4>\n<ol>\n<li>restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。</li>\n<li>restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。</li>\n<li>restful用不同的url来区分资源，graphql用类型区分资源。</li>\n</ol>\n<h4>4. 构建一个GraphQL简单的服务端（Nodejs Express）</h4>\n<ol>\n<li>\n<p>定义查询的Schema和类型</p>\n<p>const Schema = buildSchema(<br>\n<code>type Query { hello: String }</code>);</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>定义查询对应的处理器</p>\n<p>const rootValue = {<br>\nhello: ()=&gt;{<br>\nreturn “hello graphql!”<br>\n}<br>\n}</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>结合Schema和对应的处理器</p>\n<p>app.use(’/graphql’, graphqlHTTP({<br>\nschema,<br>\nrootValue,<br>\ngraphiql: true // 打开graphql语言查询调试图形界面<br>\n}))</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句</p>\n<p>nodemon app.js</p>\n</li>\n</ol>\n<pre><code>query {\n    hello\n}\n</code></pre>\n<blockquote>\n<p>结果如图 <a href=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" alt></a> 源码文件 app.js</p>\n</blockquote>\n<pre><code>// npm install express exprss-graphql graphql --save\nconst express = require('express');\nconst graphqlHTTP = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n    type Query {\n        hello: String\n    }\n   `);\nconst rootValue = {hello: () =&gt; &quot;hello graphql&quot;};\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\napp.listen(3000, ()=&gt;{\n    console.log(&quot;Now browser to localhost:3000/graphql!&quot;);\n})</code></pre>\n"},{"title":"JavaScript数据结构与算法-链表（LinkedList）","catalog":true,"url":"191.html","id":"191","date":"2019-03-07T03:52:47.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1.什么是链表？\n\n要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的\\[\\]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png)\n\n#### 2\\. 实现一个链表结构（单向链表）\n\n    // JavaScript 数据结构值列表\n    function LinkedList() {\n      let Node = function (element) {\n        this.element = element;\n        this.next = null;\n      }\n      let length = 0;\n      let head = null;\n      // 添加元素\n      this.append = function (element) {\n        let node = new Node(element);\n        let current;\n        if (head == null) {\n          head = node\n        } else {\n          current = head;\n          while (current.next) {\n            current = current.next\n          }\n          current.next = node\n        }\n        length++;\n      }\n      // 插入元素\n      this.insert = function (position, element) {\n        if (position > -1 && position <= length) {\n          let node = new Node(element);\n          let current = head;\n          let pervious;\n          let index = 0;\n          if (position == 0) {\n            node.next = current;\n            head = node;\n          } else {\n            while (index++ < position) {\n              pervious = current;\n              current = current.next;\n            }\n            node.next = current;\n            pervious.next = node;\n            length++;\n            return true;\n          }\n        } else {\n          return false;\n        }\n      }\n      // 从列表中移除一项\n      this.getHead = function () {\n        return head;\n      }\n      // 从列表移除指定的一项\n      this.removeAt = function (position) {\n        if (position > -1 && position < length) {\n          let current = head;\n          let previous;\n          let index = 0;\n          // 边界检查合法的情况下\n          if (position == 0) {\n            head = current.next;\n          } else {\n            while (index++ < position) {\n              previous = current;\n              current = current.next;\n            }\n            previous.next = current.next;\n          }\n          length--;\n          return current.element;\n        } else {\n          return false;\n        }\n      }\n      // 返回元素在列表中的索引\n      this.indexOf = function (element) {\n        let current = head;\n        index = 0;\n        while (current) {\n          if (current.element === element) {\n            return index;\n          }\n          index++;\n          current = current.next();\n        }\n        return -1;\n      }\n      // 判断列表是否为空\n      this.isEmpty = function () {\n        return length === 0;\n      }\n      // 获取列表的长度\n      this.size = function () {\n        return length;\n      }\n      // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n      this.toString = function () {\n        let current = head,\n          string = '';\n        while (current) {\n          string += current.element + (current.next ? 'n' : '');\n          current = current.next;\n        }\n        return string;\n      }\n      this.remove = function (element) {\n        let index = this.indexOf(element);\n        return this.removeAt(index);\n      }\n    }\n    \n    let list = new LinkedList();\n    list.append(15);\n    list.append(14);\n    list.append(13);\n    list.append(13);\n    \n    console.log(list);\n    console.log(list.toString()); // 15n14n13n13\n    \n    \n\n#### 3 .双向链表\n\n链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/222222222.png)\n\n#### 4.循环链表\n\n`循环链表`可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/3333333.png)\n\n#### 5\\. 双向循坏列表\n\n双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/444444.png)","source":"_posts/JavaScript数据结构与算法-链表（LinkedList）.md","raw":"---\ntitle: JavaScript数据结构与算法-链表（LinkedList）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 191.html\nid: 191\ncategories:\n  - 数据结构\ndate: 2019-03-07 11:52:47\nsubtitle:\nheader-img:\n---\n\n#### 1.什么是链表？\n\n要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的\\[\\]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png)\n\n#### 2\\. 实现一个链表结构（单向链表）\n\n    // JavaScript 数据结构值列表\n    function LinkedList() {\n      let Node = function (element) {\n        this.element = element;\n        this.next = null;\n      }\n      let length = 0;\n      let head = null;\n      // 添加元素\n      this.append = function (element) {\n        let node = new Node(element);\n        let current;\n        if (head == null) {\n          head = node\n        } else {\n          current = head;\n          while (current.next) {\n            current = current.next\n          }\n          current.next = node\n        }\n        length++;\n      }\n      // 插入元素\n      this.insert = function (position, element) {\n        if (position > -1 && position <= length) {\n          let node = new Node(element);\n          let current = head;\n          let pervious;\n          let index = 0;\n          if (position == 0) {\n            node.next = current;\n            head = node;\n          } else {\n            while (index++ < position) {\n              pervious = current;\n              current = current.next;\n            }\n            node.next = current;\n            pervious.next = node;\n            length++;\n            return true;\n          }\n        } else {\n          return false;\n        }\n      }\n      // 从列表中移除一项\n      this.getHead = function () {\n        return head;\n      }\n      // 从列表移除指定的一项\n      this.removeAt = function (position) {\n        if (position > -1 && position < length) {\n          let current = head;\n          let previous;\n          let index = 0;\n          // 边界检查合法的情况下\n          if (position == 0) {\n            head = current.next;\n          } else {\n            while (index++ < position) {\n              previous = current;\n              current = current.next;\n            }\n            previous.next = current.next;\n          }\n          length--;\n          return current.element;\n        } else {\n          return false;\n        }\n      }\n      // 返回元素在列表中的索引\n      this.indexOf = function (element) {\n        let current = head;\n        index = 0;\n        while (current) {\n          if (current.element === element) {\n            return index;\n          }\n          index++;\n          current = current.next();\n        }\n        return -1;\n      }\n      // 判断列表是否为空\n      this.isEmpty = function () {\n        return length === 0;\n      }\n      // 获取列表的长度\n      this.size = function () {\n        return length;\n      }\n      // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n      this.toString = function () {\n        let current = head,\n          string = '';\n        while (current) {\n          string += current.element + (current.next ? 'n' : '');\n          current = current.next;\n        }\n        return string;\n      }\n      this.remove = function (element) {\n        let index = this.indexOf(element);\n        return this.removeAt(index);\n      }\n    }\n    \n    let list = new LinkedList();\n    list.append(15);\n    list.append(14);\n    list.append(13);\n    list.append(13);\n    \n    console.log(list);\n    console.log(list.toString()); // 15n14n13n13\n    \n    \n\n#### 3 .双向链表\n\n链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/222222222.png)\n\n#### 4.循环链表\n\n`循环链表`可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/3333333.png)\n\n#### 5\\. 双向循坏列表\n\n双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/444444.png)","slug":"JavaScript数据结构与算法-链表（LinkedList）","published":1,"updated":"2019-12-31T03:00:25.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj4u000dzws6o5obi102","content":"<h4><span id=\"1什么是链表\">1.什么是链表？</span></h4>\n<p>要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png\" alt></p>\n<h4><span id=\"2-实现一个链表结构单向链表\">2. 实现一个链表结构（单向链表）</span></h4>\n<pre><code>// JavaScript 数据结构值列表\nfunction LinkedList() {\n  let Node = function (element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head = null;\n  // 添加元素\n  this.append = function (element) {\n    let node = new Node(element);\n    let current;\n    if (head == null) {\n      head = node\n    } else {\n      current = head;\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n    }\n    length++;\n  }\n  // 插入元素\n  this.insert = function (position, element) {\n    if (position &gt; -1 &amp;&amp; position &lt;= length) {\n      let node = new Node(element);\n      let current = head;\n      let pervious;\n      let index = 0;\n      if (position == 0) {\n        node.next = current;\n        head = node;\n      } else {\n        while (index++ &lt; position) {\n          pervious = current;\n          current = current.next;\n        }\n        node.next = current;\n        pervious.next = node;\n        length++;\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  // 从列表中移除一项\n  this.getHead = function () {\n    return head;\n  }\n  // 从列表移除指定的一项\n  this.removeAt = function (position) {\n    if (position &gt; -1 &amp;&amp; position &lt; length) {\n      let current = head;\n      let previous;\n      let index = 0;\n      // 边界检查合法的情况下\n      if (position == 0) {\n        head = current.next;\n      } else {\n        while (index++ &lt; position) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      length--;\n      return current.element;\n    } else {\n      return false;\n    }\n  }\n  // 返回元素在列表中的索引\n  this.indexOf = function (element) {\n    let current = head;\n    index = 0;\n    while (current) {\n      if (current.element === element) {\n        return index;\n      }\n      index++;\n      current = current.next();\n    }\n    return -1;\n  }\n  // 判断列表是否为空\n  this.isEmpty = function () {\n    return length === 0;\n  }\n  // 获取列表的长度\n  this.size = function () {\n    return length;\n  }\n  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n  this.toString = function () {\n    let current = head,\n      string = '';\n    while (current) {\n      string += current.element + (current.next ? 'n' : '');\n      current = current.next;\n    }\n    return string;\n  }\n  this.remove = function (element) {\n    let index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n}\n\nlet list = new LinkedList();\nlist.append(15);\nlist.append(14);\nlist.append(13);\nlist.append(13);\n\nconsole.log(list);\nconsole.log(list.toString()); // 15n14n13n13\n</code></pre>\n<h4><span id=\"3-双向链表\">3 .双向链表</span></h4>\n<p>链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/222222222.png\" alt></p>\n<h4><span id=\"4循环链表\">4.循环链表</span></h4>\n<p><code>循环链表</code>可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333.png\" alt></p>\n<h4><span id=\"5-双向循坏列表\">5. 双向循坏列表</span></h4>\n<p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h4>1.什么是链表？</h4>\n<p>要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png\" alt></p>\n<h4>2. 实现一个链表结构（单向链表）</h4>\n<pre><code>// JavaScript 数据结构值列表\nfunction LinkedList() {\n  let Node = function (element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head = null;\n  // 添加元素\n  this.append = function (element) {\n    let node = new Node(element);\n    let current;\n    if (head == null) {\n      head = node\n    } else {\n      current = head;\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n    }\n    length++;\n  }\n  // 插入元素\n  this.insert = function (position, element) {\n    if (position &gt; -1 &amp;&amp; position &lt;= length) {\n      let node = new Node(element);\n      let current = head;\n      let pervious;\n      let index = 0;\n      if (position == 0) {\n        node.next = current;\n        head = node;\n      } else {\n        while (index++ &lt; position) {\n          pervious = current;\n          current = current.next;\n        }\n        node.next = current;\n        pervious.next = node;\n        length++;\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  // 从列表中移除一项\n  this.getHead = function () {\n    return head;\n  }\n  // 从列表移除指定的一项\n  this.removeAt = function (position) {\n    if (position &gt; -1 &amp;&amp; position &lt; length) {\n      let current = head;\n      let previous;\n      let index = 0;\n      // 边界检查合法的情况下\n      if (position == 0) {\n        head = current.next;\n      } else {\n        while (index++ &lt; position) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      length--;\n      return current.element;\n    } else {\n      return false;\n    }\n  }\n  // 返回元素在列表中的索引\n  this.indexOf = function (element) {\n    let current = head;\n    index = 0;\n    while (current) {\n      if (current.element === element) {\n        return index;\n      }\n      index++;\n      current = current.next();\n    }\n    return -1;\n  }\n  // 判断列表是否为空\n  this.isEmpty = function () {\n    return length === 0;\n  }\n  // 获取列表的长度\n  this.size = function () {\n    return length;\n  }\n  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n  this.toString = function () {\n    let current = head,\n      string = '';\n    while (current) {\n      string += current.element + (current.next ? 'n' : '');\n      current = current.next;\n    }\n    return string;\n  }\n  this.remove = function (element) {\n    let index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n}\n\nlet list = new LinkedList();\nlist.append(15);\nlist.append(14);\nlist.append(13);\nlist.append(13);\n\nconsole.log(list);\nconsole.log(list.toString()); // 15n14n13n13\n</code></pre>\n<h4>3 .双向链表</h4>\n<p>链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/222222222.png\" alt></p>\n<h4>4.循环链表</h4>\n<p><code>循环链表</code>可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333.png\" alt></p>\n<h4>5. 双向循坏列表</h4>\n<p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444.png\" alt></p>\n"},{"title":"JavaScript数据结构与算法-集合","catalog":true,"url":"195.html","id":"195","date":"2019-03-07T06:49:23.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是集合 ？\n\n集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。\n\n#### 2\\. 代码实现集合\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      values() {\n        return [...this.set]\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    console.log(setA.values());\n    console.log(setA.has(3));\n    \n    \n\n#### 3\\. 集合操作 交集\n\n交集的数学概念是集合A和集合B的交集\n\n     intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n    \n\n#### 4\\. 集合操作 并集\n\n并集的数学概念是集合A和集合B的并集\n\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n    \n\n#### 5\\. 集合操作 差集\n\n差集的数学概念是集合A和集合B的差集\n\n     difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n    \n\n#### 6\\. 集合操作 子集\n\n子集的数学概念是集合A是集合B的子集\n\n     subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    \n\n#### PS: 完整代码以及结果\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      value() {\n        return [...this.set]\n      }\n      // 交集\n      intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n      // 并集\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n      // 差集\n      difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n      // 子集\n      subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    setB.add(4);\n    setB.add(4);\n    setB.add(5);\n    console.log(setA.value());\n    console.log(setB.value());\n    console.log(setA.has(3));\n    console.log(setA.union(setB));\n    console.log(setA.intersection(setB));\n    console.log(setA.difference(setB));\n    console.log(setA.subset(setB));\n    // [ 2, 3, 4, 5 ]\n    // [ 4, 5 ]\n    // true\n    // Set { 2, 3, 4, 5 }\n    // Set { 4, 5 }\n    // Set { 2, 3 }\n    // true","source":"_posts/JavaScript数据结构与算法-集合.md","raw":"---\ntitle: JavaScript数据结构与算法-集合\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 195.html\nid: 195\ncategories:\n  - 数据结构\ndate: 2019-03-07 14:49:23\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是集合 ？\n\n集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。\n\n#### 2\\. 代码实现集合\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      values() {\n        return [...this.set]\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    console.log(setA.values());\n    console.log(setA.has(3));\n    \n    \n\n#### 3\\. 集合操作 交集\n\n交集的数学概念是集合A和集合B的交集\n\n     intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n    \n\n#### 4\\. 集合操作 并集\n\n并集的数学概念是集合A和集合B的并集\n\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n    \n\n#### 5\\. 集合操作 差集\n\n差集的数学概念是集合A和集合B的差集\n\n     difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n    \n\n#### 6\\. 集合操作 子集\n\n子集的数学概念是集合A是集合B的子集\n\n     subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    \n\n#### PS: 完整代码以及结果\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      value() {\n        return [...this.set]\n      }\n      // 交集\n      intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n      // 并集\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n      // 差集\n      difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n      // 子集\n      subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    setB.add(4);\n    setB.add(4);\n    setB.add(5);\n    console.log(setA.value());\n    console.log(setB.value());\n    console.log(setA.has(3));\n    console.log(setA.union(setB));\n    console.log(setA.intersection(setB));\n    console.log(setA.difference(setB));\n    console.log(setA.subset(setB));\n    // [ 2, 3, 4, 5 ]\n    // [ 4, 5 ]\n    // true\n    // Set { 2, 3, 4, 5 }\n    // Set { 4, 5 }\n    // Set { 2, 3 }\n    // true","slug":"JavaScript数据结构与算法-集合","published":1,"updated":"2019-12-31T03:00:25.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj4w000ezws6mtw29cmu","content":"<h4><span id=\"1-什么是集合\">1. 什么是集合 ？</span></h4>\n<p>集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。</p>\n<h4><span id=\"2-代码实现集合\">2. 代码实现集合</span></h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  values() {\n    return [...this.set]\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nconsole.log(setA.values());\nconsole.log(setA.has(3));\n</code></pre>\n<h4><span id=\"3-集合操作-交集\">3. 集合操作 交集</span></h4>\n<p>交集的数学概念是集合A和集合B的交集</p>\n<pre><code> intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n</code></pre>\n<h4><span id=\"4-集合操作-并集\">4. 集合操作 并集</span></h4>\n<p>并集的数学概念是集合A和集合B的并集</p>\n<pre><code>  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n</code></pre>\n<h4><span id=\"5-集合操作-差集\">5. 集合操作 差集</span></h4>\n<p>差集的数学概念是集合A和集合B的差集</p>\n<pre><code> difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n</code></pre>\n<h4><span id=\"6-集合操作-子集\">6. 集合操作 子集</span></h4>\n<p>子集的数学概念是集合A是集合B的子集</p>\n<pre><code> subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n</code></pre>\n<h4><span id=\"ps-完整代码以及结果\">PS: 完整代码以及结果</span></h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  value() {\n    return [...this.set]\n  }\n  // 交集\n  intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n  // 并集\n  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n  // 差集\n  difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n  // 子集\n  subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nsetB.add(4);\nsetB.add(4);\nsetB.add(5);\nconsole.log(setA.value());\nconsole.log(setB.value());\nconsole.log(setA.has(3));\nconsole.log(setA.union(setB));\nconsole.log(setA.intersection(setB));\nconsole.log(setA.difference(setB));\nconsole.log(setA.subset(setB));\n// [ 2, 3, 4, 5 ]\n// [ 4, 5 ]\n// true\n// Set { 2, 3, 4, 5 }\n// Set { 4, 5 }\n// Set { 2, 3 }\n// true</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是集合 ？</h4>\n<p>集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。</p>\n<h4>2. 代码实现集合</h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  values() {\n    return [...this.set]\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nconsole.log(setA.values());\nconsole.log(setA.has(3));\n</code></pre>\n<h4>3. 集合操作 交集</h4>\n<p>交集的数学概念是集合A和集合B的交集</p>\n<pre><code> intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n</code></pre>\n<h4>4. 集合操作 并集</h4>\n<p>并集的数学概念是集合A和集合B的并集</p>\n<pre><code>  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n</code></pre>\n<h4>5. 集合操作 差集</h4>\n<p>差集的数学概念是集合A和集合B的差集</p>\n<pre><code> difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n</code></pre>\n<h4>6. 集合操作 子集</h4>\n<p>子集的数学概念是集合A是集合B的子集</p>\n<pre><code> subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n</code></pre>\n<h4>PS: 完整代码以及结果</h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  value() {\n    return [...this.set]\n  }\n  // 交集\n  intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n  // 并集\n  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n  // 差集\n  difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n  // 子集\n  subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nsetB.add(4);\nsetB.add(4);\nsetB.add(5);\nconsole.log(setA.value());\nconsole.log(setB.value());\nconsole.log(setA.has(3));\nconsole.log(setA.union(setB));\nconsole.log(setA.intersection(setB));\nconsole.log(setA.difference(setB));\nconsole.log(setA.subset(setB));\n// [ 2, 3, 4, 5 ]\n// [ 4, 5 ]\n// true\n// Set { 2, 3, 4, 5 }\n// Set { 4, 5 }\n// Set { 2, 3 }\n// true</code></pre>\n"},{"title":"JavaScript数据结构与算法队列（Queue）","catalog":true,"url":"184.html","id":"184","date":"2019-03-06T09:53:17.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是队列？\n\n队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。\n\n#### 2\\. 代码实现一个队列Queue\n\n    class Queue {\n    \n      constructor() {\n        this.items = [];\n      }\n      // 向队列添加元素\n      push(element) {\n        this.items.push(element);\n      }\n      // 从队列移除元素\n      shift() {\n        return this.items.shift();\n      }\n      // 查看队列头元素\n      peek() {\n        return this.items[0];\n      }\n      // 检查队列是否为空\n      isEmpty() {\n        return this.items.length === 0;\n      }\n      // 打印队列\n      print() {\n        return this.items.toString();\n      }\n    \n    }\n    \n    \n\n#### 3\\. 什么是优先队列？\n\n队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。\n\n    function PriorityQueue() {\n      let items = [];\n      function QueueElement (element, priority){ // {1}\n        this.element = element;\n        this.priority = priority;\n      }\n      this.enqueue = function(element, priority){\n        let queueElement = new QueueElement(element, priority);\n        let added = false;\n        for (let i=0; i<items.length; i++){\n          if (queueElement.priority < items[i].priority){ // {2}\n            items.splice(i,0,queueElement); // {3}\n            added = true;\n            break; // {4}\n    } }\n        if (!added){\n          items.push(queueElement); //{5}\n    } };\n      this.print = function(){\n        for (let i=0; i<items.length; i++){\n          console.log(`${items[i].element} -\n          ${items[i].priority}`);\n        }\n    };\n    //其他方法和默认的Queue实现相同 }\n    \n\n#### 4\\. 什么是循环队列？\n\n还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。\n\n> 循环队列——击鼓传花\n\n    function hotPotato(nameList, num) {\n      var queue = new Queue();\n      var eliminated = \"\";\n      for (let i = 0; i < nameList.length; i++) {\n        queue.push(nameList[i]);\n      }\n      while (queue.size() > 0) {\n        for (let i = 0; i < num; i++) {\n          queue.push(queue.shift())\n        }\n        eliminated = queue.shift();\n        console.log(`eliminated: ${eliminated}`);\n      }\n      return eliminated\n    }\n    var nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\n    hotPotato(nameList, 3);\n    \n    // eliminated: golang\n    // eliminated: python\n    // eliminated: php\n    // eliminated: cpp\n    // eliminated: java\n    // eliminated: c#\n    // eliminated: javascript\n    // eliminated: basic\n    \n\n#### 5\\. JavaScript 任务队列\n\n当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。","source":"_posts/JavaScript数据结构与算法队列（Queue）.md","raw":"---\ntitle: JavaScript数据结构与算法队列（Queue）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 184.html\nid: 184\ncategories:\n  - 数据结构\ndate: 2019-03-06 17:53:17\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是队列？\n\n队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。\n\n#### 2\\. 代码实现一个队列Queue\n\n    class Queue {\n    \n      constructor() {\n        this.items = [];\n      }\n      // 向队列添加元素\n      push(element) {\n        this.items.push(element);\n      }\n      // 从队列移除元素\n      shift() {\n        return this.items.shift();\n      }\n      // 查看队列头元素\n      peek() {\n        return this.items[0];\n      }\n      // 检查队列是否为空\n      isEmpty() {\n        return this.items.length === 0;\n      }\n      // 打印队列\n      print() {\n        return this.items.toString();\n      }\n    \n    }\n    \n    \n\n#### 3\\. 什么是优先队列？\n\n队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。\n\n    function PriorityQueue() {\n      let items = [];\n      function QueueElement (element, priority){ // {1}\n        this.element = element;\n        this.priority = priority;\n      }\n      this.enqueue = function(element, priority){\n        let queueElement = new QueueElement(element, priority);\n        let added = false;\n        for (let i=0; i<items.length; i++){\n          if (queueElement.priority < items[i].priority){ // {2}\n            items.splice(i,0,queueElement); // {3}\n            added = true;\n            break; // {4}\n    } }\n        if (!added){\n          items.push(queueElement); //{5}\n    } };\n      this.print = function(){\n        for (let i=0; i<items.length; i++){\n          console.log(`${items[i].element} -\n          ${items[i].priority}`);\n        }\n    };\n    //其他方法和默认的Queue实现相同 }\n    \n\n#### 4\\. 什么是循环队列？\n\n还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。\n\n> 循环队列——击鼓传花\n\n    function hotPotato(nameList, num) {\n      var queue = new Queue();\n      var eliminated = \"\";\n      for (let i = 0; i < nameList.length; i++) {\n        queue.push(nameList[i]);\n      }\n      while (queue.size() > 0) {\n        for (let i = 0; i < num; i++) {\n          queue.push(queue.shift())\n        }\n        eliminated = queue.shift();\n        console.log(`eliminated: ${eliminated}`);\n      }\n      return eliminated\n    }\n    var nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\n    hotPotato(nameList, 3);\n    \n    // eliminated: golang\n    // eliminated: python\n    // eliminated: php\n    // eliminated: cpp\n    // eliminated: java\n    // eliminated: c#\n    // eliminated: javascript\n    // eliminated: basic\n    \n\n#### 5\\. JavaScript 任务队列\n\n当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。","slug":"JavaScript数据结构与算法队列（Queue）","published":1,"updated":"2019-12-31T03:00:25.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj4z000izws6qs3lu6m3","content":"<h4><span id=\"1-什么是队列\">1. 什么是队列？</span></h4>\n<p>队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。</p>\n<h4><span id=\"2-代码实现一个队列queue\">2. 代码实现一个队列Queue</span></h4>\n<pre><code>class Queue {\n\n  constructor() {\n    this.items = [];\n  }\n  // 向队列添加元素\n  push(element) {\n    this.items.push(element);\n  }\n  // 从队列移除元素\n  shift() {\n    return this.items.shift();\n  }\n  // 查看队列头元素\n  peek() {\n    return this.items[0];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 打印队列\n  print() {\n    return this.items.toString();\n  }\n\n}\n</code></pre>\n<h4><span id=\"3-什么是优先队列\">3. 什么是优先队列？</span></h4>\n<p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。</p>\n<pre><code>function PriorityQueue() {\n  let items = [];\n  function QueueElement (element, priority){ // {1}\n    this.element = element;\n    this.priority = priority;\n  }\n  this.enqueue = function(element, priority){\n    let queueElement = new QueueElement(element, priority);\n    let added = false;\n    for (let i=0; i&lt;items.length; i++){\n      if (queueElement.priority &lt; items[i].priority){ // {2}\n        items.splice(i,0,queueElement); // {3}\n        added = true;\n        break; // {4}\n} }\n    if (!added){\n      items.push(queueElement); //{5}\n} };\n  this.print = function(){\n    for (let i=0; i&lt;items.length; i++){\n      console.log(`${items[i].element} -\n      ${items[i].priority}`);\n    }\n};\n//其他方法和默认的Queue实现相同 }\n</code></pre>\n<h4><span id=\"4-什么是循环队列\">4. 什么是循环队列？</span></h4>\n<p>还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。</p>\n<blockquote>\n<p>循环队列——击鼓传花</p>\n</blockquote>\n<pre><code>function hotPotato(nameList, num) {\n  var queue = new Queue();\n  var eliminated = &quot;&quot;;\n  for (let i = 0; i &lt; nameList.length; i++) {\n    queue.push(nameList[i]);\n  }\n  while (queue.size() &gt; 0) {\n    for (let i = 0; i &lt; num; i++) {\n      queue.push(queue.shift())\n    }\n    eliminated = queue.shift();\n    console.log(`eliminated: ${eliminated}`);\n  }\n  return eliminated\n}\nvar nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\nhotPotato(nameList, 3);\n\n// eliminated: golang\n// eliminated: python\n// eliminated: php\n// eliminated: cpp\n// eliminated: java\n// eliminated: c#\n// eliminated: javascript\n// eliminated: basic\n</code></pre>\n<h4><span id=\"5-javascript-任务队列\">5. JavaScript 任务队列</span></h4>\n<p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是队列？</h4>\n<p>队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。</p>\n<h4>2. 代码实现一个队列Queue</h4>\n<pre><code>class Queue {\n\n  constructor() {\n    this.items = [];\n  }\n  // 向队列添加元素\n  push(element) {\n    this.items.push(element);\n  }\n  // 从队列移除元素\n  shift() {\n    return this.items.shift();\n  }\n  // 查看队列头元素\n  peek() {\n    return this.items[0];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 打印队列\n  print() {\n    return this.items.toString();\n  }\n\n}\n</code></pre>\n<h4>3. 什么是优先队列？</h4>\n<p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。</p>\n<pre><code>function PriorityQueue() {\n  let items = [];\n  function QueueElement (element, priority){ // {1}\n    this.element = element;\n    this.priority = priority;\n  }\n  this.enqueue = function(element, priority){\n    let queueElement = new QueueElement(element, priority);\n    let added = false;\n    for (let i=0; i&lt;items.length; i++){\n      if (queueElement.priority &lt; items[i].priority){ // {2}\n        items.splice(i,0,queueElement); // {3}\n        added = true;\n        break; // {4}\n} }\n    if (!added){\n      items.push(queueElement); //{5}\n} };\n  this.print = function(){\n    for (let i=0; i&lt;items.length; i++){\n      console.log(`${items[i].element} -\n      ${items[i].priority}`);\n    }\n};\n//其他方法和默认的Queue实现相同 }\n</code></pre>\n<h4>4. 什么是循环队列？</h4>\n<p>还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。</p>\n<blockquote>\n<p>循环队列——击鼓传花</p>\n</blockquote>\n<pre><code>function hotPotato(nameList, num) {\n  var queue = new Queue();\n  var eliminated = &quot;&quot;;\n  for (let i = 0; i &lt; nameList.length; i++) {\n    queue.push(nameList[i]);\n  }\n  while (queue.size() &gt; 0) {\n    for (let i = 0; i &lt; num; i++) {\n      queue.push(queue.shift())\n    }\n    eliminated = queue.shift();\n    console.log(`eliminated: ${eliminated}`);\n  }\n  return eliminated\n}\nvar nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\nhotPotato(nameList, 3);\n\n// eliminated: golang\n// eliminated: python\n// eliminated: php\n// eliminated: cpp\n// eliminated: java\n// eliminated: c#\n// eliminated: javascript\n// eliminated: basic\n</code></pre>\n<h4>5. JavaScript 任务队列</h4>\n<p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。</p>\n"},{"title":"TypeScript 学习第二章 编写第一个 TypeScript","catalog":true,"date":"2019-08-15T11:37:05.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/blog/201403/20/20140320120519_M2nYE.jpeg","_content":"\n# 编写第一个 TypeScript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\n\n```javascript\nfunction greeter (person) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\n## 编译代码\n\n我们使用了 `.ts` 扩展名，但是这段代码仅仅是 JavaScript 而已。\n\n在命令行上，运行 TypeScript 编译器：\n\n```bash\ntsc greeter.ts\n```\n\n输出结果为一个 `greeter.js` 文件，它包含了和输入文件中相同的 JavsScript 代码。\n\n在命令行上，通过 Node.js 运行这段代码：\n\n```bash\nnode greeter.js\n```\n\n控制台输出：\n\n```\nHello, Yee\n```\n\n## 类型注解\n\n接下来让我们看看 TypeScript 工具带来的高级功能。 给  `person` 函数的参数添加 `: string` 类型注解，如下：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\nTypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 `greeter` 函数接收一个字符串参数。 然后尝试把 `greeter` 的调用改成传入一个数组：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n```\n\n重新编译，你会看到产生了一个错误：\n\n```\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n```\n\n类似地，尝试删除 `greeter` 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，`greeter.js` 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。\n\n## 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 `firstName` 和 `lastName` 字段的对象。 在 `TypeScript` 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 `implements` 语句。\n\n```typescript\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = {\n  firstName: 'Yee',\n  lastName: 'Huang'\n}\n\nconsole.log(greeter(user))\n```\n\n## 类\n\n最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 `Student` 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\n```typescript\nclass User {\n  fullName: string\n  firstName: string\n  lastName: string\n\n  constructor (firstName: string, lastName: string) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = firstName + ' ' + lastName\n  }\n}\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = new User('Yee', 'Huang')\n\nconsole.log(greeter(user))\n```\n\n重新运行 `tsc greeter.ts`，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 `JavaScript` 函数的实现。\n\n## 总结\n\n到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。\n\n\n\n\n","source":"_posts/TypeScript 学习第二章 编写第一个 TypeScript.md","raw":"---\ntitle: TypeScript 学习第二章 编写第一个 TypeScript\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-15 19:37:05\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/blog/201403/20/20140320120519_M2nYE.jpeg\"\n---\n\n# 编写第一个 TypeScript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\n\n```javascript\nfunction greeter (person) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\n## 编译代码\n\n我们使用了 `.ts` 扩展名，但是这段代码仅仅是 JavaScript 而已。\n\n在命令行上，运行 TypeScript 编译器：\n\n```bash\ntsc greeter.ts\n```\n\n输出结果为一个 `greeter.js` 文件，它包含了和输入文件中相同的 JavsScript 代码。\n\n在命令行上，通过 Node.js 运行这段代码：\n\n```bash\nnode greeter.js\n```\n\n控制台输出：\n\n```\nHello, Yee\n```\n\n## 类型注解\n\n接下来让我们看看 TypeScript 工具带来的高级功能。 给  `person` 函数的参数添加 `: string` 类型注解，如下：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\nTypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 `greeter` 函数接收一个字符串参数。 然后尝试把 `greeter` 的调用改成传入一个数组：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n```\n\n重新编译，你会看到产生了一个错误：\n\n```\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n```\n\n类似地，尝试删除 `greeter` 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，`greeter.js` 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。\n\n## 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 `firstName` 和 `lastName` 字段的对象。 在 `TypeScript` 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 `implements` 语句。\n\n```typescript\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = {\n  firstName: 'Yee',\n  lastName: 'Huang'\n}\n\nconsole.log(greeter(user))\n```\n\n## 类\n\n最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 `Student` 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\n```typescript\nclass User {\n  fullName: string\n  firstName: string\n  lastName: string\n\n  constructor (firstName: string, lastName: string) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = firstName + ' ' + lastName\n  }\n}\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = new User('Yee', 'Huang')\n\nconsole.log(greeter(user))\n```\n\n重新运行 `tsc greeter.ts`，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 `JavaScript` 函数的实现。\n\n## 总结\n\n到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。\n\n\n\n\n","slug":"TypeScript 学习第二章 编写第一个 TypeScript","published":1,"updated":"2019-12-31T03:00:25.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj51000kzws6wqcgrf2z","content":"<h1><span id=\"编写第一个-typescript-程序\">编写第一个 TypeScript 程序</span></h1>\n<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"编译代码\">编译代码</span></h2>\n<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>\n<p>在命令行上，运行 TypeScript 编译器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc greeter.ts</span><br></pre></td></tr></table></figure>\n<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>\n<p>在命令行上，通过 Node.js 运行这段代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node greeter.js</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, Yee</span><br></pre></td></tr></table></figure>\n<h2><span id=\"类型注解\">类型注解</span></h2>\n<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新编译，你会看到产生了一个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>\n<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>\n<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>\n<h2><span id=\"接口\">接口</span></h2>\n<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Yee'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Huang'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"类\">类</span></h2>\n<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>\n<p>让我们创建一个 <code>Student</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>\n<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'Yee'</span>, <span class=\"string\">'Huang'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>\n<h2><span id=\"总结\">总结</span></h2>\n<p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>编写第一个 TypeScript 程序</h1>\n<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2>编译代码</h2>\n<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>\n<p>在命令行上，运行 TypeScript 编译器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc greeter.ts</span><br></pre></td></tr></table></figure>\n<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>\n<p>在命令行上，通过 Node.js 运行这段代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node greeter.js</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, Yee</span><br></pre></td></tr></table></figure>\n<h2>类型注解</h2>\n<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新编译，你会看到产生了一个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>\n<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>\n<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>\n<h2>接口</h2>\n<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Yee'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Huang'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2>类</h2>\n<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>\n<p>让我们创建一个 <code>Student</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>\n<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'Yee'</span>, <span class=\"string\">'Huang'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>\n<h2>总结</h2>\n<p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>\n"},{"title":"TypeScript 学习第八章 TypeScript 类型推断","catalog":true,"date":"2019-08-21T11:09:32.000Z","subtitle":null,"header-img":"http://hbimg.b0.upaiyun.com/5df06a8b37e2da0a167432e9ab712aca1abe4b507e404-NYeXeZ_fw658","_content":"\n# 类型推断\n\n这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。\n\n## 基础\n\nTypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：\n\n```typescript\nlet x = 3\n```\n\n变量 `x` 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。\n\n## 最佳通用类型\n\n有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\n```typescript\nlet x = [0, 1, null]\n```\n\n为了推断 `x` 的类型，我们必须考虑所有元素的类型。 这里有两种选择：`number` 和 `null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：\n\n```typescript\nclass Animal {\n  numLegs: number\n}\n\nclass Bee extends Animal {\n}\n\nclass Lion extends Animal {\n}\n\nlet zoo = [new Bee(), new Lion()]\n```\n这里，我们想让 `zoo` 被推断为 `Animal[]` 类型，但是这个数组里没有对象是 `Animal` 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：\n\n```typescript\nlet zoo: Animal[] = [new Bee(), new Lion()]\n```\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Bee | Lion)[]`\n\n## 上下文类型\n\n有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：\n\n```typescript\nwindow.onmousedown = function(mouseEvent) {\n  console.log(mouseEvent.clickTime)  // Error\n}\n```\n\n这个例子会得到一个类型错误，TypeScript 类型检查器使用 `window.onmousedown` 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 `mouseEvent` 参数的类型了，所以 `mouseEvent` 访问了一个不存在的属性，就报错了。\n\n如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：\n\n```typescript\nwindow.onmousedown = function(mouseEvent:any) {\n  console.log(mouseEvent.clickTime)  // OK\n}\n```\n\n这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。\n\n上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n  return [new Bee(), new Lion()]\n}\n\nlet zoo = createZoo()\n```\n\n这个例子里，最佳通用类型有 `3` 个候选者：`Animal`，`Bee` 和 `Lion`。 其中，`Animal` 会被做为最佳通用类型。\n","source":"_posts/TypeScript 学习第八章 TypeScript类型推断.md","raw":"---\ntitle: TypeScript 学习第八章 TypeScript 类型推断\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-21 19:09:32\nsubtitle:\nheader-img: \"http://hbimg.b0.upaiyun.com/5df06a8b37e2da0a167432e9ab712aca1abe4b507e404-NYeXeZ_fw658\"\n---\n\n# 类型推断\n\n这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。\n\n## 基础\n\nTypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：\n\n```typescript\nlet x = 3\n```\n\n变量 `x` 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。\n\n大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。\n\n## 最佳通用类型\n\n有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，\n\n```typescript\nlet x = [0, 1, null]\n```\n\n为了推断 `x` 的类型，我们必须考虑所有元素的类型。 这里有两种选择：`number` 和 `null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：\n\n```typescript\nclass Animal {\n  numLegs: number\n}\n\nclass Bee extends Animal {\n}\n\nclass Lion extends Animal {\n}\n\nlet zoo = [new Bee(), new Lion()]\n```\n这里，我们想让 `zoo` 被推断为 `Animal[]` 类型，但是这个数组里没有对象是 `Animal` 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：\n\n```typescript\nlet zoo: Animal[] = [new Bee(), new Lion()]\n```\n\n如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Bee | Lion)[]`\n\n## 上下文类型\n\n有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：\n\n```typescript\nwindow.onmousedown = function(mouseEvent) {\n  console.log(mouseEvent.clickTime)  // Error\n}\n```\n\n这个例子会得到一个类型错误，TypeScript 类型检查器使用 `window.onmousedown` 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 `mouseEvent` 参数的类型了，所以 `mouseEvent` 访问了一个不存在的属性，就报错了。\n\n如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：\n\n```typescript\nwindow.onmousedown = function(mouseEvent:any) {\n  console.log(mouseEvent.clickTime)  // OK\n}\n```\n\n这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。\n\n上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n  return [new Bee(), new Lion()]\n}\n\nlet zoo = createZoo()\n```\n\n这个例子里，最佳通用类型有 `3` 个候选者：`Animal`，`Bee` 和 `Lion`。 其中，`Animal` 会被做为最佳通用类型。\n","slug":"TypeScript 学习第八章 TypeScript类型推断","published":1,"updated":"2019-12-31T03:00:25.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj55000pzws6s1b2ua9h","content":"<h1><span id=\"类型推断\">类型推断</span></h1>\n<p>这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。</p>\n<h2><span id=\"基础\">基础</span></h2>\n<p>TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>变量 <code>x</code> 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>\n<p>大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。</p>\n<h2><span id=\"最佳通用类型\">最佳通用类型</span></h2>\n<p>有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>]</span><br></pre></td></tr></table></figure>\n<p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code> 和 <code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>\n<p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  numLegs: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bee <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Lion <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo: Animal[] = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Bee | Lion)[]</code></p>\n<h2><span id=\"上下文类型\">上下文类型</span></h2>\n<p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code> 参数的类型了，所以 <code>mouseEvent</code> 访问了一个不存在的属性，就报错了。</p>\n<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent:<span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p>\n<p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title\">Animal</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = createZoo()</span><br></pre></td></tr></table></figure>\n<p>这个例子里，最佳通用类型有 <code>3</code> 个候选者：<code>Animal</code>，<code>Bee</code> 和 <code>Lion</code>。 其中，<code>Animal</code> 会被做为最佳通用类型。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>类型推断</h1>\n<p>这节介绍 TypeScript 里的类型推断。即，类型是在哪里如何被推断的。</p>\n<h2>基础</h2>\n<p>TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>变量 <code>x</code> 的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>\n<p>大多数情况下，类型推断是直截了当地。后面的小节，我们会浏览类型推断时的细微差别。</p>\n<h2>最佳通用类型</h2>\n<p>有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如，</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>]</span><br></pre></td></tr></table></figure>\n<p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。 这里有两种选择：<code>number</code> 和 <code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>\n<p>由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  numLegs: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Bee <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Lion <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo: Animal[] = [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br></pre></td></tr></table></figure>\n<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Bee | Lion)[]</code></p>\n<h2>上下文类型</h2>\n<p>有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子会得到一个类型错误，TypeScript 类型检查器使用 <code>window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 <code>mouseEvent</code> 参数的类型了，所以 <code>mouseEvent</code> 访问了一个不存在的属性，就报错了。</p>\n<p>如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mouseEvent:<span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.clickTime)  <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。</p>\n<p>上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title\">Animal</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> Bee(), <span class=\"keyword\">new</span> Lion()]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> zoo = createZoo()</span><br></pre></td></tr></table></figure>\n<p>这个例子里，最佳通用类型有 <code>3</code> 个候选者：<code>Animal</code>，<code>Bee</code> 和 <code>Lion</code>。 其中，<code>Animal</code> 会被做为最佳通用类型。</p>\n"},{"title":"GraphQL入门之GraphQL的查询","catalog":true,"url":"69.html","id":"69","date":"2019-02-19T05:18:01.000Z","subtitle":null,"header-img":null,"_content":"\n#### \n\nGraphQL入门之GraphQL的查询\n\n![](http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&fm=26&gp=0.jpg)\n\n#### 先附上源代码文件\n\n> app.js\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    \n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n\n> 然后运行\n\n     nodemon app.js\n    \n\n> 打开游览器访问 localhost:3000/graphql\n\n#### 一. 字段（Fields）\n\n> 1.  简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFields{\n     hello\n    }\n    \n\n> 在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/2.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFieldsObject {\n      randomUser {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 二. 参数（Arguments）\n\n> 即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/8.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n    \n\n#### 三. 别名（Aliases）\n\n> 你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/5.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail: userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 四. 片段（Fragments）\n\n> 假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/6.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail:userInfo(id: 10001) {\n        ...useItem\n      }\n    }\n    \n    fragment useItem on User {\n      name\n      age\n      id\n      gender\n    }\n    \n    \n\n#### 五. 变量（Variables）\n\n> 目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：\n\n1.  使用 $variableName 替代查询中的静态值。\n2.  声明 $variableName 为查询接受的变量之一。\n3.  将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/9.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n    }\n    \n\n#### 六. 操作名称（Operation name）\n\n> 这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。\n\n#### 七. 指令（Directives）\n\n> 我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/10.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001,$showId:Boolean=false){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n      userList: users{\n        name @include(if:$showId)\n        age\n        gender\n      }\n    }\n    \n\n> #### 更多学习请参考 [GraphQL官网](http://graphql.cn/)","source":"_posts/GraphQL入门之GraphQL的查询.md","raw":"---\ntitle: GraphQL入门之GraphQL的查询\ncatalog: true\ntags:\n  - graphql\nurl: 69.html\nid: 69\ncategories:\n  - GraphQL\ndate: 2019-02-19 13:18:01\nsubtitle:\nheader-img:\n---\n\n#### \n\nGraphQL入门之GraphQL的查询\n\n![](http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&fm=26&gp=0.jpg)\n\n#### 先附上源代码文件\n\n> app.js\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    \n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n\n> 然后运行\n\n     nodemon app.js\n    \n\n> 打开游览器访问 localhost:3000/graphql\n\n#### 一. 字段（Fields）\n\n> 1.  简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFields{\n     hello\n    }\n    \n\n> 在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/2.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFieldsObject {\n      randomUser {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 二. 参数（Arguments）\n\n> 即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/8.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n    \n\n#### 三. 别名（Aliases）\n\n> 你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/5.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail: userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 四. 片段（Fragments）\n\n> 假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/6.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail:userInfo(id: 10001) {\n        ...useItem\n      }\n    }\n    \n    fragment useItem on User {\n      name\n      age\n      id\n      gender\n    }\n    \n    \n\n#### 五. 变量（Variables）\n\n> 目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：\n\n1.  使用 $variableName 替代查询中的静态值。\n2.  声明 $variableName 为查询接受的变量之一。\n3.  将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/9.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n    }\n    \n\n#### 六. 操作名称（Operation name）\n\n> 这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。\n\n#### 七. 指令（Directives）\n\n> 我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/10.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001,$showId:Boolean=false){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n      userList: users{\n        name @include(if:$showId)\n        age\n        gender\n      }\n    }\n    \n\n> #### 更多学习请参考 [GraphQL官网](http://graphql.cn/)","slug":"GraphQL入门之GraphQL的查询","published":1,"updated":"2019-12-31T03:00:25.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj57000rzws609o3ty1m","content":"<h4><span id></span></h4>\n<p>GraphQL入门之GraphQL的查询</p>\n<p><img src=\"http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h4><span id=\"先附上源代码文件\">先附上源代码文件</span></h4>\n<blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\n\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<p>然后运行</p>\n</blockquote>\n<pre><code> nodemon app.js\n</code></pre>\n<blockquote>\n<p>打开游览器访问 localhost:3000/graphql</p>\n</blockquote>\n<h4><span id=\"一-字段fields\">一. 字段（Fields）</span></h4>\n<blockquote>\n<ol>\n<li>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFields{\n hello\n}\n</code></pre>\n<blockquote>\n<p>在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/2.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFieldsObject {\n  randomUser {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"二-参数arguments\">二. 参数（Arguments）</span></h4>\n<blockquote>\n<p>即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/8.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"三-别名aliases\">三. 别名（Aliases）</span></h4>\n<blockquote>\n<p>你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/5.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail: userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"四-片段fragments\">四. 片段（Fragments）</span></h4>\n<blockquote>\n<p>假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/6.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail:userInfo(id: 10001) {\n    ...useItem\n  }\n}\n\nfragment useItem on User {\n  name\n  age\n  id\n  gender\n}\n</code></pre>\n<h4><span id=\"五-变量variables\">五. 变量（Variables）</span></h4>\n<blockquote>\n<p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：</p>\n</blockquote>\n<ol>\n<li>使用 $variableName 替代查询中的静态值。</li>\n<li>声明 $variableName 为查询接受的变量之一。</li>\n<li>将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/9.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n}\n</code></pre>\n<h4><span id=\"六-操作名称operation-name\">六. 操作名称（Operation name）</span></h4>\n<blockquote>\n<p>这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。</p>\n</blockquote>\n<h4><span id=\"七-指令directives\">七. 指令（Directives）</span></h4>\n<blockquote>\n<p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/10.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001,$showId:Boolean=false){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n  userList: users{\n    name @include(if:$showId)\n    age\n    gender\n  }\n}\n</code></pre>\n<blockquote>\n<h4><span id=\"更多学习请参考-graphql官网\">更多学习请参考 </span></h4>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4></h4>\n<p>GraphQL入门之GraphQL的查询</p>\n<p><img src=\"http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h4>先附上源代码文件</h4>\n<blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\n\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<p>然后运行</p>\n</blockquote>\n<pre><code> nodemon app.js\n</code></pre>\n<blockquote>\n<p>打开游览器访问 localhost:3000/graphql</p>\n</blockquote>\n<h4>一. 字段（Fields）</h4>\n<blockquote>\n<ol>\n<li>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFields{\n hello\n}\n</code></pre>\n<blockquote>\n<p>在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/2.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFieldsObject {\n  randomUser {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>二. 参数（Arguments）</h4>\n<blockquote>\n<p>即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/8.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>三. 别名（Aliases）</h4>\n<blockquote>\n<p>你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/5.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail: userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>四. 片段（Fragments）</h4>\n<blockquote>\n<p>假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/6.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail:userInfo(id: 10001) {\n    ...useItem\n  }\n}\n\nfragment useItem on User {\n  name\n  age\n  id\n  gender\n}\n</code></pre>\n<h4>五. 变量（Variables）</h4>\n<blockquote>\n<p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：</p>\n</blockquote>\n<ol>\n<li>使用 $variableName 替代查询中的静态值。</li>\n<li>声明 $variableName 为查询接受的变量之一。</li>\n<li>将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/9.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n}\n</code></pre>\n<h4>六. 操作名称（Operation name）</h4>\n<blockquote>\n<p>这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。</p>\n</blockquote>\n<h4>七. 指令（Directives）</h4>\n<blockquote>\n<p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/10.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001,$showId:Boolean=false){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n  userList: users{\n    name @include(if:$showId)\n    age\n    gender\n  }\n}\n</code></pre>\n<blockquote>\n<h4>更多学习请参考 <a href=\"http://graphql.cn/\" target=\"_blank\" rel=\"noopener\">GraphQL官网</a></h4>\n</blockquote>\n"},{"title":"TypeScript 学习第一章 初识TypeScript","catalog":true,"date":"2019-08-14T13:37:05.000Z","subtitle":null,"header-img":"http://www.3dmgame.com/uploads/allimg/170612/1316-1F6121I945.jpg","_content":"\n# 初识 TypeScript\n\nTypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。\n\n## TypeScript 的特点\n\nTypeScript 主要有 3 大特点：\n\n- **始于JavaScript，归于JavaScript**\n\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。\n\n- **强大的工具构建大型应用程序**\n\n类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。\n\n- **先进的 JavaScript**\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。\n\n\n## 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\n```bash\nnpm install -g typescript\n```\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\n```bash\ntsc -V \n```\n\n\n## 总结\n\nTypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。\n                                                                          \n\n","source":"_posts/TypeScript 学习第一章 初识TypeScript.md","raw":"---\ntitle: TypeScript 学习第一章 初识TypeScript\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-14 21:37:05\nsubtitle:\nheader-img: \"http://www.3dmgame.com/uploads/allimg/170612/1316-1F6121I945.jpg\"\n---\n\n# 初识 TypeScript\n\nTypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。\n\n## TypeScript 的特点\n\nTypeScript 主要有 3 大特点：\n\n- **始于JavaScript，归于JavaScript**\n\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。\n\n- **强大的工具构建大型应用程序**\n\n类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。\n\n- **先进的 JavaScript**\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。\n\n\n## 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\n```bash\nnpm install -g typescript\n```\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\n```bash\ntsc -V \n```\n\n\n## 总结\n\nTypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。\n                                                                          \n\n","slug":"TypeScript 学习第一章 初识TypeScript","published":1,"updated":"2019-12-31T03:00:25.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj58000vzws62m3ru6ya","content":"<h1><span id=\"初识-typescript\">初识 TypeScript</span></h1>\n<p>TypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p>\n<h2><span id=\"typescript-的特点\">TypeScript 的特点</span></h2>\n<p>TypeScript 主要有 3 大特点：</p>\n<ul>\n<li><strong>始于JavaScript，归于JavaScript</strong></li>\n</ul>\n<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>\n<ul>\n<li><strong>强大的工具构建大型应用程序</strong></li>\n</ul>\n<p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>\n<p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p>\n<ul>\n<li><strong>先进的 JavaScript</strong></li>\n</ul>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>\n<p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p>\n<h2><span id=\"安装-typescript\">安装 TypeScript</span></h2>\n<p>命令行运行如下命令，全局安装 TypeScript：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc -V</span><br></pre></td></tr></table></figure>\n<h2><span id=\"总结\">总结</span></h2>\n<p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>初识 TypeScript</h1>\n<p>TypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p>\n<h2>TypeScript 的特点</h2>\n<p>TypeScript 主要有 3 大特点：</p>\n<ul>\n<li><strong>始于JavaScript，归于JavaScript</strong></li>\n</ul>\n<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>\n<ul>\n<li><strong>强大的工具构建大型应用程序</strong></li>\n</ul>\n<p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>\n<p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p>\n<ul>\n<li><strong>先进的 JavaScript</strong></li>\n</ul>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>\n<p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p>\n<h2>安装 TypeScript</h2>\n<p>命令行运行如下命令，全局安装 TypeScript：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc -V</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。</p>\n"},{"title":"Vue 源码阅读 模板编译（一）","catalog":true,"date":"2019-10-19T12:39:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n\n## 1. 前言\n\n在前几篇文章中，我们介绍了`Vue`中的虚拟`DOM`以及虚拟`DOM`的`patch`(DOM-Diff)过程，而虚拟`DOM`存在的必要条件是得先有`VNode`，那么`VNode`又是从哪儿来的呢？这就是接下来几篇文章要说的模板编译。你可以这么理解：把用户写的模板进行编译，就会产生`VNode`。\n\n## 2. 什么是模板编译\n\n我们知道，在日常开发中，我们把写在`<template></template>`标签中的类似于原生`HTML`的内容称之为模板。这时你可能会问了，为什么说是“类似于原生`HTML`的内容”而不是“就是`HTML`的内容”？因为我们在开发中，在`<template></template>`标签中除了写一些原生`HTML`的标签，我们还会写一些变量插值，如{{xxx}}，或者写一些`Vue`指令，如`v-on`、`v-if`等。而这些东西都是在原生`HTML`语法中不存在的，不被接受的。但是事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？\n\n这就归功于`Vue`的模板编译了，`Vue`会把用户在`<template></template>`标签中写的类似于原生`HTML`的内容进行编译，把原生`HTML`的内容找出来，再把非原生`HTML`找出来，经过一系列的逻辑处理生成渲染函数，也就是`render`函数，而`render`函数会将模板内容生成对应的`VNode`，而`VNode`再经过前几篇文章介绍的`patch`过程从而得到将要渲染的视图中的`VNode`，最后根据`VNode`创建真实的`DOM`节点并插入到视图中， 最终完成视图的渲染更新。\n\n而把用户在`<template></template>`标签中写的类似于原生`HTML`的内容进行编译，把原生`HTML`的内容找出来，再把非原生`HTML`找出来，经过一系列的逻辑处理生成渲染函数，也就是`render`函数的这一段过程称之为模板编译过程。\n\n## 3. 整体渲染流程\n\n所谓渲染流程，就是把用户写的类似于原生`HTML`的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：\n![](/img/complie/1.png)\n\n从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成`render`函数的过程。\n\n## 4. 模板编译内部流程\n\n那么模板编译内部是怎么把用户写的模板经过处理最终生成`render`函数的呢？这内部的过程是怎样的呢？\n\n### 4.1 抽象语法树AST\n\n我们知道，用户在`<template></template>`标签中写的模板对`Vue`来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树的东西。\n\n所谓抽象语法树，在计算机科学中，**抽象语法树**（**A**bstract**S**yntax**T**ree，AST），或简称**语法树**（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示。——来自百度百科\n\n我就知道，这段话贴出来也是白贴，因为看了也看不懂，哈哈。那么我们就以最直观的例子来理解什么是抽象语法树。请看下图：\n![](/img/complie/2.png)\n\n从图中我们可以看到，一个简单的`HTML`标签的代码被转换成了一个`JS`对象，而这个对象中的属性代表了这个标签中一些关键有效信息。如图中标识。\n有兴趣的同学可以在这个网站在线转换试试：https://astexplorer.net/\n### 4.2 具体流程\n\n将一堆字符串模板解析成抽象语法树`AST`后，我们就可以对其进行各种操作处理了，处理完后用处理后的`AST`来生成`render`函数。其具体流程可大致分为三个阶段：\n\n1. 模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树`AST`；\n2. 优化阶段：遍历`AST`，找出其中的静态节点，并打上标记；\n3. 代码生成阶段：将`AST`转换成渲染函数；\n\n这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：\n\n1. 模板解析阶段——解析器——源码路径：`src/compiler/parser/index.js`;\n2. 优化阶段——优化器——源码路径：`src/compiler/optimizer.js`;\n3. 代码生成阶段——代码生成器——源码路径：`src/compiler/codegen/index.js`;\n其对应的源码如下：\n\n```javascript\n// 源码位置: /src/complier/index.js\n\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；\n    optimize(ast, options)\n  }\n  // 代码生成阶段：将AST转换成渲染函数；\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n\n```\n可以看到 `baseCompile` 的代码非常的简短主要核心代码。\n\n- **const ast =parse(template.trim(), options)**:`parse` 会用正则等方式解析 `template` 模板中的指令、`class`、`style`等数据，形成`AST`。\n- **optimize(ast, options)**: `optimize` 的主要作用是标记静态节点，这是 `Vue` 在编译过程中的一处优化，挡在进行`patch` 的过程中， `DOM-Diff` 算法会直接跳过静态节点，从而减少了比较的过程，优化了 `patch` 的性能。\n- **const code =generate(ast, options)**: 将 `AST` 转化成 `render`函数字符串的过程，得到结果是 `render`函数 的字符串以及 `staticRenderFns` 字符串。\n\n最终 `baseCompile` 的返回值\n\n```js\n{\n \tast: ast,\n \trender: code.render,\n \tstaticRenderFns: code.staticRenderFns\n }\n```\n\n最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且`render` 的值为`code.render `，`staticRenderFns` 的值为`code.staticRenderFns `，也就是说通过 `generate `处理 `ast `之后得到的返回值 `code` 是一个对象。\n\n\n下面再给出模板编译内部具体流程图，便于理解。流程图如下：\n![](/img/complie/3.png)\n\n## 5. 总结\n\n本篇文章首先引出了为什么会有模板编译，因为有了模板编译，才有了虚拟`DOM`，才有了后续的视图更新。接着介绍了什么是模板编译，以及介绍了把用户所写的模板经过层层处理直到最终渲染的视图中这个整体的渲染流程；最后介绍了模板编译过程中所需要使用的抽象语法树的概念以及分析了模板编译的具体实施流程，其流程大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段。那么接下来的几篇文章将会把这三个阶段逐一进行分析介绍。\n","source":"_posts/Vue 源码阅读 模板编译（一）.md","raw":"---\ntitle: Vue 源码阅读 模板编译（一）\ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-19 20:39:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n\n## 1. 前言\n\n在前几篇文章中，我们介绍了`Vue`中的虚拟`DOM`以及虚拟`DOM`的`patch`(DOM-Diff)过程，而虚拟`DOM`存在的必要条件是得先有`VNode`，那么`VNode`又是从哪儿来的呢？这就是接下来几篇文章要说的模板编译。你可以这么理解：把用户写的模板进行编译，就会产生`VNode`。\n\n## 2. 什么是模板编译\n\n我们知道，在日常开发中，我们把写在`<template></template>`标签中的类似于原生`HTML`的内容称之为模板。这时你可能会问了，为什么说是“类似于原生`HTML`的内容”而不是“就是`HTML`的内容”？因为我们在开发中，在`<template></template>`标签中除了写一些原生`HTML`的标签，我们还会写一些变量插值，如{{xxx}}，或者写一些`Vue`指令，如`v-on`、`v-if`等。而这些东西都是在原生`HTML`语法中不存在的，不被接受的。但是事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？\n\n这就归功于`Vue`的模板编译了，`Vue`会把用户在`<template></template>`标签中写的类似于原生`HTML`的内容进行编译，把原生`HTML`的内容找出来，再把非原生`HTML`找出来，经过一系列的逻辑处理生成渲染函数，也就是`render`函数，而`render`函数会将模板内容生成对应的`VNode`，而`VNode`再经过前几篇文章介绍的`patch`过程从而得到将要渲染的视图中的`VNode`，最后根据`VNode`创建真实的`DOM`节点并插入到视图中， 最终完成视图的渲染更新。\n\n而把用户在`<template></template>`标签中写的类似于原生`HTML`的内容进行编译，把原生`HTML`的内容找出来，再把非原生`HTML`找出来，经过一系列的逻辑处理生成渲染函数，也就是`render`函数的这一段过程称之为模板编译过程。\n\n## 3. 整体渲染流程\n\n所谓渲染流程，就是把用户写的类似于原生`HTML`的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：\n![](/img/complie/1.png)\n\n从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成`render`函数的过程。\n\n## 4. 模板编译内部流程\n\n那么模板编译内部是怎么把用户写的模板经过处理最终生成`render`函数的呢？这内部的过程是怎样的呢？\n\n### 4.1 抽象语法树AST\n\n我们知道，用户在`<template></template>`标签中写的模板对`Vue`来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树的东西。\n\n所谓抽象语法树，在计算机科学中，**抽象语法树**（**A**bstract**S**yntax**T**ree，AST），或简称**语法树**（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示。——来自百度百科\n\n我就知道，这段话贴出来也是白贴，因为看了也看不懂，哈哈。那么我们就以最直观的例子来理解什么是抽象语法树。请看下图：\n![](/img/complie/2.png)\n\n从图中我们可以看到，一个简单的`HTML`标签的代码被转换成了一个`JS`对象，而这个对象中的属性代表了这个标签中一些关键有效信息。如图中标识。\n有兴趣的同学可以在这个网站在线转换试试：https://astexplorer.net/\n### 4.2 具体流程\n\n将一堆字符串模板解析成抽象语法树`AST`后，我们就可以对其进行各种操作处理了，处理完后用处理后的`AST`来生成`render`函数。其具体流程可大致分为三个阶段：\n\n1. 模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树`AST`；\n2. 优化阶段：遍历`AST`，找出其中的静态节点，并打上标记；\n3. 代码生成阶段：将`AST`转换成渲染函数；\n\n这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：\n\n1. 模板解析阶段——解析器——源码路径：`src/compiler/parser/index.js`;\n2. 优化阶段——优化器——源码路径：`src/compiler/optimizer.js`;\n3. 代码生成阶段——代码生成器——源码路径：`src/compiler/codegen/index.js`;\n其对应的源码如下：\n\n```javascript\n// 源码位置: /src/complier/index.js\n\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；\n    optimize(ast, options)\n  }\n  // 代码生成阶段：将AST转换成渲染函数；\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n\n```\n可以看到 `baseCompile` 的代码非常的简短主要核心代码。\n\n- **const ast =parse(template.trim(), options)**:`parse` 会用正则等方式解析 `template` 模板中的指令、`class`、`style`等数据，形成`AST`。\n- **optimize(ast, options)**: `optimize` 的主要作用是标记静态节点，这是 `Vue` 在编译过程中的一处优化，挡在进行`patch` 的过程中， `DOM-Diff` 算法会直接跳过静态节点，从而减少了比较的过程，优化了 `patch` 的性能。\n- **const code =generate(ast, options)**: 将 `AST` 转化成 `render`函数字符串的过程，得到结果是 `render`函数 的字符串以及 `staticRenderFns` 字符串。\n\n最终 `baseCompile` 的返回值\n\n```js\n{\n \tast: ast,\n \trender: code.render,\n \tstaticRenderFns: code.staticRenderFns\n }\n```\n\n最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且`render` 的值为`code.render `，`staticRenderFns` 的值为`code.staticRenderFns `，也就是说通过 `generate `处理 `ast `之后得到的返回值 `code` 是一个对象。\n\n\n下面再给出模板编译内部具体流程图，便于理解。流程图如下：\n![](/img/complie/3.png)\n\n## 5. 总结\n\n本篇文章首先引出了为什么会有模板编译，因为有了模板编译，才有了虚拟`DOM`，才有了后续的视图更新。接着介绍了什么是模板编译，以及介绍了把用户所写的模板经过层层处理直到最终渲染的视图中这个整体的渲染流程；最后介绍了模板编译过程中所需要使用的抽象语法树的概念以及分析了模板编译的具体实施流程，其流程大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段。那么接下来的几篇文章将会把这三个阶段逐一进行分析介绍。\n","slug":"Vue 源码阅读 模板编译（一）","published":1,"updated":"2019-12-31T03:25:31.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj59000xzws6hgdgt1f9","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在前几篇文章中，我们介绍了<code>Vue</code>中的虚拟<code>DOM</code>以及虚拟<code>DOM</code>的<code>patch</code>(DOM-Diff)过程，而虚拟<code>DOM</code>存在的必要条件是得先有<code>VNode</code>，那么<code>VNode</code>又是从哪儿来的呢？这就是接下来几篇文章要说的模板编译。你可以这么理解：把用户写的模板进行编译，就会产生<code>VNode</code>。</p>\n<h2><span id=\"2-什么是模板编译\">2. 什么是模板编译</span></h2>\n<p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些变量插值，如，或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但是事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p>\n<p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>render</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过前几篇文章介绍的<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中， 最终完成视图的渲染更新。</p>\n<p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p>\n<h2><span id=\"3-整体渲染流程\">3. 整体渲染流程</span></h2>\n<p>所谓渲染流程，就是把用户写的类似于原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：<br>\n<img src=\"/img/complie/1.png\" alt></p>\n<p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p>\n<h2><span id=\"4-模板编译内部流程\">4. 模板编译内部流程</span></h2>\n<p>那么模板编译内部是怎么把用户写的模板经过处理最终生成<code>render</code>函数的呢？这内部的过程是怎样的呢？</p>\n<h3><span id=\"41-抽象语法树ast\">4.1 抽象语法树AST</span></h3>\n<p>我们知道，用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的模板对<code>Vue</code>来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树的东西。</p>\n<p>所谓抽象语法树，在计算机科学中，<strong>抽象语法树</strong>（<strong>A</strong>bstract<strong>S</strong>yntax<strong>T</strong>ree，AST），或简称<strong>语法树</strong>（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示。——来自百度百科</p>\n<p>我就知道，这段话贴出来也是白贴，因为看了也看不懂，哈哈。那么我们就以最直观的例子来理解什么是抽象语法树。请看下图：<br>\n<img src=\"/img/complie/2.png\" alt></p>\n<p>从图中我们可以看到，一个简单的<code>HTML</code>标签的代码被转换成了一个<code>JS</code>对象，而这个对象中的属性代表了这个标签中一些关键有效信息。如图中标识。<br>\n有兴趣的同学可以在这个网站在线转换试试：<a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">https://astexplorer.net/</a></p>\n<h3><span id=\"42-具体流程\">4.2 具体流程</span></h3>\n<p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p>\n<ol>\n<li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li>\n<li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li>\n<li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li>\n</ol>\n<p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p>\n<ol>\n<li>模板解析阶段——解析器——源码路径：<code>src/compiler/parser/index.js</code>;</li>\n<li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code>;</li>\n<li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code>;<br>\n其对应的源码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置: /src/complier/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompiler = createCompilerCreator(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.optimize !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span></span><br><span class=\"line\">    optimize(ast, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 代码生成阶段：将AST转换成渲染函数；</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    render: code.render,</span><br><span class=\"line\">    staticRenderFns: code.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>baseCompile</code> 的代码非常的简短主要核心代码。</p>\n<ul>\n<li><strong>const ast =parse(template.trim(), options)</strong>:<code>parse</code> 会用正则等方式解析 <code>template</code> 模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li>\n<li><strong>optimize(ast, options)</strong>: <code>optimize</code> 的主要作用是标记静态节点，这是 <code>Vue</code> 在编译过程中的一处优化，挡在进行<code>patch</code> 的过程中， <code>DOM-Diff</code> 算法会直接跳过静态节点，从而减少了比较的过程，优化了 <code>patch</code> 的性能。</li>\n<li><strong>const code =generate(ast, options)</strong>: 将 <code>AST</code> 转化成 <code>render</code>函数字符串的过程，得到结果是 <code>render</code>函数 的字符串以及 <code>staticRenderFns</code> 字符串。</li>\n</ul>\n<p>最终 <code>baseCompile</code> 的返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> \tast: ast,</span><br><span class=\"line\"> \trender: code.render,</span><br><span class=\"line\"> \tstaticRenderFns: code.staticRenderFns</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且<code>render</code> 的值为<code>code.render</code>，<code>staticRenderFns</code> 的值为<code>code.staticRenderFns</code>，也就是说通过 <code>generate</code>处理 <code>ast</code>之后得到的返回值 <code>code</code> 是一个对象。</p>\n<p>下面再给出模板编译内部具体流程图，便于理解。流程图如下：<br>\n<img src=\"/img/complie/3.png\" alt></p>\n<h2><span id=\"5-总结\">5. 总结</span></h2>\n<p>本篇文章首先引出了为什么会有模板编译，因为有了模板编译，才有了虚拟<code>DOM</code>，才有了后续的视图更新。接着介绍了什么是模板编译，以及介绍了把用户所写的模板经过层层处理直到最终渲染的视图中这个整体的渲染流程；最后介绍了模板编译过程中所需要使用的抽象语法树的概念以及分析了模板编译的具体实施流程，其流程大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段。那么接下来的几篇文章将会把这三个阶段逐一进行分析介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在前几篇文章中，我们介绍了<code>Vue</code>中的虚拟<code>DOM</code>以及虚拟<code>DOM</code>的<code>patch</code>(DOM-Diff)过程，而虚拟<code>DOM</code>存在的必要条件是得先有<code>VNode</code>，那么<code>VNode</code>又是从哪儿来的呢？这就是接下来几篇文章要说的模板编译。你可以这么理解：把用户写的模板进行编译，就会产生<code>VNode</code>。</p>\n<h2>2. 什么是模板编译</h2>\n<p>我们知道，在日常开发中，我们把写在<code>&lt;template&gt;&lt;/template&gt;</code>标签中的类似于原生<code>HTML</code>的内容称之为模板。这时你可能会问了，为什么说是“类似于原生<code>HTML</code>的内容”而不是“就是<code>HTML</code>的内容”？因为我们在开发中，在<code>&lt;template&gt;&lt;/template&gt;</code>标签中除了写一些原生<code>HTML</code>的标签，我们还会写一些变量插值，如，或者写一些<code>Vue</code>指令，如<code>v-on</code>、<code>v-if</code>等。而这些东西都是在原生<code>HTML</code>语法中不存在的，不被接受的。但是事实上我们确实这么写了，也被正确识别了，页面也正常显示了，这又是为什么呢？</p>\n<p>这就归功于<code>Vue</code>的模板编译了，<code>Vue</code>会把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数，而<code>render</code>函数会将模板内容生成对应的<code>VNode</code>，而<code>VNode</code>再经过前几篇文章介绍的<code>patch</code>过程从而得到将要渲染的视图中的<code>VNode</code>，最后根据<code>VNode</code>创建真实的<code>DOM</code>节点并插入到视图中， 最终完成视图的渲染更新。</p>\n<p>而把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的类似于原生<code>HTML</code>的内容进行编译，把原生<code>HTML</code>的内容找出来，再把非原生<code>HTML</code>找出来，经过一系列的逻辑处理生成渲染函数，也就是<code>render</code>函数的这一段过程称之为模板编译过程。</p>\n<h2>3. 整体渲染流程</h2>\n<p>所谓渲染流程，就是把用户写的类似于原生<code>HTML</code>的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下，流程图如下：<br>\n<img src=\"/img/complie/1.png\" alt></p>\n<p>从图中我们也可以看到，模板编译过程就是把用户写的模板经过一系列处理最终生成<code>render</code>函数的过程。</p>\n<h2>4. 模板编译内部流程</h2>\n<p>那么模板编译内部是怎么把用户写的模板经过处理最终生成<code>render</code>函数的呢？这内部的过程是怎样的呢？</p>\n<h3>4.1 抽象语法树AST</h3>\n<p>我们知道，用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签中写的模板对<code>Vue</code>来说就是一堆字符串，那么如何解析这一堆字符串并且从中提取出元素的标签、属性、变量插值等有效信息呢？这就需要借助一个叫做抽象语法树的东西。</p>\n<p>所谓抽象语法树，在计算机科学中，<strong>抽象语法树</strong>（<strong>A</strong>bstract<strong>S</strong>yntax<strong>T</strong>ree，AST），或简称<strong>语法树</strong>（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于if-condition-then这样的条件跳转语句，可以使用带有两个分支的节点来表示。——来自百度百科</p>\n<p>我就知道，这段话贴出来也是白贴，因为看了也看不懂，哈哈。那么我们就以最直观的例子来理解什么是抽象语法树。请看下图：<br>\n<img src=\"/img/complie/2.png\" alt></p>\n<p>从图中我们可以看到，一个简单的<code>HTML</code>标签的代码被转换成了一个<code>JS</code>对象，而这个对象中的属性代表了这个标签中一些关键有效信息。如图中标识。<br>\n有兴趣的同学可以在这个网站在线转换试试：<a href=\"https://astexplorer.net/\" target=\"_blank\" rel=\"noopener\">https://astexplorer.net/</a></p>\n<h3>4.2 具体流程</h3>\n<p>将一堆字符串模板解析成抽象语法树<code>AST</code>后，我们就可以对其进行各种操作处理了，处理完后用处理后的<code>AST</code>来生成<code>render</code>函数。其具体流程可大致分为三个阶段：</p>\n<ol>\n<li>模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树<code>AST</code>；</li>\n<li>优化阶段：遍历<code>AST</code>，找出其中的静态节点，并打上标记；</li>\n<li>代码生成阶段：将<code>AST</code>转换成渲染函数；</li>\n</ol>\n<p>这三个阶段在源码中分别对应三个模块，下面给出三个模块的源代码在源码中的路径：</p>\n<ol>\n<li>模板解析阶段——解析器——源码路径：<code>src/compiler/parser/index.js</code>;</li>\n<li>优化阶段——优化器——源码路径：<code>src/compiler/optimizer.js</code>;</li>\n<li>代码生成阶段——代码生成器——源码路径：<code>src/compiler/codegen/index.js</code>;<br>\n其对应的源码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置: /src/complier/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompiler = createCompilerCreator(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.optimize !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span></span><br><span class=\"line\">    optimize(ast, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 代码生成阶段：将AST转换成渲染函数；</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    render: code.render,</span><br><span class=\"line\">    staticRenderFns: code.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>baseCompile</code> 的代码非常的简短主要核心代码。</p>\n<ul>\n<li><strong>const ast =parse(template.trim(), options)</strong>:<code>parse</code> 会用正则等方式解析 <code>template</code> 模板中的指令、<code>class</code>、<code>style</code>等数据，形成<code>AST</code>。</li>\n<li><strong>optimize(ast, options)</strong>: <code>optimize</code> 的主要作用是标记静态节点，这是 <code>Vue</code> 在编译过程中的一处优化，挡在进行<code>patch</code> 的过程中， <code>DOM-Diff</code> 算法会直接跳过静态节点，从而减少了比较的过程，优化了 <code>patch</code> 的性能。</li>\n<li><strong>const code =generate(ast, options)</strong>: 将 <code>AST</code> 转化成 <code>render</code>函数字符串的过程，得到结果是 <code>render</code>函数 的字符串以及 <code>staticRenderFns</code> 字符串。</li>\n</ul>\n<p>最终 <code>baseCompile</code> 的返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> \tast: ast,</span><br><span class=\"line\"> \trender: code.render,</span><br><span class=\"line\"> \tstaticRenderFns: code.staticRenderFns</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>最终返回了抽象语法树( ast )，渲染函数( render )，静态渲染函数( staticRenderFns )，且<code>render</code> 的值为<code>code.render</code>，<code>staticRenderFns</code> 的值为<code>code.staticRenderFns</code>，也就是说通过 <code>generate</code>处理 <code>ast</code>之后得到的返回值 <code>code</code> 是一个对象。</p>\n<p>下面再给出模板编译内部具体流程图，便于理解。流程图如下：<br>\n<img src=\"/img/complie/3.png\" alt></p>\n<h2>5. 总结</h2>\n<p>本篇文章首先引出了为什么会有模板编译，因为有了模板编译，才有了虚拟<code>DOM</code>，才有了后续的视图更新。接着介绍了什么是模板编译，以及介绍了把用户所写的模板经过层层处理直到最终渲染的视图中这个整体的渲染流程；最后介绍了模板编译过程中所需要使用的抽象语法树的概念以及分析了模板编译的具体实施流程，其流程大致分为三个阶段，分别是模板解析阶段、优化阶段和代码生成阶段。那么接下来的几篇文章将会把这三个阶段逐一进行分析介绍。</p>\n"},{"title":"Uni-App 基于Vue技术栈方向跨端技术实践","catalog":true,"date":"2019-04-29T22:37:05.000Z","subtitle":null,"header-img":"https://p4.ssl.cdn.btime.com/t0125a8daac3dbdb9f2.jpg?size=1200x616","_content":"\n### 1.什么是Uni-App?\nuni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。\n如下图：\n---\n![跨端图](http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&fm=26&gp=0.jpg)\n![功能架构图](https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png)\n\nuni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示\n\n![多端图](http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png)\n\n> PS: 学习一门技术最好的方式，就是看官网： https://uniapp.dcloud.io/\n\n### 2. 语法原理以及注意事项\n\nuni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。\n> PS: 过于啰嗦和简单，官网文档在此： https://uniapp.dcloud.io/use\n\n### 3. 技术实践\n> 1.先看一下项目的目录结构图\n\n\n![目录结构图](https://s2.ax1x.com/2019/04/30/EG8srn.png)\n\n\n1. src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。\n2. src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多\n3. src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。\n4. src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等\n5. src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件\n6. src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息\n7. src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录\n8. src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。\n9. src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --> unx,具体看官网\n10. dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令\n\n> PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~\n\n### 4. 实践结果\n![实践结果图](https://s2.ax1x.com/2019/04/30/EGJN9S.png)\n1. 目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。\n2. 采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。\n3. 解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。\n\n> PS: 商业项目没有参考示例代码，更多介绍请参见官网： https://uniapp.dcloud.io/","source":"_posts/Uni-App 基于Vue技术栈方向跨端技术实践.md","raw":"---\ntitle: Uni-App 基于Vue技术栈方向跨端技术实践\ncatalog: true\ntags:\n  - Vue\n  - Weex\n  - 微信小程序\ncategories:\n  - Vue\ndate: 2019-04-30 6:37:05\nsubtitle:\nheader-img: \"https://p4.ssl.cdn.btime.com/t0125a8daac3dbdb9f2.jpg?size=1200x616\"\n---\n\n### 1.什么是Uni-App?\nuni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。\n如下图：\n---\n![跨端图](http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&fm=26&gp=0.jpg)\n![功能架构图](https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png)\n\nuni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示\n\n![多端图](http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png)\n\n> PS: 学习一门技术最好的方式，就是看官网： https://uniapp.dcloud.io/\n\n### 2. 语法原理以及注意事项\n\nuni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。\n> PS: 过于啰嗦和简单，官网文档在此： https://uniapp.dcloud.io/use\n\n### 3. 技术实践\n> 1.先看一下项目的目录结构图\n\n\n![目录结构图](https://s2.ax1x.com/2019/04/30/EG8srn.png)\n\n\n1. src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。\n2. src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多\n3. src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。\n4. src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等\n5. src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件\n6. src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息\n7. src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录\n8. src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。\n9. src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --> unx,具体看官网\n10. dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令\n\n> PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~\n\n### 4. 实践结果\n![实践结果图](https://s2.ax1x.com/2019/04/30/EGJN9S.png)\n1. 目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。\n2. 采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。\n3. 解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。\n\n> PS: 商业项目没有参考示例代码，更多介绍请参见官网： https://uniapp.dcloud.io/","slug":"Uni-App 基于Vue技术栈方向跨端技术实践","published":1,"updated":"2019-12-31T03:00:25.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5b0011zws6rfbdqqz4","content":"<h3><span id=\"1什么是uni-app\">1.什么是Uni-App?</span></h3>\n<p>uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。<br>\n如下图：</p>\n<hr>\n<p><img src=\"http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&amp;fm=26&amp;gp=0.jpg\" alt=\"跨端图\"><br>\n<img src=\"https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png\" alt=\"功能架构图\"></p>\n<p>uni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示</p>\n<p><img src=\"http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png\" alt=\"多端图\"></p>\n<blockquote>\n<p>PS: 学习一门技术最好的方式，就是看官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n<h3><span id=\"2-语法原理以及注意事项\">2. 语法原理以及注意事项</span></h3>\n<p>uni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。</p>\n<blockquote>\n<p>PS: 过于啰嗦和简单，官网文档在此： <a href=\"https://uniapp.dcloud.io/use\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/use</a></p>\n</blockquote>\n<h3><span id=\"3-技术实践\">3. 技术实践</span></h3>\n<blockquote>\n<p>1.先看一下项目的目录结构图</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EG8srn.png\" alt=\"目录结构图\"></p>\n<ol>\n<li>src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。</li>\n<li>src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多</li>\n<li>src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。</li>\n<li>src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等</li>\n<li>src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件</li>\n<li>src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息</li>\n<li>src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录</li>\n<li>src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。</li>\n<li>src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --&gt; unx,具体看官网</li>\n<li>dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令</li>\n</ol>\n<blockquote>\n<p>PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~</p>\n</blockquote>\n<h3><span id=\"4-实践结果\">4. 实践结果</span></h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGJN9S.png\" alt=\"实践结果图\"></p>\n<ol>\n<li>目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。</li>\n<li>采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。</li>\n<li>解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。</li>\n</ol>\n<blockquote>\n<p>PS: 商业项目没有参考示例代码，更多介绍请参见官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>1.什么是Uni-App?</h3>\n<p>uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。<br>\n如下图：</p>\n<hr>\n<p><img src=\"http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&amp;fm=26&amp;gp=0.jpg\" alt=\"跨端图\"><br>\n<img src=\"https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png\" alt=\"功能架构图\"></p>\n<p>uni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示</p>\n<p><img src=\"http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png\" alt=\"多端图\"></p>\n<blockquote>\n<p>PS: 学习一门技术最好的方式，就是看官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n<h3>2. 语法原理以及注意事项</h3>\n<p>uni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。</p>\n<blockquote>\n<p>PS: 过于啰嗦和简单，官网文档在此： <a href=\"https://uniapp.dcloud.io/use\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/use</a></p>\n</blockquote>\n<h3>3. 技术实践</h3>\n<blockquote>\n<p>1.先看一下项目的目录结构图</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EG8srn.png\" alt=\"目录结构图\"></p>\n<ol>\n<li>src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。</li>\n<li>src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多</li>\n<li>src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。</li>\n<li>src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等</li>\n<li>src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件</li>\n<li>src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息</li>\n<li>src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录</li>\n<li>src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。</li>\n<li>src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --&gt; unx,具体看官网</li>\n<li>dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令</li>\n</ol>\n<blockquote>\n<p>PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~</p>\n</blockquote>\n<h3>4. 实践结果</h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGJN9S.png\" alt=\"实践结果图\"></p>\n<ol>\n<li>目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。</li>\n<li>采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。</li>\n<li>解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。</li>\n</ol>\n<blockquote>\n<p>PS: 商业项目没有参考示例代码，更多介绍请参见官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n"},{"title":"Vue 源码阅读 模板编译（二）","catalog":true,"date":"2019-10-20T00:39:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 整体流程\n\n上篇文章中我们说了，在模板解析阶段主要做的工作是把用户在`<template></template>`标签内写的模板使用正则等方式解析成抽象语法树（`AST`）。而这一阶段在源码中对应解析器（`parser`）模块。\n\n解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成`AST`。我们知道在`<template></template>`模板内，除了有常规的`HTML`标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规`HTML`的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。\n\n另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示：\n\n![](/img/complie/4.png)\n\n## 2. 回到源码\n\n解析器的源码位于`/src/complier/parser`文件夹下，其主线代码如下：\n\n```javascript\n// 代码位置：/src/complier/parser/index.js\n\n/**\n * Convert HTML string to AST.\n */\nexport function parse(template, options) {\n   // ...\n  parseHTML(template, {\n    warn,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    start (tag, attrs, unary) {\n\n    },\n    end () {\n\n    },\n    chars (text: string) {\n\n    },\n    comment (text: string) {\n\n    }\n  })\n  return root\n}\n```\n\n\n\n从上面代码中可以看到，`parse` 函数就是解析器的主函数，在`parse` 函数内调用了`parseHTML` 函数对模板字符串进行解析，在`parseHTML` 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器`parseText`函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器`parseFilters`函数进行解析。\n\n## 3. 总结\n\n本篇文章主要梳理了模板解析的整体运行流程，模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数`parse`中先调用HTML解析器`parseHTML` 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。\n\n了解了模板解析阶段的整体运行流程后，接下来，我们就对流程中所涉及到的三种解析器分别深入分析，逐个击破。\n\n","source":"_posts/Vue 源码阅读 模板编译（二）.md","raw":"---\ntitle: Vue 源码阅读 模板编译（二）\ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-20 08:39:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 整体流程\n\n上篇文章中我们说了，在模板解析阶段主要做的工作是把用户在`<template></template>`标签内写的模板使用正则等方式解析成抽象语法树（`AST`）。而这一阶段在源码中对应解析器（`parser`）模块。\n\n解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成`AST`。我们知道在`<template></template>`模板内，除了有常规的`HTML`标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规`HTML`的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。\n\n另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示：\n\n![](/img/complie/4.png)\n\n## 2. 回到源码\n\n解析器的源码位于`/src/complier/parser`文件夹下，其主线代码如下：\n\n```javascript\n// 代码位置：/src/complier/parser/index.js\n\n/**\n * Convert HTML string to AST.\n */\nexport function parse(template, options) {\n   // ...\n  parseHTML(template, {\n    warn,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    start (tag, attrs, unary) {\n\n    },\n    end () {\n\n    },\n    chars (text: string) {\n\n    },\n    comment (text: string) {\n\n    }\n  })\n  return root\n}\n```\n\n\n\n从上面代码中可以看到，`parse` 函数就是解析器的主函数，在`parse` 函数内调用了`parseHTML` 函数对模板字符串进行解析，在`parseHTML` 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器`parseText`函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器`parseFilters`函数进行解析。\n\n## 3. 总结\n\n本篇文章主要梳理了模板解析的整体运行流程，模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数`parse`中先调用HTML解析器`parseHTML` 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。\n\n了解了模板解析阶段的整体运行流程后，接下来，我们就对流程中所涉及到的三种解析器分别深入分析，逐个击破。\n\n","slug":"Vue 源码阅读 模板编译（二）","published":1,"updated":"2019-12-31T03:23:05.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5c0013zws6vicg6wsu","content":"<h2><span id=\"1-整体流程\">1. 整体流程</span></h2>\n<p>上篇文章中我们说了，在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p>\n<p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。</p>\n<p>另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示：</p>\n<p><img src=\"/img/complie/4.png\" alt></p>\n<h2><span id=\"2-回到源码\">2. 回到源码</span></h2>\n<p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码位置：/src/complier/parser/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Convert HTML string to AST.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parse</span>(<span class=\"params\">template, options</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">  parseHTML(template, &#123;</span><br><span class=\"line\">    warn,</span><br><span class=\"line\">    expectHTML: options.expectHTML,</span><br><span class=\"line\">    isUnaryTag: options.isUnaryTag,</span><br><span class=\"line\">    canBeLeftOpenTag: options.canBeLeftOpenTag,</span><br><span class=\"line\">    shouldDecodeNewlines: options.shouldDecodeNewlines,</span><br><span class=\"line\">    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,</span><br><span class=\"line\">    shouldKeepComment: options.comments,</span><br><span class=\"line\">    start (tag, attrs, unary) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    end () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    chars (text: string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    comment (text: string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中可以看到，<code>parse</code> 函数就是解析器的主函数，在<code>parse</code> 函数内调用了<code>parseHTML</code> 函数对模板字符串进行解析，在<code>parseHTML</code> 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器<code>parseText</code>函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器<code>parseFilters</code>函数进行解析。</p>\n<h2><span id=\"3-总结\">3. 总结</span></h2>\n<p>本篇文章主要梳理了模板解析的整体运行流程，模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数<code>parse</code>中先调用HTML解析器<code>parseHTML</code> 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p>\n<p>了解了模板解析阶段的整体运行流程后，接下来，我们就对流程中所涉及到的三种解析器分别深入分析，逐个击破。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 整体流程</h2>\n<p>上篇文章中我们说了，在模板解析阶段主要做的工作是把用户在<code>&lt;template&gt;&lt;/template&gt;</code>标签内写的模板使用正则等方式解析成抽象语法树（<code>AST</code>）。而这一阶段在源码中对应解析器（<code>parser</code>）模块。</p>\n<p>解析器，顾名思义，就是把用户所写的模板根据一定的解析规则解析出有效的信息，最后用这些信息形成<code>AST</code>。我们知道在<code>&lt;template&gt;&lt;/template&gt;</code>模板内，除了有常规的<code>HTML</code>标签外，用户还会一些文本信息以及在文本信息中包含过滤器。而这些不同的内容在解析起来肯定需要不同的解析规则，所以解析器不可能只有一个，它应该除了有解析常规<code>HTML</code>的HTML解析器，还应该有解析文本的文本解析器以及解析文本中如果包含过滤器的过滤器解析器。</p>\n<p>另外，文本信息和标签属性信息却又是存在于HTML标签之内的，所以在解析整个模板的时候它的流程应该是这样子的：HTML解析器是主线，先用HTML解析器进行解析整个模板，在解析过程中如果碰到文本内容，那就调用文本解析器来解析文本，如果碰到文本中包含过滤器那就调用过滤器解析器来解析。如下图所示：</p>\n<p><img src=\"/img/complie/4.png\" alt></p>\n<h2>2. 回到源码</h2>\n<p>解析器的源码位于<code>/src/complier/parser</code>文件夹下，其主线代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码位置：/src/complier/parser/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Convert HTML string to AST.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parse</span>(<span class=\"params\">template, options</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">  parseHTML(template, &#123;</span><br><span class=\"line\">    warn,</span><br><span class=\"line\">    expectHTML: options.expectHTML,</span><br><span class=\"line\">    isUnaryTag: options.isUnaryTag,</span><br><span class=\"line\">    canBeLeftOpenTag: options.canBeLeftOpenTag,</span><br><span class=\"line\">    shouldDecodeNewlines: options.shouldDecodeNewlines,</span><br><span class=\"line\">    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,</span><br><span class=\"line\">    shouldKeepComment: options.comments,</span><br><span class=\"line\">    start (tag, attrs, unary) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    end () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    chars (text: string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    comment (text: string) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中可以看到，<code>parse</code> 函数就是解析器的主函数，在<code>parse</code> 函数内调用了<code>parseHTML</code> 函数对模板字符串进行解析，在<code>parseHTML</code> 函数解析模板字符串的过程中，如果遇到文本信息，就会调用文本解析器<code>parseText</code>函数进行文本解析；如果遇到文本中包含过滤器，就会调用过滤器解析器<code>parseFilters</code>函数进行解析。</p>\n<h2>3. 总结</h2>\n<p>本篇文章主要梳理了模板解析的整体运行流程，模板解析其实就是根据被解析内容的特点使用正则等方式将有效信息解析提取出来，根据解析内容的不同分为HTML解析器，文本解析器和过滤器解析器。而文本信息与过滤器信息又存在于HTML标签中，所以在解析器主线函数<code>parse</code>中先调用HTML解析器<code>parseHTML</code> 函数对模板字符串进行解析，如果在解析过程中遇到文本或过滤器信息则再调用相应的解析器进行解析，最终完成对整个模板字符串的解析。</p>\n<p>了解了模板解析阶段的整体运行流程后，接下来，我们就对流程中所涉及到的三种解析器分别深入分析，逐个击破。</p>\n"},{"title":"Vue 源码阅读 深入响应式原理(一)","catalog":true,"date":"2019-10-18T11:42:52.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n\n## 1. 前言\n\n众所周知，`Vue`最大的特点之一就是数据驱动视图，那么什么是数据驱动视图呢？在这里，我们可以把数据理解为状态，而视图就是用户可直观看到页面。页面不可能是一成不变的，它应该是动态变化的，而它的变化也不应该是无迹可寻的，它或者是由用户操作引起的，亦或者是由后端数据变化引起的，不管它是因为什么引起的，我们统称为它的状态变了，它由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：\n\n<font color=\"red\">**UI = render(state)**</font>\n\n上述公式中：状态`state`是输入，页面`UI`输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。\n\nOK，有了基本概念以后，我们再把上述公式拆成三部分：`state`、`render()`以及`UI`。我们知道`state`和`UI`都是用户定的，而不变的是这个`render()`。所以`Vue`就扮演了`render()`这个角色，当`Vue`发现`state`变化之后，经过一系列加工，最终将变化反应在`UI`上。\n\n那么第一个问题来了，`Vue`怎么知道`state`变化了呢？\n\n## 2. 什么是变化侦测\n\n那`Vue`是怎么知道`state`变化了呢？换句话说，数据变化了是怎么通知给`Vue`呢？那么，这就引出了`Vue`中的变化侦测。\n\n变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。\n\n变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在`Angular`中是通过脏值检查流程来实现变化侦测；在`React`是通过对比虚拟`DOM`来实现变化侦测，而在`Vue`中也有自己的一套变化侦测实现机制。\n\n那么，接下来我们就通过阅读源码来学习一下`Vue`是怎么实现自己的对数据变化进行侦测的机制。\n\n## 3. 总结\n\n首先，我们知道了什么是数据驱动视图。数据驱动视图简单来说就是数据变化引起视图变化，那么第一步就是先要知道数据什么时候发生变化，也就是说对数据的变化要进行侦测。\n\n其次，数据的变化侦测在三大框架中均有涉及，不同的框架有着自己的一套侦测机制。\n\n最后，我们从源码出发，学习在`Vue`中是如何对数据进行变化侦测的。\n","source":"_posts/Vue 源码阅读 深入响应式原理(一).md","raw":"---\ntitle: Vue 源码阅读 深入响应式原理(一) \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-18 19:42:52\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n\n## 1. 前言\n\n众所周知，`Vue`最大的特点之一就是数据驱动视图，那么什么是数据驱动视图呢？在这里，我们可以把数据理解为状态，而视图就是用户可直观看到页面。页面不可能是一成不变的，它应该是动态变化的，而它的变化也不应该是无迹可寻的，它或者是由用户操作引起的，亦或者是由后端数据变化引起的，不管它是因为什么引起的，我们统称为它的状态变了，它由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：\n\n<font color=\"red\">**UI = render(state)**</font>\n\n上述公式中：状态`state`是输入，页面`UI`输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。\n\nOK，有了基本概念以后，我们再把上述公式拆成三部分：`state`、`render()`以及`UI`。我们知道`state`和`UI`都是用户定的，而不变的是这个`render()`。所以`Vue`就扮演了`render()`这个角色，当`Vue`发现`state`变化之后，经过一系列加工，最终将变化反应在`UI`上。\n\n那么第一个问题来了，`Vue`怎么知道`state`变化了呢？\n\n## 2. 什么是变化侦测\n\n那`Vue`是怎么知道`state`变化了呢？换句话说，数据变化了是怎么通知给`Vue`呢？那么，这就引出了`Vue`中的变化侦测。\n\n变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。\n\n变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在`Angular`中是通过脏值检查流程来实现变化侦测；在`React`是通过对比虚拟`DOM`来实现变化侦测，而在`Vue`中也有自己的一套变化侦测实现机制。\n\n那么，接下来我们就通过阅读源码来学习一下`Vue`是怎么实现自己的对数据变化进行侦测的机制。\n\n## 3. 总结\n\n首先，我们知道了什么是数据驱动视图。数据驱动视图简单来说就是数据变化引起视图变化，那么第一步就是先要知道数据什么时候发生变化，也就是说对数据的变化要进行侦测。\n\n其次，数据的变化侦测在三大框架中均有涉及，不同的框架有着自己的一套侦测机制。\n\n最后，我们从源码出发，学习在`Vue`中是如何对数据进行变化侦测的。\n","slug":"Vue 源码阅读 深入响应式原理(一)","published":1,"updated":"2019-12-31T03:13:52.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5e0018zws6wnj9jsod","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>众所周知，<code>Vue</code>最大的特点之一就是数据驱动视图，那么什么是数据驱动视图呢？在这里，我们可以把数据理解为状态，而视图就是用户可直观看到页面。页面不可能是一成不变的，它应该是动态变化的，而它的变化也不应该是无迹可寻的，它或者是由用户操作引起的，亦或者是由后端数据变化引起的，不管它是因为什么引起的，我们统称为它的状态变了，它由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：</p>\n<p><font color=\"red\"><strong>UI = render(state)</strong></font></p>\n<p>上述公式中：状态<code>state</code>是输入，页面<code>UI</code>输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。</p>\n<p>OK，有了基本概念以后，我们再把上述公式拆成三部分：<code>state</code>、<code>render()</code>以及<code>UI</code>。我们知道<code>state</code>和<code>UI</code>都是用户定的，而不变的是这个<code>render()</code>。所以<code>Vue</code>就扮演了<code>render()</code>这个角色，当<code>Vue</code>发现<code>state</code>变化之后，经过一系列加工，最终将变化反应在<code>UI</code>上。</p>\n<p>那么第一个问题来了，<code>Vue</code>怎么知道<code>state</code>变化了呢？</p>\n<h2><span id=\"2-什么是变化侦测\">2. 什么是变化侦测</span></h2>\n<p>那<code>Vue</code>是怎么知道<code>state</code>变化了呢？换句话说，数据变化了是怎么通知给<code>Vue</code>呢？那么，这就引出了<code>Vue</code>中的变化侦测。</p>\n<p>变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。</p>\n<p>变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在<code>Angular</code>中是通过脏值检查流程来实现变化侦测；在<code>React</code>是通过对比虚拟<code>DOM</code>来实现变化侦测，而在<code>Vue</code>中也有自己的一套变化侦测实现机制。</p>\n<p>那么，接下来我们就通过阅读源码来学习一下<code>Vue</code>是怎么实现自己的对数据变化进行侦测的机制。</p>\n<h2><span id=\"3-总结\">3. 总结</span></h2>\n<p>首先，我们知道了什么是数据驱动视图。数据驱动视图简单来说就是数据变化引起视图变化，那么第一步就是先要知道数据什么时候发生变化，也就是说对数据的变化要进行侦测。</p>\n<p>其次，数据的变化侦测在三大框架中均有涉及，不同的框架有着自己的一套侦测机制。</p>\n<p>最后，我们从源码出发，学习在<code>Vue</code>中是如何对数据进行变化侦测的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>众所周知，<code>Vue</code>最大的特点之一就是数据驱动视图，那么什么是数据驱动视图呢？在这里，我们可以把数据理解为状态，而视图就是用户可直观看到页面。页面不可能是一成不变的，它应该是动态变化的，而它的变化也不应该是无迹可寻的，它或者是由用户操作引起的，亦或者是由后端数据变化引起的，不管它是因为什么引起的，我们统称为它的状态变了，它由前一个状态变到了后一个状态，页面也就应该随之而变化，所以我们就可以得到如下一个公式：</p>\n<p><font color=\"red\"><strong>UI = render(state)</strong></font></p>\n<p>上述公式中：状态<code>state</code>是输入，页面<code>UI</code>输出，状态输入一旦变化了，页面输出也随之而变化。我们把这种特性称之为数据驱动视图。</p>\n<p>OK，有了基本概念以后，我们再把上述公式拆成三部分：<code>state</code>、<code>render()</code>以及<code>UI</code>。我们知道<code>state</code>和<code>UI</code>都是用户定的，而不变的是这个<code>render()</code>。所以<code>Vue</code>就扮演了<code>render()</code>这个角色，当<code>Vue</code>发现<code>state</code>变化之后，经过一系列加工，最终将变化反应在<code>UI</code>上。</p>\n<p>那么第一个问题来了，<code>Vue</code>怎么知道<code>state</code>变化了呢？</p>\n<h2>2. 什么是变化侦测</h2>\n<p>那<code>Vue</code>是怎么知道<code>state</code>变化了呢？换句话说，数据变化了是怎么通知给<code>Vue</code>呢？那么，这就引出了<code>Vue</code>中的变化侦测。</p>\n<p>变化侦测就是追踪状态，亦或者说是数据的变化，一旦发生了变化，就要去更新视图。</p>\n<p>变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在<code>Angular</code>中是通过脏值检查流程来实现变化侦测；在<code>React</code>是通过对比虚拟<code>DOM</code>来实现变化侦测，而在<code>Vue</code>中也有自己的一套变化侦测实现机制。</p>\n<p>那么，接下来我们就通过阅读源码来学习一下<code>Vue</code>是怎么实现自己的对数据变化进行侦测的机制。</p>\n<h2>3. 总结</h2>\n<p>首先，我们知道了什么是数据驱动视图。数据驱动视图简单来说就是数据变化引起视图变化，那么第一步就是先要知道数据什么时候发生变化，也就是说对数据的变化要进行侦测。</p>\n<p>其次，数据的变化侦测在三大框架中均有涉及，不同的框架有着自己的一套侦测机制。</p>\n<p>最后，我们从源码出发，学习在<code>Vue</code>中是如何对数据进行变化侦测的。</p>\n"},{"title":"Vue 源码阅读 生命周期（一）","catalog":true,"date":"2020-01-01T14:42:27.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n在`Vue`中，每个`Vue`实例从被创建出来到最终被销毁都会经历一个过程，就像人一样，从出生到死亡。在这一过程里会发生许许多多的事，例如设置数据监听，编译模板，组件挂载等。在`Vue`中，把`Vue`实例从被创建出来到最终被销毁的这一过程称为`Vue`实例的生命周期，同时，在`Vue`实例生命周期的不同阶段`Vue`还提供了不同的钩子函数，以方便用户在不同的生命周期阶段做一些额外的事情。那么，接下来的几篇文章我们就从源码角度深入剖析一下一个`Vue`实例在从生到死的生命周期里到底都经历了些什么，每个阶段都做了哪些事情。\n\n## 2. 生命周期流程图\n\n下图是`Vue`官网给出的`Vue`实例的生命周期流程图，如下：\n\n![](/img/lifecycle/1.jpg)\n\n从图中我们可以看到，`Vue`实例的生命周期大致可分为4个阶段：\n\n- 初始化阶段：为`Vue`实例上初始化一些属性，事件以及响应式数据；\n- 模板编译阶段：将模板编译成渲染函数；\n- 挂载阶段：将实例挂载到指定的`DOM`上，即将模板渲染到真实`DOM`中；\n- 销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；\n\n如下图所示：\n\n![](/img/lifecycle/8.png)\n\n## 3. 总结\n\n本篇文章是生命周期篇的开篇综述，借用`Vue`官网的生命周期流程图介绍了一个`Vue`实例的生命周期大致可分为四个阶段，分别是初始化阶段、模板编译阶段、挂载阶段、销毁阶段。接下来的几篇文章我们就从这个流程图为基础，自上到下，从每个阶段入手，深入分析在每个阶段里都干了些什么。\n","source":"_posts/Vue 源码阅读 生命周期（一）.md","raw":"---\ntitle: Vue 源码阅读 生命周期（一） \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2020-01-01 22:42:27\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n在`Vue`中，每个`Vue`实例从被创建出来到最终被销毁都会经历一个过程，就像人一样，从出生到死亡。在这一过程里会发生许许多多的事，例如设置数据监听，编译模板，组件挂载等。在`Vue`中，把`Vue`实例从被创建出来到最终被销毁的这一过程称为`Vue`实例的生命周期，同时，在`Vue`实例生命周期的不同阶段`Vue`还提供了不同的钩子函数，以方便用户在不同的生命周期阶段做一些额外的事情。那么，接下来的几篇文章我们就从源码角度深入剖析一下一个`Vue`实例在从生到死的生命周期里到底都经历了些什么，每个阶段都做了哪些事情。\n\n## 2. 生命周期流程图\n\n下图是`Vue`官网给出的`Vue`实例的生命周期流程图，如下：\n\n![](/img/lifecycle/1.jpg)\n\n从图中我们可以看到，`Vue`实例的生命周期大致可分为4个阶段：\n\n- 初始化阶段：为`Vue`实例上初始化一些属性，事件以及响应式数据；\n- 模板编译阶段：将模板编译成渲染函数；\n- 挂载阶段：将实例挂载到指定的`DOM`上，即将模板渲染到真实`DOM`中；\n- 销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；\n\n如下图所示：\n\n![](/img/lifecycle/8.png)\n\n## 3. 总结\n\n本篇文章是生命周期篇的开篇综述，借用`Vue`官网的生命周期流程图介绍了一个`Vue`实例的生命周期大致可分为四个阶段，分别是初始化阶段、模板编译阶段、挂载阶段、销毁阶段。接下来的几篇文章我们就从这个流程图为基础，自上到下，从每个阶段入手，深入分析在每个阶段里都干了些什么。\n","slug":"Vue 源码阅读 生命周期（一）","published":1,"updated":"2020-01-02T10:44:42.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5f0019zws6oryk4wdt","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在<code>Vue</code>中，每个<code>Vue</code>实例从被创建出来到最终被销毁都会经历一个过程，就像人一样，从出生到死亡。在这一过程里会发生许许多多的事，例如设置数据监听，编译模板，组件挂载等。在<code>Vue</code>中，把<code>Vue</code>实例从被创建出来到最终被销毁的这一过程称为<code>Vue</code>实例的生命周期，同时，在<code>Vue</code>实例生命周期的不同阶段<code>Vue</code>还提供了不同的钩子函数，以方便用户在不同的生命周期阶段做一些额外的事情。那么，接下来的几篇文章我们就从源码角度深入剖析一下一个<code>Vue</code>实例在从生到死的生命周期里到底都经历了些什么，每个阶段都做了哪些事情。</p>\n<h2><span id=\"2-生命周期流程图\">2. 生命周期流程图</span></h2>\n<p>下图是<code>Vue</code>官网给出的<code>Vue</code>实例的生命周期流程图，如下：</p>\n<p><img src=\"/img/lifecycle/1.jpg\" alt></p>\n<p>从图中我们可以看到，<code>Vue</code>实例的生命周期大致可分为4个阶段：</p>\n<ul>\n<li>初始化阶段：为<code>Vue</code>实例上初始化一些属性，事件以及响应式数据；</li>\n<li>模板编译阶段：将模板编译成渲染函数；</li>\n<li>挂载阶段：将实例挂载到指定的<code>DOM</code>上，即将模板渲染到真实<code>DOM</code>中；</li>\n<li>销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；</li>\n</ul>\n<p>如下图所示：</p>\n<p><img src=\"/img/lifecycle/8.png\" alt></p>\n<h2><span id=\"3-总结\">3. 总结</span></h2>\n<p>本篇文章是生命周期篇的开篇综述，借用<code>Vue</code>官网的生命周期流程图介绍了一个<code>Vue</code>实例的生命周期大致可分为四个阶段，分别是初始化阶段、模板编译阶段、挂载阶段、销毁阶段。接下来的几篇文章我们就从这个流程图为基础，自上到下，从每个阶段入手，深入分析在每个阶段里都干了些什么。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在<code>Vue</code>中，每个<code>Vue</code>实例从被创建出来到最终被销毁都会经历一个过程，就像人一样，从出生到死亡。在这一过程里会发生许许多多的事，例如设置数据监听，编译模板，组件挂载等。在<code>Vue</code>中，把<code>Vue</code>实例从被创建出来到最终被销毁的这一过程称为<code>Vue</code>实例的生命周期，同时，在<code>Vue</code>实例生命周期的不同阶段<code>Vue</code>还提供了不同的钩子函数，以方便用户在不同的生命周期阶段做一些额外的事情。那么，接下来的几篇文章我们就从源码角度深入剖析一下一个<code>Vue</code>实例在从生到死的生命周期里到底都经历了些什么，每个阶段都做了哪些事情。</p>\n<h2>2. 生命周期流程图</h2>\n<p>下图是<code>Vue</code>官网给出的<code>Vue</code>实例的生命周期流程图，如下：</p>\n<p><img src=\"/img/lifecycle/1.jpg\" alt></p>\n<p>从图中我们可以看到，<code>Vue</code>实例的生命周期大致可分为4个阶段：</p>\n<ul>\n<li>初始化阶段：为<code>Vue</code>实例上初始化一些属性，事件以及响应式数据；</li>\n<li>模板编译阶段：将模板编译成渲染函数；</li>\n<li>挂载阶段：将实例挂载到指定的<code>DOM</code>上，即将模板渲染到真实<code>DOM</code>中；</li>\n<li>销毁阶段：将实例自身从父组件中删除，并取消依赖追踪及事件监听器；</li>\n</ul>\n<p>如下图所示：</p>\n<p><img src=\"/img/lifecycle/8.png\" alt></p>\n<h2>3. 总结</h2>\n<p>本篇文章是生命周期篇的开篇综述，借用<code>Vue</code>官网的生命周期流程图介绍了一个<code>Vue</code>实例的生命周期大致可分为四个阶段，分别是初始化阶段、模板编译阶段、挂载阶段、销毁阶段。接下来的几篇文章我们就从这个流程图为基础，自上到下，从每个阶段入手，深入分析在每个阶段里都干了些什么。</p>\n"},{"title":"Vue 源码阅读 生命周期（三）","catalog":true,"date":"2020-01-02T10:50:16.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"## 1. 前言\n\n在上篇文章中，我们介绍了生命周期初始化阶段的整体工作流程，以及在该阶段都做了哪些事情。我们知道了，在该阶段会调用一些初始化函数，对`Vue`实例的属性、数据等进行初始化工作。那这些初始化函数都初始化了哪些东西以及都怎么初始化的呢？接下来我们就把这些初始化函数一一展开介绍，本篇文章介绍第一个初始化函数`initLifecycle`。\n\n## 2. initLifecycle函数分析\n\n`initLifecycle`函数的定义位于源码的`src/core/instance/lifecycle.js`中，其代码如下：\n\n```javascript\nexport function initLifecycle (vm: Component) {\n  const options = vm.$options\n\n  // locate first non-abstract parent\n  let parent = options.parent\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent\n    }\n    parent.$children.push(vm)\n  }\n\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n\n  vm.$children = []\n  vm.$refs = {}\n\n  vm._watcher = null\n  vm._inactive = null\n  vm._directInactive = false\n  vm._isMounted = false\n  vm._isDestroyed = false\n  vm._isBeingDestroyed = false\n}\n```\n\n可以看到，`initLifecycle`函数的代码量并不多，逻辑也不复杂。其主要是给`Vue`实例上挂载了一些属性并设置了默认值，值得一提的是挂载`$parent` 属性和`$root`属性， 下面我们就来逐个分析。\n\n首先是给实例上挂载`$parent`属性，这个属性有点意思，我们先来看看代码：\n\n```javascript\nlet parent = options.parent\nif (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent\n    }\n    parent.$children.push(vm)\n}\n\nvm.$parent = parent\n```\n\n从代码中可以看到，逻辑是这样子的：如果当前组件不是抽象组件并且存在父级，那么就通过`while`循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那就继续向上查找当前组件父级的父级，直到找到第一个不是抽象类型的父级时，将其赋值`vm.$parent`，同时把该实例自身添加进找到的父级的`$children`属性中。这样就确保了在子组件的`$parent`属性上能访问到父组件实例，在父组件的`$children`属性上也能访问子组件的实例。\n\n接着是给实例上挂载`$root`属性，如下：\n\n```javascript\nvm.$root = parent ? parent.$root : vm\n```\n\n实例的`$root`属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在父级，那么当前实例的根实例`$root`属性就是其父级的根实例`$root`属性，如果不存在，那么根实例`$root`属性就是它自己。这很好理解，举个例子：假如有一个人，他如果有父亲，那么他父亲的祖先肯定也是他的祖先，同理，他的儿子的祖先也肯定是他的祖先，我们不需要真正的一层一层的向上递归查找到他祖先本人，只需要知道他父亲的祖先是谁然后告诉他即可。如果他没有父亲，那说明他自己就是祖先，那么他后面的儿子、孙子的`$root`属性就是他自己了。\n\n这就是一个自上到下将根实例的`$root`属性依次传递给每一个子实例的过程。\n\n最后，再初始化了一些其它属性，因为都是简单的赋初始值，这里就不再一一介绍，等后面内容涉及到的时候再介绍。\n\n```javascript\nvm.$children = []\nvm.$refs = {}\n\nvm._watcher = null\nvm._inactive = null\nvm._directInactive = false\nvm._isMounted = false\nvm._isDestroyed = false\nvm._isBeingDestroyed = false\n```\n\n## 3. 总结\n\n  本篇文章介绍了初始化阶段调用的第一个初始化函数——`initLifecycle`函数。该函数的逻辑非常简单，就是给实例初始化了一些属性，包括以`$`开头的供用户使用的外部属性，也包括以`_`开头的供内部使用的内部属性。\n","source":"_posts/Vue 源码阅读 生命周期（三）.md","raw":"---\ntitle: Vue 源码阅读 生命周期（三） \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2020-01-02 18:50:16\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n## 1. 前言\n\n在上篇文章中，我们介绍了生命周期初始化阶段的整体工作流程，以及在该阶段都做了哪些事情。我们知道了，在该阶段会调用一些初始化函数，对`Vue`实例的属性、数据等进行初始化工作。那这些初始化函数都初始化了哪些东西以及都怎么初始化的呢？接下来我们就把这些初始化函数一一展开介绍，本篇文章介绍第一个初始化函数`initLifecycle`。\n\n## 2. initLifecycle函数分析\n\n`initLifecycle`函数的定义位于源码的`src/core/instance/lifecycle.js`中，其代码如下：\n\n```javascript\nexport function initLifecycle (vm: Component) {\n  const options = vm.$options\n\n  // locate first non-abstract parent\n  let parent = options.parent\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent\n    }\n    parent.$children.push(vm)\n  }\n\n  vm.$parent = parent\n  vm.$root = parent ? parent.$root : vm\n\n  vm.$children = []\n  vm.$refs = {}\n\n  vm._watcher = null\n  vm._inactive = null\n  vm._directInactive = false\n  vm._isMounted = false\n  vm._isDestroyed = false\n  vm._isBeingDestroyed = false\n}\n```\n\n可以看到，`initLifecycle`函数的代码量并不多，逻辑也不复杂。其主要是给`Vue`实例上挂载了一些属性并设置了默认值，值得一提的是挂载`$parent` 属性和`$root`属性， 下面我们就来逐个分析。\n\n首先是给实例上挂载`$parent`属性，这个属性有点意思，我们先来看看代码：\n\n```javascript\nlet parent = options.parent\nif (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent\n    }\n    parent.$children.push(vm)\n}\n\nvm.$parent = parent\n```\n\n从代码中可以看到，逻辑是这样子的：如果当前组件不是抽象组件并且存在父级，那么就通过`while`循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那就继续向上查找当前组件父级的父级，直到找到第一个不是抽象类型的父级时，将其赋值`vm.$parent`，同时把该实例自身添加进找到的父级的`$children`属性中。这样就确保了在子组件的`$parent`属性上能访问到父组件实例，在父组件的`$children`属性上也能访问子组件的实例。\n\n接着是给实例上挂载`$root`属性，如下：\n\n```javascript\nvm.$root = parent ? parent.$root : vm\n```\n\n实例的`$root`属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在父级，那么当前实例的根实例`$root`属性就是其父级的根实例`$root`属性，如果不存在，那么根实例`$root`属性就是它自己。这很好理解，举个例子：假如有一个人，他如果有父亲，那么他父亲的祖先肯定也是他的祖先，同理，他的儿子的祖先也肯定是他的祖先，我们不需要真正的一层一层的向上递归查找到他祖先本人，只需要知道他父亲的祖先是谁然后告诉他即可。如果他没有父亲，那说明他自己就是祖先，那么他后面的儿子、孙子的`$root`属性就是他自己了。\n\n这就是一个自上到下将根实例的`$root`属性依次传递给每一个子实例的过程。\n\n最后，再初始化了一些其它属性，因为都是简单的赋初始值，这里就不再一一介绍，等后面内容涉及到的时候再介绍。\n\n```javascript\nvm.$children = []\nvm.$refs = {}\n\nvm._watcher = null\nvm._inactive = null\nvm._directInactive = false\nvm._isMounted = false\nvm._isDestroyed = false\nvm._isBeingDestroyed = false\n```\n\n## 3. 总结\n\n  本篇文章介绍了初始化阶段调用的第一个初始化函数——`initLifecycle`函数。该函数的逻辑非常简单，就是给实例初始化了一些属性，包括以`$`开头的供用户使用的外部属性，也包括以`_`开头的供内部使用的内部属性。\n","slug":"Vue 源码阅读 生命周期（三）","published":1,"updated":"2020-01-02T10:44:32.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5g001dzws68s01j35a","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在上篇文章中，我们介绍了生命周期初始化阶段的整体工作流程，以及在该阶段都做了哪些事情。我们知道了，在该阶段会调用一些初始化函数，对<code>Vue</code>实例的属性、数据等进行初始化工作。那这些初始化函数都初始化了哪些东西以及都怎么初始化的呢？接下来我们就把这些初始化函数一一展开介绍，本篇文章介绍第一个初始化函数<code>initLifecycle</code>。</p>\n<h2><span id=\"2-initlifecycle函数分析\">2. initLifecycle函数分析</span></h2>\n<p><code>initLifecycle</code>函数的定义位于源码的<code>src/core/instance/lifecycle.js</code>中，其代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initLifecycle</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = vm.$options</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// locate first non-abstract parent</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> parent = options.parent</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">      parent = parent.$parent</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parent.$children.push(vm)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  vm.$parent = parent</span><br><span class=\"line\">  vm.$root = parent ? parent.$root : vm</span><br><span class=\"line\"></span><br><span class=\"line\">  vm.$children = []</span><br><span class=\"line\">  vm.$refs = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  vm._watcher = <span class=\"literal\">null</span></span><br><span class=\"line\">  vm._inactive = <span class=\"literal\">null</span></span><br><span class=\"line\">  vm._directInactive = <span class=\"literal\">false</span></span><br><span class=\"line\">  vm._isMounted = <span class=\"literal\">false</span></span><br><span class=\"line\">  vm._isDestroyed = <span class=\"literal\">false</span></span><br><span class=\"line\">  vm._isBeingDestroyed = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>initLifecycle</code>函数的代码量并不多，逻辑也不复杂。其主要是给<code>Vue</code>实例上挂载了一些属性并设置了默认值，值得一提的是挂载<code>$parent</code> 属性和<code>$root</code>属性， 下面我们就来逐个分析。</p>\n<p>首先是给实例上挂载<code>$parent</code>属性，这个属性有点意思，我们先来看看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> parent = options.parent</span><br><span class=\"line\"><span class=\"keyword\">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">        parent = parent.$parent</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parent.$children.push(vm)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vm.$parent = parent</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看到，逻辑是这样子的：如果当前组件不是抽象组件并且存在父级，那么就通过<code>while</code>循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那就继续向上查找当前组件父级的父级，直到找到第一个不是抽象类型的父级时，将其赋值<code>vm.$parent</code>，同时把该实例自身添加进找到的父级的<code>$children</code>属性中。这样就确保了在子组件的<code>$parent</code>属性上能访问到父组件实例，在父组件的<code>$children</code>属性上也能访问子组件的实例。</p>\n<p>接着是给实例上挂载<code>$root</code>属性，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$root = parent ? parent.$root : vm</span><br></pre></td></tr></table></figure>\n<p>实例的<code>$root</code>属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在父级，那么当前实例的根实例<code>$root</code>属性就是其父级的根实例<code>$root</code>属性，如果不存在，那么根实例<code>$root</code>属性就是它自己。这很好理解，举个例子：假如有一个人，他如果有父亲，那么他父亲的祖先肯定也是他的祖先，同理，他的儿子的祖先也肯定是他的祖先，我们不需要真正的一层一层的向上递归查找到他祖先本人，只需要知道他父亲的祖先是谁然后告诉他即可。如果他没有父亲，那说明他自己就是祖先，那么他后面的儿子、孙子的<code>$root</code>属性就是他自己了。</p>\n<p>这就是一个自上到下将根实例的<code>$root</code>属性依次传递给每一个子实例的过程。</p>\n<p>最后，再初始化了一些其它属性，因为都是简单的赋初始值，这里就不再一一介绍，等后面内容涉及到的时候再介绍。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$children = []</span><br><span class=\"line\">vm.$refs = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vm._watcher = <span class=\"literal\">null</span></span><br><span class=\"line\">vm._inactive = <span class=\"literal\">null</span></span><br><span class=\"line\">vm._directInactive = <span class=\"literal\">false</span></span><br><span class=\"line\">vm._isMounted = <span class=\"literal\">false</span></span><br><span class=\"line\">vm._isDestroyed = <span class=\"literal\">false</span></span><br><span class=\"line\">vm._isBeingDestroyed = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"3-总结\">3. 总结</span></h2>\n<p>本篇文章介绍了初始化阶段调用的第一个初始化函数——<code>initLifecycle</code>函数。该函数的逻辑非常简单，就是给实例初始化了一些属性，包括以<code>$</code>开头的供用户使用的外部属性，也包括以<code>_</code>开头的供内部使用的内部属性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在上篇文章中，我们介绍了生命周期初始化阶段的整体工作流程，以及在该阶段都做了哪些事情。我们知道了，在该阶段会调用一些初始化函数，对<code>Vue</code>实例的属性、数据等进行初始化工作。那这些初始化函数都初始化了哪些东西以及都怎么初始化的呢？接下来我们就把这些初始化函数一一展开介绍，本篇文章介绍第一个初始化函数<code>initLifecycle</code>。</p>\n<h2>2. initLifecycle函数分析</h2>\n<p><code>initLifecycle</code>函数的定义位于源码的<code>src/core/instance/lifecycle.js</code>中，其代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initLifecycle</span> (<span class=\"params\">vm: Component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = vm.$options</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// locate first non-abstract parent</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> parent = options.parent</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">      parent = parent.$parent</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parent.$children.push(vm)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  vm.$parent = parent</span><br><span class=\"line\">  vm.$root = parent ? parent.$root : vm</span><br><span class=\"line\"></span><br><span class=\"line\">  vm.$children = []</span><br><span class=\"line\">  vm.$refs = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  vm._watcher = <span class=\"literal\">null</span></span><br><span class=\"line\">  vm._inactive = <span class=\"literal\">null</span></span><br><span class=\"line\">  vm._directInactive = <span class=\"literal\">false</span></span><br><span class=\"line\">  vm._isMounted = <span class=\"literal\">false</span></span><br><span class=\"line\">  vm._isDestroyed = <span class=\"literal\">false</span></span><br><span class=\"line\">  vm._isBeingDestroyed = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>initLifecycle</code>函数的代码量并不多，逻辑也不复杂。其主要是给<code>Vue</code>实例上挂载了一些属性并设置了默认值，值得一提的是挂载<code>$parent</code> 属性和<code>$root</code>属性， 下面我们就来逐个分析。</p>\n<p>首先是给实例上挂载<code>$parent</code>属性，这个属性有点意思，我们先来看看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> parent = options.parent</span><br><span class=\"line\"><span class=\"keyword\">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">        parent = parent.$parent</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parent.$children.push(vm)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vm.$parent = parent</span><br></pre></td></tr></table></figure>\n<p>从代码中可以看到，逻辑是这样子的：如果当前组件不是抽象组件并且存在父级，那么就通过<code>while</code>循环来向上循环，如果当前组件的父级是抽象组件并且也存在父级，那就继续向上查找当前组件父级的父级，直到找到第一个不是抽象类型的父级时，将其赋值<code>vm.$parent</code>，同时把该实例自身添加进找到的父级的<code>$children</code>属性中。这样就确保了在子组件的<code>$parent</code>属性上能访问到父组件实例，在父组件的<code>$children</code>属性上也能访问子组件的实例。</p>\n<p>接着是给实例上挂载<code>$root</code>属性，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$root = parent ? parent.$root : vm</span><br></pre></td></tr></table></figure>\n<p>实例的<code>$root</code>属性表示当前实例的根实例，挂载该属性时，首先会判断如果当前实例存在父级，那么当前实例的根实例<code>$root</code>属性就是其父级的根实例<code>$root</code>属性，如果不存在，那么根实例<code>$root</code>属性就是它自己。这很好理解，举个例子：假如有一个人，他如果有父亲，那么他父亲的祖先肯定也是他的祖先，同理，他的儿子的祖先也肯定是他的祖先，我们不需要真正的一层一层的向上递归查找到他祖先本人，只需要知道他父亲的祖先是谁然后告诉他即可。如果他没有父亲，那说明他自己就是祖先，那么他后面的儿子、孙子的<code>$root</code>属性就是他自己了。</p>\n<p>这就是一个自上到下将根实例的<code>$root</code>属性依次传递给每一个子实例的过程。</p>\n<p>最后，再初始化了一些其它属性，因为都是简单的赋初始值，这里就不再一一介绍，等后面内容涉及到的时候再介绍。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$children = []</span><br><span class=\"line\">vm.$refs = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vm._watcher = <span class=\"literal\">null</span></span><br><span class=\"line\">vm._inactive = <span class=\"literal\">null</span></span><br><span class=\"line\">vm._directInactive = <span class=\"literal\">false</span></span><br><span class=\"line\">vm._isMounted = <span class=\"literal\">false</span></span><br><span class=\"line\">vm._isDestroyed = <span class=\"literal\">false</span></span><br><span class=\"line\">vm._isBeingDestroyed = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2>3. 总结</h2>\n<p>本篇文章介绍了初始化阶段调用的第一个初始化函数——<code>initLifecycle</code>函数。该函数的逻辑非常简单，就是给实例初始化了一些属性，包括以<code>$</code>开头的供用户使用的外部属性，也包括以<code>_</code>开头的供内部使用的内部属性。</p>\n"},{"title":"Vue 源码阅读开始 第一篇","catalog":true,"date":"2019-10-18T02:32:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n作为一名前端开发，日常开发的技术栈是`Vue`，并且用`Vue`开发也有一年多了，对其用法也较为熟练了，但是对各种用法和各种`api`使用都是只知其然而不知其所以然，因此，有时候在排查`bug`的时候就会有点捉襟见肘。鉴于此，索性就从`github`上`clone`下来一份`Vue`源码来学习学习，本系列博文将用来记录博主对`Vue`源码的整个学习过程，以及自己对源码的一些理解。一方面开阔自己的知识视野，另一方面也希望这些文字能够带给他人些许帮助。\n\n## 2. 学习规划\n\n### 2.1 源码学习目录\n\n本项目所剖析的`Vue.js`源码版本是目前最新的版本，版本号为 v2.6.11 ，其代码目录如下：\n\n```bash\n├─dist                   # 项目构建后的文件\n├─scripts                # 与项目构建相关的脚本和配置文件 \n├─flow                   # flow的类型声明文件\n├─src                    # 项目源代码\n│    ├─complier          # 与模板编译相关的代码\n│    ├─core              # 通用的、与运行平台无关的运行时代码\n│    │  ├─observe        # 实现变化侦测的代码\n│    │  ├─vdom           # 实现virtual dom的代码\n│    │  ├─instance       # Vue.js实例的构造函数和原型方法\n│    │  ├─global-api     # 全局api的代码\n│    │  └─components     # 内置组件的代码\n│    ├─server            # 与服务端渲染相关的代码\n│    ├─platforms         # 特定运行平台的代码，如weex \n│    ├─sfc               # 单文件组件的解析代码\n│    └─shared            # 项目公用的工具代码\n└─test                   # 项目测试代码\n```\n\n从上面的目录结构可以看出，`Vue`的整个项目包含了类型检测相关、单元测试相关、与平台无关的核心代码以及跨平台运行的相关代码。\n\n由于我们只是学习`Vue.js`的设计思想以及代码实现的相关逻辑，所以我们暂不去关心类型检测、单元测试以及特定平台运行等相关逻辑实现，仅关注它的核心代码，即`src/core`和`src/complier`这两个目录下的代码，并且接下来后续的学习也都是只在这两个目录的范围之内。\n\n### 2.2 学习路线\n\n在学习之前，我们需要先制定一个学习路线，循序渐进的学习，这样不至于一头雾水，无处下手。后面的学习路线如下：\n\n1. 变化侦测篇\n\n   学习`Vue`中如何实现数据的响应式系统，从而达到数据驱动视图。\n\n2. 虚拟DOM篇\n\n   学习什么是虚拟DOM，以及`Vue`中的`DOM-Diff`原理\n\n3. 模板编译篇\n\n   学习`Vue`内部是怎么把`template`模板编译成虚拟`DOM`,从而渲染出真实`DOM`\n\n4. 实例方法篇\n\n   学习`Vue`中所有实例方法(即所有以`$`开头的方法)的实现原理\n\n5. 全局API篇\n\n   学习`Vue`中所有全局`API`的实现原理\n\n6. 生命周期篇\n\n   学习`Vue`中组件的生命周期实现原理\n\n7. 指令篇\n\n   学习`Vue`中所有指令的实现原理\n\n8. 过滤器篇\n\n   学习`Vue`中所有过滤器的实现原理\n\n9. 内置组件篇\n\n   学习`Vue`中内置组件的实现原理\n\n\n### 2.3 学习输出\n\n通过一步步的学习，博主打算在学习过程中输出以下三个东西：\n\n- 以文字形式记录学习过程；\n- 为`clone`下来的`Vue`源码添加尽可能详细的注释；\n- 做一份思维导图，以宏观角度总览源码；\n","source":"_posts/Vue 源码阅读开始 第一篇 .md","raw":"---\ntitle: Vue 源码阅读开始 第一篇 \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-18 10:32:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n作为一名前端开发，日常开发的技术栈是`Vue`，并且用`Vue`开发也有一年多了，对其用法也较为熟练了，但是对各种用法和各种`api`使用都是只知其然而不知其所以然，因此，有时候在排查`bug`的时候就会有点捉襟见肘。鉴于此，索性就从`github`上`clone`下来一份`Vue`源码来学习学习，本系列博文将用来记录博主对`Vue`源码的整个学习过程，以及自己对源码的一些理解。一方面开阔自己的知识视野，另一方面也希望这些文字能够带给他人些许帮助。\n\n## 2. 学习规划\n\n### 2.1 源码学习目录\n\n本项目所剖析的`Vue.js`源码版本是目前最新的版本，版本号为 v2.6.11 ，其代码目录如下：\n\n```bash\n├─dist                   # 项目构建后的文件\n├─scripts                # 与项目构建相关的脚本和配置文件 \n├─flow                   # flow的类型声明文件\n├─src                    # 项目源代码\n│    ├─complier          # 与模板编译相关的代码\n│    ├─core              # 通用的、与运行平台无关的运行时代码\n│    │  ├─observe        # 实现变化侦测的代码\n│    │  ├─vdom           # 实现virtual dom的代码\n│    │  ├─instance       # Vue.js实例的构造函数和原型方法\n│    │  ├─global-api     # 全局api的代码\n│    │  └─components     # 内置组件的代码\n│    ├─server            # 与服务端渲染相关的代码\n│    ├─platforms         # 特定运行平台的代码，如weex \n│    ├─sfc               # 单文件组件的解析代码\n│    └─shared            # 项目公用的工具代码\n└─test                   # 项目测试代码\n```\n\n从上面的目录结构可以看出，`Vue`的整个项目包含了类型检测相关、单元测试相关、与平台无关的核心代码以及跨平台运行的相关代码。\n\n由于我们只是学习`Vue.js`的设计思想以及代码实现的相关逻辑，所以我们暂不去关心类型检测、单元测试以及特定平台运行等相关逻辑实现，仅关注它的核心代码，即`src/core`和`src/complier`这两个目录下的代码，并且接下来后续的学习也都是只在这两个目录的范围之内。\n\n### 2.2 学习路线\n\n在学习之前，我们需要先制定一个学习路线，循序渐进的学习，这样不至于一头雾水，无处下手。后面的学习路线如下：\n\n1. 变化侦测篇\n\n   学习`Vue`中如何实现数据的响应式系统，从而达到数据驱动视图。\n\n2. 虚拟DOM篇\n\n   学习什么是虚拟DOM，以及`Vue`中的`DOM-Diff`原理\n\n3. 模板编译篇\n\n   学习`Vue`内部是怎么把`template`模板编译成虚拟`DOM`,从而渲染出真实`DOM`\n\n4. 实例方法篇\n\n   学习`Vue`中所有实例方法(即所有以`$`开头的方法)的实现原理\n\n5. 全局API篇\n\n   学习`Vue`中所有全局`API`的实现原理\n\n6. 生命周期篇\n\n   学习`Vue`中组件的生命周期实现原理\n\n7. 指令篇\n\n   学习`Vue`中所有指令的实现原理\n\n8. 过滤器篇\n\n   学习`Vue`中所有过滤器的实现原理\n\n9. 内置组件篇\n\n   学习`Vue`中内置组件的实现原理\n\n\n### 2.3 学习输出\n\n通过一步步的学习，博主打算在学习过程中输出以下三个东西：\n\n- 以文字形式记录学习过程；\n- 为`clone`下来的`Vue`源码添加尽可能详细的注释；\n- 做一份思维导图，以宏观角度总览源码；\n","slug":"Vue 源码阅读开始 第一篇 ","published":1,"updated":"2019-12-31T03:12:30.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5h001fzws6r54ibvto","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>作为一名前端开发，日常开发的技术栈是<code>Vue</code>，并且用<code>Vue</code>开发也有一年多了，对其用法也较为熟练了，但是对各种用法和各种<code>api</code>使用都是只知其然而不知其所以然，因此，有时候在排查<code>bug</code>的时候就会有点捉襟见肘。鉴于此，索性就从<code>github</code>上<code>clone</code>下来一份<code>Vue</code>源码来学习学习，本系列博文将用来记录博主对<code>Vue</code>源码的整个学习过程，以及自己对源码的一些理解。一方面开阔自己的知识视野，另一方面也希望这些文字能够带给他人些许帮助。</p>\n<h2><span id=\"2-学习规划\">2. 学习规划</span></h2>\n<h3><span id=\"21-源码学习目录\">2.1 源码学习目录</span></h3>\n<p>本项目所剖析的<code>Vue.js</code>源码版本是目前最新的版本，版本号为 v2.6.11 ，其代码目录如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├─dist                   <span class=\"comment\"># 项目构建后的文件</span></span><br><span class=\"line\">├─scripts                <span class=\"comment\"># 与项目构建相关的脚本和配置文件 </span></span><br><span class=\"line\">├─flow                   <span class=\"comment\"># flow的类型声明文件</span></span><br><span class=\"line\">├─src                    <span class=\"comment\"># 项目源代码</span></span><br><span class=\"line\">│    ├─complier          <span class=\"comment\"># 与模板编译相关的代码</span></span><br><span class=\"line\">│    ├─core              <span class=\"comment\"># 通用的、与运行平台无关的运行时代码</span></span><br><span class=\"line\">│    │  ├─observe        <span class=\"comment\"># 实现变化侦测的代码</span></span><br><span class=\"line\">│    │  ├─vdom           <span class=\"comment\"># 实现virtual dom的代码</span></span><br><span class=\"line\">│    │  ├─instance       <span class=\"comment\"># Vue.js实例的构造函数和原型方法</span></span><br><span class=\"line\">│    │  ├─global-api     <span class=\"comment\"># 全局api的代码</span></span><br><span class=\"line\">│    │  └─components     <span class=\"comment\"># 内置组件的代码</span></span><br><span class=\"line\">│    ├─server            <span class=\"comment\"># 与服务端渲染相关的代码</span></span><br><span class=\"line\">│    ├─platforms         <span class=\"comment\"># 特定运行平台的代码，如weex </span></span><br><span class=\"line\">│    ├─sfc               <span class=\"comment\"># 单文件组件的解析代码</span></span><br><span class=\"line\">│    └─shared            <span class=\"comment\"># 项目公用的工具代码</span></span><br><span class=\"line\">└─<span class=\"built_in\">test</span>                   <span class=\"comment\"># 项目测试代码</span></span><br></pre></td></tr></table></figure>\n<p>从上面的目录结构可以看出，<code>Vue</code>的整个项目包含了类型检测相关、单元测试相关、与平台无关的核心代码以及跨平台运行的相关代码。</p>\n<p>由于我们只是学习<code>Vue.js</code>的设计思想以及代码实现的相关逻辑，所以我们暂不去关心类型检测、单元测试以及特定平台运行等相关逻辑实现，仅关注它的核心代码，即<code>src/core</code>和<code>src/complier</code>这两个目录下的代码，并且接下来后续的学习也都是只在这两个目录的范围之内。</p>\n<h3><span id=\"22-学习路线\">2.2 学习路线</span></h3>\n<p>在学习之前，我们需要先制定一个学习路线，循序渐进的学习，这样不至于一头雾水，无处下手。后面的学习路线如下：</p>\n<ol>\n<li>\n<p>变化侦测篇</p>\n<p>学习<code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</p>\n</li>\n<li>\n<p>虚拟DOM篇</p>\n<p>学习什么是虚拟DOM，以及<code>Vue</code>中的<code>DOM-Diff</code>原理</p>\n</li>\n<li>\n<p>模板编译篇</p>\n<p>学习<code>Vue</code>内部是怎么把<code>template</code>模板编译成虚拟<code>DOM</code>,从而渲染出真实<code>DOM</code></p>\n</li>\n<li>\n<p>实例方法篇</p>\n<p>学习<code>Vue</code>中所有实例方法(即所有以<code>$</code>开头的方法)的实现原理</p>\n</li>\n<li>\n<p>全局API篇</p>\n<p>学习<code>Vue</code>中所有全局<code>API</code>的实现原理</p>\n</li>\n<li>\n<p>生命周期篇</p>\n<p>学习<code>Vue</code>中组件的生命周期实现原理</p>\n</li>\n<li>\n<p>指令篇</p>\n<p>学习<code>Vue</code>中所有指令的实现原理</p>\n</li>\n<li>\n<p>过滤器篇</p>\n<p>学习<code>Vue</code>中所有过滤器的实现原理</p>\n</li>\n<li>\n<p>内置组件篇</p>\n<p>学习<code>Vue</code>中内置组件的实现原理</p>\n</li>\n</ol>\n<h3><span id=\"23-学习输出\">2.3 学习输出</span></h3>\n<p>通过一步步的学习，博主打算在学习过程中输出以下三个东西：</p>\n<ul>\n<li>以文字形式记录学习过程；</li>\n<li>为<code>clone</code>下来的<code>Vue</code>源码添加尽可能详细的注释；</li>\n<li>做一份思维导图，以宏观角度总览源码；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>作为一名前端开发，日常开发的技术栈是<code>Vue</code>，并且用<code>Vue</code>开发也有一年多了，对其用法也较为熟练了，但是对各种用法和各种<code>api</code>使用都是只知其然而不知其所以然，因此，有时候在排查<code>bug</code>的时候就会有点捉襟见肘。鉴于此，索性就从<code>github</code>上<code>clone</code>下来一份<code>Vue</code>源码来学习学习，本系列博文将用来记录博主对<code>Vue</code>源码的整个学习过程，以及自己对源码的一些理解。一方面开阔自己的知识视野，另一方面也希望这些文字能够带给他人些许帮助。</p>\n<h2>2. 学习规划</h2>\n<h3>2.1 源码学习目录</h3>\n<p>本项目所剖析的<code>Vue.js</code>源码版本是目前最新的版本，版本号为 v2.6.11 ，其代码目录如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├─dist                   <span class=\"comment\"># 项目构建后的文件</span></span><br><span class=\"line\">├─scripts                <span class=\"comment\"># 与项目构建相关的脚本和配置文件 </span></span><br><span class=\"line\">├─flow                   <span class=\"comment\"># flow的类型声明文件</span></span><br><span class=\"line\">├─src                    <span class=\"comment\"># 项目源代码</span></span><br><span class=\"line\">│    ├─complier          <span class=\"comment\"># 与模板编译相关的代码</span></span><br><span class=\"line\">│    ├─core              <span class=\"comment\"># 通用的、与运行平台无关的运行时代码</span></span><br><span class=\"line\">│    │  ├─observe        <span class=\"comment\"># 实现变化侦测的代码</span></span><br><span class=\"line\">│    │  ├─vdom           <span class=\"comment\"># 实现virtual dom的代码</span></span><br><span class=\"line\">│    │  ├─instance       <span class=\"comment\"># Vue.js实例的构造函数和原型方法</span></span><br><span class=\"line\">│    │  ├─global-api     <span class=\"comment\"># 全局api的代码</span></span><br><span class=\"line\">│    │  └─components     <span class=\"comment\"># 内置组件的代码</span></span><br><span class=\"line\">│    ├─server            <span class=\"comment\"># 与服务端渲染相关的代码</span></span><br><span class=\"line\">│    ├─platforms         <span class=\"comment\"># 特定运行平台的代码，如weex </span></span><br><span class=\"line\">│    ├─sfc               <span class=\"comment\"># 单文件组件的解析代码</span></span><br><span class=\"line\">│    └─shared            <span class=\"comment\"># 项目公用的工具代码</span></span><br><span class=\"line\">└─<span class=\"built_in\">test</span>                   <span class=\"comment\"># 项目测试代码</span></span><br></pre></td></tr></table></figure>\n<p>从上面的目录结构可以看出，<code>Vue</code>的整个项目包含了类型检测相关、单元测试相关、与平台无关的核心代码以及跨平台运行的相关代码。</p>\n<p>由于我们只是学习<code>Vue.js</code>的设计思想以及代码实现的相关逻辑，所以我们暂不去关心类型检测、单元测试以及特定平台运行等相关逻辑实现，仅关注它的核心代码，即<code>src/core</code>和<code>src/complier</code>这两个目录下的代码，并且接下来后续的学习也都是只在这两个目录的范围之内。</p>\n<h3>2.2 学习路线</h3>\n<p>在学习之前，我们需要先制定一个学习路线，循序渐进的学习，这样不至于一头雾水，无处下手。后面的学习路线如下：</p>\n<ol>\n<li>\n<p>变化侦测篇</p>\n<p>学习<code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</p>\n</li>\n<li>\n<p>虚拟DOM篇</p>\n<p>学习什么是虚拟DOM，以及<code>Vue</code>中的<code>DOM-Diff</code>原理</p>\n</li>\n<li>\n<p>模板编译篇</p>\n<p>学习<code>Vue</code>内部是怎么把<code>template</code>模板编译成虚拟<code>DOM</code>,从而渲染出真实<code>DOM</code></p>\n</li>\n<li>\n<p>实例方法篇</p>\n<p>学习<code>Vue</code>中所有实例方法(即所有以<code>$</code>开头的方法)的实现原理</p>\n</li>\n<li>\n<p>全局API篇</p>\n<p>学习<code>Vue</code>中所有全局<code>API</code>的实现原理</p>\n</li>\n<li>\n<p>生命周期篇</p>\n<p>学习<code>Vue</code>中组件的生命周期实现原理</p>\n</li>\n<li>\n<p>指令篇</p>\n<p>学习<code>Vue</code>中所有指令的实现原理</p>\n</li>\n<li>\n<p>过滤器篇</p>\n<p>学习<code>Vue</code>中所有过滤器的实现原理</p>\n</li>\n<li>\n<p>内置组件篇</p>\n<p>学习<code>Vue</code>中内置组件的实现原理</p>\n</li>\n</ol>\n<h3>2.3 学习输出</h3>\n<p>通过一步步的学习，博主打算在学习过程中输出以下三个东西：</p>\n<ul>\n<li>以文字形式记录学习过程；</li>\n<li>为<code>clone</code>下来的<code>Vue</code>源码添加尽可能详细的注释；</li>\n<li>做一份思维导图，以宏观角度总览源码；</li>\n</ul>\n"},{"title":"centOS中利用Docker安装gitlab","catalog":true,"url":"111.html","id":"111","date":"2019-02-21T03:37:05.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://images0.cnblogs.com/news/66372/201507/052157452643027.png)\n\n#### 首先安装虚拟机或者直接在你的云主机上操作\n\n#### 修改centos 默认配置 查看IP\n\n> centos 配置最好高于：4G 2核，否则运行不起来\n\n#### 查看centos的IP地址\n\n     ip addr \n    \n\n#### 无法查询IP的解决办法\n\n> 进入`ect/sysconfig/network-scripts`文件夹,修改对应的网卡配置文件，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/17.png)\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/18.png)\n\n      service network start\n    \n\n> 然后查看IP地址\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/19.png)\n\n#### 安装docker 并启动\n\n> 1.  `yum -y install docker`\n> 2.  `systemctl start docker`\n> 3.  `docker login #输入你的用户名和密码`\n> 4.  `docker pull gitlab/gitlab-ce:latest #可能需要一些时间`\n> \n> 最后创建并启动容器\n\n    docker run -d \\\n    --hostname 192.168.50.27 \\\n    -p 443:443 \\\n    -p 80:80 \\\n    -p 9090:9090 \\\n    --name gitlab \\\n    --restart always \\\n    -v /home/gitlab/config:/etc/gitlab \\\n    -v /home/gitlab/log:/var/log/gitlab \\\n    -v /home/gitlab/opt:/var/opt/gitlab \\\n    --privileged=true gitlab/gitlab-ce:latest\n    \n\n#### 需要等一会，打开游览器输入虚拟机或者云服务器的公网IP\n\n> 如图 1\\. 重置密码\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/20.png)\n\n> 2.  登录和注册\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/21.png)\n\n> 3.  登录后主界面\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/22.png)\n\n#### 配置gitlab\n\n> 查看容器id `shell docekr ps -a` 进入容器命令行\n\n      docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n    \n\n> 参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)","source":"_posts/centOS中利用Docker安装gitlab.md","raw":"---\ntitle: centOS中利用Docker安装gitlab\ncatalog: true\ntags:\n  - Docker\n  - git\n  - gitlab\nurl: 111.html\nid: 111\ncategories:\n  - Docker\ndate: 2019-02-21 11:37:05\nsubtitle:\nheader-img:\n---\n\n![](http://images0.cnblogs.com/news/66372/201507/052157452643027.png)\n\n#### 首先安装虚拟机或者直接在你的云主机上操作\n\n#### 修改centos 默认配置 查看IP\n\n> centos 配置最好高于：4G 2核，否则运行不起来\n\n#### 查看centos的IP地址\n\n     ip addr \n    \n\n#### 无法查询IP的解决办法\n\n> 进入`ect/sysconfig/network-scripts`文件夹,修改对应的网卡配置文件，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/17.png)\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/18.png)\n\n      service network start\n    \n\n> 然后查看IP地址\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/19.png)\n\n#### 安装docker 并启动\n\n> 1.  `yum -y install docker`\n> 2.  `systemctl start docker`\n> 3.  `docker login #输入你的用户名和密码`\n> 4.  `docker pull gitlab/gitlab-ce:latest #可能需要一些时间`\n> \n> 最后创建并启动容器\n\n    docker run -d \\\n    --hostname 192.168.50.27 \\\n    -p 443:443 \\\n    -p 80:80 \\\n    -p 9090:9090 \\\n    --name gitlab \\\n    --restart always \\\n    -v /home/gitlab/config:/etc/gitlab \\\n    -v /home/gitlab/log:/var/log/gitlab \\\n    -v /home/gitlab/opt:/var/opt/gitlab \\\n    --privileged=true gitlab/gitlab-ce:latest\n    \n\n#### 需要等一会，打开游览器输入虚拟机或者云服务器的公网IP\n\n> 如图 1\\. 重置密码\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/20.png)\n\n> 2.  登录和注册\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/21.png)\n\n> 3.  登录后主界面\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/22.png)\n\n#### 配置gitlab\n\n> 查看容器id `shell docekr ps -a` 进入容器命令行\n\n      docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n    \n\n> 参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)","slug":"centOS中利用Docker安装gitlab","published":1,"updated":"2019-12-31T03:00:25.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5i001jzws6m69cwmr4","content":"<p><img src=\"http://images0.cnblogs.com/news/66372/201507/052157452643027.png\" alt></p>\n<h4><span id=\"首先安装虚拟机或者直接在你的云主机上操作\">首先安装虚拟机或者直接在你的云主机上操作</span></h4>\n<h4><span id=\"修改centos-默认配置-查看ip\">修改centos 默认配置 查看IP</span></h4>\n<blockquote>\n<p>centos 配置最好高于：4G 2核，否则运行不起来</p>\n</blockquote>\n<h4><span id=\"查看centos的ip地址\">查看centos的IP地址</span></h4>\n<pre><code> ip addr \n</code></pre>\n<h4><span id=\"无法查询ip的解决办法\">无法查询IP的解决办法</span></h4>\n<blockquote>\n<p>进入<code>ect/sysconfig/network-scripts</code>文件夹,修改对应的网卡配置文件，如图所示</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/17.png\" alt></p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/18.png\" alt></p>\n<pre><code>  service network start\n</code></pre>\n<blockquote>\n<p>然后查看IP地址</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/19.png\" alt></p>\n<h4><span id=\"安装docker-并启动\">安装docker 并启动</span></h4>\n<blockquote>\n<ol>\n<li><code>yum -y install docker</code></li>\n<li><code>systemctl start docker</code></li>\n<li><code>docker login #输入你的用户名和密码</code></li>\n<li><code>docker pull gitlab/gitlab-ce:latest #可能需要一些时间</code></li>\n</ol>\n<p>最后创建并启动容器</p>\n</blockquote>\n<pre><code>docker run -d \\\n--hostname 192.168.50.27 \\\n-p 443:443 \\\n-p 80:80 \\\n-p 9090:9090 \\\n--name gitlab \\\n--restart always \\\n-v /home/gitlab/config:/etc/gitlab \\\n-v /home/gitlab/log:/var/log/gitlab \\\n-v /home/gitlab/opt:/var/opt/gitlab \\\n--privileged=true gitlab/gitlab-ce:latest\n</code></pre>\n<h4><span id=\"需要等一会打开游览器输入虚拟机或者云服务器的公网ip\">需要等一会，打开游览器输入虚拟机或者云服务器的公网IP</span></h4>\n<blockquote>\n<p>如图 1. 重置密码</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/20.png\" alt></p>\n<blockquote>\n<ol start=\"2\">\n<li>登录和注册</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/21.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>登录后主界面</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/22.png\" alt></p>\n<h4><span id=\"配置gitlab\">配置gitlab</span></h4>\n<blockquote>\n<p>查看容器id <code>shell docekr ps -a</code> 进入容器命令行</p>\n</blockquote>\n<pre><code>  docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n</code></pre>\n<blockquote>\n<p>参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://images0.cnblogs.com/news/66372/201507/052157452643027.png\" alt></p>\n<h4>首先安装虚拟机或者直接在你的云主机上操作</h4>\n<h4>修改centos 默认配置 查看IP</h4>\n<blockquote>\n<p>centos 配置最好高于：4G 2核，否则运行不起来</p>\n</blockquote>\n<h4>查看centos的IP地址</h4>\n<pre><code> ip addr \n</code></pre>\n<h4>无法查询IP的解决办法</h4>\n<blockquote>\n<p>进入<code>ect/sysconfig/network-scripts</code>文件夹,修改对应的网卡配置文件，如图所示</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/17.png\" alt></p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/18.png\" alt></p>\n<pre><code>  service network start\n</code></pre>\n<blockquote>\n<p>然后查看IP地址</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/19.png\" alt></p>\n<h4>安装docker 并启动</h4>\n<blockquote>\n<ol>\n<li><code>yum -y install docker</code></li>\n<li><code>systemctl start docker</code></li>\n<li><code>docker login #输入你的用户名和密码</code></li>\n<li><code>docker pull gitlab/gitlab-ce:latest #可能需要一些时间</code></li>\n</ol>\n<p>最后创建并启动容器</p>\n</blockquote>\n<pre><code>docker run -d \\\n--hostname 192.168.50.27 \\\n-p 443:443 \\\n-p 80:80 \\\n-p 9090:9090 \\\n--name gitlab \\\n--restart always \\\n-v /home/gitlab/config:/etc/gitlab \\\n-v /home/gitlab/log:/var/log/gitlab \\\n-v /home/gitlab/opt:/var/opt/gitlab \\\n--privileged=true gitlab/gitlab-ce:latest\n</code></pre>\n<h4>需要等一会，打开游览器输入虚拟机或者云服务器的公网IP</h4>\n<blockquote>\n<p>如图 1. 重置密码</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/20.png\" alt></p>\n<blockquote>\n<ol start=\"2\">\n<li>登录和注册</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/21.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>登录后主界面</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/22.png\" alt></p>\n<h4>配置gitlab</h4>\n<blockquote>\n<p>查看容器id <code>shell docekr ps -a</code> 进入容器命令行</p>\n</blockquote>\n<pre><code>  docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n</code></pre>\n<blockquote>\n<p>参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)</p>\n</blockquote>\n"},{"title":"graphQL 如和在客户端调用","catalog":true,"url":"92.html","id":"92","date":"2019-02-20T09:45:16.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://116.85.35.63/wp-content/uploads/2019/02/12.png)\n\n> 源码地址：[github地址](https://github.com/maliaoMJ/graphql-api-server)\n\n#### 1\\. 先展示目录结构\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/13.png)\n\n#### 2\\. 如何搭建\n\n> 1.  在上一篇文章的基础上，在 `index.js` 添加Express静态文件托管并且指明静态文件夹目录\n\n    app.use(express.static('public'));\n    \n\n> 2.  创建public目录并且在此文件中创建`index.html` 文件\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    </html>\n    \n\n此时你可以访问`localhost:3000/index.html` 可以看见你创建的index.html 文件，如下图：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/14.png)\n\n> 3.  我们要请求GraphQL数据 `(GraphQL 只支持GET和POST请求)`，在index.html的js中，添加如下代码：\n\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    \n\n1.  这里的query 请求的查询语句\n2.  这里的variables 是变量\n3.  这里的$id:Int!中的`!` 表示该参数不能为空,具体细节看下图:\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/15.png)\n\n> 4.  点击按钮，请求数据，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16.png)\n\n#### 3\\. 最后附源代码：\n\n> 1.  index.js 代码\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    \n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n    \n\n> 2.  index.html\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    <script type=\"text/javascript\">\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    </script>\n    \n    </html>\n    \n\n> 3.  执行命令,打开游览器localhost:3000/index.html\n\n      nodemon index.js","source":"_posts/graphQL 如和在客户端调用.md","raw":"---\ntitle: graphQL 如和在客户端调用\ncatalog: true\ntags:\n  - graphql\n  - nodejs\nurl: 92.html\nid: 92\ncategories:\n  - GraphQL\ndate: 2019-02-20 17:45:16\nsubtitle:\nheader-img:\n---\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/12.png)\n\n> 源码地址：[github地址](https://github.com/maliaoMJ/graphql-api-server)\n\n#### 1\\. 先展示目录结构\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/13.png)\n\n#### 2\\. 如何搭建\n\n> 1.  在上一篇文章的基础上，在 `index.js` 添加Express静态文件托管并且指明静态文件夹目录\n\n    app.use(express.static('public'));\n    \n\n> 2.  创建public目录并且在此文件中创建`index.html` 文件\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    </html>\n    \n\n此时你可以访问`localhost:3000/index.html` 可以看见你创建的index.html 文件，如下图：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/14.png)\n\n> 3.  我们要请求GraphQL数据 `(GraphQL 只支持GET和POST请求)`，在index.html的js中，添加如下代码：\n\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    \n\n1.  这里的query 请求的查询语句\n2.  这里的variables 是变量\n3.  这里的$id:Int!中的`!` 表示该参数不能为空,具体细节看下图:\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/15.png)\n\n> 4.  点击按钮，请求数据，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16.png)\n\n#### 3\\. 最后附源代码：\n\n> 1.  index.js 代码\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    \n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n    \n\n> 2.  index.html\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    <script type=\"text/javascript\">\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    </script>\n    \n    </html>\n    \n\n> 3.  执行命令,打开游览器localhost:3000/index.html\n\n      nodemon index.js","slug":"graphQL 如和在客户端调用","published":1,"updated":"2019-12-31T03:00:25.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5m001mzws64dak4n89","content":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/12.png\" alt></p>\n<blockquote>\n<p>源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n<h4><span id=\"1-先展示目录结构\">1. 先展示目录结构</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/13.png\" alt></p>\n<h4><span id=\"2-如何搭建\">2. 如何搭建</span></h4>\n<blockquote>\n<ol>\n<li>在上一篇文章的基础上，在 <code>index.js</code> 添加Express静态文件托管并且指明静态文件夹目录</li>\n</ol>\n</blockquote>\n<pre><code>app.use(express.static('public'));\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>创建public目录并且在此文件中创建<code>index.html</code> 文件</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时你可以访问<code>localhost:3000/index.html</code> 可以看见你创建的index.html 文件，如下图：</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/14.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>我们要请求GraphQL数据 <code>(GraphQL 只支持GET和POST请求)</code>，在index.html的js中，添加如下代码：</li>\n</ol>\n</blockquote>\n<pre><code>let btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n</code></pre>\n<ol>\n<li>这里的query 请求的查询语句</li>\n<li>这里的variables 是变量</li>\n<li>这里的$id:Int!中的<code>!</code> 表示该参数不能为空,具体细节看下图:</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/15.png\" alt></p>\n<blockquote>\n<ol start=\"4\">\n<li>点击按钮，请求数据，如图所示</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16.png\" alt></p>\n<h4><span id=\"3-最后附源代码\">3. 最后附源代码：</span></h4>\n<blockquote>\n<ol>\n<li>index.js 代码</li>\n</ol>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\n\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>index.html</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nlet btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>执行命令,打开游览器localhost:3000/index.html</li>\n</ol>\n</blockquote>\n<pre><code>  nodemon index.js</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/12.png\" alt></p>\n<blockquote>\n<p>源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n<h4>1. 先展示目录结构</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/13.png\" alt></p>\n<h4>2. 如何搭建</h4>\n<blockquote>\n<ol>\n<li>在上一篇文章的基础上，在 <code>index.js</code> 添加Express静态文件托管并且指明静态文件夹目录</li>\n</ol>\n</blockquote>\n<pre><code>app.use(express.static('public'));\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>创建public目录并且在此文件中创建<code>index.html</code> 文件</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时你可以访问<code>localhost:3000/index.html</code> 可以看见你创建的index.html 文件，如下图：</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/14.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>我们要请求GraphQL数据 <code>(GraphQL 只支持GET和POST请求)</code>，在index.html的js中，添加如下代码：</li>\n</ol>\n</blockquote>\n<pre><code>let btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n</code></pre>\n<ol>\n<li>这里的query 请求的查询语句</li>\n<li>这里的variables 是变量</li>\n<li>这里的$id:Int!中的<code>!</code> 表示该参数不能为空,具体细节看下图:</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/15.png\" alt></p>\n<blockquote>\n<ol start=\"4\">\n<li>点击按钮，请求数据，如图所示</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16.png\" alt></p>\n<h4>3. 最后附源代码：</h4>\n<blockquote>\n<ol>\n<li>index.js 代码</li>\n</ol>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\n\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>index.html</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nlet btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>执行命令,打开游览器localhost:3000/index.html</li>\n</ol>\n</blockquote>\n<pre><code>  nodemon index.js</code></pre>\n"},{"title":"前端面试系列 — HMTL基础篇","catalog":true,"url":"133.html","id":"133","date":"2019-02-26T04:25:17.000Z","subtitle":null,"header-img":null,"_content":"\n![banner image](http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg)\n\n> ##### 1\\. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。\n\n1.  DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）\n2.  DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。\n3.  DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。\n4.  如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。\n\n> ##### 2\\. HTML 与 XML 有什么区别\n\n主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。\n\n> ##### 3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。\n\n1.  块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr...\n2.  内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u...\n3.  判断行内元素和块级元素的快捷方法就是判断是否能并列。\n\n> ##### 4.说说HTML5新增了那些元素，以及如何更好的语义化。\n\n1.  header--显示头部信息，article---定义独立内容，常用于用户评语或博客条目，section---节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav---导航链接，在一个html中可以有多个nav， hgroup---适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer---眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。\n2.  其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等\n\n> #### 5.HTML5新增了那些API?\n> \n> 1.  Media API\n> 2.  Text Track API\n> 3.  Application Cache API\n> 4.  User Interaction\n> 5.  Data Transfer API\n> 6.  Command API\n> 7.  Constraint Validation API\n> 8.  History API\n> 9.  Canvas API\n> 10.  Geolocation API等等","source":"_posts/前端面试系列 — HMTL基础篇.md","raw":"---\ntitle: 前端面试系列 — HMTL基础篇\ncatalog: true\nurl: 133.html\nid: 133\ncategories:\n  - HTML5\ndate: 2019-02-26 12:25:17\nsubtitle:\nheader-img:\ntags:\n---\n\n![banner image](http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg)\n\n> ##### 1\\. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。\n\n1.  DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）\n2.  DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。\n3.  DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。\n4.  如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。\n\n> ##### 2\\. HTML 与 XML 有什么区别\n\n主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。\n\n> ##### 3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。\n\n1.  块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr...\n2.  内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u...\n3.  判断行内元素和块级元素的快捷方法就是判断是否能并列。\n\n> ##### 4.说说HTML5新增了那些元素，以及如何更好的语义化。\n\n1.  header--显示头部信息，article---定义独立内容，常用于用户评语或博客条目，section---节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav---导航链接，在一个html中可以有多个nav， hgroup---适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer---眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。\n2.  其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等\n\n> #### 5.HTML5新增了那些API?\n> \n> 1.  Media API\n> 2.  Text Track API\n> 3.  Application Cache API\n> 4.  User Interaction\n> 5.  Data Transfer API\n> 6.  Command API\n> 7.  Constraint Validation API\n> 8.  History API\n> 9.  Canvas API\n> 10.  Geolocation API等等","slug":"前端面试系列 — HMTL基础篇","published":1,"updated":"2019-12-31T03:00:25.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5n001pzws6a43v2o7h","content":"<p><img src=\"http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg\" alt=\"banner image\"></p>\n<blockquote>\n<h5><span id=\"1-html中首行-有什么作用-doctype-又分哪几类其中这些每一类由对应有什么作用请简单描述一下\">1. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。</span></h5>\n</blockquote>\n<ol>\n<li>DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）</li>\n<li>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。</li>\n<li>DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。</li>\n<li>如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。</li>\n</ol>\n<blockquote>\n<h5><span id=\"2-html-与-xml-有什么区别\">2. HTML 与 XML 有什么区别</span></h5>\n</blockquote>\n<p>主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。</p>\n<blockquote>\n<h5><span id=\"3说说html中有哪些块级元素那些内联元素以及块级元素与内联元素的区别\">3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。</span></h5>\n</blockquote>\n<ol>\n<li>块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr…</li>\n<li>内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u…</li>\n<li>判断行内元素和块级元素的快捷方法就是判断是否能并列。</li>\n</ol>\n<blockquote>\n<h5><span id=\"4说说html5新增了那些元素以及如何更好的语义化\">4.说说HTML5新增了那些元素，以及如何更好的语义化。</span></h5>\n</blockquote>\n<ol>\n<li>header–显示头部信息，article—定义独立内容，常用于用户评语或博客条目，section—节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav—导航链接，在一个html中可以有多个nav， hgroup—适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer—眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。</li>\n<li>其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等</li>\n</ol>\n<blockquote>\n<h4><span id=\"5html5新增了那些api\">5.HTML5新增了那些API?</span></h4>\n<ol>\n<li>Media API</li>\n<li>Text Track API</li>\n<li>Application Cache API</li>\n<li>User Interaction</li>\n<li>Data Transfer API</li>\n<li>Command API</li>\n<li>Constraint Validation API</li>\n<li>History API</li>\n<li>Canvas API</li>\n<li>Geolocation API等等</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg\" alt=\"banner image\"></p>\n<blockquote>\n<h5>1. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。</h5>\n</blockquote>\n<ol>\n<li>DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）</li>\n<li>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。</li>\n<li>DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。</li>\n<li>如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。</li>\n</ol>\n<blockquote>\n<h5>2. HTML 与 XML 有什么区别</h5>\n</blockquote>\n<p>主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。</p>\n<blockquote>\n<h5>3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。</h5>\n</blockquote>\n<ol>\n<li>块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr…</li>\n<li>内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u…</li>\n<li>判断行内元素和块级元素的快捷方法就是判断是否能并列。</li>\n</ol>\n<blockquote>\n<h5>4.说说HTML5新增了那些元素，以及如何更好的语义化。</h5>\n</blockquote>\n<ol>\n<li>header–显示头部信息，article—定义独立内容，常用于用户评语或博客条目，section—节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav—导航链接，在一个html中可以有多个nav， hgroup—适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer—眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。</li>\n<li>其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等</li>\n</ol>\n<blockquote>\n<h4>5.HTML5新增了那些API?</h4>\n<ol>\n<li>Media API</li>\n<li>Text Track API</li>\n<li>Application Cache API</li>\n<li>User Interaction</li>\n<li>Data Transfer API</li>\n<li>Command API</li>\n<li>Constraint Validation API</li>\n<li>History API</li>\n<li>Canvas API</li>\n<li>Geolocation API等等</li>\n</ol>\n</blockquote>\n"},{"title":"前端面试系列 — 布局篇","catalog":true,"url":"137.html","id":"137","date":"2019-02-26T04:28:40.000Z","subtitle":null,"header-img":null,"_content":"\n![images](http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg)\n\n> 一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。\n\n1.  利用浮动布局（圣杯布局和双飞翼布局）\n2.  利用定位布局\n3.  flex 布局\n4.  table 表格布局\n5.  grid 布局\n\n代码如下:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>layout</title>\n        <style>\n            *{\n                padding:0;\n                margin:0;\n            }\n            .layout{\n                height: 100px;\n                width: 100%;\n                margin-bottom:50px;\n                overflow: hidden;\n                position: relative;\n            }\n            .layout>div{\n                height:100px;\n            }\n            .float .left,.float .right {\n             width: 200px;\n             height:100px;\n            }\n            .float>.left{\n                float:left;\n                background:red;\n    \n            }\n            .float>.right{\n             float:right;\n             background:blue;\n            }\n            .float>.center{\n                background:green;\n    \n            }\n            /*定位 解决方案*/\n            .position>.left{\n                position:absolute;\n                left:0;\n                top:0;\n                background: red;\n                width:200px;\n                height:100px;\n            }\n            .position>.right{\n                position:absolute;\n                right:0;\n                top:0;\n                background: yellow;\n                width:200px;\n                height:100px;\n            }\n            .position>.center{\n                position: absolute;\n                left:200px;\n                right:200px;\n                background:green;\n            }\n            /*flex 解决方案*/\n            .flex{\n                display: flex;\n                height:100px;\n            }\n            .flex .right, .flex .left{\n                width:200px;\n                background:blue;\n            }\n            .flex .center{\n                flex:1;\n                background:red;\n            }\n            /*table 解决方案*/\n            .table{\n                display: table;\n            }\n            .table>.left,.table>.right{\n                height:100px;\n                width:300px;\n                display: table-cell;\n                background:yellow;\n            }\n            .table>.center{\n                background:red;\n                display: table-cell;\n            }\n            /*grid 解决方案*/\n            .grid {\n                display: grid;\n                grid-template-rows: 100;\n                grid-template-columns: 300px auto 300px;\n            }\n            .grid > .left,.grid >.right{\n               background:red;\n            }\n            .grid > .center{\n               background:yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <!-- float布局 圣杯和双飞翼布局-->\n        <section class=\"layout float\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>float 解决方案</h1>\n                <p>float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案</p>\n            </div>\n        </section>\n        <!-- 定位布局 -->\n        <section class=\"layout position\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>定位 解决方案</h1>\n                <p>定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案</p>\n            </div>\n        </section>\n        <!-- flex 布局 实现太过于简单略-->\n        <section class=\"layout flex\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>flex 解决方案</h1>\n                <p>flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- table 布局 -->\n        <section class=\"layout table\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>table 解决方案</h1>\n                <p>table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- grid 布局 -->\n        <section class=\"layout grid\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>Grid 解决方案</h1>\n                <p>Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n    </body>\n    </html>\n    \n    \n\n> ##### 思考假如高度不固定，上述的方案中又有那些符合要求。\n\n1.  flex布局\n2.  table布局\n3.  grid 布局","source":"_posts/前端面试系列 — 布局篇.md","raw":"---\ntitle: 前端面试系列 — 布局篇\ncatalog: true\nurl: 137.html\nid: 137\ncategories:\n  - CSS3\ndate: 2019-02-26 12:28:40\nsubtitle:\nheader-img:\ntags:\n---\n\n![images](http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg)\n\n> 一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。\n\n1.  利用浮动布局（圣杯布局和双飞翼布局）\n2.  利用定位布局\n3.  flex 布局\n4.  table 表格布局\n5.  grid 布局\n\n代码如下:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>layout</title>\n        <style>\n            *{\n                padding:0;\n                margin:0;\n            }\n            .layout{\n                height: 100px;\n                width: 100%;\n                margin-bottom:50px;\n                overflow: hidden;\n                position: relative;\n            }\n            .layout>div{\n                height:100px;\n            }\n            .float .left,.float .right {\n             width: 200px;\n             height:100px;\n            }\n            .float>.left{\n                float:left;\n                background:red;\n    \n            }\n            .float>.right{\n             float:right;\n             background:blue;\n            }\n            .float>.center{\n                background:green;\n    \n            }\n            /*定位 解决方案*/\n            .position>.left{\n                position:absolute;\n                left:0;\n                top:0;\n                background: red;\n                width:200px;\n                height:100px;\n            }\n            .position>.right{\n                position:absolute;\n                right:0;\n                top:0;\n                background: yellow;\n                width:200px;\n                height:100px;\n            }\n            .position>.center{\n                position: absolute;\n                left:200px;\n                right:200px;\n                background:green;\n            }\n            /*flex 解决方案*/\n            .flex{\n                display: flex;\n                height:100px;\n            }\n            .flex .right, .flex .left{\n                width:200px;\n                background:blue;\n            }\n            .flex .center{\n                flex:1;\n                background:red;\n            }\n            /*table 解决方案*/\n            .table{\n                display: table;\n            }\n            .table>.left,.table>.right{\n                height:100px;\n                width:300px;\n                display: table-cell;\n                background:yellow;\n            }\n            .table>.center{\n                background:red;\n                display: table-cell;\n            }\n            /*grid 解决方案*/\n            .grid {\n                display: grid;\n                grid-template-rows: 100;\n                grid-template-columns: 300px auto 300px;\n            }\n            .grid > .left,.grid >.right{\n               background:red;\n            }\n            .grid > .center{\n               background:yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <!-- float布局 圣杯和双飞翼布局-->\n        <section class=\"layout float\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>float 解决方案</h1>\n                <p>float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案</p>\n            </div>\n        </section>\n        <!-- 定位布局 -->\n        <section class=\"layout position\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>定位 解决方案</h1>\n                <p>定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案</p>\n            </div>\n        </section>\n        <!-- flex 布局 实现太过于简单略-->\n        <section class=\"layout flex\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>flex 解决方案</h1>\n                <p>flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- table 布局 -->\n        <section class=\"layout table\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>table 解决方案</h1>\n                <p>table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- grid 布局 -->\n        <section class=\"layout grid\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>Grid 解决方案</h1>\n                <p>Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n    </body>\n    </html>\n    \n    \n\n> ##### 思考假如高度不固定，上述的方案中又有那些符合要求。\n\n1.  flex布局\n2.  table布局\n3.  grid 布局","slug":"前端面试系列 — 布局篇","published":1,"updated":"2019-12-31T03:00:25.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5p001rzws6o6cb2ioe","content":"<p><img src=\"http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg\" alt=\"images\"></p>\n<blockquote>\n<p>一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。</p>\n</blockquote>\n<ol>\n<li>利用浮动布局（圣杯布局和双飞翼布局）</li>\n<li>利用定位布局</li>\n<li>flex 布局</li>\n<li>table 表格布局</li>\n<li>grid 布局</li>\n</ol>\n<p>代码如下:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;layout&lt;/title&gt;\n    &lt;style&gt;\n        *{\n            padding:0;\n            margin:0;\n        }\n        .layout{\n            height: 100px;\n            width: 100%;\n            margin-bottom:50px;\n            overflow: hidden;\n            position: relative;\n        }\n        .layout&gt;div{\n            height:100px;\n        }\n        .float .left,.float .right {\n         width: 200px;\n         height:100px;\n        }\n        .float&gt;.left{\n            float:left;\n            background:red;\n\n        }\n        .float&gt;.right{\n         float:right;\n         background:blue;\n        }\n        .float&gt;.center{\n            background:green;\n\n        }\n        /*定位 解决方案*/\n        .position&gt;.left{\n            position:absolute;\n            left:0;\n            top:0;\n            background: red;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.right{\n            position:absolute;\n            right:0;\n            top:0;\n            background: yellow;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.center{\n            position: absolute;\n            left:200px;\n            right:200px;\n            background:green;\n        }\n        /*flex 解决方案*/\n        .flex{\n            display: flex;\n            height:100px;\n        }\n        .flex .right, .flex .left{\n            width:200px;\n            background:blue;\n        }\n        .flex .center{\n            flex:1;\n            background:red;\n        }\n        /*table 解决方案*/\n        .table{\n            display: table;\n        }\n        .table&gt;.left,.table&gt;.right{\n            height:100px;\n            width:300px;\n            display: table-cell;\n            background:yellow;\n        }\n        .table&gt;.center{\n            background:red;\n            display: table-cell;\n        }\n        /*grid 解决方案*/\n        .grid {\n            display: grid;\n            grid-template-rows: 100;\n            grid-template-columns: 300px auto 300px;\n        }\n        .grid &gt; .left,.grid &gt;.right{\n           background:red;\n        }\n        .grid &gt; .center{\n           background:yellow;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- float布局 圣杯和双飞翼布局--&gt;\n    &lt;section class=&quot;layout float&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;float 解决方案&lt;/h1&gt;\n            &lt;p&gt;float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- 定位布局 --&gt;\n    &lt;section class=&quot;layout position&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;定位 解决方案&lt;/h1&gt;\n            &lt;p&gt;定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- flex 布局 实现太过于简单略--&gt;\n    &lt;section class=&quot;layout flex&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;flex 解决方案&lt;/h1&gt;\n            &lt;p&gt;flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- table 布局 --&gt;\n    &lt;section class=&quot;layout table&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;table 解决方案&lt;/h1&gt;\n            &lt;p&gt;table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- grid 布局 --&gt;\n    &lt;section class=&quot;layout grid&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;Grid 解决方案&lt;/h1&gt;\n            &lt;p&gt;Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<h5><span id=\"思考假如高度不固定上述的方案中又有那些符合要求\">思考假如高度不固定，上述的方案中又有那些符合要求。</span></h5>\n</blockquote>\n<ol>\n<li>flex布局</li>\n<li>table布局</li>\n<li>grid 布局</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg\" alt=\"images\"></p>\n<blockquote>\n<p>一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。</p>\n</blockquote>\n<ol>\n<li>利用浮动布局（圣杯布局和双飞翼布局）</li>\n<li>利用定位布局</li>\n<li>flex 布局</li>\n<li>table 表格布局</li>\n<li>grid 布局</li>\n</ol>\n<p>代码如下:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;layout&lt;/title&gt;\n    &lt;style&gt;\n        *{\n            padding:0;\n            margin:0;\n        }\n        .layout{\n            height: 100px;\n            width: 100%;\n            margin-bottom:50px;\n            overflow: hidden;\n            position: relative;\n        }\n        .layout&gt;div{\n            height:100px;\n        }\n        .float .left,.float .right {\n         width: 200px;\n         height:100px;\n        }\n        .float&gt;.left{\n            float:left;\n            background:red;\n\n        }\n        .float&gt;.right{\n         float:right;\n         background:blue;\n        }\n        .float&gt;.center{\n            background:green;\n\n        }\n        /*定位 解决方案*/\n        .position&gt;.left{\n            position:absolute;\n            left:0;\n            top:0;\n            background: red;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.right{\n            position:absolute;\n            right:0;\n            top:0;\n            background: yellow;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.center{\n            position: absolute;\n            left:200px;\n            right:200px;\n            background:green;\n        }\n        /*flex 解决方案*/\n        .flex{\n            display: flex;\n            height:100px;\n        }\n        .flex .right, .flex .left{\n            width:200px;\n            background:blue;\n        }\n        .flex .center{\n            flex:1;\n            background:red;\n        }\n        /*table 解决方案*/\n        .table{\n            display: table;\n        }\n        .table&gt;.left,.table&gt;.right{\n            height:100px;\n            width:300px;\n            display: table-cell;\n            background:yellow;\n        }\n        .table&gt;.center{\n            background:red;\n            display: table-cell;\n        }\n        /*grid 解决方案*/\n        .grid {\n            display: grid;\n            grid-template-rows: 100;\n            grid-template-columns: 300px auto 300px;\n        }\n        .grid &gt; .left,.grid &gt;.right{\n           background:red;\n        }\n        .grid &gt; .center{\n           background:yellow;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- float布局 圣杯和双飞翼布局--&gt;\n    &lt;section class=&quot;layout float&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;float 解决方案&lt;/h1&gt;\n            &lt;p&gt;float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- 定位布局 --&gt;\n    &lt;section class=&quot;layout position&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;定位 解决方案&lt;/h1&gt;\n            &lt;p&gt;定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- flex 布局 实现太过于简单略--&gt;\n    &lt;section class=&quot;layout flex&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;flex 解决方案&lt;/h1&gt;\n            &lt;p&gt;flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- table 布局 --&gt;\n    &lt;section class=&quot;layout table&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;table 解决方案&lt;/h1&gt;\n            &lt;p&gt;table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- grid 布局 --&gt;\n    &lt;section class=&quot;layout grid&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;Grid 解决方案&lt;/h1&gt;\n            &lt;p&gt;Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<h5>思考假如高度不固定，上述的方案中又有那些符合要求。</h5>\n</blockquote>\n<ol>\n<li>flex布局</li>\n<li>table布局</li>\n<li>grid 布局</li>\n</ol>\n"},{"title":"前端面试系列- CSS基础篇","catalog":true,"url":"153.html","id":"153","date":"2019-02-26T04:41:20.000Z","subtitle":null,"header-img":null,"_content":"\n![banner](http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg)\n\n> 一. 有哪几种游览器内核 1\\. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。\\[又称为MSHTML\\] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。\\[Opera内核原为：Presto，现为：Blink\\] 4. Webkit内核：Safari,Chrome等。\\[Chrome的:Blink(Webkit的分支)\\] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both\n\n最好的一种方式：伪类清除浮动\n\n    .clearfix:after {\n      visibility: hidden;\n      display: block;\n      font-size: 0;\n      content: \" \";\n      clear: both;\n      height: 0;\n    }\n    .clearfix{\n        zoom:1\n    }","source":"_posts/前端面试系列- CSS基础篇.md","raw":"---\ntitle: 前端面试系列- CSS基础篇\ncatalog: true\ntags:\n  - CSS3\n  - Frontend Interview\n  - html\nurl: 153.html\nid: 153\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:41:20\nsubtitle:\nheader-img:\n---\n\n![banner](http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg)\n\n> 一. 有哪几种游览器内核 1\\. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。\\[又称为MSHTML\\] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。\\[Opera内核原为：Presto，现为：Blink\\] 4. Webkit内核：Safari,Chrome等。\\[Chrome的:Blink(Webkit的分支)\\] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both\n\n最好的一种方式：伪类清除浮动\n\n    .clearfix:after {\n      visibility: hidden;\n      display: block;\n      font-size: 0;\n      content: \" \";\n      clear: both;\n      height: 0;\n    }\n    .clearfix{\n        zoom:1\n    }","slug":"前端面试系列- CSS基础篇","published":1,"updated":"2019-12-31T03:00:25.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5q001uzws6a2rr9oia","content":"<p><img src=\"http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg\" alt=\"banner\"></p>\n<blockquote>\n<p>一. 有哪几种游览器内核 1. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink] 4. Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both</p>\n</blockquote>\n<p>最好的一种方式：伪类清除浮动</p>\n<pre><code>.clearfix:after {\n  visibility: hidden;\n  display: block;\n  font-size: 0;\n  content: &quot; &quot;;\n  clear: both;\n  height: 0;\n}\n.clearfix{\n    zoom:1\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg\" alt=\"banner\"></p>\n<blockquote>\n<p>一. 有哪几种游览器内核 1. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink] 4. Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both</p>\n</blockquote>\n<p>最好的一种方式：伪类清除浮动</p>\n<pre><code>.clearfix:after {\n  visibility: hidden;\n  display: block;\n  font-size: 0;\n  content: &quot; &quot;;\n  clear: both;\n  height: 0;\n}\n.clearfix{\n    zoom:1\n}</code></pre>\n"},{"title":"前端面试系列-HTTP常考点","catalog":true,"url":"172.html","id":"172","date":"2019-03-05T08:44:04.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg)\n\n#### 经典五层模型\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png)\n\n1.  物理层主要作用是定义物理设备如何传输数据\n2.  数据链路层在通信的实体间建立数据链路连接\n3.  网络层为数据在结点之间传输创建逻辑链路\n4.  传输层（TCP，UDP...）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。\n5.  应用层（HTTP，FTP...）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。\n\n> 1.  从输入 URL 到页面加载完成的过程\n\n1.  首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP\n    \n2.  协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n    \n3.  TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件\n    \n4.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错\n    \n5.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件\n    \n6.  文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML\n    \n7.  解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。\n    \n8.  初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件\n    \n9.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n    \n10.  在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了\n    \n\n> 2.  DNS\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg)\n\n1\\. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。\n\n> 3.  HTTPS与HTTP的一些区别\n\n*   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n*   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n*   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n*   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n\n> 4.  HTTP1.x与HTTP2.0的区别\n\n*   `新的二进制格式`（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n*   `MultiPlexing）`，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n*   `header压缩`，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n*   `服务端推送（server push）`，同SPDY一样，HTTP2.0也具有server push功能。\n\n> 5.  HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？\n\n*   HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；\n*   HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；\n*   HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；\n\n### HTTP----HTTP缓存机制\n\n#### 强缓存\n\n实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200\n\n    Expires: Wed, 22 Oct 2018 08:41:00 GMT\n    \n\n`Expires` 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。\n\n    Cache-control: max-age=30\n    \n\n`Cache-Control` 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。\n\n#### 协商缓存\n\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。\n\n> 1.  Last-Modified 和 If-Modified-Since\n\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。\n\n> 2.  ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。\n\n#### 选择合适的缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n*   对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n*   对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n*   对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。","source":"_posts/前端面试系列-HTTP常考点.md","raw":"---\ntitle: 前端面试系列-HTTP常考点\ncatalog: true\ntags:\n  - http\nurl: 172.html\nid: 172\ncategories:\n  - HTTP\ndate: 2019-03-05 16:44:04\nsubtitle:\nheader-img:\n---\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg)\n\n#### 经典五层模型\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png)\n\n1.  物理层主要作用是定义物理设备如何传输数据\n2.  数据链路层在通信的实体间建立数据链路连接\n3.  网络层为数据在结点之间传输创建逻辑链路\n4.  传输层（TCP，UDP...）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。\n5.  应用层（HTTP，FTP...）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。\n\n> 1.  从输入 URL 到页面加载完成的过程\n\n1.  首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP\n    \n2.  协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n    \n3.  TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件\n    \n4.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错\n    \n5.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件\n    \n6.  文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML\n    \n7.  解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。\n    \n8.  初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件\n    \n9.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n    \n10.  在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了\n    \n\n> 2.  DNS\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg)\n\n1\\. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。\n\n> 3.  HTTPS与HTTP的一些区别\n\n*   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n*   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n*   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n*   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n\n> 4.  HTTP1.x与HTTP2.0的区别\n\n*   `新的二进制格式`（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n*   `MultiPlexing）`，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n*   `header压缩`，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n*   `服务端推送（server push）`，同SPDY一样，HTTP2.0也具有server push功能。\n\n> 5.  HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？\n\n*   HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；\n*   HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；\n*   HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；\n\n### HTTP----HTTP缓存机制\n\n#### 强缓存\n\n实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200\n\n    Expires: Wed, 22 Oct 2018 08:41:00 GMT\n    \n\n`Expires` 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。\n\n    Cache-control: max-age=30\n    \n\n`Cache-Control` 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。\n\n#### 协商缓存\n\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。\n\n> 1.  Last-Modified 和 If-Modified-Since\n\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。\n\n> 2.  ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。\n\n#### 选择合适的缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n*   对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n*   对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n*   对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。","slug":"前端面试系列-HTTP常考点","published":1,"updated":"2019-12-31T03:00:25.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5s001yzws6mm94nfqk","content":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg\" alt></p>\n<h4><span id=\"经典五层模型\">经典五层模型</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png\" alt></p>\n<ol>\n<li>物理层主要作用是定义物理设备如何传输数据</li>\n<li>数据链路层在通信的实体间建立数据链路连接</li>\n<li>网络层为数据在结点之间传输创建逻辑链路</li>\n<li>传输层（TCP，UDP…）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。</li>\n<li>应用层（HTTP，FTP…）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。</li>\n</ol>\n<blockquote>\n<ol>\n<li>从输入 URL 到页面加载完成的过程</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP</p>\n</li>\n<li>\n<p>协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</p>\n</li>\n<li>\n<p>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</p>\n</li>\n<li>\n<p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</p>\n</li>\n<li>\n<p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</p>\n</li>\n<li>\n<p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML</p>\n</li>\n<li>\n<p>解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</p>\n</li>\n<li>\n<p>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</p>\n</li>\n<li>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n</li>\n<li>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"2\">\n<li>DNS</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg\" alt></p>\n<p>1. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。</p>\n<blockquote>\n<ol start=\"3\">\n<li>HTTPS与HTTP的一些区别</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>\n<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>\n<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>\n<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>HTTP1.x与HTTP2.0的区别</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>新的二进制格式</code>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li><code>MultiPlexing）</code>，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>\n<li><code>header压缩</code>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>\n<li><code>服务端推送（server push）</code>，同SPDY一样，HTTP2.0也具有server push功能。</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h3><span id=\"http-http缓存机制\">HTTP----HTTP缓存机制</span></h3>\n<h4><span id=\"强缓存\">强缓存</span></h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，state code 为 200</p>\n<pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre><code>Cache-control: max-age=30\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4><span id=\"协商缓存\">协商缓存</span></h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<blockquote>\n<ol>\n<li>Last-Modified 和 If-Modified-Since</li>\n</ol>\n</blockquote>\n<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。</p>\n<blockquote>\n<ol start=\"2\">\n<li>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</li>\n</ol>\n</blockquote>\n<h4><span id=\"选择合适的缓存策略\">选择合适的缓存策略</span></h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg\" alt></p>\n<h4>经典五层模型</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png\" alt></p>\n<ol>\n<li>物理层主要作用是定义物理设备如何传输数据</li>\n<li>数据链路层在通信的实体间建立数据链路连接</li>\n<li>网络层为数据在结点之间传输创建逻辑链路</li>\n<li>传输层（TCP，UDP…）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。</li>\n<li>应用层（HTTP，FTP…）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。</li>\n</ol>\n<blockquote>\n<ol>\n<li>从输入 URL 到页面加载完成的过程</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP</p>\n</li>\n<li>\n<p>协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</p>\n</li>\n<li>\n<p>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</p>\n</li>\n<li>\n<p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</p>\n</li>\n<li>\n<p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</p>\n</li>\n<li>\n<p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML</p>\n</li>\n<li>\n<p>解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</p>\n</li>\n<li>\n<p>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</p>\n</li>\n<li>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n</li>\n<li>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"2\">\n<li>DNS</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg\" alt></p>\n<p>1. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。</p>\n<blockquote>\n<ol start=\"3\">\n<li>HTTPS与HTTP的一些区别</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>\n<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>\n<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>\n<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>HTTP1.x与HTTP2.0的区别</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>新的二进制格式</code>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li><code>MultiPlexing）</code>，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>\n<li><code>header压缩</code>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>\n<li><code>服务端推送（server push）</code>，同SPDY一样，HTTP2.0也具有server push功能。</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h3>HTTP----HTTP缓存机制</h3>\n<h4>强缓存</h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，state code 为 200</p>\n<pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre><code>Cache-control: max-age=30\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4>协商缓存</h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<blockquote>\n<ol>\n<li>Last-Modified 和 If-Modified-Since</li>\n</ol>\n</blockquote>\n<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。</p>\n<blockquote>\n<ol start=\"2\">\n<li>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</li>\n</ol>\n</blockquote>\n<h4>选择合适的缓存策略</h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n"},{"title":"前端面试系列-JS基础数据类型","catalog":true,"url":"141.html","id":"141","date":"2019-02-26T04:30:16.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  typeof 结果可能有哪些值\n\n`number`,`string`, `function`, `object`, `undfined`, `boolean`, `symbol`\n\n> 2.  JS 的数据类型\n\n1.  值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。\n2.  引用数据类型：对象(Object)、数组(Array)、函数(Function)。\n    \n    > 3.  JS 中有哪些内置函数 - 数据封装类对象\n    \n    1.  Object\n    2.  Array\n    3.  Boolean\n    4.  Number\n    5.  String\n    6.  Function\n    7.  Date\n    8.  RegExp\n    9.  Error\n    10.  Math(对象)","source":"_posts/前端面试系列-JS基础数据类型.md","raw":"---\ntitle: 前端面试系列-JS基础数据类型\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 141.html\nid: 141\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:30:16\nsubtitle:\nheader-img:\n---\n\n> 1.  typeof 结果可能有哪些值\n\n`number`,`string`, `function`, `object`, `undfined`, `boolean`, `symbol`\n\n> 2.  JS 的数据类型\n\n1.  值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。\n2.  引用数据类型：对象(Object)、数组(Array)、函数(Function)。\n    \n    > 3.  JS 中有哪些内置函数 - 数据封装类对象\n    \n    1.  Object\n    2.  Array\n    3.  Boolean\n    4.  Number\n    5.  String\n    6.  Function\n    7.  Date\n    8.  RegExp\n    9.  Error\n    10.  Math(对象)","slug":"前端面试系列-JS基础数据类型","published":1,"updated":"2019-12-31T03:00:25.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5t0022zws64x9m7sgx","content":"<blockquote>\n<ol>\n<li>typeof 结果可能有哪些值</li>\n</ol>\n</blockquote>\n<p><code>number</code>,<code>string</code>, <code>function</code>, <code>object</code>, <code>undfined</code>, <code>boolean</code>, <code>symbol</code></p>\n<blockquote>\n<ol start=\"2\">\n<li>JS 的数据类型</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>\n</li>\n<li>\n<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>\n<blockquote>\n<ol start=\"3\">\n<li>JS 中有哪些内置函数 - 数据封装类对象</li>\n</ol>\n</blockquote>\n<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Function</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>Math(对象)</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>typeof 结果可能有哪些值</li>\n</ol>\n</blockquote>\n<p><code>number</code>,<code>string</code>, <code>function</code>, <code>object</code>, <code>undfined</code>, <code>boolean</code>, <code>symbol</code></p>\n<blockquote>\n<ol start=\"2\">\n<li>JS 的数据类型</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>\n</li>\n<li>\n<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>\n<blockquote>\n<ol start=\"3\">\n<li>JS 中有哪些内置函数 - 数据封装类对象</li>\n</ol>\n</blockquote>\n<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Function</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>Math(对象)</li>\n</ol>\n</li>\n</ol>\n"},{"title":"前端面试系列-JavaScript 数组","catalog":true,"url":"156.html","id":"156","date":"2019-02-26T04:45:15.000Z","subtitle":null,"header-img":null,"_content":"\n#### 一. 如何对一个多维数组进行扁平化\n\n首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组\n\n    const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n    \n\n> 1.  利用递归思想来解决\n\n    let tempArr = [];\n    function flattenArrFirst(array){\n    array.map(item=>{\n        if(Array.isArray(item)){\n            tempArr.concat(flattenArrFirst(item));\n        }else{\n            tempArr.push(item);\n        }\n    });\n    return tempArr;\n    }\n    \n    console.log(flattenArrFirst(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 2.  利用toString()方法和split方法\n\n    function flattenArrSecond(array){\n        let arrStr = array.toString().split(',');\n    \n        return arrStr.map(item=>Number(item));\n    }\n    console.log(flattenArrSecond(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 3.  第三种 利用ES6语法\n\n    function flattenArrThird(array){\n        while(array.some(item => Array.isArray(item))){\n          array = [].concat(...array);\n        }\n        return array;\n    }\n    console.log(flattenArrThird(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 4.  利用数组reduce方法（高端操作，哈哈 ^_^~）\n\n    function flattenFour(array){\n       return array.reduce((result,item)=>{\n           return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n       },[])\n    }\n    console.log(flattenFour(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 5.  利用join方法和split 方法\n\n    function flattenArrFive(array){\n        return arr.join(\",\").split(\",\").map(item => Number(item))\n    }\n    \n    console.log(flattenArrFive(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n#### 二. 如何对一个数组去重\n\n假如现在有数组:\n\n    const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n    \n\n> 1.第一种利用循环遍历\n\n    function uniqueFirst(arr){\n        let tempArr = [];\n        for (let i = 0; i < arr.length; i++) {\n          if(tempArr.indexOf(arr[i]) == -1){\n              tempArr.push(arr[i]);\n          }\n        }\n        return tempArr;\n    }\n    console.log(uniqueFirst(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 2.第二种排序相邻去重法\n\n    function uniqueSecond(arr){\n        arr.sort();\n        let tempArr = [arr[0]];\n        for(let i = 1; i < arr.length; i++){\n           if(tempArr[tempArr.length-1] !== arr[i]){\n               tempArr.push(arr[i])\n           }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSecond(arr));\n    // 打印结果：\n    // [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 3.第三种利用ES6 Set\n\n    var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\n    function uniqueThird(arr){\n        return Array.from(new Set(arr));\n    }\n    console.log(uniqueThird(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 4.第四种利用reduce\n\n    function uniqueFour(array) {\n        return array.reduce((a,b)=>{\n            a.indexOf(b) == -1 ? false : a.push(b);\n            return a\n        },[])\n    }\n    console.log(uniqueFour(arr));\n    // 打印结果：\n    //[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 5.第五种利用filter和includes方法\n\n    function uniqueFive(array){\n        let tempArr = [];\n       tempArr = array.filter(item=>{\n          return tempArr.includes(item)? false : tempArr.push(item)\n       });\n       return tempArr;\n    }\n    console.log(uniqueFive(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 6.第六种 对象键值对法\n\n    function uniqueSix(array){\n        let obj = {};\n        let tempArr = [];\n        for(let i =0;i<array.length;i++){\n            if(!obj[array[i]]){\n               tempArr.push(array[i]);\n               obj[arr[i]] = arr[i];\n            }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSix(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 7.  面试官追问题：如何对一个对象数组按照规定的字段去重\n\n    var usersArr = [\n        { name: \"name1\", age: \"1\" },\n        { name: \"name2\", age: \"11\" },\n        { name: \"name7\", age: \"11\" },\n        { name: \"name3\", age: \"12\" },\n        { name: \"name4\", age: \"13\" },\n        { name: \"name2\", age: \"1\" },\n        { name: \"name6\", age: \"12\" }\n    ]\n    \n    function uniqueByFields(array,fields){\n       let hash = {}\n       return array.reduce((arr,item)=>{\n           hash[item[fields]] ? \"\" : hash[item[fields]] = true && arr.push(item);\n           return arr\n       },[])\n    }\n    \n    console.log(uniqueByFields(usersArr, \"age\"));\n    // 打印结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name4', age: '13' } ]\n    \n\n> 8.  面试时关联题目：如何对对象数组按照特定字段进行排序\n\n    function sortByFileds(arr,fields){\n        return arr.sort((a,b)=>{\n            return a[fields] - b[fields];\n        });\n    }\n    console.log(sortByFileds(usersArr, \"age\"));\n    // 输出结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name7', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name6', age: '12' },\n      { name: 'name4', age: '13' } ]","source":"_posts/前端面试系列-JavaScript 数组.md","raw":"---\ntitle: 前端面试系列-JavaScript 数组\ncatalog: true\ntags:\n  - ES6\n  - Frontend Interview\n  - javascript\nurl: 156.html\nid: 156\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:45:15\nsubtitle:\nheader-img:\n---\n\n#### 一. 如何对一个多维数组进行扁平化\n\n首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组\n\n    const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n    \n\n> 1.  利用递归思想来解决\n\n    let tempArr = [];\n    function flattenArrFirst(array){\n    array.map(item=>{\n        if(Array.isArray(item)){\n            tempArr.concat(flattenArrFirst(item));\n        }else{\n            tempArr.push(item);\n        }\n    });\n    return tempArr;\n    }\n    \n    console.log(flattenArrFirst(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 2.  利用toString()方法和split方法\n\n    function flattenArrSecond(array){\n        let arrStr = array.toString().split(',');\n    \n        return arrStr.map(item=>Number(item));\n    }\n    console.log(flattenArrSecond(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 3.  第三种 利用ES6语法\n\n    function flattenArrThird(array){\n        while(array.some(item => Array.isArray(item))){\n          array = [].concat(...array);\n        }\n        return array;\n    }\n    console.log(flattenArrThird(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 4.  利用数组reduce方法（高端操作，哈哈 ^_^~）\n\n    function flattenFour(array){\n       return array.reduce((result,item)=>{\n           return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n       },[])\n    }\n    console.log(flattenFour(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 5.  利用join方法和split 方法\n\n    function flattenArrFive(array){\n        return arr.join(\",\").split(\",\").map(item => Number(item))\n    }\n    \n    console.log(flattenArrFive(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n#### 二. 如何对一个数组去重\n\n假如现在有数组:\n\n    const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n    \n\n> 1.第一种利用循环遍历\n\n    function uniqueFirst(arr){\n        let tempArr = [];\n        for (let i = 0; i < arr.length; i++) {\n          if(tempArr.indexOf(arr[i]) == -1){\n              tempArr.push(arr[i]);\n          }\n        }\n        return tempArr;\n    }\n    console.log(uniqueFirst(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 2.第二种排序相邻去重法\n\n    function uniqueSecond(arr){\n        arr.sort();\n        let tempArr = [arr[0]];\n        for(let i = 1; i < arr.length; i++){\n           if(tempArr[tempArr.length-1] !== arr[i]){\n               tempArr.push(arr[i])\n           }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSecond(arr));\n    // 打印结果：\n    // [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 3.第三种利用ES6 Set\n\n    var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\n    function uniqueThird(arr){\n        return Array.from(new Set(arr));\n    }\n    console.log(uniqueThird(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 4.第四种利用reduce\n\n    function uniqueFour(array) {\n        return array.reduce((a,b)=>{\n            a.indexOf(b) == -1 ? false : a.push(b);\n            return a\n        },[])\n    }\n    console.log(uniqueFour(arr));\n    // 打印结果：\n    //[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 5.第五种利用filter和includes方法\n\n    function uniqueFive(array){\n        let tempArr = [];\n       tempArr = array.filter(item=>{\n          return tempArr.includes(item)? false : tempArr.push(item)\n       });\n       return tempArr;\n    }\n    console.log(uniqueFive(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 6.第六种 对象键值对法\n\n    function uniqueSix(array){\n        let obj = {};\n        let tempArr = [];\n        for(let i =0;i<array.length;i++){\n            if(!obj[array[i]]){\n               tempArr.push(array[i]);\n               obj[arr[i]] = arr[i];\n            }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSix(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 7.  面试官追问题：如何对一个对象数组按照规定的字段去重\n\n    var usersArr = [\n        { name: \"name1\", age: \"1\" },\n        { name: \"name2\", age: \"11\" },\n        { name: \"name7\", age: \"11\" },\n        { name: \"name3\", age: \"12\" },\n        { name: \"name4\", age: \"13\" },\n        { name: \"name2\", age: \"1\" },\n        { name: \"name6\", age: \"12\" }\n    ]\n    \n    function uniqueByFields(array,fields){\n       let hash = {}\n       return array.reduce((arr,item)=>{\n           hash[item[fields]] ? \"\" : hash[item[fields]] = true && arr.push(item);\n           return arr\n       },[])\n    }\n    \n    console.log(uniqueByFields(usersArr, \"age\"));\n    // 打印结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name4', age: '13' } ]\n    \n\n> 8.  面试时关联题目：如何对对象数组按照特定字段进行排序\n\n    function sortByFileds(arr,fields){\n        return arr.sort((a,b)=>{\n            return a[fields] - b[fields];\n        });\n    }\n    console.log(sortByFileds(usersArr, \"age\"));\n    // 输出结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name7', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name6', age: '12' },\n      { name: 'name4', age: '13' } ]","slug":"前端面试系列-JavaScript 数组","published":1,"updated":"2019-12-31T03:00:25.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5u0025zws69cnbx8rc","content":"<h4><span id=\"一-如何对一个多维数组进行扁平化\">一. 如何对一个多维数组进行扁平化</span></h4>\n<p>首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组</p>\n<pre><code>const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n</code></pre>\n<blockquote>\n<ol>\n<li>利用递归思想来解决</li>\n</ol>\n</blockquote>\n<pre><code>let tempArr = [];\nfunction flattenArrFirst(array){\narray.map(item=&gt;{\n    if(Array.isArray(item)){\n        tempArr.concat(flattenArrFirst(item));\n    }else{\n        tempArr.push(item);\n    }\n});\nreturn tempArr;\n}\n\nconsole.log(flattenArrFirst(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>利用toString()方法和split方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrSecond(array){\n    let arrStr = array.toString().split(',');\n\n    return arrStr.map(item=&gt;Number(item));\n}\nconsole.log(flattenArrSecond(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>第三种 利用ES6语法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrThird(array){\n    while(array.some(item =&gt; Array.isArray(item))){\n      array = [].concat(...array);\n    }\n    return array;\n}\nconsole.log(flattenArrThird(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>利用数组reduce方法（高端操作，哈哈 ^_^~）</li>\n</ol>\n</blockquote>\n<pre><code>function flattenFour(array){\n   return array.reduce((result,item)=&gt;{\n       return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n   },[])\n}\nconsole.log(flattenFour(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>利用join方法和split 方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrFive(array){\n    return arr.join(&quot;,&quot;).split(&quot;,&quot;).map(item =&gt; Number(item))\n}\n\nconsole.log(flattenArrFive(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<h4><span id=\"二-如何对一个数组去重\">二. 如何对一个数组去重</span></h4>\n<p>假如现在有数组:</p>\n<pre><code>const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n</code></pre>\n<blockquote>\n<p>1.第一种利用循环遍历</p>\n</blockquote>\n<pre><code>function uniqueFirst(arr){\n    let tempArr = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n      if(tempArr.indexOf(arr[i]) == -1){\n          tempArr.push(arr[i]);\n      }\n    }\n    return tempArr;\n}\nconsole.log(uniqueFirst(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>2.第二种排序相邻去重法</p>\n</blockquote>\n<pre><code>function uniqueSecond(arr){\n    arr.sort();\n    let tempArr = [arr[0]];\n    for(let i = 1; i &lt; arr.length; i++){\n       if(tempArr[tempArr.length-1] !== arr[i]){\n           tempArr.push(arr[i])\n       }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSecond(arr));\n// 打印结果：\n// [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>3.第三种利用ES6 Set</p>\n</blockquote>\n<pre><code>var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\nfunction uniqueThird(arr){\n    return Array.from(new Set(arr));\n}\nconsole.log(uniqueThird(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>4.第四种利用reduce</p>\n</blockquote>\n<pre><code>function uniqueFour(array) {\n    return array.reduce((a,b)=&gt;{\n        a.indexOf(b) == -1 ? false : a.push(b);\n        return a\n    },[])\n}\nconsole.log(uniqueFour(arr));\n// 打印结果：\n//[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>5.第五种利用filter和includes方法</p>\n</blockquote>\n<pre><code>function uniqueFive(array){\n    let tempArr = [];\n   tempArr = array.filter(item=&gt;{\n      return tempArr.includes(item)? false : tempArr.push(item)\n   });\n   return tempArr;\n}\nconsole.log(uniqueFive(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>6.第六种 对象键值对法</p>\n</blockquote>\n<pre><code>function uniqueSix(array){\n    let obj = {};\n    let tempArr = [];\n    for(let i =0;i&lt;array.length;i++){\n        if(!obj[array[i]]){\n           tempArr.push(array[i]);\n           obj[arr[i]] = arr[i];\n        }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSix(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<ol start=\"7\">\n<li>面试官追问题：如何对一个对象数组按照规定的字段去重</li>\n</ol>\n</blockquote>\n<pre><code>var usersArr = [\n    { name: &quot;name1&quot;, age: &quot;1&quot; },\n    { name: &quot;name2&quot;, age: &quot;11&quot; },\n    { name: &quot;name7&quot;, age: &quot;11&quot; },\n    { name: &quot;name3&quot;, age: &quot;12&quot; },\n    { name: &quot;name4&quot;, age: &quot;13&quot; },\n    { name: &quot;name2&quot;, age: &quot;1&quot; },\n    { name: &quot;name6&quot;, age: &quot;12&quot; }\n]\n\nfunction uniqueByFields(array,fields){\n   let hash = {}\n   return array.reduce((arr,item)=&gt;{\n       hash[item[fields]] ? &quot;&quot; : hash[item[fields]] = true &amp;&amp; arr.push(item);\n       return arr\n   },[])\n}\n\nconsole.log(uniqueByFields(usersArr, &quot;age&quot;));\n// 打印结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name4', age: '13' } ]\n</code></pre>\n<blockquote>\n<ol start=\"8\">\n<li>面试时关联题目：如何对对象数组按照特定字段进行排序</li>\n</ol>\n</blockquote>\n<pre><code>function sortByFileds(arr,fields){\n    return arr.sort((a,b)=&gt;{\n        return a[fields] - b[fields];\n    });\n}\nconsole.log(sortByFileds(usersArr, &quot;age&quot;));\n// 输出结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name7', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name6', age: '12' },\n  { name: 'name4', age: '13' } ]</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>一. 如何对一个多维数组进行扁平化</h4>\n<p>首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组</p>\n<pre><code>const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n</code></pre>\n<blockquote>\n<ol>\n<li>利用递归思想来解决</li>\n</ol>\n</blockquote>\n<pre><code>let tempArr = [];\nfunction flattenArrFirst(array){\narray.map(item=&gt;{\n    if(Array.isArray(item)){\n        tempArr.concat(flattenArrFirst(item));\n    }else{\n        tempArr.push(item);\n    }\n});\nreturn tempArr;\n}\n\nconsole.log(flattenArrFirst(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>利用toString()方法和split方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrSecond(array){\n    let arrStr = array.toString().split(',');\n\n    return arrStr.map(item=&gt;Number(item));\n}\nconsole.log(flattenArrSecond(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>第三种 利用ES6语法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrThird(array){\n    while(array.some(item =&gt; Array.isArray(item))){\n      array = [].concat(...array);\n    }\n    return array;\n}\nconsole.log(flattenArrThird(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>利用数组reduce方法（高端操作，哈哈 ^_^~）</li>\n</ol>\n</blockquote>\n<pre><code>function flattenFour(array){\n   return array.reduce((result,item)=&gt;{\n       return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n   },[])\n}\nconsole.log(flattenFour(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>利用join方法和split 方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrFive(array){\n    return arr.join(&quot;,&quot;).split(&quot;,&quot;).map(item =&gt; Number(item))\n}\n\nconsole.log(flattenArrFive(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<h4>二. 如何对一个数组去重</h4>\n<p>假如现在有数组:</p>\n<pre><code>const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n</code></pre>\n<blockquote>\n<p>1.第一种利用循环遍历</p>\n</blockquote>\n<pre><code>function uniqueFirst(arr){\n    let tempArr = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n      if(tempArr.indexOf(arr[i]) == -1){\n          tempArr.push(arr[i]);\n      }\n    }\n    return tempArr;\n}\nconsole.log(uniqueFirst(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>2.第二种排序相邻去重法</p>\n</blockquote>\n<pre><code>function uniqueSecond(arr){\n    arr.sort();\n    let tempArr = [arr[0]];\n    for(let i = 1; i &lt; arr.length; i++){\n       if(tempArr[tempArr.length-1] !== arr[i]){\n           tempArr.push(arr[i])\n       }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSecond(arr));\n// 打印结果：\n// [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>3.第三种利用ES6 Set</p>\n</blockquote>\n<pre><code>var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\nfunction uniqueThird(arr){\n    return Array.from(new Set(arr));\n}\nconsole.log(uniqueThird(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>4.第四种利用reduce</p>\n</blockquote>\n<pre><code>function uniqueFour(array) {\n    return array.reduce((a,b)=&gt;{\n        a.indexOf(b) == -1 ? false : a.push(b);\n        return a\n    },[])\n}\nconsole.log(uniqueFour(arr));\n// 打印结果：\n//[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>5.第五种利用filter和includes方法</p>\n</blockquote>\n<pre><code>function uniqueFive(array){\n    let tempArr = [];\n   tempArr = array.filter(item=&gt;{\n      return tempArr.includes(item)? false : tempArr.push(item)\n   });\n   return tempArr;\n}\nconsole.log(uniqueFive(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>6.第六种 对象键值对法</p>\n</blockquote>\n<pre><code>function uniqueSix(array){\n    let obj = {};\n    let tempArr = [];\n    for(let i =0;i&lt;array.length;i++){\n        if(!obj[array[i]]){\n           tempArr.push(array[i]);\n           obj[arr[i]] = arr[i];\n        }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSix(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<ol start=\"7\">\n<li>面试官追问题：如何对一个对象数组按照规定的字段去重</li>\n</ol>\n</blockquote>\n<pre><code>var usersArr = [\n    { name: &quot;name1&quot;, age: &quot;1&quot; },\n    { name: &quot;name2&quot;, age: &quot;11&quot; },\n    { name: &quot;name7&quot;, age: &quot;11&quot; },\n    { name: &quot;name3&quot;, age: &quot;12&quot; },\n    { name: &quot;name4&quot;, age: &quot;13&quot; },\n    { name: &quot;name2&quot;, age: &quot;1&quot; },\n    { name: &quot;name6&quot;, age: &quot;12&quot; }\n]\n\nfunction uniqueByFields(array,fields){\n   let hash = {}\n   return array.reduce((arr,item)=&gt;{\n       hash[item[fields]] ? &quot;&quot; : hash[item[fields]] = true &amp;&amp; arr.push(item);\n       return arr\n   },[])\n}\n\nconsole.log(uniqueByFields(usersArr, &quot;age&quot;));\n// 打印结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name4', age: '13' } ]\n</code></pre>\n<blockquote>\n<ol start=\"8\">\n<li>面试时关联题目：如何对对象数组按照特定字段进行排序</li>\n</ol>\n</blockquote>\n<pre><code>function sortByFileds(arr,fields){\n    return arr.sort((a,b)=&gt;{\n        return a[fields] - b[fields];\n    });\n}\nconsole.log(sortByFileds(usersArr, &quot;age&quot;));\n// 输出结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name7', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name6', age: '12' },\n  { name: 'name4', age: '13' } ]</code></pre>\n"},{"title":"前端面试系列-JavaScript中的this指向问题","catalog":true,"url":"150.html","id":"150","date":"2019-02-26T04:39:33.000Z","subtitle":null,"header-img":null,"_content":"\n谁调用它他就指向谁，箭头函数没有this\n\n> 1.  new 的过程中发生了什么\n\n1.  首先创建一个新的对象\n2.  链接到原型\n3.  绑定this\n4.  返回新的对象\n\n代码实现：\n\n    function create() {\n      let obj = {};\n      let Constructor = [].shift.call(arguments);\n      obj.__proto__ = Constructor.prototype\n      let result = Constructor.apply(obj, arguments);\n      return typeof result === 'object' ? result : obj\n    }\n    \n\n> 2.  怎么实现bind, call, apply 手动实现一下\n> 3.  如果不传入参数默认是window\n> 4.  改变this的指向，让新的对象执行该函数\n> 5.  先给新的对象添加一个该函数，然后执行，执行后删除\n\n代码模拟实现Call：\n\n    Function.prototype.myCall = function (context) {\n      var context = context || window;\n      context.fn = this;\n      let args = [...arguments].slice(1);\n      let result = context.fn(...args);\n      delete context.fn;\n      return result;\n    }\n    \n\n代码模拟实现Apply：\n\n    Function.prototype.myApply = function (context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn\n      return result;\n    }\n    \n\n代码模拟实现Bind：\n\n    Function.prototype.myBind = function (context) {\n      if (typeof this != 'object') {\n        throw new TypeError('type error');\n      }\n      var self = this;\n      var args = [...arguments].slice(1);\n      return function Fn() {\n        if (typeof this instanceof Fn) {\n          return new self(...args, ...arguments);\n        } else {\n          return self.apply(context, args.concat(...arguments));\n        }\n      }\n    }\n    \n    \n\n> 3.instanceof 原理是什么？手动实现一下\n\n    function instanceOf(left, right) {\n      let prototype = right.prototype;\n      let left = left.__proto__\n      while (true) {\n        if (left == null) return false\n        if (left == prototype) return true\n        left = left.__proto__\n      }\n    }","source":"_posts/前端面试系列-JavaScript中的this指向问题.md","raw":"---\ntitle: 前端面试系列-JavaScript中的this指向问题\ncatalog: true\ntags:\n  - Frontend Interview\n  - html\n  - javascript\nurl: 150.html\nid: 150\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:39:33\nsubtitle:\nheader-img:\n---\n\n谁调用它他就指向谁，箭头函数没有this\n\n> 1.  new 的过程中发生了什么\n\n1.  首先创建一个新的对象\n2.  链接到原型\n3.  绑定this\n4.  返回新的对象\n\n代码实现：\n\n    function create() {\n      let obj = {};\n      let Constructor = [].shift.call(arguments);\n      obj.__proto__ = Constructor.prototype\n      let result = Constructor.apply(obj, arguments);\n      return typeof result === 'object' ? result : obj\n    }\n    \n\n> 2.  怎么实现bind, call, apply 手动实现一下\n> 3.  如果不传入参数默认是window\n> 4.  改变this的指向，让新的对象执行该函数\n> 5.  先给新的对象添加一个该函数，然后执行，执行后删除\n\n代码模拟实现Call：\n\n    Function.prototype.myCall = function (context) {\n      var context = context || window;\n      context.fn = this;\n      let args = [...arguments].slice(1);\n      let result = context.fn(...args);\n      delete context.fn;\n      return result;\n    }\n    \n\n代码模拟实现Apply：\n\n    Function.prototype.myApply = function (context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn\n      return result;\n    }\n    \n\n代码模拟实现Bind：\n\n    Function.prototype.myBind = function (context) {\n      if (typeof this != 'object') {\n        throw new TypeError('type error');\n      }\n      var self = this;\n      var args = [...arguments].slice(1);\n      return function Fn() {\n        if (typeof this instanceof Fn) {\n          return new self(...args, ...arguments);\n        } else {\n          return self.apply(context, args.concat(...arguments));\n        }\n      }\n    }\n    \n    \n\n> 3.instanceof 原理是什么？手动实现一下\n\n    function instanceOf(left, right) {\n      let prototype = right.prototype;\n      let left = left.__proto__\n      while (true) {\n        if (left == null) return false\n        if (left == prototype) return true\n        left = left.__proto__\n      }\n    }","slug":"前端面试系列-JavaScript中的this指向问题","published":1,"updated":"2019-12-31T03:00:25.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5v0027zws62e6b5ym1","content":"<p>谁调用它他就指向谁，箭头函数没有this</p>\n<blockquote>\n<ol>\n<li>new 的过程中发生了什么</li>\n</ol>\n</blockquote>\n<ol>\n<li>首先创建一个新的对象</li>\n<li>链接到原型</li>\n<li>绑定this</li>\n<li>返回新的对象</li>\n</ol>\n<p>代码实现：</p>\n<pre><code>function create() {\n  let obj = {};\n  let Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments);\n  return typeof result === 'object' ? result : obj\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>怎么实现bind, call, apply 手动实现一下</li>\n<li>如果不传入参数默认是window</li>\n<li>改变this的指向，让新的对象执行该函数</li>\n<li>先给新的对象添加一个该函数，然后执行，执行后删除</li>\n</ol>\n</blockquote>\n<p>代码模拟实现Call：</p>\n<pre><code>Function.prototype.myCall = function (context) {\n  var context = context || window;\n  context.fn = this;\n  let args = [...arguments].slice(1);\n  let result = context.fn(...args);\n  delete context.fn;\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Apply：</p>\n<pre><code>Function.prototype.myApply = function (context) {\n  var context = context || window;\n  context.fn = this;\n  var result;\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Bind：</p>\n<pre><code>Function.prototype.myBind = function (context) {\n  if (typeof this != 'object') {\n    throw new TypeError('type error');\n  }\n  var self = this;\n  var args = [...arguments].slice(1);\n  return function Fn() {\n    if (typeof this instanceof Fn) {\n      return new self(...args, ...arguments);\n    } else {\n      return self.apply(context, args.concat(...arguments));\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>3.instanceof 原理是什么？手动实现一下</p>\n</blockquote>\n<pre><code>function instanceOf(left, right) {\n  let prototype = right.prototype;\n  let left = left.__proto__\n  while (true) {\n    if (left == null) return false\n    if (left == prototype) return true\n    left = left.__proto__\n  }\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>谁调用它他就指向谁，箭头函数没有this</p>\n<blockquote>\n<ol>\n<li>new 的过程中发生了什么</li>\n</ol>\n</blockquote>\n<ol>\n<li>首先创建一个新的对象</li>\n<li>链接到原型</li>\n<li>绑定this</li>\n<li>返回新的对象</li>\n</ol>\n<p>代码实现：</p>\n<pre><code>function create() {\n  let obj = {};\n  let Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments);\n  return typeof result === 'object' ? result : obj\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>怎么实现bind, call, apply 手动实现一下</li>\n<li>如果不传入参数默认是window</li>\n<li>改变this的指向，让新的对象执行该函数</li>\n<li>先给新的对象添加一个该函数，然后执行，执行后删除</li>\n</ol>\n</blockquote>\n<p>代码模拟实现Call：</p>\n<pre><code>Function.prototype.myCall = function (context) {\n  var context = context || window;\n  context.fn = this;\n  let args = [...arguments].slice(1);\n  let result = context.fn(...args);\n  delete context.fn;\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Apply：</p>\n<pre><code>Function.prototype.myApply = function (context) {\n  var context = context || window;\n  context.fn = this;\n  var result;\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Bind：</p>\n<pre><code>Function.prototype.myBind = function (context) {\n  if (typeof this != 'object') {\n    throw new TypeError('type error');\n  }\n  var self = this;\n  var args = [...arguments].slice(1);\n  return function Fn() {\n    if (typeof this instanceof Fn) {\n      return new self(...args, ...arguments);\n    } else {\n      return self.apply(context, args.concat(...arguments));\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>3.instanceof 原理是什么？手动实现一下</p>\n</blockquote>\n<pre><code>function instanceOf(left, right) {\n  let prototype = right.prototype;\n  let left = left.__proto__\n  while (true) {\n    if (left == null) return false\n    if (left == prototype) return true\n    left = left.__proto__\n  }\n}</code></pre>\n"},{"title":"前端面试系列-JavaScript继承","catalog":true,"url":"178.html","id":"178","date":"2019-03-05T15:12:36.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg)\n\n### Javascript 继承\n\n#### 1\\. 通过构造函数实现继承\n\n    function Parent(){\n        this.parent = 'parent'\n        this.getWho = function(){\n            return 'getWho:'+this.parent\n        }\n    }\n    Parent.prototype.sayWho = function(){\n       console.log(`prototype from ${this.parent}`);\n        return `prototype from ${this.parent}`\n    }\n    \n    function Child(){\n        Parent.call(this);\n        this.child = \"child\"\n    }\n    \n    let children = new Child();\n    \n    console.log(children.child);// child\n    console.log(children.getWho());// getWho:parent\n    console.log(children.parent); // parent\n    console.log(children.sayWho()); // TypeError: children.sayWho is not a function\n    \n    \n\n这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。\n\n#### 2\\. 借助原型链实现继承\n\n    function Parent1(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n        this.lookList=function(){\n            return this.list\n        }\n    }\n    Parent1.prototype.getList=function(){\n        return this.list\n    }\n    function Child1(){\n        this.child = 'child'\n    }\n    Child1.prototype = new Parent1();\n    \n    let s1 = new Child1();\n    let s2 = new Child1();\n    console.log(s1.list); // [ 1, 2, 3 ]\n    s1.list.push(4)\n    console.log(s2.list); // [ 1, 2, 3, 4 ]\n    console.log(s1.lookList()); // [ 1, 2, 3, 4 ]\n    console.log(s1.getList()); // [ 1, 2, 3, 4 ]\n    \n\n通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); <=> Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.pro 和 s2.pro指向同一个地址即 父类的 prototype\n\n#### 3\\. 组合式继承\n\n    function Parent2(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n    }\n    Parent2.prototype.getList = function(){\n        return this.list\n    }\n    function Child2(){\n        Parent2.call(this)\n        this.child = 'child';\n    }\n    Child2.prototype = new Parent2();\n    \n    let s3 = new Child2();\n    let s4 = new Child2();\n    \n    console.log(s3.getList());// [ 1, 2, 3 ]\n    console.log(s4.list);//[ 1, 2, 3]\n    s3.list.push(4);\n    console.log(s3.list); // [ 1, 2, 3, 4 ]\n    \n\n将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。\n\n#### 4\\. 寄生组合继承\n\n    function Parent3() {\n        this.parent = 'parent3'\n        this.list = [1, 2, 3]\n    }\n    Parent3.prototype.getList = function () {\n        return this.list\n    }\n    function Child3() {\n        Parent3.call(this)\n        this.child = 'child';\n    }\n    Child3.prototype =Object.create(Parent3.prototype); //重点\n    Child3.prototype.constructor = Child3;// 重点\n    let s5 = new Child3();\n    let s6 = new Child3();\n    \n    console.log(s5.getList());// [ 1, 2, 3 ]\n    s5.list.push(4);\n    console.log(s5.list); // [ 1, 2, 3, 4 ]\n    console.log(s6.list);//[ 1, 2, 3]\n    \n\n这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor","source":"_posts/前端面试系列-JavaScript继承.md","raw":"---\ntitle: 前端面试系列-JavaScript继承\ncatalog: true\ntags:\n  - javascript\nurl: 178.html\nid: 178\ncategories:\n  - JavaScript\ndate: 2019-03-05 23:12:36\nsubtitle:\nheader-img:\n---\n\n![](http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg)\n\n### Javascript 继承\n\n#### 1\\. 通过构造函数实现继承\n\n    function Parent(){\n        this.parent = 'parent'\n        this.getWho = function(){\n            return 'getWho:'+this.parent\n        }\n    }\n    Parent.prototype.sayWho = function(){\n       console.log(`prototype from ${this.parent}`);\n        return `prototype from ${this.parent}`\n    }\n    \n    function Child(){\n        Parent.call(this);\n        this.child = \"child\"\n    }\n    \n    let children = new Child();\n    \n    console.log(children.child);// child\n    console.log(children.getWho());// getWho:parent\n    console.log(children.parent); // parent\n    console.log(children.sayWho()); // TypeError: children.sayWho is not a function\n    \n    \n\n这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。\n\n#### 2\\. 借助原型链实现继承\n\n    function Parent1(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n        this.lookList=function(){\n            return this.list\n        }\n    }\n    Parent1.prototype.getList=function(){\n        return this.list\n    }\n    function Child1(){\n        this.child = 'child'\n    }\n    Child1.prototype = new Parent1();\n    \n    let s1 = new Child1();\n    let s2 = new Child1();\n    console.log(s1.list); // [ 1, 2, 3 ]\n    s1.list.push(4)\n    console.log(s2.list); // [ 1, 2, 3, 4 ]\n    console.log(s1.lookList()); // [ 1, 2, 3, 4 ]\n    console.log(s1.getList()); // [ 1, 2, 3, 4 ]\n    \n\n通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); <=> Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.pro 和 s2.pro指向同一个地址即 父类的 prototype\n\n#### 3\\. 组合式继承\n\n    function Parent2(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n    }\n    Parent2.prototype.getList = function(){\n        return this.list\n    }\n    function Child2(){\n        Parent2.call(this)\n        this.child = 'child';\n    }\n    Child2.prototype = new Parent2();\n    \n    let s3 = new Child2();\n    let s4 = new Child2();\n    \n    console.log(s3.getList());// [ 1, 2, 3 ]\n    console.log(s4.list);//[ 1, 2, 3]\n    s3.list.push(4);\n    console.log(s3.list); // [ 1, 2, 3, 4 ]\n    \n\n将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。\n\n#### 4\\. 寄生组合继承\n\n    function Parent3() {\n        this.parent = 'parent3'\n        this.list = [1, 2, 3]\n    }\n    Parent3.prototype.getList = function () {\n        return this.list\n    }\n    function Child3() {\n        Parent3.call(this)\n        this.child = 'child';\n    }\n    Child3.prototype =Object.create(Parent3.prototype); //重点\n    Child3.prototype.constructor = Child3;// 重点\n    let s5 = new Child3();\n    let s6 = new Child3();\n    \n    console.log(s5.getList());// [ 1, 2, 3 ]\n    s5.list.push(4);\n    console.log(s5.list); // [ 1, 2, 3, 4 ]\n    console.log(s6.list);//[ 1, 2, 3]\n    \n\n这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor","slug":"前端面试系列-JavaScript继承","published":1,"updated":"2019-12-31T03:00:25.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5x002bzws6qy217p1h","content":"<p><img src=\"http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg\" alt></p>\n<h3><span id=\"javascript-继承\">Javascript 继承</span></h3>\n<h4><span id=\"1-通过构造函数实现继承\">1. 通过构造函数实现继承</span></h4>\n<pre><code>function Parent(){\n    this.parent = 'parent'\n    this.getWho = function(){\n        return 'getWho:'+this.parent\n    }\n}\nParent.prototype.sayWho = function(){\n   console.log(`prototype from ${this.parent}`);\n    return `prototype from ${this.parent}`\n}\n\nfunction Child(){\n    Parent.call(this);\n    this.child = &quot;child&quot;\n}\n\nlet children = new Child();\n\nconsole.log(children.child);// child\nconsole.log(children.getWho());// getWho:parent\nconsole.log(children.parent); // parent\nconsole.log(children.sayWho()); // TypeError: children.sayWho is not a function\n</code></pre>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4><span id=\"2-借助原型链实现继承\">2. 借助原型链实现继承</span></h4>\n<pre><code>function Parent1(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n    this.lookList=function(){\n        return this.list\n    }\n}\nParent1.prototype.getList=function(){\n    return this.list\n}\nfunction Child1(){\n    this.child = 'child'\n}\nChild1.prototype = new Parent1();\n\nlet s1 = new Child1();\nlet s2 = new Child1();\nconsole.log(s1.list); // [ 1, 2, 3 ]\ns1.list.push(4)\nconsole.log(s2.list); // [ 1, 2, 3, 4 ]\nconsole.log(s1.lookList()); // [ 1, 2, 3, 4 ]\nconsole.log(s1.getList()); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); &lt;=&gt; Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 <a href=\"http://s1.pro\" target=\"_blank\" rel=\"noopener\">s1.pro</a> 和 s2.pro指向同一个地址即 父类的 prototype</p>\n<h4><span id=\"3-组合式继承\">3. 组合式继承</span></h4>\n<pre><code>function Parent2(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n}\nParent2.prototype.getList = function(){\n    return this.list\n}\nfunction Child2(){\n    Parent2.call(this)\n    this.child = 'child';\n}\nChild2.prototype = new Parent2();\n\nlet s3 = new Child2();\nlet s4 = new Child2();\n\nconsole.log(s3.getList());// [ 1, 2, 3 ]\nconsole.log(s4.list);//[ 1, 2, 3]\ns3.list.push(4);\nconsole.log(s3.list); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。</p>\n<h4><span id=\"4-寄生组合继承\">4. 寄生组合继承</span></h4>\n<pre><code>function Parent3() {\n    this.parent = 'parent3'\n    this.list = [1, 2, 3]\n}\nParent3.prototype.getList = function () {\n    return this.list\n}\nfunction Child3() {\n    Parent3.call(this)\n    this.child = 'child';\n}\nChild3.prototype =Object.create(Parent3.prototype); //重点\nChild3.prototype.constructor = Child3;// 重点\nlet s5 = new Child3();\nlet s6 = new Child3();\n\nconsole.log(s5.getList());// [ 1, 2, 3 ]\ns5.list.push(4);\nconsole.log(s5.list); // [ 1, 2, 3, 4 ]\nconsole.log(s6.list);//[ 1, 2, 3]\n</code></pre>\n<p>这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg\" alt></p>\n<h3>Javascript 继承</h3>\n<h4>1. 通过构造函数实现继承</h4>\n<pre><code>function Parent(){\n    this.parent = 'parent'\n    this.getWho = function(){\n        return 'getWho:'+this.parent\n    }\n}\nParent.prototype.sayWho = function(){\n   console.log(`prototype from ${this.parent}`);\n    return `prototype from ${this.parent}`\n}\n\nfunction Child(){\n    Parent.call(this);\n    this.child = &quot;child&quot;\n}\n\nlet children = new Child();\n\nconsole.log(children.child);// child\nconsole.log(children.getWho());// getWho:parent\nconsole.log(children.parent); // parent\nconsole.log(children.sayWho()); // TypeError: children.sayWho is not a function\n</code></pre>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4>2. 借助原型链实现继承</h4>\n<pre><code>function Parent1(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n    this.lookList=function(){\n        return this.list\n    }\n}\nParent1.prototype.getList=function(){\n    return this.list\n}\nfunction Child1(){\n    this.child = 'child'\n}\nChild1.prototype = new Parent1();\n\nlet s1 = new Child1();\nlet s2 = new Child1();\nconsole.log(s1.list); // [ 1, 2, 3 ]\ns1.list.push(4)\nconsole.log(s2.list); // [ 1, 2, 3, 4 ]\nconsole.log(s1.lookList()); // [ 1, 2, 3, 4 ]\nconsole.log(s1.getList()); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); &lt;=&gt; Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 <a href=\"http://s1.pro\" target=\"_blank\" rel=\"noopener\">s1.pro</a> 和 s2.pro指向同一个地址即 父类的 prototype</p>\n<h4>3. 组合式继承</h4>\n<pre><code>function Parent2(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n}\nParent2.prototype.getList = function(){\n    return this.list\n}\nfunction Child2(){\n    Parent2.call(this)\n    this.child = 'child';\n}\nChild2.prototype = new Parent2();\n\nlet s3 = new Child2();\nlet s4 = new Child2();\n\nconsole.log(s3.getList());// [ 1, 2, 3 ]\nconsole.log(s4.list);//[ 1, 2, 3]\ns3.list.push(4);\nconsole.log(s3.list); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。</p>\n<h4>4. 寄生组合继承</h4>\n<pre><code>function Parent3() {\n    this.parent = 'parent3'\n    this.list = [1, 2, 3]\n}\nParent3.prototype.getList = function () {\n    return this.list\n}\nfunction Child3() {\n    Parent3.call(this)\n    this.child = 'child';\n}\nChild3.prototype =Object.create(Parent3.prototype); //重点\nChild3.prototype.constructor = Child3;// 重点\nlet s5 = new Child3();\nlet s6 = new Child3();\n\nconsole.log(s5.getList());// [ 1, 2, 3 ]\ns5.list.push(4);\nconsole.log(s5.list); // [ 1, 2, 3, 4 ]\nconsole.log(s6.list);//[ 1, 2, 3]\n</code></pre>\n<p>这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor</p>\n"},{"title":"前端面试系列-前端跨域常用的几种方式","catalog":true,"url":"143.html","id":"143","date":"2019-02-26T04:32:55.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。\n\n封装JOSNP\n\n    function jsonp(url,callback,success){\n        var scprit = document.createElement('script');\n        script.src=url;\n        script.async = true;\n        script.type = 'text/javascript';\n        window[callback] = function(data){\n            success && success(data)\n        }\n        document.body.appendChild(script);\n    }\n    // 调用\n    jsonp('http://xvideo.com',callback,function(data){\n        console.log(data);\n    })\n    \n\n> 2.  CORS 推荐 我最常用的手段之一\n\n1.  CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。\n    \n2.  浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n    \n3.  服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n    \n\n> 3.  `document.domain` 可以思考思考如何做单点登录和cookie跨域\n\n1.  该方式只能用于`二级域名相同`的情况下，比如 `a.test.com` 和 \\`\\`\\`b.test.com\\`\\` 适用于该方式。\n    \n2.  只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域\n    \n\n> 4.PostMessage\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n    // 发送消息端\n    window.parent.postMessage('message', 'http://test.com');\n    // 接收消息端\n    var mc = new MessageChannel();\n    mc.addEventListener('message', event => {\n        var origin = event.origin || event.originalEvent.origin\n        if (origin === 'http://test.com') {\n            console.log('验证通过')\n        }\n    })\n    \n\n##### 还有更多种跨域，比如window.name等等","source":"_posts/前端面试系列-前端跨域常用的几种方式.md","raw":"---\ntitle: 前端面试系列-前端跨域常用的几种方式\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 143.html\nid: 143\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:32:55\nsubtitle:\nheader-img:\n---\n\n> 1.  JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。\n\n封装JOSNP\n\n    function jsonp(url,callback,success){\n        var scprit = document.createElement('script');\n        script.src=url;\n        script.async = true;\n        script.type = 'text/javascript';\n        window[callback] = function(data){\n            success && success(data)\n        }\n        document.body.appendChild(script);\n    }\n    // 调用\n    jsonp('http://xvideo.com',callback,function(data){\n        console.log(data);\n    })\n    \n\n> 2.  CORS 推荐 我最常用的手段之一\n\n1.  CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。\n    \n2.  浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n    \n3.  服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n    \n\n> 3.  `document.domain` 可以思考思考如何做单点登录和cookie跨域\n\n1.  该方式只能用于`二级域名相同`的情况下，比如 `a.test.com` 和 \\`\\`\\`b.test.com\\`\\` 适用于该方式。\n    \n2.  只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域\n    \n\n> 4.PostMessage\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n    // 发送消息端\n    window.parent.postMessage('message', 'http://test.com');\n    // 接收消息端\n    var mc = new MessageChannel();\n    mc.addEventListener('message', event => {\n        var origin = event.origin || event.originalEvent.origin\n        if (origin === 'http://test.com') {\n            console.log('验证通过')\n        }\n    })\n    \n\n##### 还有更多种跨域，比如window.name等等","slug":"前端面试系列-前端跨域常用的几种方式","published":1,"updated":"2019-12-31T03:00:25.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj5z002dzws6ugwue7y9","content":"<blockquote>\n<ol>\n<li>JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。</li>\n</ol>\n</blockquote>\n<p>封装JOSNP</p>\n<pre><code>function jsonp(url,callback,success){\n    var scprit = document.createElement('script');\n    script.src=url;\n    script.async = true;\n    script.type = 'text/javascript';\n    window[callback] = function(data){\n        success &amp;&amp; success(data)\n    }\n    document.body.appendChild(script);\n}\n// 调用\njsonp('http://xvideo.com',callback,function(data){\n    console.log(data);\n})\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>CORS 推荐 我最常用的手段之一</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>\n</li>\n<li>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n</li>\n<li>\n<p>服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li><code>document.domain</code> 可以思考思考如何做单点登录和cookie跨域</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>该方式只能用于<code>二级域名相同</code>的情况下，比如 <code>a.test.com</code> 和 ```b.test.com`` 适用于该方式。</p>\n</li>\n<li>\n<p>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</p>\n</li>\n</ol>\n<blockquote>\n<p>4.PostMessage</p>\n</blockquote>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<pre><code>// 发送消息端\nwindow.parent.postMessage('message', 'http://test.com');\n// 接收消息端\nvar mc = new MessageChannel();\nmc.addEventListener('message', event =&gt; {\n    var origin = event.origin || event.originalEvent.origin\n    if (origin === 'http://test.com') {\n        console.log('验证通过')\n    }\n})\n</code></pre>\n<h5><span id=\"还有更多种跨域比如windowname等等\">还有更多种跨域，比如window.name等等</span></h5>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。</li>\n</ol>\n</blockquote>\n<p>封装JOSNP</p>\n<pre><code>function jsonp(url,callback,success){\n    var scprit = document.createElement('script');\n    script.src=url;\n    script.async = true;\n    script.type = 'text/javascript';\n    window[callback] = function(data){\n        success &amp;&amp; success(data)\n    }\n    document.body.appendChild(script);\n}\n// 调用\njsonp('http://xvideo.com',callback,function(data){\n    console.log(data);\n})\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>CORS 推荐 我最常用的手段之一</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>\n</li>\n<li>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n</li>\n<li>\n<p>服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li><code>document.domain</code> 可以思考思考如何做单点登录和cookie跨域</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>该方式只能用于<code>二级域名相同</code>的情况下，比如 <code>a.test.com</code> 和 ```b.test.com`` 适用于该方式。</p>\n</li>\n<li>\n<p>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</p>\n</li>\n</ol>\n<blockquote>\n<p>4.PostMessage</p>\n</blockquote>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<pre><code>// 发送消息端\nwindow.parent.postMessage('message', 'http://test.com');\n// 接收消息端\nvar mc = new MessageChannel();\nmc.addEventListener('message', event =&gt; {\n    var origin = event.origin || event.originalEvent.origin\n    if (origin === 'http://test.com') {\n        console.log('验证通过')\n    }\n})\n</code></pre>\n<h5>还有更多种跨域，比如window.name等等</h5>\n"},{"title":"前端面试系列-游览器中的事件","catalog":true,"url":"147.html","id":"147","date":"2019-02-26T04:36:25.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  事件触发的过程\n> \n> \\- `window` 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）\n\n*   传播到事件处发处注册事件会触发\n    \n*   从事件触发处往window传播，遇见注册的事件冒泡会触发\n    \n*   事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n    \n\n    // 以下会先打印冒泡然后是捕获\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('冒泡')\n      },\n      false\n    )\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('捕获 ')\n      },\n      true\n    )\n    \n\n> 2.  事件代理\n\n    <ul id=\"ul\">\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n    </ul>\n    <script>\n      let ul = document.querySelector('#ul')\n      ul.addEventListener('click', event => {\n        console.log(event.target)\n      })\n    </script>\n    \n\n> 3.自定义事件\n\n1.  第一种利用customEvent\n\n    let customEvent = new CustomEvent(\"customEventName\", {\n        detail:{\n            data: \"hello customEvent\"\n        }\n    });\n    \n    // 分派事件对象\n    document.dispatchEvent(customEvent);\n    // 监听事件\n    document.addEventListener('customEventName', (e)=>{\n        console.log(e.detail.data); // \"hello customEvent\"\n    });\n    \n\n2.  第二种利用createEvent\n\n    // 创建事件对象\n    let customCreateEvent = new createEvent('customEventName');\n    // 初始化事件对象\n    customCreateEvent.initCustomEvent(\"ev\", false, true, {data: \"hello createEvent\"});\n    // 分派事件\n    document.dispatchEvent(customCreateEvent);\n    // 监听事件\n    document.addEventListener('ev',e=>{\n        console.log(e.detail.data) // \"hello createEvent\"\n    });","source":"_posts/前端面试系列-游览器中的事件.md","raw":"---\ntitle: 前端面试系列-游览器中的事件\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 147.html\nid: 147\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:36:25\nsubtitle:\nheader-img:\n---\n\n> 1.  事件触发的过程\n> \n> \\- `window` 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）\n\n*   传播到事件处发处注册事件会触发\n    \n*   从事件触发处往window传播，遇见注册的事件冒泡会触发\n    \n*   事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n    \n\n    // 以下会先打印冒泡然后是捕获\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('冒泡')\n      },\n      false\n    )\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('捕获 ')\n      },\n      true\n    )\n    \n\n> 2.  事件代理\n\n    <ul id=\"ul\">\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n    </ul>\n    <script>\n      let ul = document.querySelector('#ul')\n      ul.addEventListener('click', event => {\n        console.log(event.target)\n      })\n    </script>\n    \n\n> 3.自定义事件\n\n1.  第一种利用customEvent\n\n    let customEvent = new CustomEvent(\"customEventName\", {\n        detail:{\n            data: \"hello customEvent\"\n        }\n    });\n    \n    // 分派事件对象\n    document.dispatchEvent(customEvent);\n    // 监听事件\n    document.addEventListener('customEventName', (e)=>{\n        console.log(e.detail.data); // \"hello customEvent\"\n    });\n    \n\n2.  第二种利用createEvent\n\n    // 创建事件对象\n    let customCreateEvent = new createEvent('customEventName');\n    // 初始化事件对象\n    customCreateEvent.initCustomEvent(\"ev\", false, true, {data: \"hello createEvent\"});\n    // 分派事件\n    document.dispatchEvent(customCreateEvent);\n    // 监听事件\n    document.addEventListener('ev',e=>{\n        console.log(e.detail.data) // \"hello createEvent\"\n    });","slug":"前端面试系列-游览器中的事件","published":1,"updated":"2019-12-31T03:00:25.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj62002izws6ma3ddgkl","content":"<blockquote>\n<ol>\n<li>事件触发的过程</li>\n</ol>\n<p>- <code>window</code> 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）</p>\n</blockquote>\n<ul>\n<li>\n<p>传播到事件处发处注册事件会触发</p>\n</li>\n<li>\n<p>从事件触发处往window传播，遇见注册的事件冒泡会触发</p>\n</li>\n<li>\n<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>\n</li>\n</ul>\n<pre><code>// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('捕获 ')\n  },\n  true\n)\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>事件代理</li>\n</ol>\n</blockquote>\n<pre><code>&lt;ul id=&quot;ul&quot;&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  &lt;li&gt;4&lt;/li&gt;\n  &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n  let ul = document.querySelector('#ul')\n  ul.addEventListener('click', event =&gt; {\n    console.log(event.target)\n  })\n&lt;/script&gt;\n</code></pre>\n<blockquote>\n<p>3.自定义事件</p>\n</blockquote>\n<ol>\n<li>\n<p>第一种利用customEvent</p>\n<p>let customEvent = new CustomEvent(“customEventName”, {<br>\ndetail:{<br>\ndata: “hello customEvent”<br>\n}<br>\n});</p>\n<p>// 分派事件对象<br>\ndocument.dispatchEvent(customEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘customEventName’, (e)=&gt;{<br>\nconsole.log(e.detail.data); // “hello customEvent”<br>\n});</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>第二种利用createEvent</p>\n<p>// 创建事件对象<br>\nlet customCreateEvent = new createEvent(‘customEventName’);<br>\n// 初始化事件对象<br>\ncustomCreateEvent.initCustomEvent(“ev”, false, true, {data: “hello createEvent”});<br>\n// 分派事件<br>\ndocument.dispatchEvent(customCreateEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘ev’,e=&gt;{<br>\nconsole.log(e.detail.data) // “hello createEvent”<br>\n});</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>事件触发的过程</li>\n</ol>\n<p>- <code>window</code> 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）</p>\n</blockquote>\n<ul>\n<li>\n<p>传播到事件处发处注册事件会触发</p>\n</li>\n<li>\n<p>从事件触发处往window传播，遇见注册的事件冒泡会触发</p>\n</li>\n<li>\n<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>\n</li>\n</ul>\n<pre><code>// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('捕获 ')\n  },\n  true\n)\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>事件代理</li>\n</ol>\n</blockquote>\n<pre><code>&lt;ul id=&quot;ul&quot;&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  &lt;li&gt;4&lt;/li&gt;\n  &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n  let ul = document.querySelector('#ul')\n  ul.addEventListener('click', event =&gt; {\n    console.log(event.target)\n  })\n&lt;/script&gt;\n</code></pre>\n<blockquote>\n<p>3.自定义事件</p>\n</blockquote>\n<ol>\n<li>\n<p>第一种利用customEvent</p>\n<p>let customEvent = new CustomEvent(“customEventName”, {<br>\ndetail:{<br>\ndata: “hello customEvent”<br>\n}<br>\n});</p>\n<p>// 分派事件对象<br>\ndocument.dispatchEvent(customEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘customEventName’, (e)=&gt;{<br>\nconsole.log(e.detail.data); // “hello customEvent”<br>\n});</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>第二种利用createEvent</p>\n<p>// 创建事件对象<br>\nlet customCreateEvent = new createEvent(‘customEventName’);<br>\n// 初始化事件对象<br>\ncustomCreateEvent.initCustomEvent(“ev”, false, true, {data: “hello createEvent”});<br>\n// 分派事件<br>\ndocument.dispatchEvent(customCreateEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘ev’,e=&gt;{<br>\nconsole.log(e.detail.data) // “hello createEvent”<br>\n});</p>\n</li>\n</ol>\n"},{"title":"如何在Vue SPA中集成GraphQL","catalog":true,"url":"101.html","id":"101","date":"2019-02-20T10:50:50.000Z","subtitle":null,"header-img":null,"_content":"\n![](https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67)\n\n> 1.  为了快速搭建，首先我们安装vue-cli@3.x\n\n     sudo npm install -g @vue/cli\n     yarn global add @vue/cli\n    \n\n> 2.  我们快速搭建一个Vue-SPA项目\n\n      mkdir learn_vue_with_graphql\n      cd learn_vue_with_graphql\n      vue create vue-ssr-graphql\n      # 按照你自己的需求选择插件\n      # 安装完毕后，进入vue-ssr-graphql目录\n      cd vue-ssr-graphql\n    \n\n> 3.  安装关于在vue中使用graphQL的一些包\n\n    npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n或者\n\n    yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n> 4.  在项目`src` 目录下创建`apolloClient.js`文件\n\n    import { ApolloClient } from 'apollo-client';\n    import { HttpLink } from 'apollo-link-http';\n    import { InMemoryCache } from 'apollo-cache-inmemory';\n    \n    const httpLink = new HttpLink({\n      uri: 'http://localhost:3000/graphql'\n    });\n    \n    const cache = new InMemoryCache();\n    // 导出 ApolloClient graphQL客户端\n    export default new ApolloClient({\n      link: httpLink,\n      cache\n    });\n    \n\n> 5.  修改`main.js`安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）\n\n    import Vue from 'vue'\n    import App from './App.vue'\n    import router from './router'\n    import store from './store'\n    import apolloClient from './apolloClient'\n    import './registerServiceWorker'\n    import VueApollo from 'vue-apollo';\n    \n    Vue.config.productionTip = false\n    \n    const apolloProvider = new VueApollo({\n      defaultClient: apolloClient\n    })\n    Vue.use(VueApollo);\n    new Vue({\n      router,\n      store,\n      apolloProvider,\n      render: h => h(App)\n    }).$mount('#app')\n    \n    \n\n> 6.在组件中使用（需要配合graphQL服务端）\n\n服务端源码地址：[github](https://github.com/maliaoMJ/graphql-api-server)\n\n1.  首先打开`views`目录下的`Home.vue` 文件\n\n在vue文件的JS部分做如下修改\n\n    <script>\n    // @ is an alias to /src\n    import gql from \"graphql-tag\";\n    export default {\n      name: \"home\",\n      computed: {\n        loading() {\n          return this.$apollo.loading;\n        }\n      },\n      data() {\n        return {\n          hello: \"\"\n        };\n      },\n      mounted() {\n        console.log(this.$apollo.loading, this.$apollo.data);\n      },\n      apollo: {\n        hello: {\n          query: gql`\n            query getUserInfo($id: Int!) {\n              hello\n              userInfo(id: $id) {\n                name\n                age\n                gender\n                id\n              }\n            }\n          `,\n          variables: {\n            id: 10001\n          }\n        }\n      }\n    };\n    </script>\n    \n    \n\n2.  运行项目\n\n运行如下命令\n\n    yarn run serve\n    \n\n然后打开游览器访问`localhost:8080`可以看到如下结果\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16-1.png)\n\n##### 最后附上源代码文件地址 [github](https://github.com/maliaoMJ/vue-graphQL-template)","source":"_posts/如何在Vue SPA中集成GraphQL.md","raw":"---\ntitle: 如何在Vue SPA中集成GraphQL\ncatalog: true\ntags:\n  - graphql\n  - nodejs\n  - vuejs\nurl: 101.html\nid: 101\ncategories:\n  - GraphQL\ndate: 2019-02-20 18:50:50\nsubtitle:\nheader-img:\n---\n\n![](https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67)\n\n> 1.  为了快速搭建，首先我们安装vue-cli@3.x\n\n     sudo npm install -g @vue/cli\n     yarn global add @vue/cli\n    \n\n> 2.  我们快速搭建一个Vue-SPA项目\n\n      mkdir learn_vue_with_graphql\n      cd learn_vue_with_graphql\n      vue create vue-ssr-graphql\n      # 按照你自己的需求选择插件\n      # 安装完毕后，进入vue-ssr-graphql目录\n      cd vue-ssr-graphql\n    \n\n> 3.  安装关于在vue中使用graphQL的一些包\n\n    npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n或者\n\n    yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n> 4.  在项目`src` 目录下创建`apolloClient.js`文件\n\n    import { ApolloClient } from 'apollo-client';\n    import { HttpLink } from 'apollo-link-http';\n    import { InMemoryCache } from 'apollo-cache-inmemory';\n    \n    const httpLink = new HttpLink({\n      uri: 'http://localhost:3000/graphql'\n    });\n    \n    const cache = new InMemoryCache();\n    // 导出 ApolloClient graphQL客户端\n    export default new ApolloClient({\n      link: httpLink,\n      cache\n    });\n    \n\n> 5.  修改`main.js`安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）\n\n    import Vue from 'vue'\n    import App from './App.vue'\n    import router from './router'\n    import store from './store'\n    import apolloClient from './apolloClient'\n    import './registerServiceWorker'\n    import VueApollo from 'vue-apollo';\n    \n    Vue.config.productionTip = false\n    \n    const apolloProvider = new VueApollo({\n      defaultClient: apolloClient\n    })\n    Vue.use(VueApollo);\n    new Vue({\n      router,\n      store,\n      apolloProvider,\n      render: h => h(App)\n    }).$mount('#app')\n    \n    \n\n> 6.在组件中使用（需要配合graphQL服务端）\n\n服务端源码地址：[github](https://github.com/maliaoMJ/graphql-api-server)\n\n1.  首先打开`views`目录下的`Home.vue` 文件\n\n在vue文件的JS部分做如下修改\n\n    <script>\n    // @ is an alias to /src\n    import gql from \"graphql-tag\";\n    export default {\n      name: \"home\",\n      computed: {\n        loading() {\n          return this.$apollo.loading;\n        }\n      },\n      data() {\n        return {\n          hello: \"\"\n        };\n      },\n      mounted() {\n        console.log(this.$apollo.loading, this.$apollo.data);\n      },\n      apollo: {\n        hello: {\n          query: gql`\n            query getUserInfo($id: Int!) {\n              hello\n              userInfo(id: $id) {\n                name\n                age\n                gender\n                id\n              }\n            }\n          `,\n          variables: {\n            id: 10001\n          }\n        }\n      }\n    };\n    </script>\n    \n    \n\n2.  运行项目\n\n运行如下命令\n\n    yarn run serve\n    \n\n然后打开游览器访问`localhost:8080`可以看到如下结果\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16-1.png)\n\n##### 最后附上源代码文件地址 [github](https://github.com/maliaoMJ/vue-graphQL-template)","slug":"如何在Vue SPA中集成GraphQL","published":1,"updated":"2019-12-31T03:00:25.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj63002jzws66sq9t0z9","content":"<p><img src=\"https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67\" alt></p>\n<blockquote>\n<ol>\n<li>为了快速搭建，首先我们安装vue-cli@3.x</li>\n</ol>\n</blockquote>\n<pre><code> sudo npm install -g @vue/cli\n yarn global add @vue/cli\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>我们快速搭建一个Vue-SPA项目</li>\n</ol>\n</blockquote>\n<pre><code>  mkdir learn_vue_with_graphql\n  cd learn_vue_with_graphql\n  vue create vue-ssr-graphql\n  # 按照你自己的需求选择插件\n  # 安装完毕后，进入vue-ssr-graphql目录\n  cd vue-ssr-graphql\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>安装关于在vue中使用graphQL的一些包</li>\n</ol>\n</blockquote>\n<pre><code>npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<p>或者</p>\n<pre><code>yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>在项目<code>src</code> 目录下创建<code>apolloClient.js</code>文件</li>\n</ol>\n</blockquote>\n<pre><code>import { ApolloClient } from 'apollo-client';\nimport { HttpLink } from 'apollo-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:3000/graphql'\n});\n\nconst cache = new InMemoryCache();\n// 导出 ApolloClient graphQL客户端\nexport default new ApolloClient({\n  link: httpLink,\n  cache\n});\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>修改<code>main.js</code>安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）</li>\n</ol>\n</blockquote>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nimport apolloClient from './apolloClient'\nimport './registerServiceWorker'\nimport VueApollo from 'vue-apollo';\n\nVue.config.productionTip = false\n\nconst apolloProvider = new VueApollo({\n  defaultClient: apolloClient\n})\nVue.use(VueApollo);\nnew Vue({\n  router,\n  store,\n  apolloProvider,\n  render: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<blockquote>\n<p>6.在组件中使用（需要配合graphQL服务端）</p>\n</blockquote>\n<p>服务端源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ol>\n<li>首先打开<code>views</code>目录下的<code>Home.vue</code> 文件</li>\n</ol>\n<p>在vue文件的JS部分做如下修改</p>\n<pre><code>&lt;script&gt;\n// @ is an alias to /src\nimport gql from &quot;graphql-tag&quot;;\nexport default {\n  name: &quot;home&quot;,\n  computed: {\n    loading() {\n      return this.$apollo.loading;\n    }\n  },\n  data() {\n    return {\n      hello: &quot;&quot;\n    };\n  },\n  mounted() {\n    console.log(this.$apollo.loading, this.$apollo.data);\n  },\n  apollo: {\n    hello: {\n      query: gql`\n        query getUserInfo($id: Int!) {\n          hello\n          userInfo(id: $id) {\n            name\n            age\n            gender\n            id\n          }\n        }\n      `,\n      variables: {\n        id: 10001\n      }\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>运行项目</li>\n</ol>\n<p>运行如下命令</p>\n<pre><code>yarn run serve\n</code></pre>\n<p>然后打开游览器访问<code>localhost:8080</code>可以看到如下结果</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16-1.png\" alt></p>\n<h5><span id=\"最后附上源代码文件地址-github\">最后附上源代码文件地址 </span></h5>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67\" alt></p>\n<blockquote>\n<ol>\n<li>为了快速搭建，首先我们安装vue-cli@3.x</li>\n</ol>\n</blockquote>\n<pre><code> sudo npm install -g @vue/cli\n yarn global add @vue/cli\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>我们快速搭建一个Vue-SPA项目</li>\n</ol>\n</blockquote>\n<pre><code>  mkdir learn_vue_with_graphql\n  cd learn_vue_with_graphql\n  vue create vue-ssr-graphql\n  # 按照你自己的需求选择插件\n  # 安装完毕后，进入vue-ssr-graphql目录\n  cd vue-ssr-graphql\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>安装关于在vue中使用graphQL的一些包</li>\n</ol>\n</blockquote>\n<pre><code>npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<p>或者</p>\n<pre><code>yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>在项目<code>src</code> 目录下创建<code>apolloClient.js</code>文件</li>\n</ol>\n</blockquote>\n<pre><code>import { ApolloClient } from 'apollo-client';\nimport { HttpLink } from 'apollo-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:3000/graphql'\n});\n\nconst cache = new InMemoryCache();\n// 导出 ApolloClient graphQL客户端\nexport default new ApolloClient({\n  link: httpLink,\n  cache\n});\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>修改<code>main.js</code>安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）</li>\n</ol>\n</blockquote>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nimport apolloClient from './apolloClient'\nimport './registerServiceWorker'\nimport VueApollo from 'vue-apollo';\n\nVue.config.productionTip = false\n\nconst apolloProvider = new VueApollo({\n  defaultClient: apolloClient\n})\nVue.use(VueApollo);\nnew Vue({\n  router,\n  store,\n  apolloProvider,\n  render: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<blockquote>\n<p>6.在组件中使用（需要配合graphQL服务端）</p>\n</blockquote>\n<p>服务端源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ol>\n<li>首先打开<code>views</code>目录下的<code>Home.vue</code> 文件</li>\n</ol>\n<p>在vue文件的JS部分做如下修改</p>\n<pre><code>&lt;script&gt;\n// @ is an alias to /src\nimport gql from &quot;graphql-tag&quot;;\nexport default {\n  name: &quot;home&quot;,\n  computed: {\n    loading() {\n      return this.$apollo.loading;\n    }\n  },\n  data() {\n    return {\n      hello: &quot;&quot;\n    };\n  },\n  mounted() {\n    console.log(this.$apollo.loading, this.$apollo.data);\n  },\n  apollo: {\n    hello: {\n      query: gql`\n        query getUserInfo($id: Int!) {\n          hello\n          userInfo(id: $id) {\n            name\n            age\n            gender\n            id\n          }\n        }\n      `,\n      variables: {\n        id: 10001\n      }\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>运行项目</li>\n</ol>\n<p>运行如下命令</p>\n<pre><code>yarn run serve\n</code></pre>\n<p>然后打开游览器访问<code>localhost:8080</code>可以看到如下结果</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16-1.png\" alt></p>\n<h5>最后附上源代码文件地址 <a href=\"https://github.com/maliaoMJ/vue-graphQL-template\" target=\"_blank\" rel=\"noopener\">github</a></h5>\n"},{"title":"阅读Vue Composition API 了解Vue3.x的设计思想（下篇）","catalog":true,"date":"2019-10-17T14:09:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n# API Reference \n\n> 要看源码之前，首先要学会TypeScript（前十篇文档有`Typescript`学习指南）,因为vue3.x 版本中+90%的代码是使用的`Typescript`，[Vue3.x 源码地址](https://github.com/vuejs/vue-next)。\n\n## ReadOnly\n  接收一个对象（reactive or plain）或ref并返回一个对原始对象的只读（and reactive）代理。\n\n    ```javascript\n        const original = reactive({ count: 0 })\n\n        const copy = readonly(original)\n\n        watch(() => {\n        // works for reactivity tracking\n        console.log(copy.count)\n        })\n\n        // mutating original will trigger watchers relying on the copy\n        original.count++\n\n        // mutating the copy will fail and result in a warning\n        copy.count++ // warning!\n    ```\n    \n## ReadOnly\n\n### 未完待续.......","source":"_posts/阅读Vue Composition API了解Vue3的设计 （下篇）.md","raw":"---\ntitle: 阅读Vue Composition API 了解Vue3.x的设计思想（下篇）\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-17 22:09:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n# API Reference \n\n> 要看源码之前，首先要学会TypeScript（前十篇文档有`Typescript`学习指南）,因为vue3.x 版本中+90%的代码是使用的`Typescript`，[Vue3.x 源码地址](https://github.com/vuejs/vue-next)。\n\n## ReadOnly\n  接收一个对象（reactive or plain）或ref并返回一个对原始对象的只读（and reactive）代理。\n\n    ```javascript\n        const original = reactive({ count: 0 })\n\n        const copy = readonly(original)\n\n        watch(() => {\n        // works for reactivity tracking\n        console.log(copy.count)\n        })\n\n        // mutating original will trigger watchers relying on the copy\n        original.count++\n\n        // mutating the copy will fail and result in a warning\n        copy.count++ // warning!\n    ```\n    \n## ReadOnly\n\n### 未完待续.......","slug":"阅读Vue Composition API了解Vue3的设计 （下篇）","published":1,"updated":"2019-12-31T03:16:41.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj67002ozws6bi2hbgu0","content":"<h1><span id=\"api-reference\">API Reference</span></h1>\n<blockquote>\n<p>要看源码之前，首先要学会TypeScript（前十篇文档有<code>Typescript</code>学习指南）,因为vue3.x 版本中+90%的代码是使用的<code>Typescript</code>，<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">Vue3.x 源码地址</a>。</p>\n</blockquote>\n<h2><span id=\"readonly\">ReadOnly</span></h2>\n<p>接收一个对象（reactive or plain）或ref并返回一个对原始对象的只读（and reactive）代理。</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> original = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> copy = readonly(original)</span><br><span class=\"line\"></span><br><span class=\"line\">watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// works for reactivity tracking</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy.count)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mutating original will trigger watchers relying on the copy</span></span><br><span class=\"line\">original.count++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mutating the copy will fail and result in a warning</span></span><br><span class=\"line\">copy.count++ <span class=\"comment\">// warning!</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2><span id=\"readonly\">ReadOnly</span></h2>\n<h3><span id=\"未完待续\">未完待续…</span></h3>\n","site":{"data":{}},"excerpt":"","more":"<h1>API Reference</h1>\n<blockquote>\n<p>要看源码之前，首先要学会TypeScript（前十篇文档有<code>Typescript</code>学习指南）,因为vue3.x 版本中+90%的代码是使用的<code>Typescript</code>，<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">Vue3.x 源码地址</a>。</p>\n</blockquote>\n<h2>ReadOnly</h2>\n<p>接收一个对象（reactive or plain）或ref并返回一个对原始对象的只读（and reactive）代理。</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> original = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> copy = readonly(original)</span><br><span class=\"line\"></span><br><span class=\"line\">watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// works for reactivity tracking</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy.count)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mutating original will trigger watchers relying on the copy</span></span><br><span class=\"line\">original.count++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mutating the copy will fail and result in a warning</span></span><br><span class=\"line\">copy.count++ <span class=\"comment\">// warning!</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2>ReadOnly</h2>\n<h3>未完待续…</h3>\n"},{"title":"JavaScript数据结构与算法-树","catalog":true,"url":"214.html","id":"214","date":"2019-03-13T11:09:28.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是树？\n\n树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: ![](http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png) 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。\n\n#### 2.二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。\n\n#### 3\\. 手动实现一个BST(二叉搜索树)\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/12121212.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/1111.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/22222222.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/5555555.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/777777.png)\n\n    // BST 二叉搜索树\n    class TreeNode {\n        constructor(key){\n           this.key = key;\n           this.left =null;\n           this.right = null;\n        }\n    }\n    // 插入节点 辅助函数\n    function insertNode(node,newNode){\n        if(node.key > newNode.key){\n            if(node.left === null){\n                node.left = newNode\n            }else{\n              insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right === null){\n                node.right = newNode\n            }else{\n                insertNode(node.right,newNode);\n            }\n        }\n    }\n    // 中序遍历 辅助函数\n    function inOrderTraverseNode(node,callback){\n       if(node!== null){\n           inOrderTraverseNode(node.left,callback);\n           callback(node.key);\n           inOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 先序遍历 辅助函数\n    function preOrderTraverseNode(node,callback){\n       if(node !==null){\n           callback(node.key);\n           preOrderTraverseNode(node.left,callback);\n           preOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 后续遍历 辅助函数\n    function postOrderTraverseNode(node,callback){\n       if(node !== null){\n           postOrderTraverseNode(node.left, callback);\n           postOrderTraverseNode(node.right, callback);\n           callback(node.key);\n       }\n    }\n    // 最小节点辅助函数\n    function minNode(node){\n        while(node && node.left !==null){\n            node = node.left;\n        }\n        return node.key;\n    }\n    // 最大节点辅助函数\n    function maxNode(node){\n        while(node && node.right !==null){\n            node = node.right;\n        }\n        return node.key;\n    }\n    // 搜索辅助函数\n    function serachNode(node,key){\n        if(node === null){\n            return false;\n        }else{\n            if(key < node.key){\n                return serachNode(node.left,key);\n            }else if(key > node.key){\n                return serachNode(node.right,key);\n            }else{\n                return true;\n            }\n        }\n    }\n    // 删除辅助函数\n    function removeNode(node, key) {\n        if (node === null) {\n            return null;\n        }\n        if (key < node.key) {\n            node.left = removeNode(node.left, key);\n            return node;\n        } else if (key > node.key) {\n            node.right = removeNode(node.right, key);\n            return node;\n        } else { //键等于node.key\n            //第一种情况——一个叶节点\n            if (node.left === null && node.right === null) {\n                node = null;\n                return node;\n            }\n            //第二种情况——一个只有一个子节点的节点 \n            if (node.left === null) {\n                node = node.right;\n                return node;\n            } else if (node.right === null) {\n                node = node.left;\n                return node;\n            }\n            //第三种情况——一个有两个子节点的节点\n            var aux = findMinNode(node.right);\n            node.key = aux.key; //\n            node.right = removeNode(node.right, aux.key);\n            return node;\n        }\n    };\n    // callback 辅助函数\n    function printNode(value){\n       console.log(value);\n    }\n    class BinarySearchTree {\n        constructor(){\n            this.root = null;\n        }\n        // 插入几点\n        insert(key){\n            let newNode = new TreeNode(key);\n            if(this.root === null){\n                this.root = newNode;\n            }else{\n                insertNode(this.root,newNode)\n            }\n        }\n        // 中序遍历 callback 对节点操作回掉函数\n        inOrderTraverse(callback){\n            inOrderTraverseNode(this.root, callback);\n        }\n        //先序遍历\n        preOrderTraverse(callback){\n            preOrderTraverseNode(this.root,callback);\n        }\n        // 后序遍历\n        postOrderTraverse(callback){\n           postOrderTraverseNode(this.root,callback);\n        }\n        // 最小值\n        min(){\n            return minNode(this.root);\n        }\n        // 最大值\n        max(){\n            return maxNode(this.root);\n        }\n        // 搜索\n        serarch(key){\n            return serachNode(this.root,key);\n        }\n        // 删除节点\n        remove(key){\n            root = removeNode(root, key);\n        }\n    }\n    \n    var tree = new BinarySearchTree();\n    tree.insert(11);\n    tree.insert(7);\n    tree.insert(15);\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(9);\n    tree.insert(8);\n    tree.insert(10);\n    tree.insert(13);\n    tree.insert(12);\n    tree.insert(14);\n    tree.insert(20);\n    tree.insert(18);\n    tree.insert(25);\n    tree.insert(6);\n    console.log(tree);\n    console.log('--------------------中序遍历-------------');\n    console.log(tree.inOrderTraverse(printNode));\n    console.log('--------------------先序遍历-------------');\n    console.log(tree.preOrderTraverse(printNode));\n    console.log('--------------------后序遍历-------------');\n    console.log(tree.postOrderTraverse(printNode));\n    console.log('--------------------最小值-------------');\n    console.log(tree.min());\n    console.log('--------------------最大值-------------');\n    console.log(tree.max());\n    \n    console.log('--------------------搜索-------------');\n    console.log(tree.serarch(100));\n    <!----------------------中序遍历--------------->\n    <!--3-->\n    <!--5-->\n    <!--6-->\n    <!--7-->\n    <!--8-->\n    <!--9-->\n    <!--10-->\n    <!--11-->\n    <!--12-->\n    <!--13-->\n    <!--14-->\n    <!--15-->\n    <!--18-->\n    <!--20-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------先序遍历--------------->\n    <!--11-->\n    <!--7-->\n    <!--5-->\n    <!--3-->\n    <!--6-->\n    <!--9-->\n    <!--8-->\n    <!--10-->\n    <!--15-->\n    <!--13-->\n    <!--12-->\n    <!--14-->\n    <!--20-->\n    <!--18-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------后序遍历--------------->\n    <!--3-->\n    <!--6-->\n    <!--5-->\n    <!--8-->\n    <!--10-->\n    <!--9-->\n    <!--7-->\n    <!--12-->\n    <!--14-->\n    <!--13-->\n    <!--18-->\n    <!--25-->\n    <!--20-->\n    <!--15-->\n    <!--11-->\n    <!--undefined-->\n    <!----------------------最小值--------------->\n    <!--3-->\n    <!----------------------最大值--------------->\n    <!--25-->\n    <!----------------------搜索--------------->\n    <!--false-->","source":"_posts/JavaScript数据结构与算法-树.md","raw":"---\ntitle: JavaScript数据结构与算法-树\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 214.html\nid: 214\ncategories:\n  - 数据结构\ndate: 2019-03-13 19:09:28\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是树？\n\n树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: ![](http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png) 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。\n\n#### 2.二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。\n\n#### 3\\. 手动实现一个BST(二叉搜索树)\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/12121212.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/1111.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/22222222.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/5555555.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/777777.png)\n\n    // BST 二叉搜索树\n    class TreeNode {\n        constructor(key){\n           this.key = key;\n           this.left =null;\n           this.right = null;\n        }\n    }\n    // 插入节点 辅助函数\n    function insertNode(node,newNode){\n        if(node.key > newNode.key){\n            if(node.left === null){\n                node.left = newNode\n            }else{\n              insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right === null){\n                node.right = newNode\n            }else{\n                insertNode(node.right,newNode);\n            }\n        }\n    }\n    // 中序遍历 辅助函数\n    function inOrderTraverseNode(node,callback){\n       if(node!== null){\n           inOrderTraverseNode(node.left,callback);\n           callback(node.key);\n           inOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 先序遍历 辅助函数\n    function preOrderTraverseNode(node,callback){\n       if(node !==null){\n           callback(node.key);\n           preOrderTraverseNode(node.left,callback);\n           preOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 后续遍历 辅助函数\n    function postOrderTraverseNode(node,callback){\n       if(node !== null){\n           postOrderTraverseNode(node.left, callback);\n           postOrderTraverseNode(node.right, callback);\n           callback(node.key);\n       }\n    }\n    // 最小节点辅助函数\n    function minNode(node){\n        while(node && node.left !==null){\n            node = node.left;\n        }\n        return node.key;\n    }\n    // 最大节点辅助函数\n    function maxNode(node){\n        while(node && node.right !==null){\n            node = node.right;\n        }\n        return node.key;\n    }\n    // 搜索辅助函数\n    function serachNode(node,key){\n        if(node === null){\n            return false;\n        }else{\n            if(key < node.key){\n                return serachNode(node.left,key);\n            }else if(key > node.key){\n                return serachNode(node.right,key);\n            }else{\n                return true;\n            }\n        }\n    }\n    // 删除辅助函数\n    function removeNode(node, key) {\n        if (node === null) {\n            return null;\n        }\n        if (key < node.key) {\n            node.left = removeNode(node.left, key);\n            return node;\n        } else if (key > node.key) {\n            node.right = removeNode(node.right, key);\n            return node;\n        } else { //键等于node.key\n            //第一种情况——一个叶节点\n            if (node.left === null && node.right === null) {\n                node = null;\n                return node;\n            }\n            //第二种情况——一个只有一个子节点的节点 \n            if (node.left === null) {\n                node = node.right;\n                return node;\n            } else if (node.right === null) {\n                node = node.left;\n                return node;\n            }\n            //第三种情况——一个有两个子节点的节点\n            var aux = findMinNode(node.right);\n            node.key = aux.key; //\n            node.right = removeNode(node.right, aux.key);\n            return node;\n        }\n    };\n    // callback 辅助函数\n    function printNode(value){\n       console.log(value);\n    }\n    class BinarySearchTree {\n        constructor(){\n            this.root = null;\n        }\n        // 插入几点\n        insert(key){\n            let newNode = new TreeNode(key);\n            if(this.root === null){\n                this.root = newNode;\n            }else{\n                insertNode(this.root,newNode)\n            }\n        }\n        // 中序遍历 callback 对节点操作回掉函数\n        inOrderTraverse(callback){\n            inOrderTraverseNode(this.root, callback);\n        }\n        //先序遍历\n        preOrderTraverse(callback){\n            preOrderTraverseNode(this.root,callback);\n        }\n        // 后序遍历\n        postOrderTraverse(callback){\n           postOrderTraverseNode(this.root,callback);\n        }\n        // 最小值\n        min(){\n            return minNode(this.root);\n        }\n        // 最大值\n        max(){\n            return maxNode(this.root);\n        }\n        // 搜索\n        serarch(key){\n            return serachNode(this.root,key);\n        }\n        // 删除节点\n        remove(key){\n            root = removeNode(root, key);\n        }\n    }\n    \n    var tree = new BinarySearchTree();\n    tree.insert(11);\n    tree.insert(7);\n    tree.insert(15);\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(9);\n    tree.insert(8);\n    tree.insert(10);\n    tree.insert(13);\n    tree.insert(12);\n    tree.insert(14);\n    tree.insert(20);\n    tree.insert(18);\n    tree.insert(25);\n    tree.insert(6);\n    console.log(tree);\n    console.log('--------------------中序遍历-------------');\n    console.log(tree.inOrderTraverse(printNode));\n    console.log('--------------------先序遍历-------------');\n    console.log(tree.preOrderTraverse(printNode));\n    console.log('--------------------后序遍历-------------');\n    console.log(tree.postOrderTraverse(printNode));\n    console.log('--------------------最小值-------------');\n    console.log(tree.min());\n    console.log('--------------------最大值-------------');\n    console.log(tree.max());\n    \n    console.log('--------------------搜索-------------');\n    console.log(tree.serarch(100));\n    <!----------------------中序遍历--------------->\n    <!--3-->\n    <!--5-->\n    <!--6-->\n    <!--7-->\n    <!--8-->\n    <!--9-->\n    <!--10-->\n    <!--11-->\n    <!--12-->\n    <!--13-->\n    <!--14-->\n    <!--15-->\n    <!--18-->\n    <!--20-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------先序遍历--------------->\n    <!--11-->\n    <!--7-->\n    <!--5-->\n    <!--3-->\n    <!--6-->\n    <!--9-->\n    <!--8-->\n    <!--10-->\n    <!--15-->\n    <!--13-->\n    <!--12-->\n    <!--14-->\n    <!--20-->\n    <!--18-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------后序遍历--------------->\n    <!--3-->\n    <!--6-->\n    <!--5-->\n    <!--8-->\n    <!--10-->\n    <!--9-->\n    <!--7-->\n    <!--12-->\n    <!--14-->\n    <!--13-->\n    <!--18-->\n    <!--25-->\n    <!--20-->\n    <!--15-->\n    <!--11-->\n    <!--undefined-->\n    <!----------------------最小值--------------->\n    <!--3-->\n    <!----------------------最大值--------------->\n    <!--25-->\n    <!----------------------搜索--------------->\n    <!--false-->","slug":"JavaScript数据结构与算法-树","published":1,"updated":"2019-12-31T03:00:25.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj7t0069zws6mlt8pub2","content":"<h4><span id=\"1-什么是树\">1. 什么是树？</span></h4>\n<p>树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png\" alt> 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。</p>\n<h4><span id=\"2二叉树和二叉搜索树\">2.二叉树和二叉搜索树</span></h4>\n<p>二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。</p>\n<h4><span id=\"3-手动实现一个bst二叉搜索树\">3. 手动实现一个BST(二叉搜索树)</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/12121212.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/1111.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/22222222.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/5555555.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/777777.png\" alt></p>\n<pre><code>// BST 二叉搜索树\nclass TreeNode {\n    constructor(key){\n       this.key = key;\n       this.left =null;\n       this.right = null;\n    }\n}\n// 插入节点 辅助函数\nfunction insertNode(node,newNode){\n    if(node.key &gt; newNode.key){\n        if(node.left === null){\n            node.left = newNode\n        }else{\n          insertNode(node.left,newNode)\n        }\n    }else{\n        if(node.right === null){\n            node.right = newNode\n        }else{\n            insertNode(node.right,newNode);\n        }\n    }\n}\n// 中序遍历 辅助函数\nfunction inOrderTraverseNode(node,callback){\n   if(node!== null){\n       inOrderTraverseNode(node.left,callback);\n       callback(node.key);\n       inOrderTraverseNode(node.right,callback);\n   }\n}\n// 先序遍历 辅助函数\nfunction preOrderTraverseNode(node,callback){\n   if(node !==null){\n       callback(node.key);\n       preOrderTraverseNode(node.left,callback);\n       preOrderTraverseNode(node.right,callback);\n   }\n}\n// 后续遍历 辅助函数\nfunction postOrderTraverseNode(node,callback){\n   if(node !== null){\n       postOrderTraverseNode(node.left, callback);\n       postOrderTraverseNode(node.right, callback);\n       callback(node.key);\n   }\n}\n// 最小节点辅助函数\nfunction minNode(node){\n    while(node &amp;&amp; node.left !==null){\n        node = node.left;\n    }\n    return node.key;\n}\n// 最大节点辅助函数\nfunction maxNode(node){\n    while(node &amp;&amp; node.right !==null){\n        node = node.right;\n    }\n    return node.key;\n}\n// 搜索辅助函数\nfunction serachNode(node,key){\n    if(node === null){\n        return false;\n    }else{\n        if(key &lt; node.key){\n            return serachNode(node.left,key);\n        }else if(key &gt; node.key){\n            return serachNode(node.right,key);\n        }else{\n            return true;\n        }\n    }\n}\n// 删除辅助函数\nfunction removeNode(node, key) {\n    if (node === null) {\n        return null;\n    }\n    if (key &lt; node.key) {\n        node.left = removeNode(node.left, key);\n        return node;\n    } else if (key &gt; node.key) {\n        node.right = removeNode(node.right, key);\n        return node;\n    } else { //键等于node.key\n        //第一种情况——一个叶节点\n        if (node.left === null &amp;&amp; node.right === null) {\n            node = null;\n            return node;\n        }\n        //第二种情况——一个只有一个子节点的节点 \n        if (node.left === null) {\n            node = node.right;\n            return node;\n        } else if (node.right === null) {\n            node = node.left;\n            return node;\n        }\n        //第三种情况——一个有两个子节点的节点\n        var aux = findMinNode(node.right);\n        node.key = aux.key; //\n        node.right = removeNode(node.right, aux.key);\n        return node;\n    }\n};\n// callback 辅助函数\nfunction printNode(value){\n   console.log(value);\n}\nclass BinarySearchTree {\n    constructor(){\n        this.root = null;\n    }\n    // 插入几点\n    insert(key){\n        let newNode = new TreeNode(key);\n        if(this.root === null){\n            this.root = newNode;\n        }else{\n            insertNode(this.root,newNode)\n        }\n    }\n    // 中序遍历 callback 对节点操作回掉函数\n    inOrderTraverse(callback){\n        inOrderTraverseNode(this.root, callback);\n    }\n    //先序遍历\n    preOrderTraverse(callback){\n        preOrderTraverseNode(this.root,callback);\n    }\n    // 后序遍历\n    postOrderTraverse(callback){\n       postOrderTraverseNode(this.root,callback);\n    }\n    // 最小值\n    min(){\n        return minNode(this.root);\n    }\n    // 最大值\n    max(){\n        return maxNode(this.root);\n    }\n    // 搜索\n    serarch(key){\n        return serachNode(this.root,key);\n    }\n    // 删除节点\n    remove(key){\n        root = removeNode(root, key);\n    }\n}\n\nvar tree = new BinarySearchTree();\ntree.insert(11);\ntree.insert(7);\ntree.insert(15);\ntree.insert(5);\ntree.insert(3);\ntree.insert(9);\ntree.insert(8);\ntree.insert(10);\ntree.insert(13);\ntree.insert(12);\ntree.insert(14);\ntree.insert(20);\ntree.insert(18);\ntree.insert(25);\ntree.insert(6);\nconsole.log(tree);\nconsole.log('--------------------中序遍历-------------');\nconsole.log(tree.inOrderTraverse(printNode));\nconsole.log('--------------------先序遍历-------------');\nconsole.log(tree.preOrderTraverse(printNode));\nconsole.log('--------------------后序遍历-------------');\nconsole.log(tree.postOrderTraverse(printNode));\nconsole.log('--------------------最小值-------------');\nconsole.log(tree.min());\nconsole.log('--------------------最大值-------------');\nconsole.log(tree.max());\n\nconsole.log('--------------------搜索-------------');\nconsole.log(tree.serarch(100));\n&lt;!----------------------中序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--5--&gt;\n&lt;!--6--&gt;\n&lt;!--7--&gt;\n&lt;!--8--&gt;\n&lt;!--9--&gt;\n&lt;!--10--&gt;\n&lt;!--11--&gt;\n&lt;!--12--&gt;\n&lt;!--13--&gt;\n&lt;!--14--&gt;\n&lt;!--15--&gt;\n&lt;!--18--&gt;\n&lt;!--20--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------先序遍历---------------&gt;\n&lt;!--11--&gt;\n&lt;!--7--&gt;\n&lt;!--5--&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--9--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--15--&gt;\n&lt;!--13--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--20--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------后序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--5--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--9--&gt;\n&lt;!--7--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--13--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--20--&gt;\n&lt;!--15--&gt;\n&lt;!--11--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------最小值---------------&gt;\n&lt;!--3--&gt;\n&lt;!----------------------最大值---------------&gt;\n&lt;!--25--&gt;\n&lt;!----------------------搜索---------------&gt;\n&lt;!--false--&gt;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是树？</h4>\n<p>树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png\" alt> 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。</p>\n<h4>2.二叉树和二叉搜索树</h4>\n<p>二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。</p>\n<h4>3. 手动实现一个BST(二叉搜索树)</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/12121212.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/1111.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/22222222.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/5555555.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/777777.png\" alt></p>\n<pre><code>// BST 二叉搜索树\nclass TreeNode {\n    constructor(key){\n       this.key = key;\n       this.left =null;\n       this.right = null;\n    }\n}\n// 插入节点 辅助函数\nfunction insertNode(node,newNode){\n    if(node.key &gt; newNode.key){\n        if(node.left === null){\n            node.left = newNode\n        }else{\n          insertNode(node.left,newNode)\n        }\n    }else{\n        if(node.right === null){\n            node.right = newNode\n        }else{\n            insertNode(node.right,newNode);\n        }\n    }\n}\n// 中序遍历 辅助函数\nfunction inOrderTraverseNode(node,callback){\n   if(node!== null){\n       inOrderTraverseNode(node.left,callback);\n       callback(node.key);\n       inOrderTraverseNode(node.right,callback);\n   }\n}\n// 先序遍历 辅助函数\nfunction preOrderTraverseNode(node,callback){\n   if(node !==null){\n       callback(node.key);\n       preOrderTraverseNode(node.left,callback);\n       preOrderTraverseNode(node.right,callback);\n   }\n}\n// 后续遍历 辅助函数\nfunction postOrderTraverseNode(node,callback){\n   if(node !== null){\n       postOrderTraverseNode(node.left, callback);\n       postOrderTraverseNode(node.right, callback);\n       callback(node.key);\n   }\n}\n// 最小节点辅助函数\nfunction minNode(node){\n    while(node &amp;&amp; node.left !==null){\n        node = node.left;\n    }\n    return node.key;\n}\n// 最大节点辅助函数\nfunction maxNode(node){\n    while(node &amp;&amp; node.right !==null){\n        node = node.right;\n    }\n    return node.key;\n}\n// 搜索辅助函数\nfunction serachNode(node,key){\n    if(node === null){\n        return false;\n    }else{\n        if(key &lt; node.key){\n            return serachNode(node.left,key);\n        }else if(key &gt; node.key){\n            return serachNode(node.right,key);\n        }else{\n            return true;\n        }\n    }\n}\n// 删除辅助函数\nfunction removeNode(node, key) {\n    if (node === null) {\n        return null;\n    }\n    if (key &lt; node.key) {\n        node.left = removeNode(node.left, key);\n        return node;\n    } else if (key &gt; node.key) {\n        node.right = removeNode(node.right, key);\n        return node;\n    } else { //键等于node.key\n        //第一种情况——一个叶节点\n        if (node.left === null &amp;&amp; node.right === null) {\n            node = null;\n            return node;\n        }\n        //第二种情况——一个只有一个子节点的节点 \n        if (node.left === null) {\n            node = node.right;\n            return node;\n        } else if (node.right === null) {\n            node = node.left;\n            return node;\n        }\n        //第三种情况——一个有两个子节点的节点\n        var aux = findMinNode(node.right);\n        node.key = aux.key; //\n        node.right = removeNode(node.right, aux.key);\n        return node;\n    }\n};\n// callback 辅助函数\nfunction printNode(value){\n   console.log(value);\n}\nclass BinarySearchTree {\n    constructor(){\n        this.root = null;\n    }\n    // 插入几点\n    insert(key){\n        let newNode = new TreeNode(key);\n        if(this.root === null){\n            this.root = newNode;\n        }else{\n            insertNode(this.root,newNode)\n        }\n    }\n    // 中序遍历 callback 对节点操作回掉函数\n    inOrderTraverse(callback){\n        inOrderTraverseNode(this.root, callback);\n    }\n    //先序遍历\n    preOrderTraverse(callback){\n        preOrderTraverseNode(this.root,callback);\n    }\n    // 后序遍历\n    postOrderTraverse(callback){\n       postOrderTraverseNode(this.root,callback);\n    }\n    // 最小值\n    min(){\n        return minNode(this.root);\n    }\n    // 最大值\n    max(){\n        return maxNode(this.root);\n    }\n    // 搜索\n    serarch(key){\n        return serachNode(this.root,key);\n    }\n    // 删除节点\n    remove(key){\n        root = removeNode(root, key);\n    }\n}\n\nvar tree = new BinarySearchTree();\ntree.insert(11);\ntree.insert(7);\ntree.insert(15);\ntree.insert(5);\ntree.insert(3);\ntree.insert(9);\ntree.insert(8);\ntree.insert(10);\ntree.insert(13);\ntree.insert(12);\ntree.insert(14);\ntree.insert(20);\ntree.insert(18);\ntree.insert(25);\ntree.insert(6);\nconsole.log(tree);\nconsole.log('--------------------中序遍历-------------');\nconsole.log(tree.inOrderTraverse(printNode));\nconsole.log('--------------------先序遍历-------------');\nconsole.log(tree.preOrderTraverse(printNode));\nconsole.log('--------------------后序遍历-------------');\nconsole.log(tree.postOrderTraverse(printNode));\nconsole.log('--------------------最小值-------------');\nconsole.log(tree.min());\nconsole.log('--------------------最大值-------------');\nconsole.log(tree.max());\n\nconsole.log('--------------------搜索-------------');\nconsole.log(tree.serarch(100));\n&lt;!----------------------中序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--5--&gt;\n&lt;!--6--&gt;\n&lt;!--7--&gt;\n&lt;!--8--&gt;\n&lt;!--9--&gt;\n&lt;!--10--&gt;\n&lt;!--11--&gt;\n&lt;!--12--&gt;\n&lt;!--13--&gt;\n&lt;!--14--&gt;\n&lt;!--15--&gt;\n&lt;!--18--&gt;\n&lt;!--20--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------先序遍历---------------&gt;\n&lt;!--11--&gt;\n&lt;!--7--&gt;\n&lt;!--5--&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--9--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--15--&gt;\n&lt;!--13--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--20--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------后序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--5--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--9--&gt;\n&lt;!--7--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--13--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--20--&gt;\n&lt;!--15--&gt;\n&lt;!--11--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------最小值---------------&gt;\n&lt;!--3--&gt;\n&lt;!----------------------最大值---------------&gt;\n&lt;!--25--&gt;\n&lt;!----------------------搜索---------------&gt;\n&lt;!--false--&gt;</code></pre>\n"},{"title":"TypeScript 学习第三章 TypeScript基本类型","catalog":true,"date":"2019-08-16T12:07:25.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/item/201508/23/20150823200229_GuUiP.jpeg","_content":"\n# 基础类型\n\nTypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 `boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false\n```\n\n## 数字\n\n和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 20\nlet hexLiteral: number = 0x14\nlet binaryLiteral: number = 0b10100\nlet octalLiteral: number = 0o24\n```\n\n## 字符串\n\nJavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 `string` 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（`\"`）或单引号（`'`）表示字符串。\n\n```typescript\nlet name: string = 'bob'\nname = 'smith'\n```\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ``` ` ```），并且以 `${ expr }` 这种形式嵌入表达式\n\n```typescript\nlet name: string = `Yee`\nlet age: number = 37\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`\n```\n\n这与下面定义 `sentence` 的方式效果相同：\n\n```typescript\nlet sentence: string = 'Hello, my name is ' + name + '.\\n\\n' +\n    'I\\'ll be ' + (age + 1) + ' years old next month.'\n```\n\n## 数组\n\nTypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3]\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3]\n```\n\n## 元祖 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。\n\n```typescript\nlet x: [string, number]\nx = ['hello', 10] // OK\nx = [10, 'hello'] // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)) // OK\nconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法\n```\n\n当访问一个越界的元素，会使用联合类型替代：\n\n```typescript\nx[3] = 'world' // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true // Error, 布尔不是(string | number)类型\n```\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n## 枚举\n\n`enum` 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green\n```\n\n默认情况下，从 `0` 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1` 开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]\n\nconsole.log(colorName)  // 显示'Green'因为上面代码里它的值是2\n```\n\n## any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any` 类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4\nnotSure = 'maybe a string instead'\nnotSure = false // 也可以是个 boolean\n```\n\n在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，`any` 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n```\n\n## void\n\n某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：\n\n```typescript\nfunction warnUser(): void {\n  console.log('This is my warning message')\n}\n\n```\n\n声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`：\n\n```typescript\nlet unusable: void = undefined\n```\n\n## null 和 undefined\n\nTypeScript 里，`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`。 和 `void` 相似，它们的本身的类型用处不是很大：\n\n```typescript\nlet u: undefined = undefined\nlet n: null = null\n```\n\n默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n\n然而，当你指定了 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。 再次说明，稍后我们会介绍联合类型。\n\n## never\n\n`never` 类型表示的是那些永不存在的值的类型。 例如， `never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n\n`never` 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 `never` 的子类型或可以赋值给`never` 类型（除了 `never` 本身之外）。 即使 `any` 也不可以赋值给 `never`。\n\n下面是一些返回 `never` 类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n```\n\n## object\n\n`object` 表示非原始类型，也就是除 `number`，`string`，`boolean`，`symbol`，`null`或`undefined` 之外的类型。\n\n使用 `object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。例如：\n\n```typescript\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // OK\ncreate(null) // OK\n\ncreate(42) // Error\ncreate('string') // Error\ncreate(false) // Error\ncreate(undefined) // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (<string>someValue).length\n```\n\n另一个为 `as` 语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (someValue as string).length\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 `as` 语法断言是被允许的。\n\n\n\n\n","source":"_posts/TypeScript 学习第三章 TypeScript基本类型.md","raw":"---\ntitle: TypeScript 学习第三章 TypeScript基本类型\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-16 20:07:25\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/item/201508/23/20150823200229_GuUiP.jpeg\"\n---\n\n# 基础类型\n\nTypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 `boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false\n```\n\n## 数字\n\n和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 20\nlet hexLiteral: number = 0x14\nlet binaryLiteral: number = 0b10100\nlet octalLiteral: number = 0o24\n```\n\n## 字符串\n\nJavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 `string` 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（`\"`）或单引号（`'`）表示字符串。\n\n```typescript\nlet name: string = 'bob'\nname = 'smith'\n```\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ``` ` ```），并且以 `${ expr }` 这种形式嵌入表达式\n\n```typescript\nlet name: string = `Yee`\nlet age: number = 37\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`\n```\n\n这与下面定义 `sentence` 的方式效果相同：\n\n```typescript\nlet sentence: string = 'Hello, my name is ' + name + '.\\n\\n' +\n    'I\\'ll be ' + (age + 1) + ' years old next month.'\n```\n\n## 数组\n\nTypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3]\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3]\n```\n\n## 元祖 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。\n\n```typescript\nlet x: [string, number]\nx = ['hello', 10] // OK\nx = [10, 'hello'] // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)) // OK\nconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法\n```\n\n当访问一个越界的元素，会使用联合类型替代：\n\n```typescript\nx[3] = 'world' // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true // Error, 布尔不是(string | number)类型\n```\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n## 枚举\n\n`enum` 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green\n```\n\n默认情况下，从 `0` 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1` 开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]\n\nconsole.log(colorName)  // 显示'Green'因为上面代码里它的值是2\n```\n\n## any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any` 类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4\nnotSure = 'maybe a string instead'\nnotSure = false // 也可以是个 boolean\n```\n\n在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，`any` 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n```\n\n## void\n\n某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：\n\n```typescript\nfunction warnUser(): void {\n  console.log('This is my warning message')\n}\n\n```\n\n声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`：\n\n```typescript\nlet unusable: void = undefined\n```\n\n## null 和 undefined\n\nTypeScript 里，`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`。 和 `void` 相似，它们的本身的类型用处不是很大：\n\n```typescript\nlet u: undefined = undefined\nlet n: null = null\n```\n\n默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n\n然而，当你指定了 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。 再次说明，稍后我们会介绍联合类型。\n\n## never\n\n`never` 类型表示的是那些永不存在的值的类型。 例如， `never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n\n`never` 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 `never` 的子类型或可以赋值给`never` 类型（除了 `never` 本身之外）。 即使 `any` 也不可以赋值给 `never`。\n\n下面是一些返回 `never` 类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n```\n\n## object\n\n`object` 表示非原始类型，也就是除 `number`，`string`，`boolean`，`symbol`，`null`或`undefined` 之外的类型。\n\n使用 `object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。例如：\n\n```typescript\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // OK\ncreate(null) // OK\n\ncreate(42) // Error\ncreate('string') // Error\ncreate(false) // Error\ncreate(undefined) // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (<string>someValue).length\n```\n\n另一个为 `as` 语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (someValue as string).length\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 `as` 语法断言是被允许的。\n\n\n\n\n","slug":"TypeScript 学习第三章 TypeScript基本类型","published":1,"updated":"2019-12-31T03:00:25.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj7v006azws6c9u9y553","content":"<h1><span id=\"基础类型\">基础类型</span></h1>\n<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h2><span id=\"布尔值\">布尔值</span></h2>\n<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"数字\">数字</span></h2>\n<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0x14</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b10100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o24</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"字符串\">字符串</span></h2>\n<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">'bob'</span></span><br><span class=\"line\">name = <span class=\"string\">'smith'</span></span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <figure class=\"highlight plain\"><figcaption><span>```），并且以 `$&#123; expr &#125;` 这种形式嵌入表达式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```typescript</span><br><span class=\"line\">let name: string = `Yee`</span><br><span class=\"line\">let age: number = 37</span><br><span class=\"line\">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">I&apos;ll be $&#123; age + 1 &#125; years old next month.`</span><br></pre></td></tr></table></figure></p>\n<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.\\n\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'I\\'ll be '</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">' years old next month.'</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"数组\">数组</span></h2>\n<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h2><span id=\"元祖-tuple\">元祖 Tuple</span></h2>\n<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\">x = [<span class=\"string\">'hello'</span>, <span class=\"number\">10</span>] <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">'hello'</span>] <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">'world'</span> <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()) <span class=\"comment\">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h2><span id=\"枚举\">枚举</span></h2>\n<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName)  <span class=\"comment\">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"any\">any</span></h2>\n<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span></span><br><span class=\"line\">notSure = <span class=\"string\">'maybe a string instead'</span></span><br><span class=\"line\">notSure = <span class=\"literal\">false</span> <span class=\"comment\">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">'free'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"void\">void</span></h2>\n<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is my warning message'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"null-和-undefined\">null 和 undefined</span></h2>\n<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>\n<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>\n<h2><span id=\"never\">never</span></h2>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>\n<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n<p>下面是一些返回 <code>never</code> 类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"object\">object</span></h2>\n<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>\n<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: object | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">&#123; prop: 0 &#125;</span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">null</span></span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">42</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">'<span class=\"built_in\">string</span>'</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">false</span></span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">undefined</span></span>) // <span class=\"title\">Error</span></span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"类型断言\">类型断言</span></h2>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure>\n<p>另一个为 <code>as</code> 语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>基础类型</h1>\n<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h2>布尔值</h2>\n<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2>数字</h2>\n<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0x14</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b10100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o24</span></span><br></pre></td></tr></table></figure>\n<h2>字符串</h2>\n<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">'bob'</span></span><br><span class=\"line\">name = <span class=\"string\">'smith'</span></span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <figure class=\"highlight plain\"><figcaption><span>```），并且以 `$&#123; expr &#125;` 这种形式嵌入表达式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```typescript</span><br><span class=\"line\">let name: string = `Yee`</span><br><span class=\"line\">let age: number = 37</span><br><span class=\"line\">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">I&apos;ll be $&#123; age + 1 &#125; years old next month.`</span><br></pre></td></tr></table></figure></p>\n<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.\\n\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'I\\'ll be '</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">' years old next month.'</span></span><br></pre></td></tr></table></figure>\n<h2>数组</h2>\n<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h2>元祖 Tuple</h2>\n<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\">x = [<span class=\"string\">'hello'</span>, <span class=\"number\">10</span>] <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">'hello'</span>] <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">'world'</span> <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()) <span class=\"comment\">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h2>枚举</h2>\n<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName)  <span class=\"comment\">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h2>any</h2>\n<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span></span><br><span class=\"line\">notSure = <span class=\"string\">'maybe a string instead'</span></span><br><span class=\"line\">notSure = <span class=\"literal\">false</span> <span class=\"comment\">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">'free'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2>void</h2>\n<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is my warning message'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h2>null 和 undefined</h2>\n<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>\n<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>\n<h2>never</h2>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>\n<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n<p>下面是一些返回 <code>never</code> 类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>object</h2>\n<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>\n<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: object | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">&#123; prop: 0 &#125;</span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">null</span></span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">42</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">'<span class=\"built_in\">string</span>'</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">false</span></span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">undefined</span></span>) // <span class=\"title\">Error</span></span></span><br></pre></td></tr></table></figure>\n<h2>类型断言</h2>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure>\n<p>另一个为 <code>as</code> 语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>\n"},{"title":"TypeScript 学习第九章 TypeScript泛型","catalog":true,"date":"2019-08-22T10:54:42.000Z","subtitle":null,"header-img":"http://attach.bbs.miui.com/forum/201408/22/105929p5qdodm5qm4mfjf6.jpg","_content":"\n# 泛型\n\n软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n## 基础示例\n\n下面来创建第一个使用泛型的例子：`identity` 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 `echo` 命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\n```typescript\nfunction identity(arg: number): number {\n  return arg\n}\n```\n\n或者，我们使用 `any` 类型来定义函数：\n\n```typescript\nfunction identity(arg: any): any {\n  return arg\n}\n```\n\n使用 `any` 类型会导致这个函数可以接收任何类型的 `arg` 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了*类型变量*，它是一种特殊的变量，只用于表示类型而不是值。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n我们给 `identity` 添加了类型变量 `T`。 `T` 帮助我们捕获用户传入的类型（比如：`number`），之后我们就可以使用这个类型。 之后我们再次使用了 `T` 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的 `identity` 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 `any`，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\n```typescript\nlet output = identity<string>('myString')\n```\n\n这里我们明确的指定了 `T` 是 `string` 类型，并做为一个参数传给函数，使用了 `<>` 括起来而不是 `()`。\n\n第二种方法更普遍。利用了*类型推论* -- 即编译器会根据传入的参数自动地帮助我们确定 `T` 的类型：\n\n```typescript\nlet output = identity('myString')\n```\n\n注意我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看 `myString` 的值，然后把 `T` 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 `T` 的类型，在一些复杂的情况下，这是可能出现的。\n\n## 使用泛型变量\n\n使用泛型创建像 `identity` 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前 `identity` 例子：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n如果我们想打印出 `arg` 的长度。 我们很可能会这样做：\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n如果这么做，编译器会报错说我们使用了 `arg` 的 `.length` 属性，但是没有地方指明 `arg` 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 `.length` 属性的。\n\n现在假设我们想操作 `T` 类型的数组而不直接是 `T`。由于我们操作的是数组，所以 `.length` 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length)\n  return arg\n}\n```\n\n你可以这样理解 `loggingIdentity` 的类型：泛型函数 `loggingIdentity`，接收类型参数 `T` 和参数 `arg`，它是个元素类型是 `T` 的数组，并返回元素类型是`T` 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 `T` 的的类型为 `number`。 这可以让我们把泛型变量 `T` 当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n\n## 泛型类型\n\n上一节，我们创建了 `identity` 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <T>(arg: T) => T = identity\n```\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <U>(arg: U) => U = identity\n```\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity\n```\n\n这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n  <T>(arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn = identity\n```\n\n我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： `Dictionary<string>` 而不只是` Dictionary`）。这样接口里的其它成员也能知道这个参数的类型了。\n\n\n```typescript\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity\n```\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 `GenericIdentityFn` 的时候，还得传入一个类型参数来指定泛型类型（这里是：`number`），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n## 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（ `<>`）括起泛型类型，跟在类名后面。\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T\n  add: (x: T, y: T) => T\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function(x, y) {\n  return x + y \n}\n```\n\n`GenericNumber` 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 `number` 类型。 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>()\nstringNumeric.zeroValue = ''\nstringNumeric.add = function(x, y) { \n  return x + y\n}\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))\n```\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在[类](/chapter2/class)那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n## 泛型约束\n\n我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 `loggingIdentity` 例子中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 `length` 属性，所以就报错了。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n相比于操作 `any` 所有类型，我们想要限制函数去处理任意带有 `.length` 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 `T` 的约束要求。\n\n我们定义一个接口来描述约束条件，创建一个包含 `.length` 属性的接口，使用这个接口和 `extends` 关键字来实现约束：\n\n```typescript\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length) // OK\n  return arg\n}\n```\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\n```typescript\nloggingIdentity(3);  // Error\n```\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\n```typescript\nloggingIdentity({length: 10, value: 3}) // OK\n```\n\n### 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 `obj` 上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T> (obj: T, key: K ) {\n  return obj[key]\n}\n\nlet x = {a: 1, b: 2, c: 3, d: 4}\n\ngetProperty(x, 'a') // okay\ngetProperty(x, 'm') // error\n```\n\n","source":"_posts/TypeScript 学习第九章 TypeScript泛型.md","raw":"---\ntitle: TypeScript 学习第九章 TypeScript泛型\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-22 18:54:42\nsubtitle:\nheader-img: \"http://attach.bbs.miui.com/forum/201408/22/105929p5qdodm5qm4mfjf6.jpg\"\n---\n\n# 泛型\n\n软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n## 基础示例\n\n下面来创建第一个使用泛型的例子：`identity` 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 `echo` 命令。\n\n不用泛型的话，这个函数可能是下面这样：\n\n```typescript\nfunction identity(arg: number): number {\n  return arg\n}\n```\n\n或者，我们使用 `any` 类型来定义函数：\n\n```typescript\nfunction identity(arg: any): any {\n  return arg\n}\n```\n\n使用 `any` 类型会导致这个函数可以接收任何类型的 `arg` 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。\n\n因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了*类型变量*，它是一种特殊的变量，只用于表示类型而不是值。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n我们给 `identity` 添加了类型变量 `T`。 `T` 帮助我们捕获用户传入的类型（比如：`number`），之后我们就可以使用这个类型。 之后我们再次使用了 `T` 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。\n\n我们把这个版本的 `identity` 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 `any`，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n\n我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：\n\n```typescript\nlet output = identity<string>('myString')\n```\n\n这里我们明确的指定了 `T` 是 `string` 类型，并做为一个参数传给函数，使用了 `<>` 括起来而不是 `()`。\n\n第二种方法更普遍。利用了*类型推论* -- 即编译器会根据传入的参数自动地帮助我们确定 `T` 的类型：\n\n```typescript\nlet output = identity('myString')\n```\n\n注意我们没必要使用尖括号（`<>`）来明确地传入类型；编译器可以查看 `myString` 的值，然后把 `T` 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 `T` 的类型，在一些复杂的情况下，这是可能出现的。\n\n## 使用泛型变量\n\n使用泛型创建像 `identity` 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。\n\n看下之前 `identity` 例子：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n```\n\n如果我们想打印出 `arg` 的长度。 我们很可能会这样做：\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n如果这么做，编译器会报错说我们使用了 `arg` 的 `.length` 属性，但是没有地方指明 `arg` 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 `.length` 属性的。\n\n现在假设我们想操作 `T` 类型的数组而不直接是 `T`。由于我们操作的是数组，所以 `.length` 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length)\n  return arg\n}\n```\n\n你可以这样理解 `loggingIdentity` 的类型：泛型函数 `loggingIdentity`，接收类型参数 `T` 和参数 `arg`，它是个元素类型是 `T` 的数组，并返回元素类型是`T` 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 `T` 的的类型为 `number`。 这可以让我们把泛型变量 `T` 当做类型的一部分使用，而不是整个类型，增加了灵活性。\n\n\n## 泛型类型\n\n上一节，我们创建了 `identity` 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。\n\n泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <T>(arg: T) => T = identity\n```\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: <U>(arg: U) => U = identity\n```\n\n我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: {<T>(arg: T): T} = identity\n```\n\n这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n  <T>(arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn = identity\n```\n\n我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： `Dictionary<string>` 而不只是` Dictionary`）。这样接口里的其它成员也能知道这个参数的类型了。\n\n\n```typescript\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity\n```\n\n注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 `GenericIdentityFn` 的时候，还得传入一个类型参数来指定泛型类型（这里是：`number`），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。\n\n除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。\n\n## 泛型类\n\n泛型类看上去与泛型接口差不多。 泛型类使用（ `<>`）括起泛型类型，跟在类名后面。\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T\n  add: (x: T, y: T) => T\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function(x, y) {\n  return x + y \n}\n```\n\n`GenericNumber` 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 `number` 类型。 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>()\nstringNumeric.zeroValue = ''\nstringNumeric.add = function(x, y) { \n  return x + y\n}\n\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, 'test'))\n```\n\n与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n我们在[类](/chapter2/class)那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n## 泛型约束\n\n我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 `loggingIdentity` 例子中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 `length` 属性，所以就报错了。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length)\n  return arg\n}\n```\n\n相比于操作 `any` 所有类型，我们想要限制函数去处理任意带有 `.length` 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 `T` 的约束要求。\n\n我们定义一个接口来描述约束条件，创建一个包含 `.length` 属性的接口，使用这个接口和 `extends` 关键字来实现约束：\n\n```typescript\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length) // OK\n  return arg\n}\n```\n\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n\n```typescript\nloggingIdentity(3);  // Error\n```\n\n我们需要传入符合约束类型的值，必须包含必须的属性：\n\n```typescript\nloggingIdentity({length: 10, value: 3}) // OK\n```\n\n### 在泛型约束中使用类型参数\n\n你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 `obj` 上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T> (obj: T, key: K ) {\n  return obj[key]\n}\n\nlet x = {a: 1, b: 2, c: 3, d: 4}\n\ngetProperty(x, 'a') // okay\ngetProperty(x, 'm') // error\n```\n\n","slug":"TypeScript 学习第九章 TypeScript泛型","published":1,"updated":"2019-12-31T03:00:25.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj7w006czws6kp32hw7p","content":"<h1><span id=\"泛型\">泛型</span></h1>\n<p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>\n<p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>\n<h2><span id=\"基础示例\">基础示例</span></h2>\n<p>下面来创建第一个使用泛型的例子：<code>identity</code> 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code> 命令。</p>\n<p>不用泛型的话，这个函数可能是下面这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者，我们使用 <code>any</code> 类型来定义函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 <code>arg</code> 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>\n<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了<em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们给 <code>identity</code> 添加了类型变量 <code>T</code>。 <code>T</code> 帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code> 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。</p>\n<p>我们把这个版本的 <code>identity</code> 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>\n<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>这里我们明确的指定了 <code>T</code> 是 <code>string</code> 类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code> 括起来而不是 <code>()</code>。</p>\n<p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code> 的值，然后把 <code>T</code> 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code> 的类型，在一些复杂的情况下，这是可能出现的。</p>\n<h2><span id=\"使用泛型变量\">使用泛型变量</span></h2>\n<p>使用泛型创建像 <code>identity</code> 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>\n<p>看下之前 <code>identity</code> 例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想打印出 <code>arg</code> 的长度。 我们很可能会这样做：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这么做，编译器会报错说我们使用了 <code>arg</code> 的 <code>.length</code> 属性，但是没有地方指明 <code>arg</code> 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code> 属性的。</p>\n<p>现在假设我们想操作 <code>T</code> 类型的数组而不直接是 <code>T</code>。由于我们操作的是数组，所以 <code>.length</code> 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T[]</span>): <span class=\"title\">T</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以这样理解 <code>loggingIdentity</code> 的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code> 和参数 <code>arg</code>，它是个元素类型是 <code>T</code> 的数组，并返回元素类型是<code>T</code> 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code> 的的类型为 <code>number</code>。 这可以让我们把泛型变量 <code>T</code> 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>\n<h2><span id=\"泛型类型\">泛型类型</span></h2>\n<p>上一节，我们创建了 <code>identity</code> 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>\n<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;T&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></table></figure>\n<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;U&gt;<span class=\"function\">(<span class=\"params\">arg: U</span>) =&gt;</span> U = identity</span><br></pre></td></tr></table></figure>\n<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity</span><br></pre></td></tr></table></figure>\n<p>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn &#123;</span><br><span class=\"line\">  &lt;T&gt;(arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></table></figure>\n<p>我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是<code>Dictionary</code>）。这样接口里的其它成员也能知道这个参数的类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class=\"line\">  (arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn&lt;<span class=\"built_in\">number</span>&gt; = identity</span><br></pre></td></tr></table></figure>\n<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>\n<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>\n<h2><span id=\"泛型类\">泛型类</span></h2>\n<p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class=\"line\">  zeroValue: T</span><br><span class=\"line\">  add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">number</span>&gt;()</span><br><span class=\"line\">myGenericNumber.zeroValue = <span class=\"number\">0</span></span><br><span class=\"line\">myGenericNumber.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>GenericNumber</code> 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 <code>number</code> 类型。 也可以使用字符串或其它更复杂的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">string</span>&gt;()</span><br><span class=\"line\">stringNumeric.zeroValue = <span class=\"string\">''</span></span><br><span class=\"line\">stringNumeric.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class=\"string\">'test'</span>))</span><br></pre></td></tr></table></figure>\n<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>\n<p>我们在<a href=\"/chapter2/class\">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>\n<h2><span id=\"泛型约束\">泛型约束</span></h2>\n<p>我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 <code>length</code> 属性，所以就报错了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p>\n<p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lengthwise &#123;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Lengthwise</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length) <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(<span class=\"number\">3</span>);  <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(&#123;length: <span class=\"number\">10</span>, value: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"在泛型约束中使用类型参数\">在泛型约束中使用类型参数</span></h3>\n<p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt; (<span class=\"params\">obj: T, key: K </span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123;a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span>, d: <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'a'</span>) <span class=\"comment\">// okay</span></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'m'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>泛型</h1>\n<p>软件工程中，我们不仅要创建定义良好且一致的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>\n<p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>\n<h2>基础示例</h2>\n<p>下面来创建第一个使用泛型的例子：<code>identity</code> 函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code> 命令。</p>\n<p>不用泛型的话，这个函数可能是下面这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者，我们使用 <code>any</code> 类型来定义函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 <code>any</code> 类型会导致这个函数可以接收任何类型的 <code>arg</code> 参数，但是这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>\n<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。这里，我们使用了<em>类型变量</em>，它是一种特殊的变量，只用于表示类型而不是值。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们给 <code>identity</code> 添加了类型变量 <code>T</code>。 <code>T</code> 帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了 <code>T</code> 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。</p>\n<p>我们把这个版本的 <code>identity</code> 函数叫做泛型，因为它可以适用于多个类型。 不同于使用 <code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>\n<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>这里我们明确的指定了 <code>T</code> 是 <code>string</code> 类型，并做为一个参数传给函数，使用了 <code>&lt;&gt;</code> 括起来而不是 <code>()</code>。</p>\n<p>第二种方法更普遍。利用了<em>类型推论</em> – 即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity(<span class=\"string\">'myString'</span>)</span><br></pre></td></tr></table></figure>\n<p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看 <code>myString</code> 的值，然后把 <code>T</code> 设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入 <code>T</code> 的类型，在一些复杂的情况下，这是可能出现的。</p>\n<h2>使用泛型变量</h2>\n<p>使用泛型创建像 <code>identity</code> 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>\n<p>看下之前 <code>identity</code> 例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果我们想打印出 <code>arg</code> 的长度。 我们很可能会这样做：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果这么做，编译器会报错说我们使用了 <code>arg</code> 的 <code>.length</code> 属性，但是没有地方指明 <code>arg</code> 具有这个属性。记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code> 属性的。</p>\n<p>现在假设我们想操作 <code>T</code> 类型的数组而不直接是 <code>T</code>。由于我们操作的是数组，所以 <code>.length</code> 属性是应该存在的。我们可以像创建其它数组一样创建这个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T[]</span>): <span class=\"title\">T</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以这样理解 <code>loggingIdentity</code> 的类型：泛型函数 <code>loggingIdentity</code>，接收类型参数 <code>T</code> 和参数 <code>arg</code>，它是个元素类型是 <code>T</code> 的数组，并返回元素类型是<code>T</code> 的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code> 的的类型为 <code>number</code>。 这可以让我们把泛型变量 <code>T</code> 当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>\n<h2>泛型类型</h2>\n<p>上一节，我们创建了 <code>identity</code> 通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>\n<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;T&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></table></figure>\n<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;U&gt;<span class=\"function\">(<span class=\"params\">arg: U</span>) =&gt;</span> U = identity</span><br></pre></td></tr></table></figure>\n<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity</span><br></pre></td></tr></table></figure>\n<p>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn &#123;</span><br><span class=\"line\">  &lt;T&gt;(arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></table></figure>\n<p>我们甚至可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;</code> 而不只是<code>Dictionary</code>）。这样接口里的其它成员也能知道这个参数的类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class=\"line\">  (arg: T): T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: GenericIdentityFn&lt;<span class=\"built_in\">number</span>&gt; = identity</span><br></pre></td></tr></table></figure>\n<p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>\n<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>\n<h2>泛型类</h2>\n<p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class=\"line\">  zeroValue: T</span><br><span class=\"line\">  add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">number</span>&gt;()</span><br><span class=\"line\">myGenericNumber.zeroValue = <span class=\"number\">0</span></span><br><span class=\"line\">myGenericNumber.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>GenericNumber</code> 类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用 <code>number</code> 类型。 也可以使用字符串或其它更复杂的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">string</span>&gt;()</span><br><span class=\"line\">stringNumeric.zeroValue = <span class=\"string\">''</span></span><br><span class=\"line\">stringNumeric.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class=\"string\">'test'</span>))</span><br></pre></td></tr></table></figure>\n<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>\n<p>我们在<a href=\"/chapter2/class\">类</a>那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>\n<h2>泛型约束</h2>\n<p>我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 <code>length</code> 属性，所以就报错了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p>\n<p>我们定义一个接口来描述约束条件，创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lengthwise &#123;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Lengthwise</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length) <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(<span class=\"number\">3</span>);  <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(&#123;length: <span class=\"number\">10</span>, value: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<h3>在泛型约束中使用类型参数</h3>\n<p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt; (<span class=\"params\">obj: T, key: K </span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123;a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>, c: <span class=\"number\">3</span>, d: <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'a'</span>) <span class=\"comment\">// okay</span></span><br><span class=\"line\">getProperty(x, <span class=\"string\">'m'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n"},{"title":"TypeScript 学习第七章 TypeScript 变量声明","catalog":true,"date":"2019-08-20T03:49:52.000Z","subtitle":null,"header-img":"http://www.downxia.com/uploadfiles/2015/1007/20151007031916598.jpg","_content":"\n# 变量声明\n\n`let` 和 `const` 是 JavaScript 里相对较新的变量声明方式。`let` 在很多方面与 `var` 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。`const` 是对 `let` 的一个增强，它能阻止对一个变量再次赋值。\n\n因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 `let` 和 `const`。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 `var`。\n\n 如果你已经对 `var` 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n## var 声明\n\n在 ES5 的时代，我们都是通过 `var` 关键字定义JavaScript 变量：\n\n```javascript\nvar a = 10\n```\n\n大家都能理解，这里定义了一个名为 `a` 值为 `10` 的变量。\n\n我们也可以在函数内部定义变量：\n\n```javascript\nfunction f() {\n  var message = 'Hello World!'\n\n  return message\n}\n```\n\n并且我们也可以在其它函数内部访问相同的变量：\n\n```javascript\nfunction f() {\n  var a = 10\n  return function g() {\n    var b = a + 1\n    return b\n  }\n}\n\nvar g = f()\ng() // returns 11\n```\n\n上面的例子是一个典型的闭包场景，`g` 可以获取到 `f` 函数里定义的 `a` 变量。 每当 `g` 被调用时，它都可以访问到 `f` 里的 `a` 变量。 即使当 `g` 在 `f` 已经执行完后才被调用，它仍然可以访问 `a`。\n\n### 作用域规则\n\n`var` 声明有些奇怪的作用域规则。 看下面的例子：\n\n```javascript\nfunction f(shouldInitialize) {\n  if (shouldInitialize) {\n    var x = 10\n  }\n\n  return x\n}\n\nf(true)  // returns '10'\nf(false) // returns 'undefined'\n```\n\n有些同学可能要多看几遍这个例子。 变量 `x` 是定义在 `if` 语句里面，但是我们却可以在语句的外面访问它。 这是因为 `var` 声明的作用域是函数作用域，函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```javascript\nfunction sumMatrix(matrix) {\n  var sum = 0\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i]\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n  \n  return sum\n}\n```\n\n这里很容易看出一些问题，里层的 `for` 循环会覆盖变量 `i`，因为所有 `i` 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 捕获变量怪异之处\n\n猜一下下面的代码会返回什么：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n答案是，`setTimeout` 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：\n\n``` javascript\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n> 我们传给 `setTimeout` 的每一个函数表达式实际上都引用了相同作用域里的同一个 `i`。\n\n让我们花点时间思考一下这是为什么。 `setTimeout` 在若干毫秒后执行一个函数，并且是在 `for` 循环结束后。`for` 循环结束后，`i` 的值为 `10`。 所以当函数被调用的时候，它会打印出 `10`。\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 `i` 的值：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i)\n    }, 100 * i)\n  })(i)\n}\n```\n\n这种奇怪的形式我们已经司空见惯了。 参数 `i` 会覆盖 `for` 循环里的 `i`，但是因为我们起了同样的名字，所以我们不用怎么改 `for` 循环体里的代码。\n\n## let 声明\n\n现在你已经知道了 `var` 存在一些问题，这恰好说明了为什么用 `let` 语句来声明变量。 除了名字不同外， `let` 与 `var` 的写法一致：\n\n```javascript\nlet hello = 'Hello!'\n```\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 块作用域\n\n当用 `let` 声明一个变量，它使用的是块作用域。 不同于使用 `var` 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 `for` 循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n  let a = 100\n\n  if (input) {\n    // OK: 仍然能访问到 a\n    let b = a + 1\n    return b\n  }\n\n  // Error: 'b' 在这里不存在\n  return b\n}\n```\n\n这里我们定义了 2 个变量 `a` 和 `b`。 `a` 的作用域是 `f` 函数体内，而 `b` 的作用域是 `if` 语句块里。\n\n在 `catch` 语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n  throw 'Oh no!';\n}\ncatch (e) {\n  console.log('Catch it.')\n}\n\n// Error: 'e' 在这里不存在\nconsole.log(e)\n```\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于*暂时性死区*。 它只是用来说明我们不能在 `let` 语句之前访问它们，幸运的是 `TypeScript` 可以告诉我们这些信息。\n\n```typescript\na++ // TS2448: Block-scoped variable 'a' used before its declaration.\nlet a\n```\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。\n\n```typescript\nfunction foo() {\n  // okay to capture 'a'\n  return a\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo()\n\nlet a\n```\n\n关于*暂时性死区*的更多信息，查看这里 [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)。\n\n\n### 重定义及屏蔽\n\n我们提过使用 `var` 声明时，它不在乎你声明多少次；你只会得到 1 个。\n\n```javascript\nfunction f(x) {\n  var x\n  var x\n\n  if (true) {\n    var x\n  }\n}\n```\n\n在上面的例子里，所有 `x` 的声明实际上都引用一个相同的`x`，并且这是完全有效的代码，但这经常会成为 `bug` 的来源。幸运的是 `let` 的声明就不会这么宽松了。\n\n```typescript\nlet x = 10\nlet x = 20 // 错误，不能在 1 个作用域里多次声明 x\n```\n\n并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n  let x = 100 // Error: 干扰参数声明\n}\n\nfunction g() {\n  let x = 100\n  var x = 100 // Error: 不能同时具有 x 的两个声明\n}\n```\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100\n    return x\n  }\n\n  return x\n}\n\nf(false, 0) // returns 0\nf(true, 0)  // returns 100\n```\n\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 `let` 重写之前的 `sumMatrix` 函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0\n  for (let i = 0; i < matrix.length; i++) {\n    let currentRow = matrix[i]\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n\n  return sum\n}\n```\n\n这个版本的循环能得到正确的结果，因为内层循环的 `i` 可以屏蔽掉外层循环的 `i`。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。\n\n### 块级作用域变量的获取\n\n每次进入一个作用域时，`let` 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n回想一下前面 `setTimeout` 的例子，我们最后需要使用立即执行的函数表达式来获取每次 `for` 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 `TypeScript` 里这样做了。\n\n当 `let` 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 `setTimeout` 例子里我们仅使用 `let` 声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10 ; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n会输出与预料一致的结果：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n## const 声明\n\n`const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9\n```\n\n它们与 `let` 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 `let` 相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n\n```typescript\nconst numLivesForCat = 9\nconst kitty = {\n  name: 'Kitty',\n  numLives: numLivesForCat\n}\n\n// Error\nkitty = {\n  name: 'Tommy',\n  numLives: numLivesForCat\n};\n\n// OK\nkitty.name = 'Jerry'\nkitty.numLives--\n```\n\n除非你使用特殊的方法去避免，实际上 `const` 变量的内部状态是可修改的。 幸运的是，`TypeScript` 允许你将对象的成员设置成只读的。接口一章有详细说明。\n\n## let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用 `const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 `const` 也可以让我们更容易的推测数据的流动。\n\n## 解构\n\n### 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2]\nlet [first, second] = input\nconsole.log(first) // outputs 1\nconsole.log(second) // outputs 2\n```\n\n这创建了 2 个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nlet first = input[0]\nlet second = input[1]\n```\n\n作用于函数参数：\n\n```typescript\nlet input: [number, number] = [1, 2]\n\nfunction f([first, second]: [number, number]) {\n  console.log(first)\n  console.log(second)\n}\n\nf(input)\n```\n\n你可以在数组里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\nconsole.log(rest) // outputs [ 2, 3, 4 ]\n```\n\n你也可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\n```\n\n或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4]\n```\n\n### 对象解构\n\n你也可以解构对象：\n\n```typescript\nlet o = {\n    a: 'foo',\n    b: 12,\n    c: 'bar'\n}\nlet { a, b } = o\n\n```\n\n这通过 `o.a` 和 `o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n\n你可以在对象里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o\nlet total = passthrough.b + passthrough.c.length\n```\n\n### 属性重命名\n\n你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o\n```\n\n这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 `\"a 作为 newName1\"`。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a\nlet newName2 = o.b\n```\n\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。\n\n```typescript\nlet {a, b}: {a: string, b: number} = o\n```\n\n### 默认值\n\n默认值可以让你在属性为 `undefined` 时使用缺省值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n  let { a, b = 1001 } = wholeObject\n}\n```\n\n现在，即使 `b` 为 `undefined` ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n### 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a = '', b = 0 } = {}): void {\n  // ...\n}\nf()\n```\n\n> 上面的代码是一个类型推断的例子，将在后续章节介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: '' }): void {\n  // ...\n}\nf({ a: 'yes' }) // OK, 默认 b = 0\nf() // OK, 默认 a: '', b = 0\nf({}) // Error, 一旦传入参数则 a 是必须的\n```\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。\n\n## 展开\n\n```typescript\nlet first = [1, 2]\nlet second = [3, 4]\nlet bothPlus = [0, ...first, ...second, 5]\n```\n这会令 `bothPlus` 的值为 `[0, 1, 2, 3, 4, 5]`。 展开操作创建了 `first` 和 `second的` 一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { ...defaults, food: 'rich' }\n```\n\nsearch的值为 `{ food: 'rich', price: '$10', ambiance: 'noisy' }`。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { food: 'rich', ...defaults }\n```\n\n那么，`defaults` 里的 `food` 属性会重写 `food: 'rich'`，在这里这并不是我们想要的结果。\n","source":"_posts/TypeScript 学习第七章 TypeScript变量声明.md","raw":"---\ntitle: TypeScript 学习第七章 TypeScript 变量声明\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-20 11:49:52\nsubtitle:\nheader-img: \"http://www.downxia.com/uploadfiles/2015/1007/20151007031916598.jpg\"\n---\n\n# 变量声明\n\n`let` 和 `const` 是 JavaScript 里相对较新的变量声明方式。`let` 在很多方面与 `var` 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。`const` 是对 `let` 的一个增强，它能阻止对一个变量再次赋值。\n\n因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 `let` 和 `const`。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 `var`。\n\n 如果你已经对 `var` 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n## var 声明\n\n在 ES5 的时代，我们都是通过 `var` 关键字定义JavaScript 变量：\n\n```javascript\nvar a = 10\n```\n\n大家都能理解，这里定义了一个名为 `a` 值为 `10` 的变量。\n\n我们也可以在函数内部定义变量：\n\n```javascript\nfunction f() {\n  var message = 'Hello World!'\n\n  return message\n}\n```\n\n并且我们也可以在其它函数内部访问相同的变量：\n\n```javascript\nfunction f() {\n  var a = 10\n  return function g() {\n    var b = a + 1\n    return b\n  }\n}\n\nvar g = f()\ng() // returns 11\n```\n\n上面的例子是一个典型的闭包场景，`g` 可以获取到 `f` 函数里定义的 `a` 变量。 每当 `g` 被调用时，它都可以访问到 `f` 里的 `a` 变量。 即使当 `g` 在 `f` 已经执行完后才被调用，它仍然可以访问 `a`。\n\n### 作用域规则\n\n`var` 声明有些奇怪的作用域规则。 看下面的例子：\n\n```javascript\nfunction f(shouldInitialize) {\n  if (shouldInitialize) {\n    var x = 10\n  }\n\n  return x\n}\n\nf(true)  // returns '10'\nf(false) // returns 'undefined'\n```\n\n有些同学可能要多看几遍这个例子。 变量 `x` 是定义在 `if` 语句里面，但是我们却可以在语句的外面访问它。 这是因为 `var` 声明的作用域是函数作用域，函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```javascript\nfunction sumMatrix(matrix) {\n  var sum = 0\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i]\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n  \n  return sum\n}\n```\n\n这里很容易看出一些问题，里层的 `for` 循环会覆盖变量 `i`，因为所有 `i` 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 捕获变量怪异之处\n\n猜一下下面的代码会返回什么：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n答案是，`setTimeout` 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：\n\n``` javascript\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n\n很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n\n> 我们传给 `setTimeout` 的每一个函数表达式实际上都引用了相同作用域里的同一个 `i`。\n\n让我们花点时间思考一下这是为什么。 `setTimeout` 在若干毫秒后执行一个函数，并且是在 `for` 循环结束后。`for` 循环结束后，`i` 的值为 `10`。 所以当函数被调用的时候，它会打印出 `10`。\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 `i` 的值：\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  (function(i) {\n    setTimeout(function() {\n      console.log(i)\n    }, 100 * i)\n  })(i)\n}\n```\n\n这种奇怪的形式我们已经司空见惯了。 参数 `i` 会覆盖 `for` 循环里的 `i`，但是因为我们起了同样的名字，所以我们不用怎么改 `for` 循环体里的代码。\n\n## let 声明\n\n现在你已经知道了 `var` 存在一些问题，这恰好说明了为什么用 `let` 语句来声明变量。 除了名字不同外， `let` 与 `var` 的写法一致：\n\n```javascript\nlet hello = 'Hello!'\n```\n\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 块作用域\n\n当用 `let` 声明一个变量，它使用的是块作用域。 不同于使用 `var` 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 `for` 循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n  let a = 100\n\n  if (input) {\n    // OK: 仍然能访问到 a\n    let b = a + 1\n    return b\n  }\n\n  // Error: 'b' 在这里不存在\n  return b\n}\n```\n\n这里我们定义了 2 个变量 `a` 和 `b`。 `a` 的作用域是 `f` 函数体内，而 `b` 的作用域是 `if` 语句块里。\n\n在 `catch` 语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n  throw 'Oh no!';\n}\ncatch (e) {\n  console.log('Catch it.')\n}\n\n// Error: 'e' 在这里不存在\nconsole.log(e)\n```\n\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于*暂时性死区*。 它只是用来说明我们不能在 `let` 语句之前访问它们，幸运的是 `TypeScript` 可以告诉我们这些信息。\n\n```typescript\na++ // TS2448: Block-scoped variable 'a' used before its declaration.\nlet a\n```\n\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。\n\n```typescript\nfunction foo() {\n  // okay to capture 'a'\n  return a\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo()\n\nlet a\n```\n\n关于*暂时性死区*的更多信息，查看这里 [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)。\n\n\n### 重定义及屏蔽\n\n我们提过使用 `var` 声明时，它不在乎你声明多少次；你只会得到 1 个。\n\n```javascript\nfunction f(x) {\n  var x\n  var x\n\n  if (true) {\n    var x\n  }\n}\n```\n\n在上面的例子里，所有 `x` 的声明实际上都引用一个相同的`x`，并且这是完全有效的代码，但这经常会成为 `bug` 的来源。幸运的是 `let` 的声明就不会这么宽松了。\n\n```typescript\nlet x = 10\nlet x = 20 // 错误，不能在 1 个作用域里多次声明 x\n```\n\n并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n  let x = 100 // Error: 干扰参数声明\n}\n\nfunction g() {\n  let x = 100\n  var x = 100 // Error: 不能同时具有 x 的两个声明\n}\n```\n\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100\n    return x\n  }\n\n  return x\n}\n\nf(false, 0) // returns 0\nf(true, 0)  // returns 100\n```\n\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 `let` 重写之前的 `sumMatrix` 函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0\n  for (let i = 0; i < matrix.length; i++) {\n    let currentRow = matrix[i]\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i]\n    }\n  }\n\n  return sum\n}\n```\n\n这个版本的循环能得到正确的结果，因为内层循环的 `i` 可以屏蔽掉外层循环的 `i`。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。\n\n### 块级作用域变量的获取\n\n每次进入一个作用域时，`let` 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n回想一下前面 `setTimeout` 的例子，我们最后需要使用立即执行的函数表达式来获取每次 `for` 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 `TypeScript` 里这样做了。\n\n当 `let` 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 `setTimeout` 例子里我们仅使用 `let` 声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10 ; i++) {\n  setTimeout(function() {\n    console.log(i)\n  }, 100 * i)\n}\n```\n\n会输出与预料一致的结果：\n\n```javascript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n## const 声明\n\n`const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9\n```\n\n它们与 `let` 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 `let` 相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n\n```typescript\nconst numLivesForCat = 9\nconst kitty = {\n  name: 'Kitty',\n  numLives: numLivesForCat\n}\n\n// Error\nkitty = {\n  name: 'Tommy',\n  numLives: numLivesForCat\n};\n\n// OK\nkitty.name = 'Jerry'\nkitty.numLives--\n```\n\n除非你使用特殊的方法去避免，实际上 `const` 变量的内部状态是可修改的。 幸运的是，`TypeScript` 允许你将对象的成员设置成只读的。接口一章有详细说明。\n\n## let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用 `const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 `const` 也可以让我们更容易的推测数据的流动。\n\n## 解构\n\n### 解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2]\nlet [first, second] = input\nconsole.log(first) // outputs 1\nconsole.log(second) // outputs 2\n```\n\n这创建了 2 个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nlet first = input[0]\nlet second = input[1]\n```\n\n作用于函数参数：\n\n```typescript\nlet input: [number, number] = [1, 2]\n\nfunction f([first, second]: [number, number]) {\n  console.log(first)\n  console.log(second)\n}\n\nf(input)\n```\n\n你可以在数组里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\nconsole.log(rest) // outputs [ 2, 3, 4 ]\n```\n\n你也可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4]\nconsole.log(first) // outputs 1\n```\n\n或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4]\n```\n\n### 对象解构\n\n你也可以解构对象：\n\n```typescript\nlet o = {\n    a: 'foo',\n    b: 12,\n    c: 'bar'\n}\nlet { a, b } = o\n\n```\n\n这通过 `o.a` 和 `o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n\n你可以在对象里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o\nlet total = passthrough.b + passthrough.c.length\n```\n\n### 属性重命名\n\n你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o\n```\n\n这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 `\"a 作为 newName1\"`。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a\nlet newName2 = o.b\n```\n\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。\n\n```typescript\nlet {a, b}: {a: string, b: number} = o\n```\n\n### 默认值\n\n默认值可以让你在属性为 `undefined` 时使用缺省值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n  let { a, b = 1001 } = wholeObject\n}\n```\n\n现在，即使 `b` 为 `undefined` ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n### 函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a = '', b = 0 } = {}): void {\n  // ...\n}\nf()\n```\n\n> 上面的代码是一个类型推断的例子，将在后续章节介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: '' }): void {\n  // ...\n}\nf({ a: 'yes' }) // OK, 默认 b = 0\nf() // OK, 默认 a: '', b = 0\nf({}) // Error, 一旦传入参数则 a 是必须的\n```\n\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。\n\n## 展开\n\n```typescript\nlet first = [1, 2]\nlet second = [3, 4]\nlet bothPlus = [0, ...first, ...second, 5]\n```\n这会令 `bothPlus` 的值为 `[0, 1, 2, 3, 4, 5]`。 展开操作创建了 `first` 和 `second的` 一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { ...defaults, food: 'rich' }\n```\n\nsearch的值为 `{ food: 'rich', price: '$10', ambiance: 'noisy' }`。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: 'spicy', price: '$10', ambiance: 'noisy' }\nlet search = { food: 'rich', ...defaults }\n```\n\n那么，`defaults` 里的 `food` 属性会重写 `food: 'rich'`，在这里这并不是我们想要的结果。\n","slug":"TypeScript 学习第七章 TypeScript变量声明","published":1,"updated":"2019-12-31T03:00:25.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj7x006ezws6in1fy04u","content":"<h1><span id=\"变量声明\">变量声明</span></h1>\n<p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p>\n<p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p>\n<p>如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n<h2><span id=\"var-声明\">var 声明</span></h2>\n<p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义JavaScript 变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p>\n<p>我们也可以在函数内部定义变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> message</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且我们也可以在其它函数内部访问相同的变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f()</span><br><span class=\"line\">g() <span class=\"comment\">// returns 11</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p>\n<h3><span id=\"作用域规则\">作用域规则</span></h3>\n<p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>)  <span class=\"comment\">// returns '10'</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>) <span class=\"comment\">// returns 'undefined'</span></span><br></pre></td></tr></table></figure>\n<p>有些同学可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p>\n<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>\n<h3><span id=\"捕获变量怪异之处\">捕获变量怪异之处</span></h3>\n<p>猜一下下面的代码会返回什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p>\n</blockquote>\n<p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p>\n<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p>\n<h2><span id=\"let-声明\">let 声明</span></h2>\n<p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">'Hello!'</span></span><br></pre></td></tr></table></figure>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n<h3><span id=\"块作用域\">块作用域</span></h3>\n<p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// OK: 仍然能访问到 a</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Error: 'b' 在这里不存在</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p>\n<p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'Oh no!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch it.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: 'e' 在这里不存在</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e)</span><br></pre></td></tr></table></figure>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++ <span class=\"comment\">// TS2448: Block-scoped variable 'a' used before its declaration.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// okay to capture 'a'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在'a'被声明前调用'foo'</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>关于<em>暂时性死区</em>的更多信息，查看这里 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\" target=\"_blank\" rel=\"noopener\">Mozilla Developer Network</a>。</p>\n<h3><span id=\"重定义及屏蔽\">重定义及屏蔽</span></h3>\n<p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span> <span class=\"comment\">// 错误，不能在 1 个作用域里多次声明 x</span></span><br></pre></td></tr></table></figure>\n<p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 干扰参数声明</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 不能同时具有 x 的两个声明</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>) <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>)  <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p>\n<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p>\n<h3><span id=\"块级作用域变量的获取\">块级作用域变量的获取</span></h3>\n<p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n<p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p>\n<p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出与预料一致的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"const-声明\">const 声明</span></h2>\n<p><code>const</code> 声明是声明变量的另一种方式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p>\n<p>这很好理解，它们引用的值是不可变的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kitty'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tommy'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">'Jerry'</span></span><br><span class=\"line\">kitty.numLives--</span><br></pre></td></tr></table></figure>\n<p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p>\n<h2><span id=\"let-vs-const\">let vs. const</span></h2>\n<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p>\n<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p>\n<h2><span id=\"解构\">解构</span></h2>\n<h3><span id=\"解构数组\">解构数组</span></h3>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second) <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n<p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = input[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = input[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>作用于函数参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(first)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(input)</span><br></pre></td></tr></table></figure>\n<p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest) <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>你也可以忽略你不关心的尾随元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n<p>或其它元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<h3><span id=\"对象解构\">对象解构</span></h3>\n<p>你也可以解构对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">    b: <span class=\"number\">12</span>,</span><br><span class=\"line\">    c: <span class=\"string\">'bar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p>\n<p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length</span><br></pre></td></tr></table></figure>\n<h3><span id=\"属性重命名\">属性重命名</span></h3>\n<p>你也可以给属性以不同的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a: newName1, b: newName2 &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b</span><br></pre></td></tr></table></figure>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125;: &#123;a: <span class=\"built_in\">string</span>, b: <span class=\"built_in\">number</span>&#125; = o</span><br></pre></td></tr></table></figure>\n<h3><span id=\"默认值\">默认值</span></h3>\n<p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>\n<h3><span id=\"函数声明\">函数声明</span></h3>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a = '', b = 0 &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p>\n</blockquote>\n<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = 0 &#125; = &#123; a: '' &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; a: <span class=\"string\">'yes'</span> &#125;) <span class=\"comment\">// OK, 默认 b = 0</span></span><br><span class=\"line\">f() <span class=\"comment\">// OK, 默认 a: '', b = 0</span></span><br><span class=\"line\">f(&#123;&#125;) <span class=\"comment\">// Error, 一旦传入参数则 a 是必须的</span></span><br></pre></td></tr></table></figure>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p>\n<h2><span id=\"展开\">展开</span></h2>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p>\n<p>你还可以展开对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, food: <span class=\"string\">'rich'</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>search的值为 <code>{ food: 'rich', price: '$10', ambiance: 'noisy' }</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; food: <span class=\"string\">'rich'</span>, ...defaults &#125;</span><br></pre></td></tr></table></figure>\n<p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: 'rich'</code>，在这里这并不是我们想要的结果。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>变量声明</h1>\n<p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p>\n<p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p>\n<p>如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n<h2>var 声明</h2>\n<p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义JavaScript 变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p>\n<p>我们也可以在函数内部定义变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">'Hello World!'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> message</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且我们也可以在其它函数内部访问相同的变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f()</span><br><span class=\"line\">g() <span class=\"comment\">// returns 11</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p>\n<h3>作用域规则</h3>\n<p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>)  <span class=\"comment\">// returns '10'</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>) <span class=\"comment\">// returns 'undefined'</span></span><br></pre></td></tr></table></figure>\n<p>有些同学可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p>\n<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>\n<h3>捕获变量怪异之处</h3>\n<p>猜一下下面的代码会返回什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p>\n</blockquote>\n<p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p>\n<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p>\n<h2>let 声明</h2>\n<p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">'Hello!'</span></span><br></pre></td></tr></table></figure>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n<h3>块作用域</h3>\n<p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// OK: 仍然能访问到 a</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Error: 'b' 在这里不存在</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p>\n<p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'Oh no!'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Catch it.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: 'e' 在这里不存在</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e)</span><br></pre></td></tr></table></figure>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++ <span class=\"comment\">// TS2448: Block-scoped variable 'a' used before its declaration.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// okay to capture 'a'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在'a'被声明前调用'foo'</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a</span><br></pre></td></tr></table></figure>\n<p>关于<em>暂时性死区</em>的更多信息，查看这里 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\" target=\"_blank\" rel=\"noopener\">Mozilla Developer Network</a>。</p>\n<h3>重定义及屏蔽</h3>\n<p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span> <span class=\"comment\">// 错误，不能在 1 个作用域里多次声明 x</span></span><br></pre></td></tr></table></figure>\n<p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 干扰参数声明</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span> <span class=\"comment\">// Error: 不能同时具有 x 的两个声明</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>) <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>)  <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> currentRow = matrix[i]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p>\n<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p>\n<h3>块级作用域变量的获取</h3>\n<p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n<p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p>\n<p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出与预料一致的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h2>const 声明</h2>\n<p><code>const</code> 声明是声明变量的另一种方式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p>\n<p>这很好理解，它们引用的值是不可变的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kitty'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Tommy'</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">'Jerry'</span></span><br><span class=\"line\">kitty.numLives--</span><br></pre></td></tr></table></figure>\n<p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p>\n<h2>let vs. const</h2>\n<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p>\n<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p>\n<h2>解构</h2>\n<h3>解构数组</h3>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second) <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n<p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = input[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = input[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>作用于函数参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(first)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(input)</span><br></pre></td></tr></table></figure>\n<p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest) <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>你也可以忽略你不关心的尾随元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first) <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n<p>或其它元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\n<h3>对象解构</h3>\n<p>你也可以解构对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">    b: <span class=\"number\">12</span>,</span><br><span class=\"line\">    c: <span class=\"string\">'bar'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p>\n<p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length</span><br></pre></td></tr></table></figure>\n<h3>属性重命名</h3>\n<p>你也可以给属性以不同的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a: newName1, b: newName2 &#125; = o</span><br></pre></td></tr></table></figure>\n<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b</span><br></pre></td></tr></table></figure>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125;: &#123;a: <span class=\"built_in\">string</span>, b: <span class=\"built_in\">number</span>&#125; = o</span><br></pre></td></tr></table></figure>\n<h3>默认值</h3>\n<p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>\n<h3>函数声明</h3>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a = '', b = 0 &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p>\n</blockquote>\n<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = 0 &#125; = &#123; a: '' &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; a: <span class=\"string\">'yes'</span> &#125;) <span class=\"comment\">// OK, 默认 b = 0</span></span><br><span class=\"line\">f() <span class=\"comment\">// OK, 默认 a: '', b = 0</span></span><br><span class=\"line\">f(&#123;&#125;) <span class=\"comment\">// Error, 一旦传入参数则 a 是必须的</span></span><br></pre></td></tr></table></figure>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p>\n<h2>展开</h2>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure>\n<p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p>\n<p>你还可以展开对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, food: <span class=\"string\">'rich'</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>search的值为 <code>{ food: 'rich', price: '$10', ambiance: 'noisy' }</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">'spicy'</span>, price: <span class=\"string\">'$10'</span>, ambiance: <span class=\"string\">'noisy'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; food: <span class=\"string\">'rich'</span>, ...defaults &#125;</span><br></pre></td></tr></table></figure>\n<p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: 'rich'</code>，在这里这并不是我们想要的结果。</p>\n"},{"title":"TypeScript 学习第十章 TypeScript 高级类型","catalog":true,"date":"2019-08-24T15:39:42.000Z","subtitle":null,"header-img":"http://hbimg.b0.upaiyun.com/41b12ee52728b42d69cbcc29bf4af166b18860fa49c77-CvohEM_fw658","_content":"\n# 高级类型\n\n## 交叉类型\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，`Person & Loggable` 同时是 `Person` 和 `Loggable`。 就是说这个类型的对象同时拥有了这两种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：\n\n```typescript\nfunction extend<T, U> (first: T, second: U): T & U {\n  let result = {} as T & U\n  for (let id in first) {\n    result[id] = first[id] as any\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      result[id] = second[id] as any\n    }\n  }\n  return result\n}\n\nclass Person {\n  constructor (public name: string) {\n  }\n}\n\ninterface Loggable {\n  log (): void\n}\n\nclass ConsoleLogger implements Loggable {\n  log () {\n    // ...\n  }\n}\n\nvar jim = extend(new Person('Jim'), new ConsoleLogger())\nvar n = jim.name\njim.log()\n```\n\n## 联合类型\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 `number` 或 `string` 类型的参数。 例如下面的函数：\n\n```typescript\nfunction padLeft(value: string, padding: any) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n\npadLeft('Hello world', 4) // returns \"    Hello world\"\n\n```\n\n`padLeft` 存在一个问题，`padding` 参数的类型指定成了 `any`。 这就是说我们可以传入一个既不是 `number` 也不是 `string` 类型的参数，但是 TypeScript 却不报错。\n\n```typescript\nlet indentedString = padLeft('Hello world', true) // 编译阶段通过，运行时报错\n```\n\n为了解决这个问题，我们可以使用 联合类型做为 `padding` 的参数：\n\n```typescript\nfunction padLeft(value: string, padding: string | number) {\n  // ...\n}\n\nlet indentedString = padLeft('Hello world', true) // 编译阶段报错\n```\n\n联合类型表示一个值可以是几种类型之一。我们用竖线（`|`）分隔每个类型，所以 `number | string` 表示一个值可以是 `number` 或 `string`。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\n```typescript\ninterface Bird {\n  fly()\n  layEggs()\n}\n\ninterface Fish {\n  swim()\n  layEggs()\n}\n\nfunction getSmallPet(): Fish | Bird {\n  // ...\n}\n\nlet pet = getSmallPet()\npet.layEggs() // okay\npet.swim()    // error\n```\n\n这里的联合类型可能有点复杂：如果一个值的类型是 `A | B`，我们能够确定的是它包含了 `A` 和 `B` 中共有的成员。这个例子里，`Fish` 具有一个 `swim` 方法，我们不能确定一个 `Bird | Fish` 类型的变量是否有 `swim`方法。 如果变量在运行时是 `Bird` 类型，那么调用 `pet.swim()` 就出错了。\n\n## 类型保护\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 `Fish` 或者是 `Bird` 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\nlet pet = getSmallPet()\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n  pet.swim()\n} else if (pet.fly) {\n  pet.fly()\n}\n```\n\n为了让这段代码工作，我们要使用类型断言：\n\n```typescript\nlet pet = getSmallPet()\n\nif ((pet as Fish).swim) {\n  (pet as Fish).swim()\n} else {\n  (pet as Bird).fly()\n}\n```\n\n### 用户自定义的类型保护\n\n这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 `pet` 的类型的话就好了。\n\nTypeScript 里的*类型保护*机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个*类型谓词*：\n\n```typescript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined\n}\n```\n\n在这个例子里，`pet is Fish` 就是类型谓词。谓词为 `parameterName is Type` 这种形式， `parameterName` 必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用 `isFish` 时，`TypeScript` 会将变量缩减为那个具体的类型。\n\n```typescript\nif (isFish(pet)) {\n  pet.swim()\n}\nelse {\n  pet.fly()\n}\n```\n\n注意 `TypeScript` 不仅知道在 `if` 分支里 `pet` 是 `Fish` 类型；它还清楚在 `else` 分支里，一定不是 Fish类型而是 `Bird` 类型。\n\n### typeof 类型保护\n\n现在我们回过头来看看怎么使用联合类型书写 `padLeft` 代码。我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber (x: any):x is string {\n  return typeof x === 'number'\n}\n\nfunction isString (x: any): x is string {\n  return typeof x === 'string'\n}\n\nfunction padLeft (value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (isString(padding)) {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 `typeof x === 'number' `抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\n\n```typescript\nfunction padLeft (value: string, padding: string | number) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n这些 `typeof` 类型保护只有两种形式能被识别：`typeof v === \"typename\"` 和 `typeof v !== \"typename\"`， `\"typename\"`必须是 `\"number\"`， `\"string\"`，`\"boolean\"` 或 `\"symbol\"`。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。\n\n### instanceof 类型保护\n\n如果你已经阅读了 `typeof` 类型保护并且对 JavaScript 里的 `instanceof` 操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\n`instanceof` 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：\n\n```typescript\nclass Bird {\n  fly () {\n    console.log('bird fly')\n  }\n\n  layEggs () {\n    console.log('bird lay eggs')\n  }\n}\n\nclass Fish {\n  swim () {\n    console.log('fish swim')\n  }\n\n  layEggs () {\n    console.log('fish lay eggs')\n  }\n}\n\nfunction getRandomPet () {\n  return Math.random() > 0.5 ? new Bird() : new Fish()\n}\n\nlet pet = getRandomPet()\n\nif (pet instanceof Bird) {\n  pet.fly()\n}\nif (pet instanceof Fish) {\n  pet.swim()\n}\n```\n\n## 可以为 null 的类型\n\nTypeScript 具有两种特殊的类型，`null` 和 `undefined`，它们分别具有值 `null` 和 `undefined`。我们在[基础类型](/chapter2/type)一节里已经做过简要说明。 默认情况下，类型检查器认为 `null` 与 `undefined` 可以赋值给任何类型。 `null` 与 `undefined` 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。`null`的发明者，Tony Hoare，称它为[价值亿万美金的错误](https://en.wikipedia.org/wiki/Null_pointer#History)。\n\n`--strictNullChecks` 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 `null` 或 `undefined`。 你可以使用联合类型明确的包含它们：\n\n```typescript\nlet s = 'foo'\ns = null // 错误, 'null'不能赋值给'string'\nlet sn: string | null = 'bar'\nsn = null // 可以\n\nsn = undefined // error, 'undefined'不能赋值给'string | null'\n```\n\n注意，按照 JavaScript 的语义，TypeScript 会把 `null` 和 `undefined` 区别对待。`string | null`，`string | undefined` 和 `string | undefined | null` 是不同的类型。\n\n### 可选参数和可选属性\n\n使用了 `--strictNullChecks`，可选参数会被自动地加上 `| undefined`:\n\n```typescript\nfunction f(x: number, y?: number) {\n  return x + (y || 0)\n}\nf(1, 2)\nf(1)\nf(1, undefined)\nf(1, null) // error, 'null' 不能赋值给 'number | undefined'\n```\n\n可选属性也会有同样的处理：\n\n```typescript\nclass C {\n  a: number\n  b?: number\n}\nlet c = new C()\nc.a = 12\nc.a = undefined // error, 'undefined' 不能赋值给 'number'\nc.b = 13\nc.b = undefined // ok\nc.b = null // error, 'null' 不能赋值给 'number | undefined'\n```\n\n### 类型保护和类型断言\n\n由于可以为 `null` 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 `null`。幸运地是这与在 `JavaScript` 里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n  if (sn === null) {\n    return 'default'\n  } else {\n    return sn\n  }\n}\n```\n\n这里很明显地去除了 `null`，你也可以使用短路运算符：\n\n```typescript\nfunction f(sn: string | null): string {\n  return sn || 'default'\n}\n```\n\n如果编译器不能够去除 `null` 或 `undefined`，你可以使用类型断言手动去除。语法是添加 `!` 后缀： `identifier!` 从 `identifier` 的类型里去除了 `null` 和 `undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charAt(0) + '.  the ' + epithet // error, 'name' 可能为 null\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charAt(0) + '.  the ' + epithet // ok\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nbroken(null)\n\n```\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的 `null`（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 `name` 的类型。\n\n## 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = 'ease-in' | 'ease-out' | 'ease-in-out'\n\nclass UIElement {\n  animate (dx: number, dy: number, easing: Easing) {\n    if (easing === 'ease-in') {\n      // ...\n    } else if (easing === 'ease-out') {\n    } else if (easing === 'ease-in-out') {\n    } else {\n      // error! 不能传入 null 或者 undefined.\n    }\n  }\n}\n\nlet button = new UIElement()\nbutton.animate(0, 0, 'ease-in')\nbutton.animate(0, 0, 'uneasy') // error\n\n```\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\n```\nArgument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n```\n\n\n","source":"_posts/TypeScript 学习第十章 TypeScript高级类型.md","raw":"---\ntitle: TypeScript 学习第十章 TypeScript 高级类型\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-24 23:39:42\nsubtitle:\nheader-img: \"http://hbimg.b0.upaiyun.com/41b12ee52728b42d69cbcc29bf4af166b18860fa49c77-CvohEM_fw658\"\n---\n\n# 高级类型\n\n## 交叉类型\n\n交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，`Person & Loggable` 同时是 `Person` 和 `Loggable`。 就是说这个类型的对象同时拥有了这两种类型的成员。\n\n我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：\n\n```typescript\nfunction extend<T, U> (first: T, second: U): T & U {\n  let result = {} as T & U\n  for (let id in first) {\n    result[id] = first[id] as any\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      result[id] = second[id] as any\n    }\n  }\n  return result\n}\n\nclass Person {\n  constructor (public name: string) {\n  }\n}\n\ninterface Loggable {\n  log (): void\n}\n\nclass ConsoleLogger implements Loggable {\n  log () {\n    // ...\n  }\n}\n\nvar jim = extend(new Person('Jim'), new ConsoleLogger())\nvar n = jim.name\njim.log()\n```\n\n## 联合类型\n\n联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 `number` 或 `string` 类型的参数。 例如下面的函数：\n\n```typescript\nfunction padLeft(value: string, padding: any) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n\npadLeft('Hello world', 4) // returns \"    Hello world\"\n\n```\n\n`padLeft` 存在一个问题，`padding` 参数的类型指定成了 `any`。 这就是说我们可以传入一个既不是 `number` 也不是 `string` 类型的参数，但是 TypeScript 却不报错。\n\n```typescript\nlet indentedString = padLeft('Hello world', true) // 编译阶段通过，运行时报错\n```\n\n为了解决这个问题，我们可以使用 联合类型做为 `padding` 的参数：\n\n```typescript\nfunction padLeft(value: string, padding: string | number) {\n  // ...\n}\n\nlet indentedString = padLeft('Hello world', true) // 编译阶段报错\n```\n\n联合类型表示一个值可以是几种类型之一。我们用竖线（`|`）分隔每个类型，所以 `number | string` 表示一个值可以是 `number` 或 `string`。\n\n如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。\n\n```typescript\ninterface Bird {\n  fly()\n  layEggs()\n}\n\ninterface Fish {\n  swim()\n  layEggs()\n}\n\nfunction getSmallPet(): Fish | Bird {\n  // ...\n}\n\nlet pet = getSmallPet()\npet.layEggs() // okay\npet.swim()    // error\n```\n\n这里的联合类型可能有点复杂：如果一个值的类型是 `A | B`，我们能够确定的是它包含了 `A` 和 `B` 中共有的成员。这个例子里，`Fish` 具有一个 `swim` 方法，我们不能确定一个 `Bird | Fish` 类型的变量是否有 `swim`方法。 如果变量在运行时是 `Bird` 类型，那么调用 `pet.swim()` 就出错了。\n\n## 类型保护\n\n联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 `Fish` 或者是 `Bird` 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\nlet pet = getSmallPet()\n\n// 每一个成员访问都会报错\nif (pet.swim) {\n  pet.swim()\n} else if (pet.fly) {\n  pet.fly()\n}\n```\n\n为了让这段代码工作，我们要使用类型断言：\n\n```typescript\nlet pet = getSmallPet()\n\nif ((pet as Fish).swim) {\n  (pet as Fish).swim()\n} else {\n  (pet as Bird).fly()\n}\n```\n\n### 用户自定义的类型保护\n\n这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 `pet` 的类型的话就好了。\n\nTypeScript 里的*类型保护*机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个*类型谓词*：\n\n```typescript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined\n}\n```\n\n在这个例子里，`pet is Fish` 就是类型谓词。谓词为 `parameterName is Type` 这种形式， `parameterName` 必须是来自于当前函数签名里的一个参数名。\n\n每当使用一些变量调用 `isFish` 时，`TypeScript` 会将变量缩减为那个具体的类型。\n\n```typescript\nif (isFish(pet)) {\n  pet.swim()\n}\nelse {\n  pet.fly()\n}\n```\n\n注意 `TypeScript` 不仅知道在 `if` 分支里 `pet` 是 `Fish` 类型；它还清楚在 `else` 分支里，一定不是 Fish类型而是 `Bird` 类型。\n\n### typeof 类型保护\n\n现在我们回过头来看看怎么使用联合类型书写 `padLeft` 代码。我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber (x: any):x is string {\n  return typeof x === 'number'\n}\n\nfunction isString (x: any): x is string {\n  return typeof x === 'string'\n}\n\nfunction padLeft (value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (isString(padding)) {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 `typeof x === 'number' `抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。\n\n\n```typescript\nfunction padLeft (value: string, padding: string | number) {\n  if (typeof padding === 'number') {\n    return Array(padding + 1).join(' ') + value\n  }\n  if (typeof padding === 'string') {\n    return padding + value\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`)\n}\n```\n\n这些 `typeof` 类型保护只有两种形式能被识别：`typeof v === \"typename\"` 和 `typeof v !== \"typename\"`， `\"typename\"`必须是 `\"number\"`， `\"string\"`，`\"boolean\"` 或 `\"symbol\"`。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。\n\n### instanceof 类型保护\n\n如果你已经阅读了 `typeof` 类型保护并且对 JavaScript 里的 `instanceof` 操作符熟悉的话，你可能已经猜到了这节要讲的内容。\n\n`instanceof` 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：\n\n```typescript\nclass Bird {\n  fly () {\n    console.log('bird fly')\n  }\n\n  layEggs () {\n    console.log('bird lay eggs')\n  }\n}\n\nclass Fish {\n  swim () {\n    console.log('fish swim')\n  }\n\n  layEggs () {\n    console.log('fish lay eggs')\n  }\n}\n\nfunction getRandomPet () {\n  return Math.random() > 0.5 ? new Bird() : new Fish()\n}\n\nlet pet = getRandomPet()\n\nif (pet instanceof Bird) {\n  pet.fly()\n}\nif (pet instanceof Fish) {\n  pet.swim()\n}\n```\n\n## 可以为 null 的类型\n\nTypeScript 具有两种特殊的类型，`null` 和 `undefined`，它们分别具有值 `null` 和 `undefined`。我们在[基础类型](/chapter2/type)一节里已经做过简要说明。 默认情况下，类型检查器认为 `null` 与 `undefined` 可以赋值给任何类型。 `null` 与 `undefined` 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。`null`的发明者，Tony Hoare，称它为[价值亿万美金的错误](https://en.wikipedia.org/wiki/Null_pointer#History)。\n\n`--strictNullChecks` 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 `null` 或 `undefined`。 你可以使用联合类型明确的包含它们：\n\n```typescript\nlet s = 'foo'\ns = null // 错误, 'null'不能赋值给'string'\nlet sn: string | null = 'bar'\nsn = null // 可以\n\nsn = undefined // error, 'undefined'不能赋值给'string | null'\n```\n\n注意，按照 JavaScript 的语义，TypeScript 会把 `null` 和 `undefined` 区别对待。`string | null`，`string | undefined` 和 `string | undefined | null` 是不同的类型。\n\n### 可选参数和可选属性\n\n使用了 `--strictNullChecks`，可选参数会被自动地加上 `| undefined`:\n\n```typescript\nfunction f(x: number, y?: number) {\n  return x + (y || 0)\n}\nf(1, 2)\nf(1)\nf(1, undefined)\nf(1, null) // error, 'null' 不能赋值给 'number | undefined'\n```\n\n可选属性也会有同样的处理：\n\n```typescript\nclass C {\n  a: number\n  b?: number\n}\nlet c = new C()\nc.a = 12\nc.a = undefined // error, 'undefined' 不能赋值给 'number'\nc.b = 13\nc.b = undefined // ok\nc.b = null // error, 'null' 不能赋值给 'number | undefined'\n```\n\n### 类型保护和类型断言\n\n由于可以为 `null` 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 `null`。幸运地是这与在 `JavaScript` 里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n  if (sn === null) {\n    return 'default'\n  } else {\n    return sn\n  }\n}\n```\n\n这里很明显地去除了 `null`，你也可以使用短路运算符：\n\n```typescript\nfunction f(sn: string | null): string {\n  return sn || 'default'\n}\n```\n\n如果编译器不能够去除 `null` 或 `undefined`，你可以使用类型断言手动去除。语法是添加 `!` 后缀： `identifier!` 从 `identifier` 的类型里去除了 `null` 和 `undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epithet: string) {\n    return name.charAt(0) + '.  the ' + epithet // error, 'name' 可能为 null\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epithet: string) {\n    return name!.charAt(0) + '.  the ' + epithet // ok\n  }\n  name = name || 'Bob'\n  return postfix('great')\n}\n\nbroken(null)\n\n```\n\n本例使用了嵌套函数，因为编译器无法去除嵌套函数的 `null`（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 `name` 的类型。\n\n## 字符串字面量类型\n\n字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = 'ease-in' | 'ease-out' | 'ease-in-out'\n\nclass UIElement {\n  animate (dx: number, dy: number, easing: Easing) {\n    if (easing === 'ease-in') {\n      // ...\n    } else if (easing === 'ease-out') {\n    } else if (easing === 'ease-in-out') {\n    } else {\n      // error! 不能传入 null 或者 undefined.\n    }\n  }\n}\n\nlet button = new UIElement()\nbutton.animate(0, 0, 'ease-in')\nbutton.animate(0, 0, 'uneasy') // error\n\n```\n\n你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。\n\n```\nArgument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n```\n\n\n","slug":"TypeScript 学习第十章 TypeScript高级类型","published":1,"updated":"2019-12-31T03:00:25.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj7y006hzws6onw5vjs9","content":"<h1><span id=\"高级类型\">高级类型</span></h1>\n<h2><span id=\"交叉类型\">交叉类型</span></h2>\n<p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p>\n<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; (<span class=\"params\">first: T, second: U</span>): <span class=\"title\">T</span> &amp; <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T &amp; U</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">    result[id] = first[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class=\"line\">      result[id] = second[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Loggable &#123;</span><br><span class=\"line\">  log (): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> ConsoleLogger <span class=\"keyword\">implements</span> Loggable &#123;</span><br><span class=\"line\">  log () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jim = extend(<span class=\"keyword\">new</span> Person(<span class=\"string\">'Jim'</span>), <span class=\"keyword\">new</span> ConsoleLogger())</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = jim.name</span><br><span class=\"line\">jim.log()</span><br></pre></td></tr></table></figure>\n<h2><span id=\"联合类型\">联合类型</span></h2>\n<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"number\">4</span>) <span class=\"comment\">// returns \"    Hello world\"</span></span><br></pre></td></tr></table></figure>\n<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段报错</span></span><br></pre></td></tr></table></figure>\n<p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p>\n<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\">pet.layEggs() <span class=\"comment\">// okay</span></span><br><span class=\"line\">pet.swim()    <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p>\n<h2><span id=\"类型保护\">类型保护</span></h2>\n<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code>Fish</code> 或者是 <code>Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一个成员访问都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet.swim) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.fly) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了让这段代码工作，我们要使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((pet <span class=\"keyword\">as</span> Fish).swim) &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Fish).swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Bird).fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"用户自定义的类型保护\">用户自定义的类型保护</span></h3>\n<p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p>\n<p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> Fish).swim !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>\n<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isFish(pet)) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分支里，一定不是 Fish类型而是 <code>Bird</code> 类型。</p>\n<h3><span id=\"typeof-类型保护\">typeof 类型保护</span></h3>\n<p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>):<span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === 'number'</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>\n<h3><span id=\"instanceof-类型保护\">instanceof 类型保护</span></h3>\n<p>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>\n<p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Bird &#123;</span><br><span class=\"line\">  fly () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird fly'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Fish &#123;</span><br><span class=\"line\">  swim () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish swim'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPet</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">0.5</span> ? <span class=\"keyword\">new</span> Bird() : <span class=\"keyword\">new</span> Fish()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getRandomPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Bird) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Fish) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"可以为-null-的类型\">可以为 null 的类型</span></h2>\n<p>TypeScript 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code>，它们分别具有值 <code>null</code> 和 <code>undefined</code>。我们在<a href=\"/chapter2/type\">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code>null</code>的发明者，Tony Hoare，称它为<a href=\"https://en.wikipedia.org/wiki/Null_pointer#History\" target=\"_blank\" rel=\"noopener\">价值亿万美金的错误</a>。</p>\n<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。 你可以使用联合类型明确的包含它们：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'foo'</span></span><br><span class=\"line\">s = <span class=\"literal\">null</span> <span class=\"comment\">// 错误, 'null'不能赋值给'string'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span> = <span class=\"string\">'bar'</span></span><br><span class=\"line\">sn = <span class=\"literal\">null</span> <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\">sn = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined'不能赋值给'string | null'</span></span><br></pre></td></tr></table></figure>\n<p>注意，按照 JavaScript 的语义，TypeScript 会把 <code>null</code> 和 <code>undefined</code> 区别对待。<code>string | null</code>，<code>string | undefined</code> 和 <code>string | undefined | null</code> 是不同的类型。</p>\n<h3><span id=\"可选参数和可选属性\">可选参数和可选属性</span></h3>\n<p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y?: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + (y || <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">null</span>) <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<p>可选属性也会有同样的处理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">  a: <span class=\"built_in\">number</span></span><br><span class=\"line\">  b?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C()</span><br><span class=\"line\">c.a = <span class=\"number\">12</span></span><br><span class=\"line\">c.a = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined' 不能赋值给 'number'</span></span><br><span class=\"line\">c.b = <span class=\"number\">13</span></span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span> <span class=\"comment\">// ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span> <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"类型保护和类型断言\">类型保护和类型断言</span></h3>\n<p>由于可以为 <code>null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sn === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'default'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很明显地去除了 <code>null</code>，你也可以使用短路运算符：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sn || <span class=\"string\">'default'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">broken</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// error, 'name' 可能为 null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name!.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// ok</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">broken(<span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>\n<h2><span id=\"字符串字面量类型\">字符串字面量类型</span></h2>\n<p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">'ease-in'</span> | <span class=\"string\">'ease-out'</span> | <span class=\"string\">'ease-in-out'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> UIElement &#123;</span><br><span class=\"line\">  animate (dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// error! 不能传入 null 或者 undefined.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement()</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'ease-in'</span>)</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'uneasy'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>高级类型</h1>\n<h2>交叉类型</h2>\n<p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。 就是说这个类型的对象同时拥有了这两种类型的成员。</p>\n<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">U</span>&gt; (<span class=\"params\">first: T, second: U</span>): <span class=\"title\">T</span> &amp; <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T &amp; U</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">    result[id] = first[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> id <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class=\"line\">      result[id] = second[id] <span class=\"keyword\">as</span> <span class=\"built_in\">any</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Loggable &#123;</span><br><span class=\"line\">  log (): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> ConsoleLogger <span class=\"keyword\">implements</span> Loggable &#123;</span><br><span class=\"line\">  log () &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jim = extend(<span class=\"keyword\">new</span> Person(<span class=\"string\">'Jim'</span>), <span class=\"keyword\">new</span> ConsoleLogger())</span><br><span class=\"line\"><span class=\"keyword\">var</span> n = jim.name</span><br><span class=\"line\">jim.log()</span><br></pre></td></tr></table></figure>\n<h2>联合类型</h2>\n<p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"number\">4</span>) <span class=\"comment\">// returns \"    Hello world\"</span></span><br></pre></td></tr></table></figure>\n<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。 这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 TypeScript 却不报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段通过，运行时报错</span></span><br></pre></td></tr></table></figure>\n<p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">'Hello world'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 编译阶段报错</span></span><br></pre></td></tr></table></figure>\n<p>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code> 或 <code>string</code>。</p>\n<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim()</span><br><span class=\"line\">  layEggs()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\">pet.layEggs() <span class=\"comment\">// okay</span></span><br><span class=\"line\">pet.swim()    <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Fish</code> 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 <code>Bird</code> 类型，那么调用 <code>pet.swim()</code> 就出错了。</p>\n<h2>类型保护</h2>\n<p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 <code>Fish</code> 或者是 <code>Bird</code> 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一个成员访问都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet.swim) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.fly) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了让这段代码工作，我们要使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((pet <span class=\"keyword\">as</span> Fish).swim) &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Fish).swim()</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  (pet <span class=\"keyword\">as</span> Bird).fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>用户自定义的类型保护</h3>\n<p>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p>\n<p>TypeScript 里的<em>类型保护</em>机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个<em>类型谓词</em>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> Fish).swim !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</p>\n<p>每当使用一些变量调用 <code>isFish</code> 时，<code>TypeScript</code> 会将变量缩减为那个具体的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isFish(pet)) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分支里，一定不是 Fish类型而是 <code>Bird</code> 类型。</p>\n<h3>typeof 类型保护</h3>\n<p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。我们可以像下面这样利用类型断言来写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>):<span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span> (<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">'string'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === 'number'</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span> (<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">' '</span>) + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got '<span class=\"subst\">$&#123;padding&#125;</span>'.`</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p>\n<h3>instanceof 类型保护</h3>\n<p>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p>\n<p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Bird &#123;</span><br><span class=\"line\">  fly () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird fly'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bird lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Fish &#123;</span><br><span class=\"line\">  swim () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish swim'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'fish lay eggs'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPet</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">0.5</span> ? <span class=\"keyword\">new</span> Bird() : <span class=\"keyword\">new</span> Fish()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getRandomPet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Bird) &#123;</span><br><span class=\"line\">  pet.fly()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pet <span class=\"keyword\">instanceof</span> Fish) &#123;</span><br><span class=\"line\">  pet.swim()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>可以为 null 的类型</h2>\n<p>TypeScript 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code>，它们分别具有值 <code>null</code> 和 <code>undefined</code>。我们在<a href=\"/chapter2/type\">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 <code>null</code> 与 <code>undefined</code> 可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。<code>null</code>的发明者，Tony Hoare，称它为<a href=\"https://en.wikipedia.org/wiki/Null_pointer#History\" target=\"_blank\" rel=\"noopener\">价值亿万美金的错误</a>。</p>\n<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。 你可以使用联合类型明确的包含它们：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">'foo'</span></span><br><span class=\"line\">s = <span class=\"literal\">null</span> <span class=\"comment\">// 错误, 'null'不能赋值给'string'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span> = <span class=\"string\">'bar'</span></span><br><span class=\"line\">sn = <span class=\"literal\">null</span> <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\">sn = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined'不能赋值给'string | null'</span></span><br></pre></td></tr></table></figure>\n<p>注意，按照 JavaScript 的语义，TypeScript 会把 <code>null</code> 和 <code>undefined</code> 区别对待。<code>string | null</code>，<code>string | undefined</code> 和 <code>string | undefined | null</code> 是不同的类型。</p>\n<h3>可选参数和可选属性</h3>\n<p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y?: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + (y || <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>)</span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">null</span>) <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<p>可选属性也会有同样的处理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">  a: <span class=\"built_in\">number</span></span><br><span class=\"line\">  b?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C()</span><br><span class=\"line\">c.a = <span class=\"number\">12</span></span><br><span class=\"line\">c.a = <span class=\"literal\">undefined</span> <span class=\"comment\">// error, 'undefined' 不能赋值给 'number'</span></span><br><span class=\"line\">c.b = <span class=\"number\">13</span></span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span> <span class=\"comment\">// ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span> <span class=\"comment\">// error, 'null' 不能赋值给 'number | undefined'</span></span><br></pre></td></tr></table></figure>\n<h3>类型保护和类型断言</h3>\n<p>由于可以为 <code>null</code> 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sn === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'default'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很明显地去除了 <code>null</code>，你也可以使用短路运算符：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sn || <span class=\"string\">'default'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">broken</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// error, 'name' 可能为 null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epithet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name!.charAt(<span class=\"number\">0</span>) + <span class=\"string\">'.  the '</span> + epithet <span class=\"comment\">// ok</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">'Bob'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">'great'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">broken(<span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code>（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>\n<h2>字符串字面量类型</h2>\n<p>字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">'ease-in'</span> | <span class=\"string\">'ease-out'</span> | <span class=\"string\">'ease-in-out'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> UIElement &#123;</span><br><span class=\"line\">  animate (dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">'ease-in-out'</span>) &#123;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// error! 不能传入 null 或者 undefined.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement()</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'ease-in'</span>)</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'uneasy'</span>) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Argument of type &apos;&quot;uneasy&quot;&apos; is not assignable to parameter of type &apos;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&apos;</span><br></pre></td></tr></table></figure>\n"},{"title":"TypeScript 学习第四章 TypeScript函数","catalog":true,"date":"2019-08-17T02:07:25.000Z","subtitle":null,"header-img":"http://10wallpaper.com/wallpaper/1680x1050/1508/Iron_man_hulkbuster_in_avengers-Movie_HD_Wallpaper_1680x1050.jpg","_content":"\n# 函数\n\n函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。\n\n## 基本示例\n\n和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：\n\n```javascript\n// 命名函数\nfunction add(x, y) {\n  return x + y\n}\n\n// 匿名函数\nlet myAdd = function(x, y) { \n  return x + y;\n}\n```\n\n在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。\n\n```javascript\nlet z = 100\n\nfunction addToZ(x, y) {\n  return x + y + z\n}\n```\n\n## 函数类型\n\n### 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\n```typescript\nfunction add(x: number, y: number): number {\n  return x + y\n}\n\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n```\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。\n\n### 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\n```typescript\nlet myAdd: (x: number, y: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n\n```\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：\n\n```typescript\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n```\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(`=>`)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 `void` 而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。\n\n### 推断类型\n\n尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：\n\n```typescript\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x, y) {\n  return x + y\n}\n```\n\n这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n## 可选参数和默认参数\n\nTypeScript 里的每个函数参数都是必须的。 这不是指不能传递 `null` 或 `undefined` 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + ' ' + lastName;\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', 'Sr.');  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams');         // OK\n```\n\nJavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 `undefined`。 在TypeScript 里我们可以在参数名旁使用 `?` 实现可选参数的功能。 比如，我们想让 `lastName` 是可选的：\n\n```typescript\nfunction buildName(firstName: string, lastName?: string): string {\n  if (lastName)\n    return firstName + ' ' + lastName\n  else\n    return firstName\n}\n\nlet result1 = buildName('Bob');  // 现在正常了\nlet result2 = buildName('Bob', 'Adams', 'Sr.')  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')  // OK\n```\n\n可选参数必须跟在必须参数后面。 如果上例我们想让 `firstName` 是可选的，那么就必须调整它们的位置，把 `firstName` 放在后面。\n\n在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 `undefined` 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把`lastName` 的默认值设置为 `\"Smith\"`。\n\n```typescript\nfunction buildName(firstName: string, lastName = 'Smith'): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // 返回 \"Bob Smith\"\nlet result2 = buildName('Bob', undefined)     // 正常, 同样 \"Bob Smith\"\nlet result3 = buildName('Bob', 'Adams', 'Sr.')  // 错误, 参数过多\nlet result4 = buildName('Bob', 'Adams')        // OK\n```\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 `undefined` 值来获得默认值。 例如，我们重写最后一个例子，让 `firstName` 是带默认值的参数：\n\n```typescript\nfunction buildName(firstName = 'Will', lastName: string): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', \"Sr.\")  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')         // OK， 返回 \"Bob Adams\"\nlet result4 = buildName(undefined, 'Adams')     // OK，  返回 \"Will Adams\"\n```\n\n### 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 `arguments` 来访问所有传入的参数。\n\n在 TypeScript 里，你可以把所有参数收集到一个变量里：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie')\n```\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ `...`）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName\n```\n\n## this\n\n学习如何在 JavaScript 里正确使用 `this` 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 `this` 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 `this` 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 [Understanding JavaScript Function Invocation and \"this\"](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)。 Yehuda 的文章详细的阐述了 `this` 的内部工作原理，因此我们这里只做简单介绍。\n\n### this 和箭头函数\n\nJavaScript里，`this` 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    return function() {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n可以看到 `createCardPicker` 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 `createCardPicker` 返回的函数里的 `this` 被设置成了 `global` 而不是 `deck` 对象。 因为我们只是独立的调用了 `cardPicker()`。 顶级的非方法式调用会将 `this` 视为 `global`。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的`this`。 这样的话，无论之后怎么使用它，都会引用绑定的`deck` 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 `this` 值，而不是调用时的值：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    // 注意：这里使用箭头函数\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n### this 参数\n在上述的例子中 `this.suits[pickedSuit]` 的类型为 `any`，这是因为 `this` 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 `this` 参数。 `this` 参数是个假的参数，它出现在参数列表的最前面：\n\n```typescript\nfunction f(this: void) {\n  // 确保“this”在此独立函数中不可用\n}\n```\n\n让我们往例子里添加一些接口，`Card` 和 `Deck`，让类型重用能够变得清晰简单些：\n\n```typescript\ninterface Card {\n  suit: string\n  card: number\n}\n\ninterface Deck {\n  suits: string[]\n  cards: number[]\n\n  createCardPicker (this: Deck): () => Card\n}\n\nlet deck: Deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  // NOTE: 函数现在显式指定其被调用方必须是 deck 类型\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n现在 TypeScrip t知道 `createCardPicker` 期望在某个 `Deck` 对象上调用。也就是说 `this` 是 `Deck` 类型的，而非 `any`。\n\n### this 参数在回调函数里\n\n你可以也看到过在回调函数里的 `this` 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，`this` 将为 `undefined`。 稍做改动，你就可以通过 `this` 参数来避免错误。 首先，库函数的作者要指定 `this` 的类型：\n\n```typescript\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void\n}\n```\n\n`this: void` 意味着 `addClickListener` 期望传入的 `onclick` 方法不需要 `this`\n\n```typescript\ninterface UIElement {\n  addClickListener (onclick: (this: void, e: Event) => void): void\n}\n\nclass Handler {\n  type: string\n\n  onClickBad (this: Handler, e: Event) {\n    this.type = e.type\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad) // error!\n\n```\n \n指定了 `this` 类型后，你显式声明 `onClickBad` 必须在 `Handler` 的实例上调用。 然后 TypeScript 会检测到 `addClickListener` 要求函数带有 `this: void`。 改变 `this` 类型来修复这个错误：\n\n```typescript\nclass Handler {\n  type: string;\n\n  onClickBad (this: void, e: Event) {\n    console.log('clicked!')\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad)\n```\n\n因为 `onClickGood` 指定了 `this` 类型为 `void`，因此传递 `addClickListener` 是合法的。 当然了，这也意味着不能使用 `this.info`。 如果你两者都想要，你不得不使用箭头函数了：\n\n```typescript\nclass Handler {\n  type: string\n  onClickGood = (e: Event) => {\n    this.type = e.type \n  }\n}\n```\n\n这是可行的因为箭头函数不会捕获 `this`，所以你总是可以把它们传给期望 `this: void` 的函数。\n\n## 重载\n\nJavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n`pickCard` 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 `pickCard` 函数。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x: {suit: string; card: number }[]): number\nfunction pickCard(x: number): {suit: string; card: number }\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n这样改变后，重载的 `pickCard` 函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，`function pickCard(x): any` 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 `pickCard` 会产生错误。\n","source":"_posts/TypeScript 学习第四章 TypeScript函数.md","raw":"---\ntitle: TypeScript 学习第四章 TypeScript函数\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-17 10:07:25\nsubtitle:\nheader-img: \"http://10wallpaper.com/wallpaper/1680x1050/1508/Iron_man_hulkbuster_in_avengers-Movie_HD_Wallpaper_1680x1050.jpg\"\n---\n\n# 函数\n\n函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。\n\n## 基本示例\n\n和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。\n\n通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：\n\n```javascript\n// 命名函数\nfunction add(x, y) {\n  return x + y\n}\n\n// 匿名函数\nlet myAdd = function(x, y) { \n  return x + y;\n}\n```\n\n在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。\n\n```javascript\nlet z = 100\n\nfunction addToZ(x, y) {\n  return x + y + z\n}\n```\n\n## 函数类型\n\n### 为函数定义类型\n\n让我们为上面那个函数添加类型：\n\n```typescript\nfunction add(x: number, y: number): number {\n  return x + y\n}\n\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n```\n\n我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。\n\n### 书写完整函数类型\n\n现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。\n\n```typescript\nlet myAdd: (x: number, y: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n\n```\n\n函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：\n\n```typescript\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x: number, y: number): number {\n  return x + y\n}\n```\n\n只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n\n第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(`=>`)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 `void` 而不能留空。\n\n函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。\n\n### 推断类型\n\n尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：\n\n```typescript\nlet myAdd = function(x: number, y: number): number { \n  return x + y\n}\n\nlet myAdd: (baseValue: number, increment: number) => number = \nfunction(x, y) {\n  return x + y\n}\n```\n\n这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n## 可选参数和默认参数\n\nTypeScript 里的每个函数参数都是必须的。 这不是指不能传递 `null` 或 `undefined` 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + ' ' + lastName;\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', 'Sr.');  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams');         // OK\n```\n\nJavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 `undefined`。 在TypeScript 里我们可以在参数名旁使用 `?` 实现可选参数的功能。 比如，我们想让 `lastName` 是可选的：\n\n```typescript\nfunction buildName(firstName: string, lastName?: string): string {\n  if (lastName)\n    return firstName + ' ' + lastName\n  else\n    return firstName\n}\n\nlet result1 = buildName('Bob');  // 现在正常了\nlet result2 = buildName('Bob', 'Adams', 'Sr.')  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')  // OK\n```\n\n可选参数必须跟在必须参数后面。 如果上例我们想让 `firstName` 是可选的，那么就必须调整它们的位置，把 `firstName` 放在后面。\n\n在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 `undefined` 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把`lastName` 的默认值设置为 `\"Smith\"`。\n\n```typescript\nfunction buildName(firstName: string, lastName = 'Smith'): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // 返回 \"Bob Smith\"\nlet result2 = buildName('Bob', undefined)     // 正常, 同样 \"Bob Smith\"\nlet result3 = buildName('Bob', 'Adams', 'Sr.')  // 错误, 参数过多\nlet result4 = buildName('Bob', 'Adams')        // OK\n```\n\n与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 `undefined` 值来获得默认值。 例如，我们重写最后一个例子，让 `firstName` 是带默认值的参数：\n\n```typescript\nfunction buildName(firstName = 'Will', lastName: string): string {\n  return firstName + ' ' + lastName\n}\n\nlet result1 = buildName('Bob')                  // Error, 参数过少\nlet result2 = buildName('Bob', 'Adams', \"Sr.\")  // Error, 参数过多\nlet result3 = buildName('Bob', 'Adams')         // OK， 返回 \"Bob Adams\"\nlet result4 = buildName(undefined, 'Adams')     // OK，  返回 \"Will Adams\"\n```\n\n### 剩余参数\n\n必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 `arguments` 来访问所有传入的参数。\n\n在 TypeScript 里，你可以把所有参数收集到一个变量里：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie')\n```\n\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ `...`）后面给定的名字，你可以在函数体内使用这个数组。\n\n这个省略号也会在带有剩余参数的函数类型定义上使用到：\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]): string {\n  return firstName + ' ' + restOfName.join(' ')\n}\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName\n```\n\n## this\n\n学习如何在 JavaScript 里正确使用 `this` 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 `this` 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 `this` 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 [Understanding JavaScript Function Invocation and \"this\"](http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)。 Yehuda 的文章详细的阐述了 `this` 的内部工作原理，因此我们这里只做简单介绍。\n\n### this 和箭头函数\n\nJavaScript里，`this` 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。\n\n下面看一个例子：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    return function() {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n可以看到 `createCardPicker` 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 `createCardPicker` 返回的函数里的 `this` 被设置成了 `global` 而不是 `deck` 对象。 因为我们只是独立的调用了 `cardPicker()`。 顶级的非方法式调用会将 `this` 视为 `global`。\n\n为了解决这个问题，我们可以在函数被返回时就绑好正确的`this`。 这样的话，无论之后怎么使用它，都会引用绑定的`deck` 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 `this` 值，而不是调用时的值：\n\n```typescript\nlet deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  createCardPicker: function() {\n    // 注意：这里使用箭头函数\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n### this 参数\n在上述的例子中 `this.suits[pickedSuit]` 的类型为 `any`，这是因为 `this` 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 `this` 参数。 `this` 参数是个假的参数，它出现在参数列表的最前面：\n\n```typescript\nfunction f(this: void) {\n  // 确保“this”在此独立函数中不可用\n}\n```\n\n让我们往例子里添加一些接口，`Card` 和 `Deck`，让类型重用能够变得清晰简单些：\n\n```typescript\ninterface Card {\n  suit: string\n  card: number\n}\n\ninterface Deck {\n  suits: string[]\n  cards: number[]\n\n  createCardPicker (this: Deck): () => Card\n}\n\nlet deck: Deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  // NOTE: 函数现在显式指定其被调用方必须是 deck 类型\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52)\n      let pickedSuit = Math.floor(pickedCard / 13)\n\n      return {suit: this.suits[pickedSuit], card: pickedCard % 13}\n    }\n  }\n}\n\nlet cardPicker = deck.createCardPicker()\nlet pickedCard = cardPicker()\n\nconsole.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit)\n```\n\n现在 TypeScrip t知道 `createCardPicker` 期望在某个 `Deck` 对象上调用。也就是说 `this` 是 `Deck` 类型的，而非 `any`。\n\n### this 参数在回调函数里\n\n你可以也看到过在回调函数里的 `this` 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，`this` 将为 `undefined`。 稍做改动，你就可以通过 `this` 参数来避免错误。 首先，库函数的作者要指定 `this` 的类型：\n\n```typescript\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void\n}\n```\n\n`this: void` 意味着 `addClickListener` 期望传入的 `onclick` 方法不需要 `this`\n\n```typescript\ninterface UIElement {\n  addClickListener (onclick: (this: void, e: Event) => void): void\n}\n\nclass Handler {\n  type: string\n\n  onClickBad (this: Handler, e: Event) {\n    this.type = e.type\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad) // error!\n\n```\n \n指定了 `this` 类型后，你显式声明 `onClickBad` 必须在 `Handler` 的实例上调用。 然后 TypeScript 会检测到 `addClickListener` 要求函数带有 `this: void`。 改变 `this` 类型来修复这个错误：\n\n```typescript\nclass Handler {\n  type: string;\n\n  onClickBad (this: void, e: Event) {\n    console.log('clicked!')\n  }\n}\n\nlet h = new Handler()\n\nlet uiElement: UIElement = {\n  addClickListener () {\n  }\n}\n\nuiElement.addClickListener(h.onClickBad)\n```\n\n因为 `onClickGood` 指定了 `this` 类型为 `void`，因此传递 `addClickListener` 是合法的。 当然了，这也意味着不能使用 `this.info`。 如果你两者都想要，你不得不使用箭头函数了：\n\n```typescript\nclass Handler {\n  type: string\n  onClickGood = (e: Event) => {\n    this.type = e.type \n  }\n}\n```\n\n这是可行的因为箭头函数不会捕获 `this`，所以你总是可以把它们传给期望 `this: void` 的函数。\n\n## 重载\n\nJavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n`pickCard` 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。\n\n方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 `pickCard` 函数。\n\n\n```typescript\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds']\n\nfunction pickCard(x: {suit: string; card: number }[]): number\nfunction pickCard(x: number): {suit: string; card: number }\n\nfunction pickCard(x): any {\n  if (Array.isArray(x)) {\n    let pickedCard = Math.floor(Math.random() * x.length)\n    return pickedCard\n  } else if (typeof x === 'number') {\n    let pickedSuit = Math.floor(x / 13)\n    return { suit: suits[pickedSuit], card: x % 13 }\n  }\n}\n\nlet myDeck = [\n  { suit: 'diamonds', card: 2 },\n  { suit: 'spades', card: 10 },\n  { suit: 'hearts', card: 4 }\n]\nlet pickedCard1 = myDeck[pickCard(myDeck)];\nconsole.log('card: ' + pickedCard1.card + ' of ' + pickedCard1.suit)\n\nlet pickedCard2 = pickCard(15)\nconsole.log('card: ' + pickedCard2.card + ' of ' + pickedCard2.suit)\n```\n\n这样改变后，重载的 `pickCard` 函数在调用的时候会进行正确的类型检查。\n\n为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\n注意，`function pickCard(x): any` 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 `pickCard` 会产生错误。\n","slug":"TypeScript 学习第四章 TypeScript函数","published":1,"updated":"2019-12-31T03:00:25.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj7z006kzws6ldrt5ldk","content":"<h1><span id=\"函数\">函数</span></h1>\n<p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p>\n<h2><span id=\"基本示例\">基本示例</span></h2>\n<p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p>\n<p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addToZ</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y + z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"函数类型\">函数类型</span></h2>\n<h3><span id=\"为函数定义类型\">为函数定义类型</span></h3>\n<p>让我们为上面那个函数添加类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p>\n<h3><span id=\"书写完整函数类型\">书写完整函数类型</span></h3>\n<p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>\n<p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code> 而不能留空。</p>\n<p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。</p>\n<h3><span id=\"推断类型\">推断类型</span></h3>\n<p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p>\n<h2><span id=\"可选参数和默认参数\">可选参数和默认参数</span></h2>\n<p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>);  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>);         <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lastName)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>);  <span class=\"comment\">// 现在正常了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)  <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>可选参数必须跟在必须参数后面。 如果上例我们想让 <code>firstName</code> 是可选的，那么就必须调整它们的位置，把 <code>firstName</code> 放在后面。</p>\n<p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把<code>lastName</code> 的默认值设置为 <code>&quot;Smith&quot;</code>。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = 'Smith'</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// 返回 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"literal\">undefined</span>)     <span class=\"comment\">// 正常, 同样 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// 错误, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)        <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code> 是带默认值的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName = 'Will', lastName: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">\"Sr.\"</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)         <span class=\"comment\">// OK， 返回 \"Bob Adams\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"literal\">undefined</span>, <span class=\"string\">'Adams'</span>)     <span class=\"comment\">// OK，  返回 \"Will Adams\"</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"剩余参数\">剩余参数</span></h3>\n<p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p>\n<p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employeeName = buildName(<span class=\"string\">'Joseph'</span>, <span class=\"string\">'Samuel'</span>, <span class=\"string\">'Lucas'</span>, <span class=\"string\">'MacKinzie'</span>)</span><br></pre></td></tr></table></figure>\n<p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>\n<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fname: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">string</span>[]</span>) =&gt;</span> <span class=\"built_in\">string</span> = buildName</span><br></pre></td></tr></table></figure>\n<h2><span id=\"this\">this</span></h2>\n<p>学习如何在 JavaScript 里正确使用 <code>this</code> 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 <code>this</code> 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 <code>this</code> 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 <a href=\"http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\" target=\"_blank\" rel=\"noopener\">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda 的文章详细的阐述了 <code>this</code> 的内部工作原理，因此我们这里只做简单介绍。</p>\n<h3><span id=\"this-和箭头函数\">this 和箭头函数</span></h3>\n<p>JavaScript里，<code>this</code> 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>\n<p>下面看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>createCardPicker</code> 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 <code>createCardPicker</code> 返回的函数里的 <code>this</code> 被设置成了 <code>global</code> 而不是 <code>deck</code> 对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code> 视为 <code>global</code>。</p>\n<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的<code>deck</code> 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 <code>this</code> 值，而不是调用时的值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：这里使用箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"this-参数\">this 参数</span></h3>\n<p>在上述的例子中 <code>this.suits[pickedSuit]</code> 的类型为 <code>any</code>，这是因为 <code>this</code> 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code> 参数。 <code>this</code> 参数是个假的参数，它出现在参数列表的最前面：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保“this”在此独立函数中不可用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">  suit: <span class=\"built_in\">string</span></span><br><span class=\"line\">  card: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">  suits: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  cards: <span class=\"built_in\">number</span>[]</span><br><span class=\"line\"></span><br><span class=\"line\">  createCardPicker (<span class=\"keyword\">this</span>: Deck): <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> Card</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 函数现在显式指定其被调用方必须是 deck 类型</span></span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"keyword\">this</span>: Deck</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>现在 TypeScrip t知道 <code>createCardPicker</code> 期望在某个 <code>Deck</code> 对象上调用。也就是说 <code>this</code> 是 <code>Deck</code> 类型的，而非 <code>any</code>。</p>\n<h3><span id=\"this-参数在回调函数里\">this 参数在回调函数里</span></h3>\n<p>你可以也看到过在回调函数里的 <code>this</code> 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，<code>this</code> 将为 <code>undefined</code>。 稍做改动，你就可以通过 <code>this</code> 参数来避免错误。 首先，库函数的作者要指定 <code>this</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener(onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>this: void</code> 意味着 <code>addClickListener</code> 期望传入的 <code>onclick</code> 方法不需要 <code>this</code></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener (onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: Handler, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad) <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>指定了 <code>this</code> 类型后，你显式声明 <code>onClickBad</code> 必须在 <code>Handler</code> 的实例上调用。 然后 TypeScript 会检测到 <code>addClickListener</code> 要求函数带有 <code>this: void</code>。 改变 <code>this</code> 类型来修复这个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'clicked!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>onClickGood</code> 指定了 <code>this</code> 类型为 <code>void</code>，因此传递 <code>addClickListener</code> 是合法的。 当然了，这也意味着不能使用 <code>this.info</code>。 如果你两者都想要，你不得不使用箭头函数了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  onClickGood = <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是可行的因为箭头函数不会捕获 <code>this</code>，所以你总是可以把它们传给期望 <code>this: void</code> 的函数。</p>\n<h2><span id=\"重载\">重载</span></h2>\n<p>JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p><code>pickCard</code> 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p>\n<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: &#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span> &#125;[]</span>): <span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): </span>&#123;<span class=\"title\">suit</span>: <span class=\"title\">string</span></span>; card: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p>这样改变后，重载的 <code>pickCard</code> 函数在调用的时候会进行正确的类型检查。</p>\n<p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>\n<p>注意，<code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 <code>pickCard</code> 会产生错误。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>函数</h1>\n<p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p>\n<h2>基本示例</h2>\n<p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p>\n<p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 里，函数可以使用函数体外部的变量。 当函数这么做时，我们说它‘捕获’了这些变量。 至于为什么可以这样做以及其中的利弊超出了本文的范围，但是深刻理解这个机制对学习 JavaScript 和 TypeScript 会很有帮助。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addToZ</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y + z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>函数类型</h2>\n<h3>为函数定义类型</h3>\n<p>让我们为上面那个函数添加类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。</p>\n<h3>书写完整函数类型</h3>\n<p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。 我们也可以这么写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>\n<p>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code> 而不能留空。</p>\n<p>函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成 API 的一部分。</p>\n<h3>推断类型</h3>\n<p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这叫做“按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p>\n<h2>可选参数和默认参数</h2>\n<p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>);  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>);         <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 <code>undefined</code>。 在TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。 比如，我们想让 <code>lastName</code> 是可选的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lastName)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>);  <span class=\"comment\">// 现在正常了</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)  <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>可选参数必须跟在必须参数后面。 如果上例我们想让 <code>firstName</code> 是可选的，那么就必须调整它们的位置，把 <code>firstName</code> 放在后面。</p>\n<p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 <code>undefined</code> 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把<code>lastName</code> 的默认值设置为 <code>&quot;Smith&quot;</code>。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = 'Smith'</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// 返回 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"literal\">undefined</span>)     <span class=\"comment\">// 正常, 同样 \"Bob Smith\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">'Sr.'</span>)  <span class=\"comment\">// 错误, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)        <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。 例如，我们重写最后一个例子，让 <code>firstName</code> 是带默认值的参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName = 'Will', lastName: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result1 = buildName(<span class=\"string\">'Bob'</span>)                  <span class=\"comment\">// Error, 参数过少</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result2 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>, <span class=\"string\">\"Sr.\"</span>)  <span class=\"comment\">// Error, 参数过多</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">'Bob'</span>, <span class=\"string\">'Adams'</span>)         <span class=\"comment\">// OK， 返回 \"Bob Adams\"</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result4 = buildName(<span class=\"literal\">undefined</span>, <span class=\"string\">'Adams'</span>)     <span class=\"comment\">// OK，  返回 \"Will Adams\"</span></span><br></pre></td></tr></table></figure>\n<h3>剩余参数</h3>\n<p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。</p>\n<p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employeeName = buildName(<span class=\"string\">'Joseph'</span>, <span class=\"string\">'Samuel'</span>, <span class=\"string\">'Lucas'</span>, <span class=\"string\">'MacKinzie'</span>)</span><br></pre></td></tr></table></figure>\n<p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ <code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>\n<p>这个省略号也会在带有剩余参数的函数类型定义上使用到：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">' '</span> + restOfName.join(<span class=\"string\">' '</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fname: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">string</span>[]</span>) =&gt;</span> <span class=\"built_in\">string</span> = buildName</span><br></pre></td></tr></table></figure>\n<h2>this</h2>\n<p>学习如何在 JavaScript 里正确使用 <code>this</code> 就好比一场成年礼。由于 TypeScript 是 JavaScript 的超集，TypeScript 程序员也需要弄清 <code>this</code> 工作机制并且当有 bug 的时候能够找出错误所在。 幸运的是，TypeScript 能通知你错误地使用了 <code>this</code> 的地方。 如果你想了解 JavaScript 里的 this是如何工作的，那么首先阅读 Yehuda Katz 写的 <a href=\"http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\" target=\"_blank\" rel=\"noopener\">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda 的文章详细的阐述了 <code>this</code> 的内部工作原理，因此我们这里只做简单介绍。</p>\n<h3>this 和箭头函数</h3>\n<p>JavaScript里，<code>this</code> 的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>\n<p>下面看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>可以看到 <code>createCardPicker</code> 是个函数，并且它又返回了一个函数。如果我们尝试运行这个程序，会发现它并没有输出而是报错了。 因为 <code>createCardPicker</code> 返回的函数里的 <code>this</code> 被设置成了 <code>global</code> 而不是 <code>deck</code> 对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code> 视为 <code>global</code>。</p>\n<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的<code>deck</code> 对象。 我们需要改变函数表达式来使用 ECMAScript 6 箭头语法。 箭头函数能保存函数创建时的 <code>this</code> 值，而不是调用时的值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：这里使用箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<h3>this 参数</h3>\n<p>在上述的例子中 <code>this.suits[pickedSuit]</code> 的类型为 <code>any</code>，这是因为 <code>this</code> 来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code> 参数。 <code>this</code> 参数是个假的参数，它出现在参数列表的最前面：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保“this”在此独立函数中不可用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">  suit: <span class=\"built_in\">string</span></span><br><span class=\"line\">  card: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">  suits: <span class=\"built_in\">string</span>[]</span><br><span class=\"line\">  cards: <span class=\"built_in\">number</span>[]</span><br><span class=\"line\"></span><br><span class=\"line\">  createCardPicker (<span class=\"keyword\">this</span>: Deck): <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> Card</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> 函数现在显式指定其被调用方必须是 deck 类型</span></span><br><span class=\"line\">  createCardPicker: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"keyword\">this</span>: Deck</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;suit: <span class=\"keyword\">this</span>.suits[pickedSuit], card: pickedCard % <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker()</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard.card + <span class=\"string\">' of '</span> + pickedCard.suit)</span><br></pre></td></tr></table></figure>\n<p>现在 TypeScrip t知道 <code>createCardPicker</code> 期望在某个 <code>Deck</code> 对象上调用。也就是说 <code>this</code> 是 <code>Deck</code> 类型的，而非 <code>any</code>。</p>\n<h3>this 参数在回调函数里</h3>\n<p>你可以也看到过在回调函数里的 <code>this</code> 报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用，<code>this</code> 将为 <code>undefined</code>。 稍做改动，你就可以通过 <code>this</code> 参数来避免错误。 首先，库函数的作者要指定 <code>this</code> 的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener(onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>this: void</code> 意味着 <code>addClickListener</code> 期望传入的 <code>onclick</code> 方法不需要 <code>this</code></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> UIElement &#123;</span><br><span class=\"line\">  addClickListener (onclick: <span class=\"function\">(<span class=\"params\"><span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: Handler, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad) <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>指定了 <code>this</code> 类型后，你显式声明 <code>onClickBad</code> 必须在 <code>Handler</code> 的实例上调用。 然后 TypeScript 会检测到 <code>addClickListener</code> 要求函数带有 <code>this: void</code>。 改变 <code>this</code> 类型来修复这个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  onClickBad (<span class=\"keyword\">this</span>: <span class=\"built_in\">void</span>, e: Event) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'clicked!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> h = <span class=\"keyword\">new</span> Handler()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> uiElement: UIElement = &#123;</span><br><span class=\"line\">  addClickListener () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">uiElement.addClickListener(h.onClickBad)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>onClickGood</code> 指定了 <code>this</code> 类型为 <code>void</code>，因此传递 <code>addClickListener</code> 是合法的。 当然了，这也意味着不能使用 <code>this.info</code>。 如果你两者都想要，你不得不使用箭头函数了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Handler &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span>: <span class=\"built_in\">string</span></span><br><span class=\"line\">  onClickGood = <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = e.type </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是可行的因为箭头函数不会捕获 <code>this</code>，所以你总是可以把它们传给期望 <code>this: void</code> 的函数。</p>\n<h2>重载</h2>\n<p>JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p><code>pickCard</code> 方法根据传入参数的不同会返回两种不同的类型。如果传入的是代表纸牌的对象数组，函数作用是从中抓一张牌。如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p>\n<p>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 <code>pickCard</code> 函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> suits = [<span class=\"string\">'hearts'</span>, <span class=\"string\">'spades'</span>, <span class=\"string\">'clubs'</span>, <span class=\"string\">'diamonds'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: &#123;suit: <span class=\"built_in\">string</span>; card: <span class=\"built_in\">number</span> &#125;[]</span>): <span class=\"title\">number</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): </span>&#123;<span class=\"title\">suit</span>: <span class=\"title\">string</span></span>; card: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pickCard</span>(<span class=\"params\">x</span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(x)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * x.length)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pickedCard</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(x / <span class=\"number\">13</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; suit: suits[pickedSuit], card: x % <span class=\"number\">13</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myDeck = [</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'diamonds'</span>, card: <span class=\"number\">2</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'spades'</span>, card: <span class=\"number\">10</span> &#125;,</span><br><span class=\"line\">  &#123; suit: <span class=\"string\">'hearts'</span>, card: <span class=\"number\">4</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard1.card + <span class=\"string\">' of '</span> + pickedCard1.suit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard2 = pickCard(<span class=\"number\">15</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'card: '</span> + pickedCard2.card + <span class=\"string\">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>\n<p>这样改变后，重载的 <code>pickCard</code> 函数在调用的时候会进行正确的类型检查。</p>\n<p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>\n<p>注意，<code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象数组，另一个接收数字。 以其它参数调用 <code>pickCard</code> 会产生错误。</p>\n"},{"title":"Vue 源码阅读 模板编译（七）","catalog":true,"date":"2019-10-26T14:39:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n到现在，模板编译的三大阶段就已经全部介绍完毕了，接下来本篇文章，就以宏观角度回顾并梳理一下模板编译整个流程是怎样的。\n\n首先，我们需要搞清楚模板编译的最终目的是什么，它的最终目的就是：把用户所写的模板转化成供`Vue`实例在挂载时可调用的`render`函数。或者你可以这样简单的理解为：模板编译就是一台机器，给它输入模板字符串，它就输出对应的`render`函数。\n\n我们把模板编译的最终目的只要牢记在心以后，那么模板编译中间的所有的变化都是在为达到这个目的而努力。\n\n接下来我们就以宏观角度来梳理一下模板编译的整个流程。\n\n## 2. 整体流程\n\n上文说了，模板编译就是把模板转化成供`Vue`实例在挂载时可调用的`render`函数。那么我们就从`Vue`实例挂载时入手，一步一步从后往前推。我们知道，`Vue`实例在挂载时会调用全局实例方法——`$mount`方法(关于该方法后面会详细介绍)。那么我们就先看一下`$mount`方法，如下：\n\n```javascript\nVue.prototype.$mount = function (el){\n    const options = this.$options\n    // 如果用户没有手写render函数\n    if (!options.render) {\n        // 获取模板，先尝试获取内部模板，如果获取不到则获取外部模板\n        let template = options.template\n        if (template) {\n            \n        } else {\n             template = getOuterHTML(el)\n        }\n        const { render, staticRenderFns } = compileToFunctions(template, {\n            shouldDecodeNewlines,\n            shouldDecodeNewlinesForHref,\n            delimiters: options.delimiters,\n            comments: options.comments\n          }, this)\n        options.render = render\n        options.staticRenderFns = staticRenderFns\n    }\n}\n```\n\n从上述代码中可以看到，首先从`Vue`实例的属性选项中获取`render`选项，如果没有获取到，说明用户没有手写`render`函数，那么此时，就像上一篇文章中说的，需要`Vue`自己将模板转化成`render`函数。接着获取模板，先尝试获取内部模板，如果获取不到则获取外部模板。最后，调用`compileToFunctions`函数将模板转化成`render`函数，再将`render`函数赋值给`options.render`。\n\n显然，上面代码中的核心部分是调用`compileToFunctions`函数生成`render`函数的部分，如下：\n\n```javascript\nconst { render, staticRenderFns } = compileToFunctions(template, {\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n```\n\n将模板`template`传给`compileToFunctions`函数就可以得到`render `函数，那这个`compileToFunctions`函数是怎么来的呢？\n\n我们通过代码跳转发现`compileToFunctions`函数的出处如下：\n\n```javascript\nconst { compile, compileToFunctions } = createCompiler(baseOptions)\n```\n\n我们发现，`compileToFunctions`函数是 `createCompiler` 函数的返回值对象中的其中一个，`createCompiler` 函数顾名思义他的作用就是创建一个编译器。那么我们再继续往前推，看看`createCompiler` 函数又是从哪来的。\n\n`createCompiler` 函数出处位于源码的`src/complier/index.js`文件中，如下：\n\n```javascript\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；\n    optimize(ast, options)\n  }\n  // 代码生成阶段：将AST转换成渲染函数；\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n```\n\n可以看到，`createCompiler`函数是又 调用`createCompilerCreator` 函数返回得到的，`createCompilerCreator` 函数接收一个`baseCompile`函数作为参数。我们仔细看这个`baseCompile`函数，这个函数就是我们所说的模板编译三大阶段的主函数。将这个函数传给`createCompilerCreator` 函数就可以得到`createCompiler`函数，那么我们再往前推，看一下`createCompilerCreator` 函数又是怎么定义的。\n\n`createCompilerCreator` 函数的定义位于源码的`src/complier/create-compiler.js`文件中，如下：\n\n```javascript\nexport function createCompilerCreator (baseCompile) {\n    return function createCompiler (baseOptions) {\n        \n    }\n}\n```\n\n可以看到，调用`createCompilerCreator` 函数会返回`createCompiler`函数，同时我们也可以看到`createCompiler`函数的定义，如下：\n\n```javascript\nfunction createCompiler (baseOptions) {\n    function compile (){\n\n    } \n    return {\n      compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n}\n```\n\n在`createCompiler`函数的内部定义了一个子函数`compile`，同时返回一个对象，其中这个对象的第二个属性就是我们在开头看到的`compileToFunctions`，其值对应的是`createCompileToFunctionFn(compile)`函数的返回值，那么我们再往前推，看看`createCompileToFunctionFn(compile)`函数又是怎么样的。\n\n`createCompileToFunctionFn(compile)`函数的出处位于源码的`src/complier/to-function.js`文件中，如下：\n\n```javascript\nexport function createCompileToFunctionFn (compile) {\n     return function compileToFunctions (){\n         // compile\n    \tconst compiled = compile(template, options)\n        res.render = createFunction(compiled.render, fnGenErrors)\n     }\n}\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err, code })\n    return noop\n  }\n}\n```\n\n可以看到，调用`createCompileToFunctionFn`函数就可以得到`compileToFunctions`函数了，终于推到头了，原来最开始调用`compileToFunctions`函数是在这里定义的，那么我们就来看一下`compileToFunctions`函数内部都干了些什么。\n\n`compileToFunctions`函数内部会调用传入的`compile`函数，而这个`compile`函数是`createCompiler`函数内部定义的子函数，如下：\n\n```javascript\nfunction compile (template,options) {\n    const compiled = baseCompile(template, finalOptions)\n    compiled.errors = errors\n    compiled.tips = tips\n    return compiled\n}\n```\n\n在`compile`函数内部又会调用传入的`baseCompile`函数，而这个`baseCompile`函数就是我们所说的模板编译三大阶段的主线函数，如下：\n\n```javascript\nfunction baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；\n    optimize(ast, options)\n  }\n  // 代码生成阶段：将AST转换成渲染函数；\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n\n```\n\n那么现在就清晰了，最开始调用的`compileToFunctions`函数内部调用了`compile`函数，在`compile`函数内部又调用了`baseCompile`函数，而`baseCompile`函数返回的是代码生成阶段生成好的`render`函数字符串。所以在`compileToFunctions`函数内部调用`compile`函数就可以拿到生成好的`render`函数字符串，然后在`compileToFunctions`函数内部将`render`函数字符串传给`createFunction`函数从而变成真正的`render`函数返回出去，最后将其赋值给`options.render`。为了便于更好的理解，我们画出了其上述过程的流程图，如下：\n\n![](/img/complie/8.jpg)\n\n以上，就是模板编译的整体流程。\n\n\n","source":"_posts/Vue 源码阅读 模板编译（七）.md","raw":"---\ntitle: Vue 源码阅读 模板编译（七）\ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-26 22:39:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n到现在，模板编译的三大阶段就已经全部介绍完毕了，接下来本篇文章，就以宏观角度回顾并梳理一下模板编译整个流程是怎样的。\n\n首先，我们需要搞清楚模板编译的最终目的是什么，它的最终目的就是：把用户所写的模板转化成供`Vue`实例在挂载时可调用的`render`函数。或者你可以这样简单的理解为：模板编译就是一台机器，给它输入模板字符串，它就输出对应的`render`函数。\n\n我们把模板编译的最终目的只要牢记在心以后，那么模板编译中间的所有的变化都是在为达到这个目的而努力。\n\n接下来我们就以宏观角度来梳理一下模板编译的整个流程。\n\n## 2. 整体流程\n\n上文说了，模板编译就是把模板转化成供`Vue`实例在挂载时可调用的`render`函数。那么我们就从`Vue`实例挂载时入手，一步一步从后往前推。我们知道，`Vue`实例在挂载时会调用全局实例方法——`$mount`方法(关于该方法后面会详细介绍)。那么我们就先看一下`$mount`方法，如下：\n\n```javascript\nVue.prototype.$mount = function (el){\n    const options = this.$options\n    // 如果用户没有手写render函数\n    if (!options.render) {\n        // 获取模板，先尝试获取内部模板，如果获取不到则获取外部模板\n        let template = options.template\n        if (template) {\n            \n        } else {\n             template = getOuterHTML(el)\n        }\n        const { render, staticRenderFns } = compileToFunctions(template, {\n            shouldDecodeNewlines,\n            shouldDecodeNewlinesForHref,\n            delimiters: options.delimiters,\n            comments: options.comments\n          }, this)\n        options.render = render\n        options.staticRenderFns = staticRenderFns\n    }\n}\n```\n\n从上述代码中可以看到，首先从`Vue`实例的属性选项中获取`render`选项，如果没有获取到，说明用户没有手写`render`函数，那么此时，就像上一篇文章中说的，需要`Vue`自己将模板转化成`render`函数。接着获取模板，先尝试获取内部模板，如果获取不到则获取外部模板。最后，调用`compileToFunctions`函数将模板转化成`render`函数，再将`render`函数赋值给`options.render`。\n\n显然，上面代码中的核心部分是调用`compileToFunctions`函数生成`render`函数的部分，如下：\n\n```javascript\nconst { render, staticRenderFns } = compileToFunctions(template, {\n        shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this)\n```\n\n将模板`template`传给`compileToFunctions`函数就可以得到`render `函数，那这个`compileToFunctions`函数是怎么来的呢？\n\n我们通过代码跳转发现`compileToFunctions`函数的出处如下：\n\n```javascript\nconst { compile, compileToFunctions } = createCompiler(baseOptions)\n```\n\n我们发现，`compileToFunctions`函数是 `createCompiler` 函数的返回值对象中的其中一个，`createCompiler` 函数顾名思义他的作用就是创建一个编译器。那么我们再继续往前推，看看`createCompiler` 函数又是从哪来的。\n\n`createCompiler` 函数出处位于源码的`src/complier/index.js`文件中，如下：\n\n```javascript\nexport const createCompiler = createCompilerCreator(function baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；\n    optimize(ast, options)\n  }\n  // 代码生成阶段：将AST转换成渲染函数；\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})\n```\n\n可以看到，`createCompiler`函数是又 调用`createCompilerCreator` 函数返回得到的，`createCompilerCreator` 函数接收一个`baseCompile`函数作为参数。我们仔细看这个`baseCompile`函数，这个函数就是我们所说的模板编译三大阶段的主函数。将这个函数传给`createCompilerCreator` 函数就可以得到`createCompiler`函数，那么我们再往前推，看一下`createCompilerCreator` 函数又是怎么定义的。\n\n`createCompilerCreator` 函数的定义位于源码的`src/complier/create-compiler.js`文件中，如下：\n\n```javascript\nexport function createCompilerCreator (baseCompile) {\n    return function createCompiler (baseOptions) {\n        \n    }\n}\n```\n\n可以看到，调用`createCompilerCreator` 函数会返回`createCompiler`函数，同时我们也可以看到`createCompiler`函数的定义，如下：\n\n```javascript\nfunction createCompiler (baseOptions) {\n    function compile (){\n\n    } \n    return {\n      compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n}\n```\n\n在`createCompiler`函数的内部定义了一个子函数`compile`，同时返回一个对象，其中这个对象的第二个属性就是我们在开头看到的`compileToFunctions`，其值对应的是`createCompileToFunctionFn(compile)`函数的返回值，那么我们再往前推，看看`createCompileToFunctionFn(compile)`函数又是怎么样的。\n\n`createCompileToFunctionFn(compile)`函数的出处位于源码的`src/complier/to-function.js`文件中，如下：\n\n```javascript\nexport function createCompileToFunctionFn (compile) {\n     return function compileToFunctions (){\n         // compile\n    \tconst compiled = compile(template, options)\n        res.render = createFunction(compiled.render, fnGenErrors)\n     }\n}\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err, code })\n    return noop\n  }\n}\n```\n\n可以看到，调用`createCompileToFunctionFn`函数就可以得到`compileToFunctions`函数了，终于推到头了，原来最开始调用`compileToFunctions`函数是在这里定义的，那么我们就来看一下`compileToFunctions`函数内部都干了些什么。\n\n`compileToFunctions`函数内部会调用传入的`compile`函数，而这个`compile`函数是`createCompiler`函数内部定义的子函数，如下：\n\n```javascript\nfunction compile (template,options) {\n    const compiled = baseCompile(template, finalOptions)\n    compiled.errors = errors\n    compiled.tips = tips\n    return compiled\n}\n```\n\n在`compile`函数内部又会调用传入的`baseCompile`函数，而这个`baseCompile`函数就是我们所说的模板编译三大阶段的主线函数，如下：\n\n```javascript\nfunction baseCompile (\n  template: string,\n  options: CompilerOptions\n): CompiledResult {\n  // 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST\n  const ast = parse(template.trim(), options)\n  if (options.optimize !== false) {\n    // 优化阶段：遍历AST，找出其中的静态节点，并打上标记；\n    optimize(ast, options)\n  }\n  // 代码生成阶段：将AST转换成渲染函数；\n  const code = generate(ast, options)\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n\n```\n\n那么现在就清晰了，最开始调用的`compileToFunctions`函数内部调用了`compile`函数，在`compile`函数内部又调用了`baseCompile`函数，而`baseCompile`函数返回的是代码生成阶段生成好的`render`函数字符串。所以在`compileToFunctions`函数内部调用`compile`函数就可以拿到生成好的`render`函数字符串，然后在`compileToFunctions`函数内部将`render`函数字符串传给`createFunction`函数从而变成真正的`render`函数返回出去，最后将其赋值给`options.render`。为了便于更好的理解，我们画出了其上述过程的流程图，如下：\n\n![](/img/complie/8.jpg)\n\n以上，就是模板编译的整体流程。\n\n\n","slug":"Vue 源码阅读 模板编译（七）","published":1,"updated":"2019-12-31T03:24:30.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj80006nzws6uras5da7","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>到现在，模板编译的三大阶段就已经全部介绍完毕了，接下来本篇文章，就以宏观角度回顾并梳理一下模板编译整个流程是怎样的。</p>\n<p>首先，我们需要搞清楚模板编译的最终目的是什么，它的最终目的就是：把用户所写的模板转化成供<code>Vue</code>实例在挂载时可调用的<code>render</code>函数。或者你可以这样简单的理解为：模板编译就是一台机器，给它输入模板字符串，它就输出对应的<code>render</code>函数。</p>\n<p>我们把模板编译的最终目的只要牢记在心以后，那么模板编译中间的所有的变化都是在为达到这个目的而努力。</p>\n<p>接下来我们就以宏观角度来梳理一下模板编译的整个流程。</p>\n<h2><span id=\"2-整体流程\">2. 整体流程</span></h2>\n<p>上文说了，模板编译就是把模板转化成供<code>Vue</code>实例在挂载时可调用的<code>render</code>函数。那么我们就从<code>Vue</code>实例挂载时入手，一步一步从后往前推。我们知道，<code>Vue</code>实例在挂载时会调用全局实例方法——<code>$mount</code>方法(关于该方法后面会详细介绍)。那么我们就先看一下<code>$mount</code>方法，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$mount = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">    <span class=\"comment\">// 如果用户没有手写render函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options.render) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取模板，先尝试获取内部模板，如果获取不到则获取外部模板</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> template = options.template</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (template) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             template = getOuterHTML(el)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class=\"line\">            shouldDecodeNewlines,</span><br><span class=\"line\">            shouldDecodeNewlinesForHref,</span><br><span class=\"line\">            delimiters: options.delimiters,</span><br><span class=\"line\">            comments: options.comments</span><br><span class=\"line\">          &#125;, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">        options.render = render</span><br><span class=\"line\">        options.staticRenderFns = staticRenderFns</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码中可以看到，首先从<code>Vue</code>实例的属性选项中获取<code>render</code>选项，如果没有获取到，说明用户没有手写<code>render</code>函数，那么此时，就像上一篇文章中说的，需要<code>Vue</code>自己将模板转化成<code>render</code>函数。接着获取模板，先尝试获取内部模板，如果获取不到则获取外部模板。最后，调用<code>compileToFunctions</code>函数将模板转化成<code>render</code>函数，再将<code>render</code>函数赋值给<code>options.render</code>。</p>\n<p>显然，上面代码中的核心部分是调用<code>compileToFunctions</code>函数生成<code>render</code>函数的部分，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class=\"line\">        shouldDecodeNewlines,</span><br><span class=\"line\">        shouldDecodeNewlinesForHref,</span><br><span class=\"line\">        delimiters: options.delimiters,</span><br><span class=\"line\">        comments: options.comments</span><br><span class=\"line\">      &#125;, <span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n<p>将模板<code>template</code>传给<code>compileToFunctions</code>函数就可以得到<code>render</code>函数，那这个<code>compileToFunctions</code>函数是怎么来的呢？</p>\n<p>我们通过代码跳转发现<code>compileToFunctions</code>函数的出处如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; compile, compileToFunctions &#125; = createCompiler(baseOptions)</span><br></pre></td></tr></table></figure>\n<p>我们发现，<code>compileToFunctions</code>函数是 <code>createCompiler</code> 函数的返回值对象中的其中一个，<code>createCompiler</code> 函数顾名思义他的作用就是创建一个编译器。那么我们再继续往前推，看看<code>createCompiler</code> 函数又是从哪来的。</p>\n<p><code>createCompiler</code> 函数出处位于源码的<code>src/complier/index.js</code>文件中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompiler = createCompilerCreator(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.optimize !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span></span><br><span class=\"line\">    optimize(ast, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 代码生成阶段：将AST转换成渲染函数；</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    render: code.render,</span><br><span class=\"line\">    staticRenderFns: code.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>createCompiler</code>函数是又 调用<code>createCompilerCreator</code> 函数返回得到的，<code>createCompilerCreator</code> 函数接收一个<code>baseCompile</code>函数作为参数。我们仔细看这个<code>baseCompile</code>函数，这个函数就是我们所说的模板编译三大阶段的主函数。将这个函数传给<code>createCompilerCreator</code> 函数就可以得到<code>createCompiler</code>函数，那么我们再往前推，看一下<code>createCompilerCreator</code> 函数又是怎么定义的。</p>\n<p><code>createCompilerCreator</code> 函数的定义位于源码的<code>src/complier/create-compiler.js</code>文件中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompilerCreator</span> (<span class=\"params\">baseCompile</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompiler</span> (<span class=\"params\">baseOptions</span>) </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，调用<code>createCompilerCreator</code> 函数会返回<code>createCompiler</code>函数，同时我们也可以看到<code>createCompiler</code>函数的定义，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompiler</span> (<span class=\"params\">baseOptions</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compile</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      compile,</span><br><span class=\"line\">      compileToFunctions: createCompileToFunctionFn(compile)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>createCompiler</code>函数的内部定义了一个子函数<code>compile</code>，同时返回一个对象，其中这个对象的第二个属性就是我们在开头看到的<code>compileToFunctions</code>，其值对应的是<code>createCompileToFunctionFn(compile)</code>函数的返回值，那么我们再往前推，看看<code>createCompileToFunctionFn(compile)</code>函数又是怎么样的。</p>\n<p><code>createCompileToFunctionFn(compile)</code>函数的出处位于源码的<code>src/complier/to-function.js</code>文件中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompileToFunctionFn</span> (<span class=\"params\">compile</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compileToFunctions</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">// compile</span></span><br><span class=\"line\">    \t<span class=\"keyword\">const</span> compiled = compile(template, options)</span><br><span class=\"line\">        res.render = createFunction(compiled.render, fnGenErrors)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunction</span> (<span class=\"params\">code, errors</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(code)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    errors.push(&#123; err, code &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> noop</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，调用<code>createCompileToFunctionFn</code>函数就可以得到<code>compileToFunctions</code>函数了，终于推到头了，原来最开始调用<code>compileToFunctions</code>函数是在这里定义的，那么我们就来看一下<code>compileToFunctions</code>函数内部都干了些什么。</p>\n<p><code>compileToFunctions</code>函数内部会调用传入的<code>compile</code>函数，而这个<code>compile</code>函数是<code>createCompiler</code>函数内部定义的子函数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compile</span> (<span class=\"params\">template,options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compiled = baseCompile(template, finalOptions)</span><br><span class=\"line\">    compiled.errors = errors</span><br><span class=\"line\">    compiled.tips = tips</span><br><span class=\"line\">    <span class=\"keyword\">return</span> compiled</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>compile</code>函数内部又会调用传入的<code>baseCompile</code>函数，而这个<code>baseCompile</code>函数就是我们所说的模板编译三大阶段的主线函数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.optimize !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span></span><br><span class=\"line\">    optimize(ast, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 代码生成阶段：将AST转换成渲染函数；</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    render: code.render,</span><br><span class=\"line\">    staticRenderFns: code.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>那么现在就清晰了，最开始调用的<code>compileToFunctions</code>函数内部调用了<code>compile</code>函数，在<code>compile</code>函数内部又调用了<code>baseCompile</code>函数，而<code>baseCompile</code>函数返回的是代码生成阶段生成好的<code>render</code>函数字符串。所以在<code>compileToFunctions</code>函数内部调用<code>compile</code>函数就可以拿到生成好的<code>render</code>函数字符串，然后在<code>compileToFunctions</code>函数内部将<code>render</code>函数字符串传给<code>createFunction</code>函数从而变成真正的<code>render</code>函数返回出去，最后将其赋值给<code>options.render</code>。为了便于更好的理解，我们画出了其上述过程的流程图，如下：</p>\n<p><img src=\"/img/complie/8.jpg\" alt></p>\n<p>以上，就是模板编译的整体流程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>到现在，模板编译的三大阶段就已经全部介绍完毕了，接下来本篇文章，就以宏观角度回顾并梳理一下模板编译整个流程是怎样的。</p>\n<p>首先，我们需要搞清楚模板编译的最终目的是什么，它的最终目的就是：把用户所写的模板转化成供<code>Vue</code>实例在挂载时可调用的<code>render</code>函数。或者你可以这样简单的理解为：模板编译就是一台机器，给它输入模板字符串，它就输出对应的<code>render</code>函数。</p>\n<p>我们把模板编译的最终目的只要牢记在心以后，那么模板编译中间的所有的变化都是在为达到这个目的而努力。</p>\n<p>接下来我们就以宏观角度来梳理一下模板编译的整个流程。</p>\n<h2>2. 整体流程</h2>\n<p>上文说了，模板编译就是把模板转化成供<code>Vue</code>实例在挂载时可调用的<code>render</code>函数。那么我们就从<code>Vue</code>实例挂载时入手，一步一步从后往前推。我们知道，<code>Vue</code>实例在挂载时会调用全局实例方法——<code>$mount</code>方法(关于该方法后面会详细介绍)。那么我们就先看一下<code>$mount</code>方法，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$mount = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = <span class=\"keyword\">this</span>.$options</span><br><span class=\"line\">    <span class=\"comment\">// 如果用户没有手写render函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options.render) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取模板，先尝试获取内部模板，如果获取不到则获取外部模板</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> template = options.template</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (template) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">             template = getOuterHTML(el)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class=\"line\">            shouldDecodeNewlines,</span><br><span class=\"line\">            shouldDecodeNewlinesForHref,</span><br><span class=\"line\">            delimiters: options.delimiters,</span><br><span class=\"line\">            comments: options.comments</span><br><span class=\"line\">          &#125;, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">        options.render = render</span><br><span class=\"line\">        options.staticRenderFns = staticRenderFns</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上述代码中可以看到，首先从<code>Vue</code>实例的属性选项中获取<code>render</code>选项，如果没有获取到，说明用户没有手写<code>render</code>函数，那么此时，就像上一篇文章中说的，需要<code>Vue</code>自己将模板转化成<code>render</code>函数。接着获取模板，先尝试获取内部模板，如果获取不到则获取外部模板。最后，调用<code>compileToFunctions</code>函数将模板转化成<code>render</code>函数，再将<code>render</code>函数赋值给<code>options.render</code>。</p>\n<p>显然，上面代码中的核心部分是调用<code>compileToFunctions</code>函数生成<code>render</code>函数的部分，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class=\"line\">        shouldDecodeNewlines,</span><br><span class=\"line\">        shouldDecodeNewlinesForHref,</span><br><span class=\"line\">        delimiters: options.delimiters,</span><br><span class=\"line\">        comments: options.comments</span><br><span class=\"line\">      &#125;, <span class=\"keyword\">this</span>)</span><br></pre></td></tr></table></figure>\n<p>将模板<code>template</code>传给<code>compileToFunctions</code>函数就可以得到<code>render</code>函数，那这个<code>compileToFunctions</code>函数是怎么来的呢？</p>\n<p>我们通过代码跳转发现<code>compileToFunctions</code>函数的出处如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; compile, compileToFunctions &#125; = createCompiler(baseOptions)</span><br></pre></td></tr></table></figure>\n<p>我们发现，<code>compileToFunctions</code>函数是 <code>createCompiler</code> 函数的返回值对象中的其中一个，<code>createCompiler</code> 函数顾名思义他的作用就是创建一个编译器。那么我们再继续往前推，看看<code>createCompiler</code> 函数又是从哪来的。</p>\n<p><code>createCompiler</code> 函数出处位于源码的<code>src/complier/index.js</code>文件中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompiler = createCompilerCreator(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.optimize !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span></span><br><span class=\"line\">    optimize(ast, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 代码生成阶段：将AST转换成渲染函数；</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    render: code.render,</span><br><span class=\"line\">    staticRenderFns: code.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>createCompiler</code>函数是又 调用<code>createCompilerCreator</code> 函数返回得到的，<code>createCompilerCreator</code> 函数接收一个<code>baseCompile</code>函数作为参数。我们仔细看这个<code>baseCompile</code>函数，这个函数就是我们所说的模板编译三大阶段的主函数。将这个函数传给<code>createCompilerCreator</code> 函数就可以得到<code>createCompiler</code>函数，那么我们再往前推，看一下<code>createCompilerCreator</code> 函数又是怎么定义的。</p>\n<p><code>createCompilerCreator</code> 函数的定义位于源码的<code>src/complier/create-compiler.js</code>文件中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompilerCreator</span> (<span class=\"params\">baseCompile</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompiler</span> (<span class=\"params\">baseOptions</span>) </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，调用<code>createCompilerCreator</code> 函数会返回<code>createCompiler</code>函数，同时我们也可以看到<code>createCompiler</code>函数的定义，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompiler</span> (<span class=\"params\">baseOptions</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compile</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      compile,</span><br><span class=\"line\">      compileToFunctions: createCompileToFunctionFn(compile)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>createCompiler</code>函数的内部定义了一个子函数<code>compile</code>，同时返回一个对象，其中这个对象的第二个属性就是我们在开头看到的<code>compileToFunctions</code>，其值对应的是<code>createCompileToFunctionFn(compile)</code>函数的返回值，那么我们再往前推，看看<code>createCompileToFunctionFn(compile)</code>函数又是怎么样的。</p>\n<p><code>createCompileToFunctionFn(compile)</code>函数的出处位于源码的<code>src/complier/to-function.js</code>文件中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createCompileToFunctionFn</span> (<span class=\"params\">compile</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compileToFunctions</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">// compile</span></span><br><span class=\"line\">    \t<span class=\"keyword\">const</span> compiled = compile(template, options)</span><br><span class=\"line\">        res.render = createFunction(compiled.render, fnGenErrors)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunction</span> (<span class=\"params\">code, errors</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(code)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    errors.push(&#123; err, code &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> noop</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，调用<code>createCompileToFunctionFn</code>函数就可以得到<code>compileToFunctions</code>函数了，终于推到头了，原来最开始调用<code>compileToFunctions</code>函数是在这里定义的，那么我们就来看一下<code>compileToFunctions</code>函数内部都干了些什么。</p>\n<p><code>compileToFunctions</code>函数内部会调用传入的<code>compile</code>函数，而这个<code>compile</code>函数是<code>createCompiler</code>函数内部定义的子函数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compile</span> (<span class=\"params\">template,options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compiled = baseCompile(template, finalOptions)</span><br><span class=\"line\">    compiled.errors = errors</span><br><span class=\"line\">    compiled.tips = tips</span><br><span class=\"line\">    <span class=\"keyword\">return</span> compiled</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>compile</code>函数内部又会调用传入的<code>baseCompile</code>函数，而这个<code>baseCompile</code>函数就是我们所说的模板编译三大阶段的主线函数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 模板解析阶段：用正则等方式解析 template 模板中的指令、class、style等数据，形成AST</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.optimize !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span></span><br><span class=\"line\">    optimize(ast, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 代码生成阶段：将AST转换成渲染函数；</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ast,</span><br><span class=\"line\">    render: code.render,</span><br><span class=\"line\">    staticRenderFns: code.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>那么现在就清晰了，最开始调用的<code>compileToFunctions</code>函数内部调用了<code>compile</code>函数，在<code>compile</code>函数内部又调用了<code>baseCompile</code>函数，而<code>baseCompile</code>函数返回的是代码生成阶段生成好的<code>render</code>函数字符串。所以在<code>compileToFunctions</code>函数内部调用<code>compile</code>函数就可以拿到生成好的<code>render</code>函数字符串，然后在<code>compileToFunctions</code>函数内部将<code>render</code>函数字符串传给<code>createFunction</code>函数从而变成真正的<code>render</code>函数返回出去，最后将其赋值给<code>options.render</code>。为了便于更好的理解，我们画出了其上述过程的流程图，如下：</p>\n<p><img src=\"/img/complie/8.jpg\" alt></p>\n<p>以上，就是模板编译的整体流程。</p>\n"},{"title":"Vue 源码阅读 模板编译（五）","catalog":true,"date":"2019-10-21T12:45:30.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n\n## 1. 前言\n\n在前几篇文章中，我们介绍了模板编译流程三大阶段中的第一阶段模板解析阶段，在这一阶段主要做的工作是用解析器将用户所写的模板字符串解析成`AST`抽象语法树，理论上来讲，有了`AST`就可直接进入第三阶段生成`render`函数了。其实不然，`Vue`还是很看重性能的，只要有一点可以优化的地方就要将其进行优化。在之前介绍虚拟`DOM`的时候我们说过，有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点，如下：\n\n```html\n<ul>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n</ul>\n```\n\n在上面代码中，`ul`标签下面有5个`li`标签，每个`li`标签里的内容都是不含任何变量的纯文本，也就是说这种标签一旦第一次被渲染成`DOM`节点以后，之后不管状态再怎么变化它都不会变了，我们把像`li`的这种节点称之为静态节点。而这5个`li`节点的父节点是`ul`节点，也就是说`ul`节点的所有子节点都是静态节点，那么我们把像`ul`的这种节点称之为静态根节点。\n\nOK，有了静态节点和静态根节点这两个概念之后，我们再仔细思考，模板编译的最终目的是用模板生成一个`render`函数，而用`render`函数就可以生成与模板对应的`VNode`，之后再进行`patch`算法，最后完成视图渲染。这中间的`patch`算法又是用来对比新旧`VNode`之间存在的差异。在上面我们还说了，静态节点不管状态怎么变化它是不会变的，基于此，那我们就可以在`patch`过程中不用去对比这些静态节点了，这样不就又可以提高一些性能了吗？\n\n所以我们在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，用于告诉后面`patch`过程打了标记的这些节点是不需要对比的，你只要把它们克隆一份去用就好啦。这就是优化阶段存在的意义。\n\n上面也说了，优化阶段其实就干了两件事：\n\n1. 在`AST`中找出所有静态节点并打上标记；\n2. 在`AST`中找出所有静态根节点并打上标记；\n\n优化阶段的源码位于`src/compiler/optimizer.js`中，如下：\n\n```javascript\nexport function optimize (root: ?ASTElement, options: CompilerOptions) {\n  if (!root) return\n  isStaticKey = genStaticKeysCached(options.staticKeys || '')\n  isPlatformReservedTag = options.isReservedTag || no\n  // 标记静态节点\n  markStatic(root)\n  // 标记静态根节点\n  markStaticRoots(root, false)\n}\n```\n\n\n\n接下来，我们就对所干的这两件事逐个分析。\n\n## 2. 标记静态节点\n\n从`AST`中找出所有静态节点并标记其实不难，我们只需从根节点开始，先标记根节点是否为静态节点，然后看根节点如果是元素节点，那么就去向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到标记完所有节点。代码如下：\n\n```javascript\nfunction markStatic (node: ASTNode) {\n  node.static = isStatic(node)\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (let i = 0, l = node.children.length; i < l; i++) {\n      const child = node.children[i]\n      markStatic(child)\n      if (!child.static) {\n        node.static = false\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        const block = node.ifConditions[i].block\n        markStatic(block)\n        if (!block.static) {\n          node.static = false\n        }\n      }\n    }\n  }\n}\n```\n\n在上面代码中，首先调用`isStatic`函数标记节点是否为静态节点，该函数若返回`true`表示该节点是静态节点，若返回`false`表示该节点不是静态节点，函数实现如下：\n\n```javascript\nfunction isStatic (node: ASTNode): boolean {\n  if (node.type === 2) { // 包含变量的动态文本节点\n    return false\n  }\n  if (node.type === 3) { // 不包含变量的纯文本节点\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n```\n\n该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。还记得在`HTML`解析器在调用钩子函数创建`AST`节点时会根据节点类型的不同为节点加上不同的`type`属性，用`type`属性来标记`AST`节点的节点类型，其对应关系如下：\n\n| type取值 | 对应的AST节点类型      |\n| -------- | ---------------------- |\n| 1        | 元素节点               |\n| 2        | 包含变量的动态文本节点 |\n| 3        | 不包含变量的纯文本节点 |\n\n所以在判断一个节点是否为静态节点时首先会根据`type`值判断节点类型，如果`type`值为2，那么该节点是包含变量的动态文本节点，它就肯定不是静态节点，返回`false`；\n\n```javascript\nif (node.type === 2) { // 包含变量的动态文本节点\n    return false\n}\n```\n\n如果`type`值为2，那么该节点是不包含变量的纯文本节点，它就肯定是静态节点，返回`true`；\n\n```javascript\nif (node.type === 3) { // 不包含变量的纯文本节点\n    return true\n}\n```\n\n\n\n如果`type`值为1,说明该节点是元素节点，那就需要进一步判断。\n\n```javascript\nnode.pre || \n(\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n)\n```\n\n\n\n如果元素节点是静态节点，那就必须满足以下几点要求：\n\n- 如果节点使用了`v-pre`指令，那就断定它是静态节点；\n- 如果节点没有使用`v-pre`指令，那它要成为静态节点必须满足：\n  - 不能使用动态绑定语法，即标签上不能有`v-`、`@`、`:`开头的属性；\n  - 不能使用`v-if`、`v-else`、`v-for`指令；\n  - 不能是内置组件，即标签名不能是`slot`和`component`；\n  - 标签名必须是平台保留标签，即不能是组件；\n  - 当前节点的父节点不能是带有 `v-for` 的 `template` 标签；\n  - 节点的所有属性的 `key` 都必须是静态节点才有的 `key`，注：静态节点的`key`是有限的，它只能是`type`,`tag`,`attrsList`,`attrsMap`,`plain`,`parent`,`children`,`attrs`之一；\n\n标记完当前节点是否为静态节点之后，如果该节点是元素节点，那么还要继续去递归判断它的子节点，如下：\n\n```javascript\nfor (let i = 0, l = node.children.length; i < l; i++) {\n    const child = node.children[i]\n    markStatic(child)\n    if (!child.static) {\n        node.static = false\n    }\n}\n```\n\n注意，在上面代码中，新增了一个判断：\n\n```javascript\nif (!child.static) {\n    node.static = false\n}\n```\n\n这个判断的意思是如果当前节点的子节点有一个不是静态节点，那就把当前节点也标记为非静态节点。为什么要这么做呢？这是因为我们在判断的时候是从上往下判断的，也就是说先判断当前节点，再判断当前节点的子节点，如果当前节点在一开始被标记为了静态节点，但是通过判断子节点的时候发现有一个子节点却不是静态节点，这就有问题了，我们之前说过一旦标记为静态节点，就说明这个节点首次渲染之后不会再发生任何变化，但是它的一个子节点却又是可以变化的，就出现了自相矛盾，所以我们需要当发现它的子节点中有一个不是静态节点的时候，就得把当前节点重新设置为非静态节点。\n\n循环`node.children`后还不算把所有子节点都遍历完，因为如果当前节点的子节点中有标签带有`v-if`、`v-else-if`、`v-else`等指令时，这些子节点在每次渲染时都只渲染一个，所以其余没有被渲染的肯定不在`node.children`中，而是存在于`node.ifConditions`，所以我们还要把`node.ifConditions`循环一遍，如下：\n\n```javascript\nif (node.ifConditions) {\n    for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        const block = node.ifConditions[i].block\n        markStatic(block)\n        if (!block.static) {\n            node.static = false\n        }\n    }\n}\n```\n\n同理，如果当前节点的`node.ifConditions`中有一个子节点不是静态节点也要将当前节点设置为非静态节点。\n\n以上就是标记静态节点的全部逻辑。\n\n## 3. 标记静态根节点\n\n寻找静态根节点根寻找静态节点的逻辑类似，都是从`AST`根节点递归向下遍历寻找，其代码如下：\n\n```javascript\nfunction markStaticRoots (node: ASTNode, isInFor: boolean) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true\n      return\n    } else {\n      node.staticRoot = false\n    }\n    if (node.children) {\n      for (let i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        markStaticRoots(node.ifConditions[i].block, isInFor)\n      }\n    }\n  }\n}\n```\n\n上面代码中，首先`markStaticRoots` 第二个参数是 `isInFor`，对于已经是 `static` 的节点或者是 `v-once` 指令的节点，`node.staticInFor = isInFor`，如下：\n\n```javascript\nif (node.static || node.once) {\n    node.staticInFor = isInFor\n}\n```\n\n\n\n接着判断该节点是否为静态根节点，如下：\n\n```javascript\n// For a node to qualify as a static root, it should have children that\n// are not just static text. Otherwise the cost of hoisting out will\n// outweigh the benefits and it's better off to just always render it fresh.\n// 为了使节点有资格作为静态根节点，它应具有不只是静态文本的子节点。 否则，优化的成本将超过收益，最好始终将其更新。\nif (node.static && node.children.length && !(\n    node.children.length === 1 &&\n    node.children[0].type === 3\n)) {\n    node.staticRoot = true\n    return\n} else {\n    node.staticRoot = false\n}\n```\n\n从代码和注释中我们可以看到，一个节点要想成为静态根节点，它必须满足以下要求：\n\n- 节点本身必须是静态节点；\n- 必须拥有子节点 `children`；\n- 子节点不能只是只有一个文本节点；\n\n否则的话，对它的优化成本将大于优化后带来的收益。\n\n如果当前节点不是静态根节点，那就继续递归遍历它的子节点`node.children`和`node.ifConditions`，如下：\n\n```javascript\nif (node.children) {\n    for (let i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n    }\n}\nif (node.ifConditions) {\n    for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        markStaticRoots(node.ifConditions[i].block, isInFor)\n    }\n}\n```\n\n\n\n这里的原理跟寻找静态节点相同，此处就不再重复。\n\n## 4. 总结\n\n本篇文章介绍了模板编译过程三大阶段的第二阶段——优化阶段。\n\n首先，介绍了为什么要有优化阶段，是为了提高虚拟`DOM`中`patch`过程的性能。在优化阶段将所有静态节点都打上标记，这样在`patch`过程中就可以跳过对比这些节点。\n\n接着，介绍了优化阶段主要干了两件事情，分别是从构建出的`AST`中找出并标记所有静态节点和所有静态根节点。\n\n最后，分别通过逐行分析源码的方式分析了这两件事具体的内部工作原理。\n\n","source":"_posts/Vue 源码阅读 模板编译（五）.md","raw":"---\ntitle: Vue 源码阅读 模板编译（五）\ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-21 20:45:30\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n\n## 1. 前言\n\n在前几篇文章中，我们介绍了模板编译流程三大阶段中的第一阶段模板解析阶段，在这一阶段主要做的工作是用解析器将用户所写的模板字符串解析成`AST`抽象语法树，理论上来讲，有了`AST`就可直接进入第三阶段生成`render`函数了。其实不然，`Vue`还是很看重性能的，只要有一点可以优化的地方就要将其进行优化。在之前介绍虚拟`DOM`的时候我们说过，有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点，如下：\n\n```html\n<ul>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n    <li>我是文本信息</li>\n</ul>\n```\n\n在上面代码中，`ul`标签下面有5个`li`标签，每个`li`标签里的内容都是不含任何变量的纯文本，也就是说这种标签一旦第一次被渲染成`DOM`节点以后，之后不管状态再怎么变化它都不会变了，我们把像`li`的这种节点称之为静态节点。而这5个`li`节点的父节点是`ul`节点，也就是说`ul`节点的所有子节点都是静态节点，那么我们把像`ul`的这种节点称之为静态根节点。\n\nOK，有了静态节点和静态根节点这两个概念之后，我们再仔细思考，模板编译的最终目的是用模板生成一个`render`函数，而用`render`函数就可以生成与模板对应的`VNode`，之后再进行`patch`算法，最后完成视图渲染。这中间的`patch`算法又是用来对比新旧`VNode`之间存在的差异。在上面我们还说了，静态节点不管状态怎么变化它是不会变的，基于此，那我们就可以在`patch`过程中不用去对比这些静态节点了，这样不就又可以提高一些性能了吗？\n\n所以我们在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，用于告诉后面`patch`过程打了标记的这些节点是不需要对比的，你只要把它们克隆一份去用就好啦。这就是优化阶段存在的意义。\n\n上面也说了，优化阶段其实就干了两件事：\n\n1. 在`AST`中找出所有静态节点并打上标记；\n2. 在`AST`中找出所有静态根节点并打上标记；\n\n优化阶段的源码位于`src/compiler/optimizer.js`中，如下：\n\n```javascript\nexport function optimize (root: ?ASTElement, options: CompilerOptions) {\n  if (!root) return\n  isStaticKey = genStaticKeysCached(options.staticKeys || '')\n  isPlatformReservedTag = options.isReservedTag || no\n  // 标记静态节点\n  markStatic(root)\n  // 标记静态根节点\n  markStaticRoots(root, false)\n}\n```\n\n\n\n接下来，我们就对所干的这两件事逐个分析。\n\n## 2. 标记静态节点\n\n从`AST`中找出所有静态节点并标记其实不难，我们只需从根节点开始，先标记根节点是否为静态节点，然后看根节点如果是元素节点，那么就去向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到标记完所有节点。代码如下：\n\n```javascript\nfunction markStatic (node: ASTNode) {\n  node.static = isStatic(node)\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (let i = 0, l = node.children.length; i < l; i++) {\n      const child = node.children[i]\n      markStatic(child)\n      if (!child.static) {\n        node.static = false\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        const block = node.ifConditions[i].block\n        markStatic(block)\n        if (!block.static) {\n          node.static = false\n        }\n      }\n    }\n  }\n}\n```\n\n在上面代码中，首先调用`isStatic`函数标记节点是否为静态节点，该函数若返回`true`表示该节点是静态节点，若返回`false`表示该节点不是静态节点，函数实现如下：\n\n```javascript\nfunction isStatic (node: ASTNode): boolean {\n  if (node.type === 2) { // 包含变量的动态文本节点\n    return false\n  }\n  if (node.type === 3) { // 不包含变量的纯文本节点\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n```\n\n该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。还记得在`HTML`解析器在调用钩子函数创建`AST`节点时会根据节点类型的不同为节点加上不同的`type`属性，用`type`属性来标记`AST`节点的节点类型，其对应关系如下：\n\n| type取值 | 对应的AST节点类型      |\n| -------- | ---------------------- |\n| 1        | 元素节点               |\n| 2        | 包含变量的动态文本节点 |\n| 3        | 不包含变量的纯文本节点 |\n\n所以在判断一个节点是否为静态节点时首先会根据`type`值判断节点类型，如果`type`值为2，那么该节点是包含变量的动态文本节点，它就肯定不是静态节点，返回`false`；\n\n```javascript\nif (node.type === 2) { // 包含变量的动态文本节点\n    return false\n}\n```\n\n如果`type`值为2，那么该节点是不包含变量的纯文本节点，它就肯定是静态节点，返回`true`；\n\n```javascript\nif (node.type === 3) { // 不包含变量的纯文本节点\n    return true\n}\n```\n\n\n\n如果`type`值为1,说明该节点是元素节点，那就需要进一步判断。\n\n```javascript\nnode.pre || \n(\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n)\n```\n\n\n\n如果元素节点是静态节点，那就必须满足以下几点要求：\n\n- 如果节点使用了`v-pre`指令，那就断定它是静态节点；\n- 如果节点没有使用`v-pre`指令，那它要成为静态节点必须满足：\n  - 不能使用动态绑定语法，即标签上不能有`v-`、`@`、`:`开头的属性；\n  - 不能使用`v-if`、`v-else`、`v-for`指令；\n  - 不能是内置组件，即标签名不能是`slot`和`component`；\n  - 标签名必须是平台保留标签，即不能是组件；\n  - 当前节点的父节点不能是带有 `v-for` 的 `template` 标签；\n  - 节点的所有属性的 `key` 都必须是静态节点才有的 `key`，注：静态节点的`key`是有限的，它只能是`type`,`tag`,`attrsList`,`attrsMap`,`plain`,`parent`,`children`,`attrs`之一；\n\n标记完当前节点是否为静态节点之后，如果该节点是元素节点，那么还要继续去递归判断它的子节点，如下：\n\n```javascript\nfor (let i = 0, l = node.children.length; i < l; i++) {\n    const child = node.children[i]\n    markStatic(child)\n    if (!child.static) {\n        node.static = false\n    }\n}\n```\n\n注意，在上面代码中，新增了一个判断：\n\n```javascript\nif (!child.static) {\n    node.static = false\n}\n```\n\n这个判断的意思是如果当前节点的子节点有一个不是静态节点，那就把当前节点也标记为非静态节点。为什么要这么做呢？这是因为我们在判断的时候是从上往下判断的，也就是说先判断当前节点，再判断当前节点的子节点，如果当前节点在一开始被标记为了静态节点，但是通过判断子节点的时候发现有一个子节点却不是静态节点，这就有问题了，我们之前说过一旦标记为静态节点，就说明这个节点首次渲染之后不会再发生任何变化，但是它的一个子节点却又是可以变化的，就出现了自相矛盾，所以我们需要当发现它的子节点中有一个不是静态节点的时候，就得把当前节点重新设置为非静态节点。\n\n循环`node.children`后还不算把所有子节点都遍历完，因为如果当前节点的子节点中有标签带有`v-if`、`v-else-if`、`v-else`等指令时，这些子节点在每次渲染时都只渲染一个，所以其余没有被渲染的肯定不在`node.children`中，而是存在于`node.ifConditions`，所以我们还要把`node.ifConditions`循环一遍，如下：\n\n```javascript\nif (node.ifConditions) {\n    for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        const block = node.ifConditions[i].block\n        markStatic(block)\n        if (!block.static) {\n            node.static = false\n        }\n    }\n}\n```\n\n同理，如果当前节点的`node.ifConditions`中有一个子节点不是静态节点也要将当前节点设置为非静态节点。\n\n以上就是标记静态节点的全部逻辑。\n\n## 3. 标记静态根节点\n\n寻找静态根节点根寻找静态节点的逻辑类似，都是从`AST`根节点递归向下遍历寻找，其代码如下：\n\n```javascript\nfunction markStaticRoots (node: ASTNode, isInFor: boolean) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true\n      return\n    } else {\n      node.staticRoot = false\n    }\n    if (node.children) {\n      for (let i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n      }\n    }\n    if (node.ifConditions) {\n      for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        markStaticRoots(node.ifConditions[i].block, isInFor)\n      }\n    }\n  }\n}\n```\n\n上面代码中，首先`markStaticRoots` 第二个参数是 `isInFor`，对于已经是 `static` 的节点或者是 `v-once` 指令的节点，`node.staticInFor = isInFor`，如下：\n\n```javascript\nif (node.static || node.once) {\n    node.staticInFor = isInFor\n}\n```\n\n\n\n接着判断该节点是否为静态根节点，如下：\n\n```javascript\n// For a node to qualify as a static root, it should have children that\n// are not just static text. Otherwise the cost of hoisting out will\n// outweigh the benefits and it's better off to just always render it fresh.\n// 为了使节点有资格作为静态根节点，它应具有不只是静态文本的子节点。 否则，优化的成本将超过收益，最好始终将其更新。\nif (node.static && node.children.length && !(\n    node.children.length === 1 &&\n    node.children[0].type === 3\n)) {\n    node.staticRoot = true\n    return\n} else {\n    node.staticRoot = false\n}\n```\n\n从代码和注释中我们可以看到，一个节点要想成为静态根节点，它必须满足以下要求：\n\n- 节点本身必须是静态节点；\n- 必须拥有子节点 `children`；\n- 子节点不能只是只有一个文本节点；\n\n否则的话，对它的优化成本将大于优化后带来的收益。\n\n如果当前节点不是静态根节点，那就继续递归遍历它的子节点`node.children`和`node.ifConditions`，如下：\n\n```javascript\nif (node.children) {\n    for (let i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for)\n    }\n}\nif (node.ifConditions) {\n    for (let i = 1, l = node.ifConditions.length; i < l; i++) {\n        markStaticRoots(node.ifConditions[i].block, isInFor)\n    }\n}\n```\n\n\n\n这里的原理跟寻找静态节点相同，此处就不再重复。\n\n## 4. 总结\n\n本篇文章介绍了模板编译过程三大阶段的第二阶段——优化阶段。\n\n首先，介绍了为什么要有优化阶段，是为了提高虚拟`DOM`中`patch`过程的性能。在优化阶段将所有静态节点都打上标记，这样在`patch`过程中就可以跳过对比这些节点。\n\n接着，介绍了优化阶段主要干了两件事情，分别是从构建出的`AST`中找出并标记所有静态节点和所有静态根节点。\n\n最后，分别通过逐行分析源码的方式分析了这两件事具体的内部工作原理。\n\n","slug":"Vue 源码阅读 模板编译（五）","published":1,"updated":"2019-12-31T03:14:09.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj81006qzws680vu3vpm","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在前几篇文章中，我们介绍了模板编译流程三大阶段中的第一阶段模板解析阶段，在这一阶段主要做的工作是用解析器将用户所写的模板字符串解析成<code>AST</code>抽象语法树，理论上来讲，有了<code>AST</code>就可直接进入第三阶段生成<code>render</code>函数了。其实不然，<code>Vue</code>还是很看重性能的，只要有一点可以优化的地方就要将其进行优化。在之前介绍虚拟<code>DOM</code>的时候我们说过，有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在上面代码中，<code>ul</code>标签下面有5个<code>li</code>标签，每个<code>li</code>标签里的内容都是不含任何变量的纯文本，也就是说这种标签一旦第一次被渲染成<code>DOM</code>节点以后，之后不管状态再怎么变化它都不会变了，我们把像<code>li</code>的这种节点称之为静态节点。而这5个<code>li</code>节点的父节点是<code>ul</code>节点，也就是说<code>ul</code>节点的所有子节点都是静态节点，那么我们把像<code>ul</code>的这种节点称之为静态根节点。</p>\n<p>OK，有了静态节点和静态根节点这两个概念之后，我们再仔细思考，模板编译的最终目的是用模板生成一个<code>render</code>函数，而用<code>render</code>函数就可以生成与模板对应的<code>VNode</code>，之后再进行<code>patch</code>算法，最后完成视图渲染。这中间的<code>patch</code>算法又是用来对比新旧<code>VNode</code>之间存在的差异。在上面我们还说了，静态节点不管状态怎么变化它是不会变的，基于此，那我们就可以在<code>patch</code>过程中不用去对比这些静态节点了，这样不就又可以提高一些性能了吗？</p>\n<p>所以我们在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，用于告诉后面<code>patch</code>过程打了标记的这些节点是不需要对比的，你只要把它们克隆一份去用就好啦。这就是优化阶段存在的意义。</p>\n<p>上面也说了，优化阶段其实就干了两件事：</p>\n<ol>\n<li>在<code>AST</code>中找出所有静态节点并打上标记；</li>\n<li>在<code>AST</code>中找出所有静态根节点并打上标记；</li>\n</ol>\n<p>优化阶段的源码位于<code>src/compiler/optimizer.js</code>中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">optimize</span> (<span class=\"params\">root: ?ASTElement, options: CompilerOptions</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span></span><br><span class=\"line\">  isStaticKey = genStaticKeysCached(options.staticKeys || <span class=\"string\">''</span>)</span><br><span class=\"line\">  isPlatformReservedTag = options.isReservedTag || no</span><br><span class=\"line\">  <span class=\"comment\">// 标记静态节点</span></span><br><span class=\"line\">  markStatic(root)</span><br><span class=\"line\">  <span class=\"comment\">// 标记静态根节点</span></span><br><span class=\"line\">  markStaticRoots(root, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们就对所干的这两件事逐个分析。</p>\n<h2><span id=\"2-标记静态节点\">2. 标记静态节点</span></h2>\n<p>从<code>AST</code>中找出所有静态节点并标记其实不难，我们只需从根节点开始，先标记根节点是否为静态节点，然后看根节点如果是元素节点，那么就去向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到标记完所有节点。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">markStatic</span> (<span class=\"params\">node: ASTNode</span>) </span>&#123;</span><br><span class=\"line\">  node.static = isStatic(node)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do not make component slot content static. this avoids</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. components not able to mutate slot nodes</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. static slot content fails for hot-reloading</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !isPlatformReservedTag(node.tag) &amp;&amp;</span><br><span class=\"line\">      node.tag !== <span class=\"string\">'slot'</span> &amp;&amp;</span><br><span class=\"line\">      node.attrsMap[<span class=\"string\">'inline-template'</span>] == <span class=\"literal\">null</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> child = node.children[i]</span><br><span class=\"line\">      markStatic(child)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!child.static) &#123;</span><br><span class=\"line\">        node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> block = node.ifConditions[i].block</span><br><span class=\"line\">        markStatic(block)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!block.static) &#123;</span><br><span class=\"line\">          node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，首先调用<code>isStatic</code>函数标记节点是否为静态节点，该函数若返回<code>true</code>表示该节点是静态节点，若返回<code>false</code>表示该节点不是静态节点，函数实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isStatic</span> (<span class=\"params\">node: ASTNode</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">2</span>) &#123; <span class=\"comment\">// 包含变量的动态文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">3</span>) &#123; <span class=\"comment\">// 不包含变量的纯文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(node.pre || (</span><br><span class=\"line\">    !node.hasBindings &amp;&amp; <span class=\"comment\">// no dynamic bindings</span></span><br><span class=\"line\">    !node.if &amp;&amp; !node.for &amp;&amp; <span class=\"comment\">// not v-if or v-for or v-else</span></span><br><span class=\"line\">    !isBuiltInTag(node.tag) &amp;&amp; <span class=\"comment\">// not a built-in</span></span><br><span class=\"line\">    isPlatformReservedTag(node.tag) &amp;&amp; <span class=\"comment\">// not a component</span></span><br><span class=\"line\">    !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(node).every(isStaticKey)</span><br><span class=\"line\">  ))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。还记得在<code>HTML</code>解析器在调用钩子函数创建<code>AST</code>节点时会根据节点类型的不同为节点加上不同的<code>type</code>属性，用<code>type</code>属性来标记<code>AST</code>节点的节点类型，其对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>type取值</th>\n<th>对应的AST节点类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>元素节点</td>\n</tr>\n<tr>\n<td>2</td>\n<td>包含变量的动态文本节点</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不包含变量的纯文本节点</td>\n</tr>\n</tbody>\n</table>\n<p>所以在判断一个节点是否为静态节点时首先会根据<code>type</code>值判断节点类型，如果<code>type</code>值为2，那么该节点是包含变量的动态文本节点，它就肯定不是静态节点，返回<code>false</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.type === <span class=\"number\">2</span>) &#123; <span class=\"comment\">// 包含变量的动态文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果<code>type</code>值为2，那么该节点是不包含变量的纯文本节点，它就肯定是静态节点，返回<code>true</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.type === <span class=\"number\">3</span>) &#123; <span class=\"comment\">// 不包含变量的纯文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果<code>type</code>值为1,说明该节点是元素节点，那就需要进一步判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node.pre || </span><br><span class=\"line\">(</span><br><span class=\"line\">    !node.hasBindings &amp;&amp; <span class=\"comment\">// no dynamic bindings</span></span><br><span class=\"line\">    !node.if &amp;&amp; !node.for &amp;&amp; <span class=\"comment\">// not v-if or v-for or v-else</span></span><br><span class=\"line\">    !isBuiltInTag(node.tag) &amp;&amp; <span class=\"comment\">// not a built-in</span></span><br><span class=\"line\">    isPlatformReservedTag(node.tag) &amp;&amp; <span class=\"comment\">// not a component</span></span><br><span class=\"line\">    !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(node).every(isStaticKey)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>如果元素节点是静态节点，那就必须满足以下几点要求：</p>\n<ul>\n<li>如果节点使用了<code>v-pre</code>指令，那就断定它是静态节点；</li>\n<li>如果节点没有使用<code>v-pre</code>指令，那它要成为静态节点必须满足：\n<ul>\n<li>不能使用动态绑定语法，即标签上不能有<code>v-</code>、<code>@</code>、<code>:</code>开头的属性；</li>\n<li>不能使用<code>v-if</code>、<code>v-else</code>、<code>v-for</code>指令；</li>\n<li>不能是内置组件，即标签名不能是<code>slot</code>和<code>component</code>；</li>\n<li>标签名必须是平台保留标签，即不能是组件；</li>\n<li>当前节点的父节点不能是带有 <code>v-for</code> 的 <code>template</code> 标签；</li>\n<li>节点的所有属性的 <code>key</code> 都必须是静态节点才有的 <code>key</code>，注：静态节点的<code>key</code>是有限的，它只能是<code>type</code>,<code>tag</code>,<code>attrsList</code>,<code>attrsMap</code>,<code>plain</code>,<code>parent</code>,<code>children</code>,<code>attrs</code>之一；</li>\n</ul>\n</li>\n</ul>\n<p>标记完当前节点是否为静态节点之后，如果该节点是元素节点，那么还要继续去递归判断它的子节点，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> child = node.children[i]</span><br><span class=\"line\">    markStatic(child)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!child.static) &#123;</span><br><span class=\"line\">        node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，在上面代码中，新增了一个判断：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!child.static) &#123;</span><br><span class=\"line\">    node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个判断的意思是如果当前节点的子节点有一个不是静态节点，那就把当前节点也标记为非静态节点。为什么要这么做呢？这是因为我们在判断的时候是从上往下判断的，也就是说先判断当前节点，再判断当前节点的子节点，如果当前节点在一开始被标记为了静态节点，但是通过判断子节点的时候发现有一个子节点却不是静态节点，这就有问题了，我们之前说过一旦标记为静态节点，就说明这个节点首次渲染之后不会再发生任何变化，但是它的一个子节点却又是可以变化的，就出现了自相矛盾，所以我们需要当发现它的子节点中有一个不是静态节点的时候，就得把当前节点重新设置为非静态节点。</p>\n<p>循环<code>node.children</code>后还不算把所有子节点都遍历完，因为如果当前节点的子节点中有标签带有<code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>等指令时，这些子节点在每次渲染时都只渲染一个，所以其余没有被渲染的肯定不在<code>node.children</code>中，而是存在于<code>node.ifConditions</code>，所以我们还要把<code>node.ifConditions</code>循环一遍，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> block = node.ifConditions[i].block</span><br><span class=\"line\">        markStatic(block)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!block.static) &#123;</span><br><span class=\"line\">            node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，如果当前节点的<code>node.ifConditions</code>中有一个子节点不是静态节点也要将当前节点设置为非静态节点。</p>\n<p>以上就是标记静态节点的全部逻辑。</p>\n<h2><span id=\"3-标记静态根节点\">3. 标记静态根节点</span></h2>\n<p>寻找静态根节点根寻找静态节点的逻辑类似，都是从<code>AST</code>根节点递归向下遍历寻找，其代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">markStaticRoots</span> (<span class=\"params\">node: ASTNode, isInFor: boolean</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.static || node.once) &#123;</span><br><span class=\"line\">      node.staticInFor = isInFor</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// For a node to qualify as a static root, it should have children that</span></span><br><span class=\"line\">    <span class=\"comment\">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class=\"line\">    <span class=\"comment\">// outweigh the benefits and it's better off to just always render it fresh.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class=\"line\">      node.children.length === <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">      node.children[<span class=\"number\">0</span>].type === <span class=\"number\">3</span></span><br><span class=\"line\">    )) &#123;</span><br><span class=\"line\">      node.staticRoot = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      node.staticRoot = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.children) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.ifConditions[i].block, isInFor)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，首先<code>markStaticRoots</code> 第二个参数是 <code>isInFor</code>，对于已经是 <code>static</code> 的节点或者是 <code>v-once</code> 指令的节点，<code>node.staticInFor = isInFor</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.static || node.once) &#123;</span><br><span class=\"line\">    node.staticInFor = isInFor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着判断该节点是否为静态根节点，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// For a node to qualify as a static root, it should have children that</span></span><br><span class=\"line\"><span class=\"comment\">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class=\"line\"><span class=\"comment\">// outweigh the benefits and it's better off to just always render it fresh.</span></span><br><span class=\"line\"><span class=\"comment\">// 为了使节点有资格作为静态根节点，它应具有不只是静态文本的子节点。 否则，优化的成本将超过收益，最好始终将其更新。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class=\"line\">    node.children.length === <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">    node.children[<span class=\"number\">0</span>].type === <span class=\"number\">3</span></span><br><span class=\"line\">)) &#123;</span><br><span class=\"line\">    node.staticRoot = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    node.staticRoot = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码和注释中我们可以看到，一个节点要想成为静态根节点，它必须满足以下要求：</p>\n<ul>\n<li>节点本身必须是静态节点；</li>\n<li>必须拥有子节点 <code>children</code>；</li>\n<li>子节点不能只是只有一个文本节点；</li>\n</ul>\n<p>否则的话，对它的优化成本将大于优化后带来的收益。</p>\n<p>如果当前节点不是静态根节点，那就继续递归遍历它的子节点<code>node.children</code>和<code>node.ifConditions</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.children) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.ifConditions[i].block, isInFor)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的原理跟寻找静态节点相同，此处就不再重复。</p>\n<h2><span id=\"4-总结\">4. 总结</span></h2>\n<p>本篇文章介绍了模板编译过程三大阶段的第二阶段——优化阶段。</p>\n<p>首先，介绍了为什么要有优化阶段，是为了提高虚拟<code>DOM</code>中<code>patch</code>过程的性能。在优化阶段将所有静态节点都打上标记，这样在<code>patch</code>过程中就可以跳过对比这些节点。</p>\n<p>接着，介绍了优化阶段主要干了两件事情，分别是从构建出的<code>AST</code>中找出并标记所有静态节点和所有静态根节点。</p>\n<p>最后，分别通过逐行分析源码的方式分析了这两件事具体的内部工作原理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在前几篇文章中，我们介绍了模板编译流程三大阶段中的第一阶段模板解析阶段，在这一阶段主要做的工作是用解析器将用户所写的模板字符串解析成<code>AST</code>抽象语法树，理论上来讲，有了<code>AST</code>就可直接进入第三阶段生成<code>render</code>函数了。其实不然，<code>Vue</code>还是很看重性能的，只要有一点可以优化的地方就要将其进行优化。在之前介绍虚拟<code>DOM</code>的时候我们说过，有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>我是文本信息<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在上面代码中，<code>ul</code>标签下面有5个<code>li</code>标签，每个<code>li</code>标签里的内容都是不含任何变量的纯文本，也就是说这种标签一旦第一次被渲染成<code>DOM</code>节点以后，之后不管状态再怎么变化它都不会变了，我们把像<code>li</code>的这种节点称之为静态节点。而这5个<code>li</code>节点的父节点是<code>ul</code>节点，也就是说<code>ul</code>节点的所有子节点都是静态节点，那么我们把像<code>ul</code>的这种节点称之为静态根节点。</p>\n<p>OK，有了静态节点和静态根节点这两个概念之后，我们再仔细思考，模板编译的最终目的是用模板生成一个<code>render</code>函数，而用<code>render</code>函数就可以生成与模板对应的<code>VNode</code>，之后再进行<code>patch</code>算法，最后完成视图渲染。这中间的<code>patch</code>算法又是用来对比新旧<code>VNode</code>之间存在的差异。在上面我们还说了，静态节点不管状态怎么变化它是不会变的，基于此，那我们就可以在<code>patch</code>过程中不用去对比这些静态节点了，这样不就又可以提高一些性能了吗？</p>\n<p>所以我们在模板编译的时候就先找出模板中所有的静态节点和静态根节点，然后给它们打上标记，用于告诉后面<code>patch</code>过程打了标记的这些节点是不需要对比的，你只要把它们克隆一份去用就好啦。这就是优化阶段存在的意义。</p>\n<p>上面也说了，优化阶段其实就干了两件事：</p>\n<ol>\n<li>在<code>AST</code>中找出所有静态节点并打上标记；</li>\n<li>在<code>AST</code>中找出所有静态根节点并打上标记；</li>\n</ol>\n<p>优化阶段的源码位于<code>src/compiler/optimizer.js</code>中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">optimize</span> (<span class=\"params\">root: ?ASTElement, options: CompilerOptions</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span></span><br><span class=\"line\">  isStaticKey = genStaticKeysCached(options.staticKeys || <span class=\"string\">''</span>)</span><br><span class=\"line\">  isPlatformReservedTag = options.isReservedTag || no</span><br><span class=\"line\">  <span class=\"comment\">// 标记静态节点</span></span><br><span class=\"line\">  markStatic(root)</span><br><span class=\"line\">  <span class=\"comment\">// 标记静态根节点</span></span><br><span class=\"line\">  markStaticRoots(root, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们就对所干的这两件事逐个分析。</p>\n<h2>2. 标记静态节点</h2>\n<p>从<code>AST</code>中找出所有静态节点并标记其实不难，我们只需从根节点开始，先标记根节点是否为静态节点，然后看根节点如果是元素节点，那么就去向下递归它的子节点，子节点如果还有子节点那就继续向下递归，直到标记完所有节点。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">markStatic</span> (<span class=\"params\">node: ASTNode</span>) </span>&#123;</span><br><span class=\"line\">  node.static = isStatic(node)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do not make component slot content static. this avoids</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. components not able to mutate slot nodes</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. static slot content fails for hot-reloading</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !isPlatformReservedTag(node.tag) &amp;&amp;</span><br><span class=\"line\">      node.tag !== <span class=\"string\">'slot'</span> &amp;&amp;</span><br><span class=\"line\">      node.attrsMap[<span class=\"string\">'inline-template'</span>] == <span class=\"literal\">null</span></span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> child = node.children[i]</span><br><span class=\"line\">      markStatic(child)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!child.static) &#123;</span><br><span class=\"line\">        node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> block = node.ifConditions[i].block</span><br><span class=\"line\">        markStatic(block)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!block.static) &#123;</span><br><span class=\"line\">          node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，首先调用<code>isStatic</code>函数标记节点是否为静态节点，该函数若返回<code>true</code>表示该节点是静态节点，若返回<code>false</code>表示该节点不是静态节点，函数实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isStatic</span> (<span class=\"params\">node: ASTNode</span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">2</span>) &#123; <span class=\"comment\">// 包含变量的动态文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">3</span>) &#123; <span class=\"comment\">// 不包含变量的纯文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(node.pre || (</span><br><span class=\"line\">    !node.hasBindings &amp;&amp; <span class=\"comment\">// no dynamic bindings</span></span><br><span class=\"line\">    !node.if &amp;&amp; !node.for &amp;&amp; <span class=\"comment\">// not v-if or v-for or v-else</span></span><br><span class=\"line\">    !isBuiltInTag(node.tag) &amp;&amp; <span class=\"comment\">// not a built-in</span></span><br><span class=\"line\">    isPlatformReservedTag(node.tag) &amp;&amp; <span class=\"comment\">// not a component</span></span><br><span class=\"line\">    !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(node).every(isStaticKey)</span><br><span class=\"line\">  ))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数的实现过程其实也说明了如何判断一个节点是否为静态节点。还记得在<code>HTML</code>解析器在调用钩子函数创建<code>AST</code>节点时会根据节点类型的不同为节点加上不同的<code>type</code>属性，用<code>type</code>属性来标记<code>AST</code>节点的节点类型，其对应关系如下：</p>\n<table>\n<thead>\n<tr>\n<th>type取值</th>\n<th>对应的AST节点类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>元素节点</td>\n</tr>\n<tr>\n<td>2</td>\n<td>包含变量的动态文本节点</td>\n</tr>\n<tr>\n<td>3</td>\n<td>不包含变量的纯文本节点</td>\n</tr>\n</tbody>\n</table>\n<p>所以在判断一个节点是否为静态节点时首先会根据<code>type</code>值判断节点类型，如果<code>type</code>值为2，那么该节点是包含变量的动态文本节点，它就肯定不是静态节点，返回<code>false</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.type === <span class=\"number\">2</span>) &#123; <span class=\"comment\">// 包含变量的动态文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果<code>type</code>值为2，那么该节点是不包含变量的纯文本节点，它就肯定是静态节点，返回<code>true</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.type === <span class=\"number\">3</span>) &#123; <span class=\"comment\">// 不包含变量的纯文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果<code>type</code>值为1,说明该节点是元素节点，那就需要进一步判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node.pre || </span><br><span class=\"line\">(</span><br><span class=\"line\">    !node.hasBindings &amp;&amp; <span class=\"comment\">// no dynamic bindings</span></span><br><span class=\"line\">    !node.if &amp;&amp; !node.for &amp;&amp; <span class=\"comment\">// not v-if or v-for or v-else</span></span><br><span class=\"line\">    !isBuiltInTag(node.tag) &amp;&amp; <span class=\"comment\">// not a built-in</span></span><br><span class=\"line\">    isPlatformReservedTag(node.tag) &amp;&amp; <span class=\"comment\">// not a component</span></span><br><span class=\"line\">    !isDirectChildOfTemplateFor(node) &amp;&amp;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(node).every(isStaticKey)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>如果元素节点是静态节点，那就必须满足以下几点要求：</p>\n<ul>\n<li>如果节点使用了<code>v-pre</code>指令，那就断定它是静态节点；</li>\n<li>如果节点没有使用<code>v-pre</code>指令，那它要成为静态节点必须满足：\n<ul>\n<li>不能使用动态绑定语法，即标签上不能有<code>v-</code>、<code>@</code>、<code>:</code>开头的属性；</li>\n<li>不能使用<code>v-if</code>、<code>v-else</code>、<code>v-for</code>指令；</li>\n<li>不能是内置组件，即标签名不能是<code>slot</code>和<code>component</code>；</li>\n<li>标签名必须是平台保留标签，即不能是组件；</li>\n<li>当前节点的父节点不能是带有 <code>v-for</code> 的 <code>template</code> 标签；</li>\n<li>节点的所有属性的 <code>key</code> 都必须是静态节点才有的 <code>key</code>，注：静态节点的<code>key</code>是有限的，它只能是<code>type</code>,<code>tag</code>,<code>attrsList</code>,<code>attrsMap</code>,<code>plain</code>,<code>parent</code>,<code>children</code>,<code>attrs</code>之一；</li>\n</ul>\n</li>\n</ul>\n<p>标记完当前节点是否为静态节点之后，如果该节点是元素节点，那么还要继续去递归判断它的子节点，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> child = node.children[i]</span><br><span class=\"line\">    markStatic(child)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!child.static) &#123;</span><br><span class=\"line\">        node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，在上面代码中，新增了一个判断：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!child.static) &#123;</span><br><span class=\"line\">    node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个判断的意思是如果当前节点的子节点有一个不是静态节点，那就把当前节点也标记为非静态节点。为什么要这么做呢？这是因为我们在判断的时候是从上往下判断的，也就是说先判断当前节点，再判断当前节点的子节点，如果当前节点在一开始被标记为了静态节点，但是通过判断子节点的时候发现有一个子节点却不是静态节点，这就有问题了，我们之前说过一旦标记为静态节点，就说明这个节点首次渲染之后不会再发生任何变化，但是它的一个子节点却又是可以变化的，就出现了自相矛盾，所以我们需要当发现它的子节点中有一个不是静态节点的时候，就得把当前节点重新设置为非静态节点。</p>\n<p>循环<code>node.children</code>后还不算把所有子节点都遍历完，因为如果当前节点的子节点中有标签带有<code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>等指令时，这些子节点在每次渲染时都只渲染一个，所以其余没有被渲染的肯定不在<code>node.children</code>中，而是存在于<code>node.ifConditions</code>，所以我们还要把<code>node.ifConditions</code>循环一遍，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> block = node.ifConditions[i].block</span><br><span class=\"line\">        markStatic(block)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!block.static) &#123;</span><br><span class=\"line\">            node.static = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同理，如果当前节点的<code>node.ifConditions</code>中有一个子节点不是静态节点也要将当前节点设置为非静态节点。</p>\n<p>以上就是标记静态节点的全部逻辑。</p>\n<h2>3. 标记静态根节点</h2>\n<p>寻找静态根节点根寻找静态节点的逻辑类似，都是从<code>AST</code>根节点递归向下遍历寻找，其代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">markStaticRoots</span> (<span class=\"params\">node: ASTNode, isInFor: boolean</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.static || node.once) &#123;</span><br><span class=\"line\">      node.staticInFor = isInFor</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// For a node to qualify as a static root, it should have children that</span></span><br><span class=\"line\">    <span class=\"comment\">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class=\"line\">    <span class=\"comment\">// outweigh the benefits and it's better off to just always render it fresh.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class=\"line\">      node.children.length === <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">      node.children[<span class=\"number\">0</span>].type === <span class=\"number\">3</span></span><br><span class=\"line\">    )) &#123;</span><br><span class=\"line\">      node.staticRoot = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      node.staticRoot = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.children) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.ifConditions[i].block, isInFor)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，首先<code>markStaticRoots</code> 第二个参数是 <code>isInFor</code>，对于已经是 <code>static</code> 的节点或者是 <code>v-once</code> 指令的节点，<code>node.staticInFor = isInFor</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.static || node.once) &#123;</span><br><span class=\"line\">    node.staticInFor = isInFor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着判断该节点是否为静态根节点，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// For a node to qualify as a static root, it should have children that</span></span><br><span class=\"line\"><span class=\"comment\">// are not just static text. Otherwise the cost of hoisting out will</span></span><br><span class=\"line\"><span class=\"comment\">// outweigh the benefits and it's better off to just always render it fresh.</span></span><br><span class=\"line\"><span class=\"comment\">// 为了使节点有资格作为静态根节点，它应具有不只是静态文本的子节点。 否则，优化的成本将超过收益，最好始终将其更新。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class=\"line\">    node.children.length === <span class=\"number\">1</span> &amp;&amp;</span><br><span class=\"line\">    node.children[<span class=\"number\">0</span>].type === <span class=\"number\">3</span></span><br><span class=\"line\">)) &#123;</span><br><span class=\"line\">    node.staticRoot = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    node.staticRoot = <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码和注释中我们可以看到，一个节点要想成为静态根节点，它必须满足以下要求：</p>\n<ul>\n<li>节点本身必须是静态节点；</li>\n<li>必须拥有子节点 <code>children</code>；</li>\n<li>子节点不能只是只有一个文本节点；</li>\n</ul>\n<p>否则的话，对它的优化成本将大于优化后带来的收益。</p>\n<p>如果当前节点不是静态根节点，那就继续递归遍历它的子节点<code>node.children</code>和<code>node.ifConditions</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.children) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.children[i], isInFor || !!node.for)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (node.ifConditions) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>, l = node.ifConditions.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">        markStaticRoots(node.ifConditions[i].block, isInFor)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的原理跟寻找静态节点相同，此处就不再重复。</p>\n<h2>4. 总结</h2>\n<p>本篇文章介绍了模板编译过程三大阶段的第二阶段——优化阶段。</p>\n<p>首先，介绍了为什么要有优化阶段，是为了提高虚拟<code>DOM</code>中<code>patch</code>过程的性能。在优化阶段将所有静态节点都打上标记，这样在<code>patch</code>过程中就可以跳过对比这些节点。</p>\n<p>接着，介绍了优化阶段主要干了两件事情，分别是从构建出的<code>AST</code>中找出并标记所有静态节点和所有静态根节点。</p>\n<p>最后，分别通过逐行分析源码的方式分析了这两件事具体的内部工作原理。</p>\n"},{"title":"Vue 源码阅读 模板编译（六）","catalog":true,"date":"2019-10-26T10:39:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n经过前几篇文章，我们把用户所写的模板字符串先经过解析阶段解析生成对应的抽象语法树`AST`，接着再经过优化阶段将`AST`中的静态节点及静态根节点都打上标记，现在终于到了模板编译三大阶段的最后一个阶段了——代码生成阶段。所谓代码生成阶段，到底是要生成什么代码？答：要生成`render`函数字符串。\n\n我们知道，`Vue`实例在挂载的时候会调用其自身的`render`函数来生成实例上的`template`选项所对应的`VNode`，简单的来说就是`Vue`只要调用了`render`函数，就可以把模板转换成对应的虚拟`DOM`。那么`Vue`要想调用`render`函数，那必须要先有这个`render`函数，那这个`render`函数又是从哪来的呢？是用户手写的还是`Vue`自己生成的？答案是都有可能。我们知道，我们在日常开发中是可以在`Vue`组件选项中手写一个`render`选项，其值对应一个函数，那这个函数就是`render`函数，当用户手写了`render`函数时，那么`Vue`在挂载该组件的时候就会调用用户手写的这个`render`函数。那如果用户没有写呢？那这个时候`Vue`就要自己根据模板内容生成一个`render`函数供组件挂载的时候调用。而`Vue`自己根据模板内容生成`render`函数的过程就是本篇文章所要介绍的代码生成阶段。\n\n现在我们知道了，所谓代码生成其实就是根据模板对应的抽象语法树`AST`生成一个函数，通过调用这个函数就可以得到模板对应的虚拟`DOM`。\n\n## 2. 如何根据AST生成render函数\n\n通过上文我们知道了，代码生成阶段主要的工作就是根据已有的`AST`生成对应的`render`函数供组件挂载时调用，组件只要调用的这个`render`函数就可以得到`AST`对应的虚拟`DOM`的`VNode`。那么如何根据`AST`生成`render`函数呢？这其中是怎样一个过程呢？接下来我们就来细细剖析一下。\n\n假设现有如下模板：\n\n```html\n<div id=\"NLRX\"><p>Hello {{name}}</p></div>\n```\n\n该模板经过解析并优化后对应的`AST`如下：\n\n```javascript\nast = {\n    'type': 1,\n    'tag': 'div',\n    'attrsList': [\n        {\n            'name':'id',\n            'value':'NLRX',\n        }\n    ],\n    'attrsMap': {\n      'id': 'NLRX',\n    },\n    'static':false,\n    'parent': undefined,\n    'plain': false,\n    'children': [{\n      'type': 1,\n      'tag': 'p',\n      'plain': false,\n      'static':false,  \n      'children': [\n        {\n            'type': 2,\n            'expression': '\"Hello \"+_s(name)',\n            'text': 'Hello {{name}}',\n            'static':false,\n        }\n      ]\n    }]\n  }\n```\n\n下面我们就来根据已有的这个`AST`来生成对应的`render`函数。生成`render`函数的过程其实就是一个递归的过程，从顶向下依次递归`AST`中的每一个节点，根据不同的`AST`节点类型创建不同的`VNode`类型。接下来我们就来对照已有的模板和`AST`实际演示一下生成`render`函数的过程。\n\n1. 首先，根节点`div`是一个元素型`AST`节点，那么我们就要创建一个元素型`VNode`，我们把创建元素型`VNode`的方法叫做`_c(tagName,data,children)`。我们暂且不管`_c()`是什么，只需知道调用`_c()`就可以创建一个元素型`VNode`。那么就可以生成如下代码：\n\n   ```javascript\n   _c('div',{attrs:{\"id\":\"NLRX\"}},[/*子节点列表*/])\n   ```\n\n2. 根节点`div`有子节点，那么我们进入子节点列表`children`里遍历子节点，发现子节点`p`也是元素型的，那就继续创建元素型`VNode`并将其放入上述代码中根节点的子节点列表中，如下：\n\n   ```javascript\n   _c('div',{attrs:{\"id\":\"NLRX\"}},[_c('p'),[/*子节点列表*/]])\n   ```\n\n3. 同理，继续遍历`p`节点的子节点，发现是一个文本型节点，那就创建一个文本型`VNode`并将其插入到`p`节点的子节点列表中，同理，创建文本型`VNode`我们调用`_v()`方法，如下：\n\n   ```javascript\n   _c('div',{attrs:{\"id\":\"NLRX\"}},[_c('p'),[_v(\"Hello \"+_s(name))]])\n   ```\n\n4. 到此，整个`AST`就遍历完毕了，我们将得到的代码再包装一下，如下：\n\n   ```javascript\n   `\n   with(this){\n       reurn _c(\n           'div',\n           {\n               attrs:{\"id\":\"NLRX\"},\n           }\n           [\n               _c('p'),\n               [\n                   _v(\"Hello \"+_s(name))\n               ]\n           ])\n   }\n   `\n   ```\n\n5. 最后，我们将上面得到的这个函数字符串传递给`createFunction `函数（关于这个函数在后面会介绍到），`createFunction `函数会帮我们把得到的函数字符串转换成真正的函数，赋给组件中的`render`选项，从而就是`render`函数了。如下：\n\n   ```javascript\n   res.render = createFunction(compiled.render, fnGenErrors)\n   \n   function createFunction (code, errors) {\n     try {\n       return new Function(code)\n     } catch (err) {\n       errors.push({ err, code })\n       return noop\n     }\n   }\n   ```\n\n以上就是根据一个简单的模板所对应的`AST`生成`render`函数的过程，理论过程我们已经了解了，那么在源码中实际是如何实现的呢？下面我们就回归源码分析其具体实现过程。\n\n## 3. 回归源码\n\n代码生成阶段的源码位于`src/compiler/codegen/index.js` 中，源码虽然很长，但是逻辑不复杂，核心逻辑如下：\n\n```javascript\nexport function generate (ast,option) {\n  const state = new CodegenState(options)\n  const code = ast ? genElement(ast, state) : '_c(\"div\")'\n  return {\n    render: `with(this){return ${code}}`,\n    staticRenderFns: state.staticRenderFns\n  }\n}\n```\n\n```javascript\nconst code = generate(ast, options)\n```\n\n调用`generate`函数并传入优化后得到的`ast`，在`generate`函数内部先判断`ast`是否为空，不为空则调用`genElement(ast, state)`函数创建`VNode`，为空则创建一个空的元素型`div`的`VNode`。然后将得到的结果用`with(this){return ${code}}`包裹返回。可以看出，真正起作用的是`genElement`函数，下面我们继续来看一下`genElement`函数内部是怎样的。\n\n`genElement`函数定义如下：\n\n```javascript\nexport function genElement (el: ASTElement, state: CodegenState): string {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      const data = el.plain ? undefined : genData(el, state)\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c('${el.tag}'${\n        data ? `,${data}` : '' // data\n      }${\n        children ? `,${children}` : '' // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n```\n\n`genElement`函数逻辑很清晰，就是根据当前 `AST` 元素节点属性的不同从而执行不同的代码生成函数。虽然元素节点属性的情况有很多种，但是最后真正创建出来的`VNode`无非就三种，分别是元素节点，文本节点，注释节点。接下来我们就着重分析一下如何生成这三种节点类型的`render`函数的。\n\n### 3.1 元素节点\n\n生成元素型节点的`render`函数代码如下：\n\n```javascript\nconst data = el.plain ? undefined : genData(el, state)\n\nconst children = el.inlineTemplate ? null : genChildren(el, state, true)\ncode = `_c('${el.tag}'${\ndata ? `,${data}` : '' // data\n}${\nchildren ? `,${children}` : '' // children\n})`\n```\n\n生成元素节点的`render`函数就是生成一个`_c()`函数调用的字符串，上文提到了`_c()`函数接收三个参数，分别是节点的标签名`tagName`，节点属性`data`，节点的子节点列表`children`。那么我们只需将这三部分都填进去即可。\n\n1. 获取节点属性data\n\n   首先判断`plain`属性是否为`true`，若为`true`则表示节点没有属性，将`data`赋值为`undefined`；如果不为`true`则调用`genData`函数获取节点属性`data`数据。`genData`函数定义如下：\n\n   ```javascript\n   export function genData (el: ASTElement, state: CodegenState): string {\n     let data = '{'\n     const dirs = genDirectives(el, state)\n     if (dirs) data += dirs + ','\n   \n       // key\n       if (el.key) {\n           data += `key:${el.key},`\n       }\n       // ref\n       if (el.ref) {\n           data += `ref:${el.ref},`\n       }\n       if (el.refInFor) {\n           data += `refInFor:true,`\n       }\n       // pre\n       if (el.pre) {\n           data += `pre:true,`\n       }\n       // 篇幅所限，省略其他情况的判断\t\n       data = data.replace(/,$/, '') + '}'\n       return data\n   }\n   ```\n\n   我们看到，源码中`genData`虽然很长，但是其逻辑非常简单，就是在拼接字符串，先给`data`赋值为一个`{`，然后判断存在哪些属性数据，就将这些数据拼接到`data`中，最后再加一个`}`，最终得到节点全部属性`data`。\n\n2. 获取子节点列表children\n\n   获取子节点列表`children`其实就是遍历`AST`的`children`属性中的元素，然后根据元素属性的不同生成不同的`VNode`创建函数调用字符串，如下：\n\n   ```javascript\n   export function genChildren (el):  {\n       if (children.length) {\n           return `[${children.map(c => genNode(c, state)).join(',')}]`\n       }\n   }\n   function genNode (node: ASTNode, state: CodegenState): string {\n     if (node.type === 1) {\n       return genElement(node, state)\n     } if (node.type === 3 && node.isComment) {\n       return genComment(node)\n     } else {\n       return genText(node)\n     }\n   }\n   ```\n\n3. 上面两步完成之后，生成`_c（）`函数调用字符串，如下：\n\n   ```javascript\n   code = `_c('${el.tag}'${\n           data ? `,${data}` : '' // data\n         }${\n           children ? `,${children}` : '' // children\n         })`\n   ```\n\n### 3.2 文本节点\n\n文本型的`VNode`可以调用`_v(text)`函数来创建，所以生成文本节点的`render`函数就是生成一个`_v(text)`函数调用的字符串。`_v()`函数接收文本内容作为参数，如果文本是动态文本，则使用动态文本`AST`节点的`expression`属性，如果是纯静态文本，则使用`text`属性。其生成代码如下：\n\n```javascript\nexport function genText (text: ASTText | ASTExpression): string {\n  return `_v(${text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))\n  })`\n}\n```\n\n### 3.3 注释节点\n\n注释型的`VNode`可以调用`_e(text)`函数来创建，所以生成注释节点的`render`函数就是生成一个`_e(text)`函数调用的字符串。`_e()`函数接收注释内容作为参数，其生成代码如下：\n\n```javascript\nexport function genComment (comment: ASTText): string {\n  return `_e(${JSON.stringify(comment.text)})`\n}\n```\n\n## 4. 总结\n\n本篇文章介绍了模板编译三大阶段的最后一个阶段——代码生成阶段。\n\n首先，介绍了为什么要有代码生成阶段以及代码生成阶段主要干什么。我们知道了，代码生成其实就是根据模板对应的抽象语法树`AST`生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟`DOM`。\n\n接着，我们通过一个简单的模板演示了把模板经过递归遍历最后生成`render`函数的过程。\n\n最后，我们回归源码，通过分析源码了解了生成`render`函数的具体实现过程。\n\n\n\n","source":"_posts/Vue 源码阅读 模板编译（六）.md","raw":"---\ntitle: Vue 源码阅读 模板编译（六）\ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-26 18:39:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n经过前几篇文章，我们把用户所写的模板字符串先经过解析阶段解析生成对应的抽象语法树`AST`，接着再经过优化阶段将`AST`中的静态节点及静态根节点都打上标记，现在终于到了模板编译三大阶段的最后一个阶段了——代码生成阶段。所谓代码生成阶段，到底是要生成什么代码？答：要生成`render`函数字符串。\n\n我们知道，`Vue`实例在挂载的时候会调用其自身的`render`函数来生成实例上的`template`选项所对应的`VNode`，简单的来说就是`Vue`只要调用了`render`函数，就可以把模板转换成对应的虚拟`DOM`。那么`Vue`要想调用`render`函数，那必须要先有这个`render`函数，那这个`render`函数又是从哪来的呢？是用户手写的还是`Vue`自己生成的？答案是都有可能。我们知道，我们在日常开发中是可以在`Vue`组件选项中手写一个`render`选项，其值对应一个函数，那这个函数就是`render`函数，当用户手写了`render`函数时，那么`Vue`在挂载该组件的时候就会调用用户手写的这个`render`函数。那如果用户没有写呢？那这个时候`Vue`就要自己根据模板内容生成一个`render`函数供组件挂载的时候调用。而`Vue`自己根据模板内容生成`render`函数的过程就是本篇文章所要介绍的代码生成阶段。\n\n现在我们知道了，所谓代码生成其实就是根据模板对应的抽象语法树`AST`生成一个函数，通过调用这个函数就可以得到模板对应的虚拟`DOM`。\n\n## 2. 如何根据AST生成render函数\n\n通过上文我们知道了，代码生成阶段主要的工作就是根据已有的`AST`生成对应的`render`函数供组件挂载时调用，组件只要调用的这个`render`函数就可以得到`AST`对应的虚拟`DOM`的`VNode`。那么如何根据`AST`生成`render`函数呢？这其中是怎样一个过程呢？接下来我们就来细细剖析一下。\n\n假设现有如下模板：\n\n```html\n<div id=\"NLRX\"><p>Hello {{name}}</p></div>\n```\n\n该模板经过解析并优化后对应的`AST`如下：\n\n```javascript\nast = {\n    'type': 1,\n    'tag': 'div',\n    'attrsList': [\n        {\n            'name':'id',\n            'value':'NLRX',\n        }\n    ],\n    'attrsMap': {\n      'id': 'NLRX',\n    },\n    'static':false,\n    'parent': undefined,\n    'plain': false,\n    'children': [{\n      'type': 1,\n      'tag': 'p',\n      'plain': false,\n      'static':false,  \n      'children': [\n        {\n            'type': 2,\n            'expression': '\"Hello \"+_s(name)',\n            'text': 'Hello {{name}}',\n            'static':false,\n        }\n      ]\n    }]\n  }\n```\n\n下面我们就来根据已有的这个`AST`来生成对应的`render`函数。生成`render`函数的过程其实就是一个递归的过程，从顶向下依次递归`AST`中的每一个节点，根据不同的`AST`节点类型创建不同的`VNode`类型。接下来我们就来对照已有的模板和`AST`实际演示一下生成`render`函数的过程。\n\n1. 首先，根节点`div`是一个元素型`AST`节点，那么我们就要创建一个元素型`VNode`，我们把创建元素型`VNode`的方法叫做`_c(tagName,data,children)`。我们暂且不管`_c()`是什么，只需知道调用`_c()`就可以创建一个元素型`VNode`。那么就可以生成如下代码：\n\n   ```javascript\n   _c('div',{attrs:{\"id\":\"NLRX\"}},[/*子节点列表*/])\n   ```\n\n2. 根节点`div`有子节点，那么我们进入子节点列表`children`里遍历子节点，发现子节点`p`也是元素型的，那就继续创建元素型`VNode`并将其放入上述代码中根节点的子节点列表中，如下：\n\n   ```javascript\n   _c('div',{attrs:{\"id\":\"NLRX\"}},[_c('p'),[/*子节点列表*/]])\n   ```\n\n3. 同理，继续遍历`p`节点的子节点，发现是一个文本型节点，那就创建一个文本型`VNode`并将其插入到`p`节点的子节点列表中，同理，创建文本型`VNode`我们调用`_v()`方法，如下：\n\n   ```javascript\n   _c('div',{attrs:{\"id\":\"NLRX\"}},[_c('p'),[_v(\"Hello \"+_s(name))]])\n   ```\n\n4. 到此，整个`AST`就遍历完毕了，我们将得到的代码再包装一下，如下：\n\n   ```javascript\n   `\n   with(this){\n       reurn _c(\n           'div',\n           {\n               attrs:{\"id\":\"NLRX\"},\n           }\n           [\n               _c('p'),\n               [\n                   _v(\"Hello \"+_s(name))\n               ]\n           ])\n   }\n   `\n   ```\n\n5. 最后，我们将上面得到的这个函数字符串传递给`createFunction `函数（关于这个函数在后面会介绍到），`createFunction `函数会帮我们把得到的函数字符串转换成真正的函数，赋给组件中的`render`选项，从而就是`render`函数了。如下：\n\n   ```javascript\n   res.render = createFunction(compiled.render, fnGenErrors)\n   \n   function createFunction (code, errors) {\n     try {\n       return new Function(code)\n     } catch (err) {\n       errors.push({ err, code })\n       return noop\n     }\n   }\n   ```\n\n以上就是根据一个简单的模板所对应的`AST`生成`render`函数的过程，理论过程我们已经了解了，那么在源码中实际是如何实现的呢？下面我们就回归源码分析其具体实现过程。\n\n## 3. 回归源码\n\n代码生成阶段的源码位于`src/compiler/codegen/index.js` 中，源码虽然很长，但是逻辑不复杂，核心逻辑如下：\n\n```javascript\nexport function generate (ast,option) {\n  const state = new CodegenState(options)\n  const code = ast ? genElement(ast, state) : '_c(\"div\")'\n  return {\n    render: `with(this){return ${code}}`,\n    staticRenderFns: state.staticRenderFns\n  }\n}\n```\n\n```javascript\nconst code = generate(ast, options)\n```\n\n调用`generate`函数并传入优化后得到的`ast`，在`generate`函数内部先判断`ast`是否为空，不为空则调用`genElement(ast, state)`函数创建`VNode`，为空则创建一个空的元素型`div`的`VNode`。然后将得到的结果用`with(this){return ${code}}`包裹返回。可以看出，真正起作用的是`genElement`函数，下面我们继续来看一下`genElement`函数内部是怎样的。\n\n`genElement`函数定义如下：\n\n```javascript\nexport function genElement (el: ASTElement, state: CodegenState): string {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    let code\n    if (el.component) {\n      code = genComponent(el.component, el, state)\n    } else {\n      const data = el.plain ? undefined : genData(el, state)\n\n      const children = el.inlineTemplate ? null : genChildren(el, state, true)\n      code = `_c('${el.tag}'${\n        data ? `,${data}` : '' // data\n      }${\n        children ? `,${children}` : '' // children\n      })`\n    }\n    // module transforms\n    for (let i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code)\n    }\n    return code\n  }\n}\n```\n\n`genElement`函数逻辑很清晰，就是根据当前 `AST` 元素节点属性的不同从而执行不同的代码生成函数。虽然元素节点属性的情况有很多种，但是最后真正创建出来的`VNode`无非就三种，分别是元素节点，文本节点，注释节点。接下来我们就着重分析一下如何生成这三种节点类型的`render`函数的。\n\n### 3.1 元素节点\n\n生成元素型节点的`render`函数代码如下：\n\n```javascript\nconst data = el.plain ? undefined : genData(el, state)\n\nconst children = el.inlineTemplate ? null : genChildren(el, state, true)\ncode = `_c('${el.tag}'${\ndata ? `,${data}` : '' // data\n}${\nchildren ? `,${children}` : '' // children\n})`\n```\n\n生成元素节点的`render`函数就是生成一个`_c()`函数调用的字符串，上文提到了`_c()`函数接收三个参数，分别是节点的标签名`tagName`，节点属性`data`，节点的子节点列表`children`。那么我们只需将这三部分都填进去即可。\n\n1. 获取节点属性data\n\n   首先判断`plain`属性是否为`true`，若为`true`则表示节点没有属性，将`data`赋值为`undefined`；如果不为`true`则调用`genData`函数获取节点属性`data`数据。`genData`函数定义如下：\n\n   ```javascript\n   export function genData (el: ASTElement, state: CodegenState): string {\n     let data = '{'\n     const dirs = genDirectives(el, state)\n     if (dirs) data += dirs + ','\n   \n       // key\n       if (el.key) {\n           data += `key:${el.key},`\n       }\n       // ref\n       if (el.ref) {\n           data += `ref:${el.ref},`\n       }\n       if (el.refInFor) {\n           data += `refInFor:true,`\n       }\n       // pre\n       if (el.pre) {\n           data += `pre:true,`\n       }\n       // 篇幅所限，省略其他情况的判断\t\n       data = data.replace(/,$/, '') + '}'\n       return data\n   }\n   ```\n\n   我们看到，源码中`genData`虽然很长，但是其逻辑非常简单，就是在拼接字符串，先给`data`赋值为一个`{`，然后判断存在哪些属性数据，就将这些数据拼接到`data`中，最后再加一个`}`，最终得到节点全部属性`data`。\n\n2. 获取子节点列表children\n\n   获取子节点列表`children`其实就是遍历`AST`的`children`属性中的元素，然后根据元素属性的不同生成不同的`VNode`创建函数调用字符串，如下：\n\n   ```javascript\n   export function genChildren (el):  {\n       if (children.length) {\n           return `[${children.map(c => genNode(c, state)).join(',')}]`\n       }\n   }\n   function genNode (node: ASTNode, state: CodegenState): string {\n     if (node.type === 1) {\n       return genElement(node, state)\n     } if (node.type === 3 && node.isComment) {\n       return genComment(node)\n     } else {\n       return genText(node)\n     }\n   }\n   ```\n\n3. 上面两步完成之后，生成`_c（）`函数调用字符串，如下：\n\n   ```javascript\n   code = `_c('${el.tag}'${\n           data ? `,${data}` : '' // data\n         }${\n           children ? `,${children}` : '' // children\n         })`\n   ```\n\n### 3.2 文本节点\n\n文本型的`VNode`可以调用`_v(text)`函数来创建，所以生成文本节点的`render`函数就是生成一个`_v(text)`函数调用的字符串。`_v()`函数接收文本内容作为参数，如果文本是动态文本，则使用动态文本`AST`节点的`expression`属性，如果是纯静态文本，则使用`text`属性。其生成代码如下：\n\n```javascript\nexport function genText (text: ASTText | ASTExpression): string {\n  return `_v(${text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))\n  })`\n}\n```\n\n### 3.3 注释节点\n\n注释型的`VNode`可以调用`_e(text)`函数来创建，所以生成注释节点的`render`函数就是生成一个`_e(text)`函数调用的字符串。`_e()`函数接收注释内容作为参数，其生成代码如下：\n\n```javascript\nexport function genComment (comment: ASTText): string {\n  return `_e(${JSON.stringify(comment.text)})`\n}\n```\n\n## 4. 总结\n\n本篇文章介绍了模板编译三大阶段的最后一个阶段——代码生成阶段。\n\n首先，介绍了为什么要有代码生成阶段以及代码生成阶段主要干什么。我们知道了，代码生成其实就是根据模板对应的抽象语法树`AST`生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟`DOM`。\n\n接着，我们通过一个简单的模板演示了把模板经过递归遍历最后生成`render`函数的过程。\n\n最后，我们回归源码，通过分析源码了解了生成`render`函数的具体实现过程。\n\n\n\n","slug":"Vue 源码阅读 模板编译（六）","published":1,"updated":"2019-12-31T03:14:11.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj83006tzws6w0q5v416","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>经过前几篇文章，我们把用户所写的模板字符串先经过解析阶段解析生成对应的抽象语法树<code>AST</code>，接着再经过优化阶段将<code>AST</code>中的静态节点及静态根节点都打上标记，现在终于到了模板编译三大阶段的最后一个阶段了——代码生成阶段。所谓代码生成阶段，到底是要生成什么代码？答：要生成<code>render</code>函数字符串。</p>\n<p>我们知道，<code>Vue</code>实例在挂载的时候会调用其自身的<code>render</code>函数来生成实例上的<code>template</code>选项所对应的<code>VNode</code>，简单的来说就是<code>Vue</code>只要调用了<code>render</code>函数，就可以把模板转换成对应的虚拟<code>DOM</code>。那么<code>Vue</code>要想调用<code>render</code>函数，那必须要先有这个<code>render</code>函数，那这个<code>render</code>函数又是从哪来的呢？是用户手写的还是<code>Vue</code>自己生成的？答案是都有可能。我们知道，我们在日常开发中是可以在<code>Vue</code>组件选项中手写一个<code>render</code>选项，其值对应一个函数，那这个函数就是<code>render</code>函数，当用户手写了<code>render</code>函数时，那么<code>Vue</code>在挂载该组件的时候就会调用用户手写的这个<code>render</code>函数。那如果用户没有写呢？那这个时候<code>Vue</code>就要自己根据模板内容生成一个<code>render</code>函数供组件挂载的时候调用。而<code>Vue</code>自己根据模板内容生成<code>render</code>函数的过程就是本篇文章所要介绍的代码生成阶段。</p>\n<p>现在我们知道了，所谓代码生成其实就是根据模板对应的抽象语法树<code>AST</code>生成一个函数，通过调用这个函数就可以得到模板对应的虚拟<code>DOM</code>。</p>\n<h2><span id=\"2-如何根据ast生成render函数\">2. 如何根据AST生成render函数</span></h2>\n<p>通过上文我们知道了，代码生成阶段主要的工作就是根据已有的<code>AST</code>生成对应的<code>render</code>函数供组件挂载时调用，组件只要调用的这个<code>render</code>函数就可以得到<code>AST</code>对应的虚拟<code>DOM</code>的<code>VNode</code>。那么如何根据<code>AST</code>生成<code>render</code>函数呢？这其中是怎样一个过程呢？接下来我们就来细细剖析一下。</p>\n<p>假设现有如下模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"NLRX\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello &#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该模板经过解析并优化后对应的<code>AST</code>如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ast = &#123;</span><br><span class=\"line\">    <span class=\"string\">'type'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'tag'</span>: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    <span class=\"string\">'attrsList'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'name'</span>:<span class=\"string\">'id'</span>,</span><br><span class=\"line\">            <span class=\"string\">'value'</span>:<span class=\"string\">'NLRX'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">'id'</span>: <span class=\"string\">'NLRX'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'static'</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">'parent'</span>: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    <span class=\"string\">'plain'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">'children'</span>: [&#123;</span><br><span class=\"line\">      <span class=\"string\">'type'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"string\">'tag'</span>: <span class=\"string\">'p'</span>,</span><br><span class=\"line\">      <span class=\"string\">'plain'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">'static'</span>:<span class=\"literal\">false</span>,  </span><br><span class=\"line\">      <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'type'</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">            <span class=\"string\">'expression'</span>: <span class=\"string\">'\"Hello \"+_s(name)'</span>,</span><br><span class=\"line\">            <span class=\"string\">'text'</span>: <span class=\"string\">'Hello &#123;&#123;name&#125;&#125;'</span>,</span><br><span class=\"line\">            <span class=\"string\">'static'</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们就来根据已有的这个<code>AST</code>来生成对应的<code>render</code>函数。生成<code>render</code>函数的过程其实就是一个递归的过程，从顶向下依次递归<code>AST</code>中的每一个节点，根据不同的<code>AST</code>节点类型创建不同的<code>VNode</code>类型。接下来我们就来对照已有的模板和<code>AST</code>实际演示一下生成<code>render</code>函数的过程。</p>\n<ol>\n<li>\n<p>首先，根节点<code>div</code>是一个元素型<code>AST</code>节点，那么我们就要创建一个元素型<code>VNode</code>，我们把创建元素型<code>VNode</code>的方法叫做<code>_c(tagName,data,children)</code>。我们暂且不管<code>_c()</code>是什么，只需知道调用<code>_c()</code>就可以创建一个元素型<code>VNode</code>。那么就可以生成如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_c(<span class=\"string\">'div'</span>,&#123;<span class=\"attr\">attrs</span>:&#123;<span class=\"string\">\"id\"</span>:<span class=\"string\">\"NLRX\"</span>&#125;&#125;,[<span class=\"comment\">/*子节点列表*/</span>])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>根节点<code>div</code>有子节点，那么我们进入子节点列表<code>children</code>里遍历子节点，发现子节点<code>p</code>也是元素型的，那就继续创建元素型<code>VNode</code>并将其放入上述代码中根节点的子节点列表中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_c(<span class=\"string\">'div'</span>,&#123;<span class=\"attr\">attrs</span>:&#123;<span class=\"string\">\"id\"</span>:<span class=\"string\">\"NLRX\"</span>&#125;&#125;,[_c(<span class=\"string\">'p'</span>),[<span class=\"comment\">/*子节点列表*/</span>]])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>同理，继续遍历<code>p</code>节点的子节点，发现是一个文本型节点，那就创建一个文本型<code>VNode</code>并将其插入到<code>p</code>节点的子节点列表中，同理，创建文本型<code>VNode</code>我们调用<code>_v()</code>方法，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_c(<span class=\"string\">'div'</span>,&#123;<span class=\"attr\">attrs</span>:&#123;<span class=\"string\">\"id\"</span>:<span class=\"string\">\"NLRX\"</span>&#125;&#125;,[_c(<span class=\"string\">'p'</span>),[_v(<span class=\"string\">\"Hello \"</span>+_s(name))]])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>到此，整个<code>AST</code>就遍历完毕了，我们将得到的代码再包装一下，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">with(this)&#123;</span></span><br><span class=\"line\"><span class=\"string\">    reurn _c(</span></span><br><span class=\"line\"><span class=\"string\">        'div',</span></span><br><span class=\"line\"><span class=\"string\">        &#123;</span></span><br><span class=\"line\"><span class=\"string\">            attrs:&#123;\"id\":\"NLRX\"&#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        [</span></span><br><span class=\"line\"><span class=\"string\">            _c('p'),</span></span><br><span class=\"line\"><span class=\"string\">            [</span></span><br><span class=\"line\"><span class=\"string\">                _v(\"Hello \"+_s(name))</span></span><br><span class=\"line\"><span class=\"string\">            ]</span></span><br><span class=\"line\"><span class=\"string\">        ])</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>最后，我们将上面得到的这个函数字符串传递给<code>createFunction</code>函数（关于这个函数在后面会介绍到），<code>createFunction</code>函数会帮我们把得到的函数字符串转换成真正的函数，赋给组件中的<code>render</code>选项，从而就是<code>render</code>函数了。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.render = createFunction(compiled.render, fnGenErrors)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunction</span> (<span class=\"params\">code, errors</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(code)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    errors.push(&#123; err, code &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> noop</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以上就是根据一个简单的模板所对应的<code>AST</code>生成<code>render</code>函数的过程，理论过程我们已经了解了，那么在源码中实际是如何实现的呢？下面我们就回归源码分析其具体实现过程。</p>\n<h2><span id=\"3-回归源码\">3. 回归源码</span></h2>\n<p>代码生成阶段的源码位于<code>src/compiler/codegen/index.js</code> 中，源码虽然很长，但是逻辑不复杂，核心逻辑如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generate</span> (<span class=\"params\">ast,option</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = <span class=\"keyword\">new</span> CodegenState(options)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = ast ? genElement(ast, state) : <span class=\"string\">'_c(\"div\")'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render: <span class=\"string\">`with(this)&#123;return <span class=\"subst\">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class=\"line\">    staticRenderFns: state.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> code = generate(ast, options)</span><br></pre></td></tr></table></figure>\n<p>调用<code>generate</code>函数并传入优化后得到的<code>ast</code>，在<code>generate</code>函数内部先判断<code>ast</code>是否为空，不为空则调用<code>genElement(ast, state)</code>函数创建<code>VNode</code>，为空则创建一个空的元素型<code>div</code>的<code>VNode</code>。然后将得到的结果用<code>with(this){return ${code}}</code>包裹返回。可以看出，真正起作用的是<code>genElement</code>函数，下面我们继续来看一下<code>genElement</code>函数内部是怎样的。</p>\n<p><code>genElement</code>函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genElement</span> (<span class=\"params\">el: ASTElement, state: CodegenState</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genStatic(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genOnce(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genFor(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genIf(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.tag === <span class=\"string\">'template'</span> &amp;&amp; !el.slotTarget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genChildren(el, state) || <span class=\"string\">'void 0'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.tag === <span class=\"string\">'slot'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genSlot(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// component or element</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.component) &#123;</span><br><span class=\"line\">      code = genComponent(el.component, el, state)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> data = el.plain ? <span class=\"literal\">undefined</span> : genData(el, state)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> children = el.inlineTemplate ? <span class=\"literal\">null</span> : genChildren(el, state, <span class=\"literal\">true</span>)</span><br><span class=\"line\">      code = <span class=\"string\">`_c('<span class=\"subst\">$&#123;el.tag&#125;</span>'<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        data ? <span class=\"string\">`,<span class=\"subst\">$&#123;data&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> data</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span><span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        children ? <span class=\"string\">`,<span class=\"subst\">$&#123;children&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> children</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span>)`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// module transforms</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; state.transforms.length; i++) &#123;</span><br><span class=\"line\">      code = state.transforms[i](el, code)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> code</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>genElement</code>函数逻辑很清晰，就是根据当前 <code>AST</code> 元素节点属性的不同从而执行不同的代码生成函数。虽然元素节点属性的情况有很多种，但是最后真正创建出来的<code>VNode</code>无非就三种，分别是元素节点，文本节点，注释节点。接下来我们就着重分析一下如何生成这三种节点类型的<code>render</code>函数的。</p>\n<h3><span id=\"31-元素节点\">3.1 元素节点</span></h3>\n<p>生成元素型节点的<code>render</code>函数代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = el.plain ? <span class=\"literal\">undefined</span> : genData(el, state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> children = el.inlineTemplate ? <span class=\"literal\">null</span> : genChildren(el, state, <span class=\"literal\">true</span>)</span><br><span class=\"line\">code = <span class=\"string\">`_c('<span class=\"subst\">$&#123;el.tag&#125;</span>'<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">data ? <span class=\"string\">`,<span class=\"subst\">$&#123;data&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> data</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">&#125;</span><span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">children ? <span class=\"string\">`,<span class=\"subst\">$&#123;children&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> children</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">&#125;</span>)`</span></span><br></pre></td></tr></table></figure>\n<p>生成元素节点的<code>render</code>函数就是生成一个<code>_c()</code>函数调用的字符串，上文提到了<code>_c()</code>函数接收三个参数，分别是节点的标签名<code>tagName</code>，节点属性<code>data</code>，节点的子节点列表<code>children</code>。那么我们只需将这三部分都填进去即可。</p>\n<ol>\n<li>\n<p>获取节点属性data</p>\n<p>首先判断<code>plain</code>属性是否为<code>true</code>，若为<code>true</code>则表示节点没有属性，将<code>data</code>赋值为<code>undefined</code>；如果不为<code>true</code>则调用<code>genData</code>函数获取节点属性<code>data</code>数据。<code>genData</code>函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genData</span> (<span class=\"params\">el: ASTElement, state: CodegenState</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"string\">'&#123;'</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dirs = genDirectives(el, state)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dirs) data += dirs + <span class=\"string\">','</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// key</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.key) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`key:<span class=\"subst\">$&#123;el.key&#125;</span>,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ref</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.ref) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`ref:<span class=\"subst\">$&#123;el.ref&#125;</span>,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.refInFor) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`refInFor:true,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pre</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.pre) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`pre:true,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 篇幅所限，省略其他情况的判断\t</span></span><br><span class=\"line\">    data = data.replace(<span class=\"regexp\">/,$/</span>, <span class=\"string\">''</span>) + <span class=\"string\">'&#125;'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，源码中<code>genData</code>虽然很长，但是其逻辑非常简单，就是在拼接字符串，先给<code>data</code>赋值为一个<code>{</code>，然后判断存在哪些属性数据，就将这些数据拼接到<code>data</code>中，最后再加一个<code>}</code>，最终得到节点全部属性<code>data</code>。</p>\n</li>\n<li>\n<p>获取子节点列表children</p>\n<p>获取子节点列表<code>children</code>其实就是遍历<code>AST</code>的<code>children</code>属性中的元素，然后根据元素属性的不同生成不同的<code>VNode</code>创建函数调用字符串，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genChildren</span> (<span class=\"params\">el</span>):  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (children.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`[<span class=\"subst\">$&#123;children.map(c =&gt; genNode(c, state)).join(<span class=\"string\">','</span>)&#125;</span>]`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genNode</span> (<span class=\"params\">node: ASTNode, state: CodegenState</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genElement(node, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">if</span> (node.type === <span class=\"number\">3</span> &amp;&amp; node.isComment) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genComment(node)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genText(node)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>上面两步完成之后，生成<code>_c（）</code>函数调用字符串，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code = <span class=\"string\">`_c('<span class=\"subst\">$&#123;el.tag&#125;</span>'<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        data ? <span class=\"string\">`,<span class=\"subst\">$&#123;data&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> data</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span><span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        children ? <span class=\"string\">`,<span class=\"subst\">$&#123;children&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> children</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span>)`</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3><span id=\"32-文本节点\">3.2 文本节点</span></h3>\n<p>文本型的<code>VNode</code>可以调用<code>_v(text)</code>函数来创建，所以生成文本节点的<code>render</code>函数就是生成一个<code>_v(text)</code>函数调用的字符串。<code>_v()</code>函数接收文本内容作为参数，如果文本是动态文本，则使用动态文本<code>AST</code>节点的<code>expression</code>属性，如果是纯静态文本，则使用<code>text</code>属性。其生成代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genText</span> (<span class=\"params\">text: ASTText | ASTExpression</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`_v(<span class=\"subst\">$&#123;text.type === <span class=\"number\">2</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">    ? text.expression <span class=\"regexp\">//</span> no need <span class=\"keyword\">for</span> () because already wrapped <span class=\"keyword\">in</span> _s()</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">    : transformSpecialNewlines(<span class=\"built_in\">JSON</span>.stringify(text.text))</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">  &#125;</span>)`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"33-注释节点\">3.3 注释节点</span></h3>\n<p>注释型的<code>VNode</code>可以调用<code>_e(text)</code>函数来创建，所以生成注释节点的<code>render</code>函数就是生成一个<code>_e(text)</code>函数调用的字符串。<code>_e()</code>函数接收注释内容作为参数，其生成代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genComment</span> (<span class=\"params\">comment: ASTText</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`_e(<span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(comment.text)&#125;</span>)`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"4-总结\">4. 总结</span></h2>\n<p>本篇文章介绍了模板编译三大阶段的最后一个阶段——代码生成阶段。</p>\n<p>首先，介绍了为什么要有代码生成阶段以及代码生成阶段主要干什么。我们知道了，代码生成其实就是根据模板对应的抽象语法树<code>AST</code>生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟<code>DOM</code>。</p>\n<p>接着，我们通过一个简单的模板演示了把模板经过递归遍历最后生成<code>render</code>函数的过程。</p>\n<p>最后，我们回归源码，通过分析源码了解了生成<code>render</code>函数的具体实现过程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>经过前几篇文章，我们把用户所写的模板字符串先经过解析阶段解析生成对应的抽象语法树<code>AST</code>，接着再经过优化阶段将<code>AST</code>中的静态节点及静态根节点都打上标记，现在终于到了模板编译三大阶段的最后一个阶段了——代码生成阶段。所谓代码生成阶段，到底是要生成什么代码？答：要生成<code>render</code>函数字符串。</p>\n<p>我们知道，<code>Vue</code>实例在挂载的时候会调用其自身的<code>render</code>函数来生成实例上的<code>template</code>选项所对应的<code>VNode</code>，简单的来说就是<code>Vue</code>只要调用了<code>render</code>函数，就可以把模板转换成对应的虚拟<code>DOM</code>。那么<code>Vue</code>要想调用<code>render</code>函数，那必须要先有这个<code>render</code>函数，那这个<code>render</code>函数又是从哪来的呢？是用户手写的还是<code>Vue</code>自己生成的？答案是都有可能。我们知道，我们在日常开发中是可以在<code>Vue</code>组件选项中手写一个<code>render</code>选项，其值对应一个函数，那这个函数就是<code>render</code>函数，当用户手写了<code>render</code>函数时，那么<code>Vue</code>在挂载该组件的时候就会调用用户手写的这个<code>render</code>函数。那如果用户没有写呢？那这个时候<code>Vue</code>就要自己根据模板内容生成一个<code>render</code>函数供组件挂载的时候调用。而<code>Vue</code>自己根据模板内容生成<code>render</code>函数的过程就是本篇文章所要介绍的代码生成阶段。</p>\n<p>现在我们知道了，所谓代码生成其实就是根据模板对应的抽象语法树<code>AST</code>生成一个函数，通过调用这个函数就可以得到模板对应的虚拟<code>DOM</code>。</p>\n<h2>2. 如何根据AST生成render函数</h2>\n<p>通过上文我们知道了，代码生成阶段主要的工作就是根据已有的<code>AST</code>生成对应的<code>render</code>函数供组件挂载时调用，组件只要调用的这个<code>render</code>函数就可以得到<code>AST</code>对应的虚拟<code>DOM</code>的<code>VNode</code>。那么如何根据<code>AST</code>生成<code>render</code>函数呢？这其中是怎样一个过程呢？接下来我们就来细细剖析一下。</p>\n<p>假设现有如下模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"NLRX\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello &#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该模板经过解析并优化后对应的<code>AST</code>如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ast = &#123;</span><br><span class=\"line\">    <span class=\"string\">'type'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'tag'</span>: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    <span class=\"string\">'attrsList'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'name'</span>:<span class=\"string\">'id'</span>,</span><br><span class=\"line\">            <span class=\"string\">'value'</span>:<span class=\"string\">'NLRX'</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">'attrsMap'</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">'id'</span>: <span class=\"string\">'NLRX'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'static'</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">'parent'</span>: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    <span class=\"string\">'plain'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">'children'</span>: [&#123;</span><br><span class=\"line\">      <span class=\"string\">'type'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">      <span class=\"string\">'tag'</span>: <span class=\"string\">'p'</span>,</span><br><span class=\"line\">      <span class=\"string\">'plain'</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"string\">'static'</span>:<span class=\"literal\">false</span>,  </span><br><span class=\"line\">      <span class=\"string\">'children'</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">'type'</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">            <span class=\"string\">'expression'</span>: <span class=\"string\">'\"Hello \"+_s(name)'</span>,</span><br><span class=\"line\">            <span class=\"string\">'text'</span>: <span class=\"string\">'Hello &#123;&#123;name&#125;&#125;'</span>,</span><br><span class=\"line\">            <span class=\"string\">'static'</span>:<span class=\"literal\">false</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们就来根据已有的这个<code>AST</code>来生成对应的<code>render</code>函数。生成<code>render</code>函数的过程其实就是一个递归的过程，从顶向下依次递归<code>AST</code>中的每一个节点，根据不同的<code>AST</code>节点类型创建不同的<code>VNode</code>类型。接下来我们就来对照已有的模板和<code>AST</code>实际演示一下生成<code>render</code>函数的过程。</p>\n<ol>\n<li>\n<p>首先，根节点<code>div</code>是一个元素型<code>AST</code>节点，那么我们就要创建一个元素型<code>VNode</code>，我们把创建元素型<code>VNode</code>的方法叫做<code>_c(tagName,data,children)</code>。我们暂且不管<code>_c()</code>是什么，只需知道调用<code>_c()</code>就可以创建一个元素型<code>VNode</code>。那么就可以生成如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_c(<span class=\"string\">'div'</span>,&#123;<span class=\"attr\">attrs</span>:&#123;<span class=\"string\">\"id\"</span>:<span class=\"string\">\"NLRX\"</span>&#125;&#125;,[<span class=\"comment\">/*子节点列表*/</span>])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>根节点<code>div</code>有子节点，那么我们进入子节点列表<code>children</code>里遍历子节点，发现子节点<code>p</code>也是元素型的，那就继续创建元素型<code>VNode</code>并将其放入上述代码中根节点的子节点列表中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_c(<span class=\"string\">'div'</span>,&#123;<span class=\"attr\">attrs</span>:&#123;<span class=\"string\">\"id\"</span>:<span class=\"string\">\"NLRX\"</span>&#125;&#125;,[_c(<span class=\"string\">'p'</span>),[<span class=\"comment\">/*子节点列表*/</span>]])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>同理，继续遍历<code>p</code>节点的子节点，发现是一个文本型节点，那就创建一个文本型<code>VNode</code>并将其插入到<code>p</code>节点的子节点列表中，同理，创建文本型<code>VNode</code>我们调用<code>_v()</code>方法，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_c(<span class=\"string\">'div'</span>,&#123;<span class=\"attr\">attrs</span>:&#123;<span class=\"string\">\"id\"</span>:<span class=\"string\">\"NLRX\"</span>&#125;&#125;,[_c(<span class=\"string\">'p'</span>),[_v(<span class=\"string\">\"Hello \"</span>+_s(name))]])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>到此，整个<code>AST</code>就遍历完毕了，我们将得到的代码再包装一下，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">with(this)&#123;</span></span><br><span class=\"line\"><span class=\"string\">    reurn _c(</span></span><br><span class=\"line\"><span class=\"string\">        'div',</span></span><br><span class=\"line\"><span class=\"string\">        &#123;</span></span><br><span class=\"line\"><span class=\"string\">            attrs:&#123;\"id\":\"NLRX\"&#125;,</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        [</span></span><br><span class=\"line\"><span class=\"string\">            _c('p'),</span></span><br><span class=\"line\"><span class=\"string\">            [</span></span><br><span class=\"line\"><span class=\"string\">                _v(\"Hello \"+_s(name))</span></span><br><span class=\"line\"><span class=\"string\">            ]</span></span><br><span class=\"line\"><span class=\"string\">        ])</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>最后，我们将上面得到的这个函数字符串传递给<code>createFunction</code>函数（关于这个函数在后面会介绍到），<code>createFunction</code>函数会帮我们把得到的函数字符串转换成真正的函数，赋给组件中的<code>render</code>选项，从而就是<code>render</code>函数了。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.render = createFunction(compiled.render, fnGenErrors)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunction</span> (<span class=\"params\">code, errors</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(code)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    errors.push(&#123; err, code &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> noop</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>以上就是根据一个简单的模板所对应的<code>AST</code>生成<code>render</code>函数的过程，理论过程我们已经了解了，那么在源码中实际是如何实现的呢？下面我们就回归源码分析其具体实现过程。</p>\n<h2>3. 回归源码</h2>\n<p>代码生成阶段的源码位于<code>src/compiler/codegen/index.js</code> 中，源码虽然很长，但是逻辑不复杂，核心逻辑如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generate</span> (<span class=\"params\">ast,option</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = <span class=\"keyword\">new</span> CodegenState(options)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> code = ast ? genElement(ast, state) : <span class=\"string\">'_c(\"div\")'</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render: <span class=\"string\">`with(this)&#123;return <span class=\"subst\">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class=\"line\">    staticRenderFns: state.staticRenderFns</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> code = generate(ast, options)</span><br></pre></td></tr></table></figure>\n<p>调用<code>generate</code>函数并传入优化后得到的<code>ast</code>，在<code>generate</code>函数内部先判断<code>ast</code>是否为空，不为空则调用<code>genElement(ast, state)</code>函数创建<code>VNode</code>，为空则创建一个空的元素型<code>div</code>的<code>VNode</code>。然后将得到的结果用<code>with(this){return ${code}}</code>包裹返回。可以看出，真正起作用的是<code>genElement</code>函数，下面我们继续来看一下<code>genElement</code>函数内部是怎样的。</p>\n<p><code>genElement</code>函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genElement</span> (<span class=\"params\">el: ASTElement, state: CodegenState</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genStatic(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genOnce(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genFor(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genIf(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.tag === <span class=\"string\">'template'</span> &amp;&amp; !el.slotTarget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genChildren(el, state) || <span class=\"string\">'void 0'</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (el.tag === <span class=\"string\">'slot'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genSlot(el, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// component or element</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.component) &#123;</span><br><span class=\"line\">      code = genComponent(el.component, el, state)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> data = el.plain ? <span class=\"literal\">undefined</span> : genData(el, state)</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> children = el.inlineTemplate ? <span class=\"literal\">null</span> : genChildren(el, state, <span class=\"literal\">true</span>)</span><br><span class=\"line\">      code = <span class=\"string\">`_c('<span class=\"subst\">$&#123;el.tag&#125;</span>'<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        data ? <span class=\"string\">`,<span class=\"subst\">$&#123;data&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> data</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span><span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        children ? <span class=\"string\">`,<span class=\"subst\">$&#123;children&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> children</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span>)`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// module transforms</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; state.transforms.length; i++) &#123;</span><br><span class=\"line\">      code = state.transforms[i](el, code)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> code</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>genElement</code>函数逻辑很清晰，就是根据当前 <code>AST</code> 元素节点属性的不同从而执行不同的代码生成函数。虽然元素节点属性的情况有很多种，但是最后真正创建出来的<code>VNode</code>无非就三种，分别是元素节点，文本节点，注释节点。接下来我们就着重分析一下如何生成这三种节点类型的<code>render</code>函数的。</p>\n<h3>3.1 元素节点</h3>\n<p>生成元素型节点的<code>render</code>函数代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = el.plain ? <span class=\"literal\">undefined</span> : genData(el, state)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> children = el.inlineTemplate ? <span class=\"literal\">null</span> : genChildren(el, state, <span class=\"literal\">true</span>)</span><br><span class=\"line\">code = <span class=\"string\">`_c('<span class=\"subst\">$&#123;el.tag&#125;</span>'<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">data ? <span class=\"string\">`,<span class=\"subst\">$&#123;data&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> data</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">&#125;</span><span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">children ? <span class=\"string\">`,<span class=\"subst\">$&#123;children&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> children</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">&#125;</span>)`</span></span><br></pre></td></tr></table></figure>\n<p>生成元素节点的<code>render</code>函数就是生成一个<code>_c()</code>函数调用的字符串，上文提到了<code>_c()</code>函数接收三个参数，分别是节点的标签名<code>tagName</code>，节点属性<code>data</code>，节点的子节点列表<code>children</code>。那么我们只需将这三部分都填进去即可。</p>\n<ol>\n<li>\n<p>获取节点属性data</p>\n<p>首先判断<code>plain</code>属性是否为<code>true</code>，若为<code>true</code>则表示节点没有属性，将<code>data</code>赋值为<code>undefined</code>；如果不为<code>true</code>则调用<code>genData</code>函数获取节点属性<code>data</code>数据。<code>genData</code>函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genData</span> (<span class=\"params\">el: ASTElement, state: CodegenState</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"string\">'&#123;'</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> dirs = genDirectives(el, state)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dirs) data += dirs + <span class=\"string\">','</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// key</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.key) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`key:<span class=\"subst\">$&#123;el.key&#125;</span>,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ref</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.ref) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`ref:<span class=\"subst\">$&#123;el.ref&#125;</span>,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.refInFor) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`refInFor:true,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// pre</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (el.pre) &#123;</span><br><span class=\"line\">        data += <span class=\"string\">`pre:true,`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 篇幅所限，省略其他情况的判断\t</span></span><br><span class=\"line\">    data = data.replace(<span class=\"regexp\">/,$/</span>, <span class=\"string\">''</span>) + <span class=\"string\">'&#125;'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，源码中<code>genData</code>虽然很长，但是其逻辑非常简单，就是在拼接字符串，先给<code>data</code>赋值为一个<code>{</code>，然后判断存在哪些属性数据，就将这些数据拼接到<code>data</code>中，最后再加一个<code>}</code>，最终得到节点全部属性<code>data</code>。</p>\n</li>\n<li>\n<p>获取子节点列表children</p>\n<p>获取子节点列表<code>children</code>其实就是遍历<code>AST</code>的<code>children</code>属性中的元素，然后根据元素属性的不同生成不同的<code>VNode</code>创建函数调用字符串，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genChildren</span> (<span class=\"params\">el</span>):  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (children.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`[<span class=\"subst\">$&#123;children.map(c =&gt; genNode(c, state)).join(<span class=\"string\">','</span>)&#125;</span>]`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genNode</span> (<span class=\"params\">node: ASTNode, state: CodegenState</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (node.type === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genElement(node, state)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">if</span> (node.type === <span class=\"number\">3</span> &amp;&amp; node.isComment) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genComment(node)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> genText(node)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>上面两步完成之后，生成<code>_c（）</code>函数调用字符串，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">code = <span class=\"string\">`_c('<span class=\"subst\">$&#123;el.tag&#125;</span>'<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        data ? <span class=\"string\">`,<span class=\"subst\">$&#123;data&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> data</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span><span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        children ? <span class=\"string\">`,<span class=\"subst\">$&#123;children&#125;</span>`</span> : <span class=\"string\">''</span> <span class=\"regexp\">//</span> children</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      &#125;</span>)`</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3>3.2 文本节点</h3>\n<p>文本型的<code>VNode</code>可以调用<code>_v(text)</code>函数来创建，所以生成文本节点的<code>render</code>函数就是生成一个<code>_v(text)</code>函数调用的字符串。<code>_v()</code>函数接收文本内容作为参数，如果文本是动态文本，则使用动态文本<code>AST</code>节点的<code>expression</code>属性，如果是纯静态文本，则使用<code>text</code>属性。其生成代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genText</span> (<span class=\"params\">text: ASTText | ASTExpression</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`_v(<span class=\"subst\">$&#123;text.type === <span class=\"number\">2</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">    ? text.expression <span class=\"regexp\">//</span> no need <span class=\"keyword\">for</span> () because already wrapped <span class=\"keyword\">in</span> _s()</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">    : transformSpecialNewlines(<span class=\"built_in\">JSON</span>.stringify(text.text))</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">  &#125;</span>)`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>3.3 注释节点</h3>\n<p>注释型的<code>VNode</code>可以调用<code>_e(text)</code>函数来创建，所以生成注释节点的<code>render</code>函数就是生成一个<code>_e(text)</code>函数调用的字符串。<code>_e()</code>函数接收注释内容作为参数，其生成代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genComment</span> (<span class=\"params\">comment: ASTText</span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`_e(<span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(comment.text)&#125;</span>)`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>4. 总结</h2>\n<p>本篇文章介绍了模板编译三大阶段的最后一个阶段——代码生成阶段。</p>\n<p>首先，介绍了为什么要有代码生成阶段以及代码生成阶段主要干什么。我们知道了，代码生成其实就是根据模板对应的抽象语法树<code>AST</code>生成一个函数供组件挂载时调用，通过调用这个函数就可以得到模板对应的虚拟<code>DOM</code>。</p>\n<p>接着，我们通过一个简单的模板演示了把模板经过递归遍历最后生成<code>render</code>函数的过程。</p>\n<p>最后，我们回归源码，通过分析源码了解了生成<code>render</code>函数的具体实现过程。</p>\n"},{"title":"Vue 源码阅读 深入响应式原理(二)","catalog":true,"date":"2019-10-18T15:09:39.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n在上一篇文章中，我们知道：数据驱动视图的关键点则在于我们如何知道数据发生了变化，只要知道数据在什么时候变了，那么问题就变得迎刃而解，我们只需在数据变化的时候去通知视图更新即可。\n\n要想知道数据什么时候被读取了或数据什么时候被改写了，其实不难，`JS`为我们提供了`Object.defineProperty`方法，通过该方法我们就可以轻松的知道数据在什么时候发生变化。\n\n## 2. 使Object数据变得“可观测”\n\n数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。\n\n要将数据变的‘可观测’，我们就要借助前言中提到的`Object.defineProperty`方法了，在本文中，我们就使用这个方法使数据变得“可观测”。\n\n首先，我们定义一个数据对象`car`：\n\n```javascript\nlet car = {\n\t\t'brand':'BMW',\n\t\t'price':3000\n\t}\n```\n\n我们定义了这个`car`的品牌`brand`是`BMW`,价格`price`是3000。现在我们可以通过`car.brand`和`car.price`直接读写这个`car`对应的属性值。但是，当这个`car`的属性被读取或修改时，我们并不知情。那么应该如何做才能够让`car`主动告诉我们，它的属性被修改了呢？\n\n接下来，我们使用`Object.defineProperty() `改写上面的例子：\n\n```javascript\n\tlet car = {}\n\tlet val = 3000\n\tObject.defineProperty(car, 'price', {\n        enumerable: true,\n    \tconfigurable: true,\n\t\tget(){\n\t\t\tconsole.log('price属性被读取了')\n\t\t\treturn val\n\t\t},\n\t\tset(newVal){\n\t\t\tconsole.log('price属性被修改了')\n\t\t\tval = newVal\n\t\t}\n\t})\n```\n\n通过`Object.defineProperty() `方法给`car`定义了一个`price`属性，并把这个属性的读和写分别使用`get()`和`set()`进行拦截，每当该属性进行读或写操作的时候就会触发`get()`和`set()`。如下图：\n\n![](/img/reactive/1.png)\n\n可以看到，`car`已经可以主动告诉我们它的属性的读写情况了，这也意味着，这个`car`的数据对象已经是“可观测”的了。\n\n为了把`car`的所有属性都变得可观测，我们可以编写如下代码：\n\n```javascript\n// 源码位置：src/core/observer/index.js\t\n\n/**\n * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象\n */\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    // 给value新增一个__ob__属性，值为该value的Observer实例\n    // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作  \n    def(value,'__ob__',this)    \n    if (Array.isArray(value)) {\n      // 当value为数组时的逻辑\n      // ...  \n    } else {\n      this.walk(value)\n    }\n  }\n\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n}\n/**\n * 使一个对象转化成可观测对象\n * @param { Object } obj 对象\n * @param { String } key 对象的key\n * @param { Any } val 对象的某个key的值\n */\nfunction defineReactive (obj,key,val) {\n  // 如果只传了obj和key，那么val = obj[key]\n  if (arguments.length === 2) {\n    val = obj[key]\n  }\n  if(typeof val === 'object'){\n      new Observer(val)\n  }\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get(){\n      console.log(`${key}属性被读取了`);\n      return val;\n    },\n    set(newVal){\n      if(val === newVal){\n          return\n      }\n      console.log(`${key}属性被修改了`);\n      val = newVal;\n    }\n  })\n}\n```\n\n在上面的代码中，我们定义了`observer`类，它用来将一个正常的`object`转换成可观测的`object`。\n\n并且给`value`新增一个`__ob__`属性，值为该`value`的`Observer`实例。这个操作相当于为`value`打上标记，表示它已经被转化成响应式了，避免重复操作\n\n然后判断数据的类型，只有`object`类型的数据才会调用`walk`将每一个属性转换成`getter/setter`的形式来侦测变化。\n最后，在`defineReactive`中当传入的属性值还是一个`object`时使用` new observer（val）`来递归子属性，这样我们就可以把`obj`中的所有属性（包括子属性）都转换成`getter/seter`的形式来侦测变化。\n也就是说，只要我们将一个`object`传到`observer`中，那么这个`object`就会变成可观测的、响应式的`object`。\n\n`observer`类位于源码的`src/core/observer/index.js`中。\n\n那么现在，我们就可以这样定义`car`:\n\n```javascript\nlet car = new Observer({\n  'brand':'BMW',\n  'price':3000\n})\n```\n\n这样，`car`的两个属性都变得可观测了。\n\n## 3. 依赖收集\n\n### 3.1 什么是依赖收集\n\n在上一章中，我们迈出了第一步：让`object`数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。\n\n视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把\"谁用到了这个数据\"称为\"谁依赖了这个数据\",我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：\"你们依赖的数据变啦，你们该更新啦！\"。这个过程就是依赖收集。\n\n### 3.2 何时收集依赖？何时通知依赖更新？\n\n明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？\n\n其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发`getter`属性，那么我们就可以在`getter`中收集这个依赖。同样，当这个数据变化时会触发`setter`属性，那么我们就可以在`setter`中通知依赖更新。\n\n总结一句话就是：**在getter中收集依赖，在setter中通知依赖更新**。\n\n### 3.3 把依赖收集到哪里\n\n明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？\n\n在3.1小节中也说了，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器`Dep`类应运而生，代码如下：\n\n```javascript\n// 源码位置：src/core/observer/dep.js\t\nexport default class Dep {\n  constructor () {\n    this.subs = []\n  }\n  \n  addSub (sub) {\n    this.subs.push(sub)\n  }\n  // 删除一个依赖\n  removeSub (sub) {\n    remove(this.subs, sub)\n  }\n  // 添加一个依赖\n  depend () {\n    if (window.target) {\n      this.addSub(window.target)\n    }\n  }\n  // 通知所有依赖更新\n  notify () {\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n/**\n * Remove an item from an array\n */\nexport function remove (arr, item) {\n  if (arr.length) {\n    const index = arr.indexOf(item)\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n```\n\n在上面的依赖管理器`Dep`类中，我们先初始化了一个`subs`数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。\n\n有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：\n\n```javascript\nfunction defineReactive (obj,key,val) {\n  if (arguments.length === 2) {\n    val = obj[key]\n  }\n  if(typeof val === 'object'){\n    new Observer(val)\n  }\n  const dep = new Dep()  //实例化一个依赖管理器，生成一个依赖管理数组dep\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get(){\n      dep.depend()    // 在getter中收集依赖\n      return val;\n    },\n    set(newVal){\n      if(val === newVal){\n          return\n      }\n      val = newVal;\n      dep.notify()   // 在setter中通知依赖更新\n    }\n  })\n}\n```\n\n在上述代码中，我们在`getter`中调用了`dep.depend()`方法收集依赖，在`setter`中调用`dep.notify()`方法通知所有依赖更新。\n\n## 4. 依赖到底是谁\n\n通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？\n\n虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？\n\n其实在`Vue`中还实现了一个叫做`Watcher`的类，而`Watcher`类的实例就是我们上面所说的那个\"谁\"。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个`Watcher`实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的`Watch`实例，由`Watcher`实例去通知真正的视图。\n\n`Watcher`类的具体实现如下：\n\n```javascript\nexport default class Watcher {\n  constructor (vm,expOrFn,cb) {\n    this.vm = vm;\n    this.cb = cb;\n    this.getter = parsePath(expOrFn)\n    this.value = this.get()\n  }\n  get () {\n    window.target = this;\n    const vm = this.vm\n    let value = this.getter.call(vm, vm)\n    window.target = undefined;\n    return value\n  }\n  update () {\n    const oldValue = this.value\n    this.value = this.get()\n    this.cb.call(this.vm, this.value, oldValue)\n  }\n}\n\n/**\n * Parse simple path.\n * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来\n * 例如：\n * data = {a:{b:{c:2}}}\n * parsePath('a.b.c')(data)  // 2\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  const segments = path.split('.')\n  return function (obj) {\n    for (let i = 0; i < segments.length; i++) {\n      if (!obj) return\n      obj = obj[segments[i]]\n    }\n    return obj\n  }\n}\n```\n\n谁用到了数据，谁就是依赖，我们就为谁创建一个`Watcher`实例，在创建`Watcher`实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个`Watcher`实例就代表这个依赖，当数据变化时，我们就通知`Watcher`实例，由`Watcher`实例再去通知真正的依赖。\n\n那么，在创建`Watcher`实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？\n\n下面我们分析`Watcher`类的代码实现逻辑：\n\n1. 当实例化`Watcher`类时，会先执行其构造函数；\n2. 在构造函数中调用了`this.get()`实例方法；\n3. 在`get()`方法中，首先通过`window.target = this`把实例自身赋给了全局的一个唯一对象`window.target`上，然后通过`let value = this.getter.call(vm, vm)`获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的`getter`，上文我们说过，在`getter`里会调用`dep.depend()`收集依赖，而在`dep.depend()`中取到挂载`window.target`上的值并将其存入依赖数组中，在`get()`方法最后将`window.target`释放掉。\n4. 而当数据变化时，会触发数据的`setter`，在`setter`中调用了`dep.notify()`方法，在`dep.notify()`方法中，遍历所有依赖(即watcher实例)，执行依赖的`update()`方法，也就是`Watcher`类中的`update()`实例方法，在`update()`方法中调用数据变化的更新回调函数，从而更新视图。\n\n简单总结一下就是：`Watcher`先把自己设置到全局唯一的指定位置（`window.target`），然后读取数据。因为读取了数据，所以会触发这个数据的`getter`。接着，在`getter`中就会从全局唯一的那个位置读取当前正在读取数据的`Watcher`，并把这个`watcher`收集到`Dep`中去。收集好之后，当数据发生变化时，会向`Dep`中的每个`Watcher`发送通知。通过这样的方式，`Watcher `可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图：\n\n![](~@/reactive/3.jpg)\n\n以上，就彻底完成了对`Object`数据的侦测，依赖收集，依赖的更新等所有操作。\n\n## 5. 不足之处\n\n虽然我们通过`Object.defineProperty`方法实现了对`object`数据的可观测，但是这个方法仅仅只能观测到`object`数据的取值及设置值，当我们向`object`数据里添加一对新的`key/value`或删除一对已有的`key/value`时，它是无法观测到的，导致当我们对`object`数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。\n\n当然，`Vue`也注意到了这一点，为了解决这一问题，`Vue`增加了两个全局API:`Vue.set`和`Vue.delete`，这两个API的实现原理将会在后面学习全局API的时候说到。\n\n## 6. 总结\n\n首先，我们通过`Object.defineProperty`方法实现了对`object`数据的可观测，并且封装了`Observer`类，让我们能够方便的把`object`数据中的所有属性（包括子属性）都转换成`getter/seter`的形式来侦测变化。\n\n接着，我们学习了什么是依赖收集？并且知道了在`getter`中收集依赖，在`setter`中通知依赖更新，以及封装了依赖管理器`Dep`，用于存储收集到的依赖。\n\n最后，我们为每一个依赖都创建了一个`Watcher`实例，当数据发生变化时，通知`Watcher`实例，由`Watcher`实例去做真实的更新操作。\n\n其整个流程大致如下：\n\n1. `Data`通过`observer`转换成了`getter/setter`的形式来追踪变化。\n2. 当外界通过`Watcher`读取数据时，会触发`getter`从而将`Watcher`添加到依赖中。\n3. 当数据发生了变化时，会触发`setter`，从而向`Dep`中的依赖（即Watcher）发送通知。\n4. `Watcher`接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。\n","source":"_posts/Vue 源码阅读 深入响应式原理(二).md","raw":"---\ntitle: Vue 源码阅读 深入响应式原理(二) \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-18 23:09:39\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n在上一篇文章中，我们知道：数据驱动视图的关键点则在于我们如何知道数据发生了变化，只要知道数据在什么时候变了，那么问题就变得迎刃而解，我们只需在数据变化的时候去通知视图更新即可。\n\n要想知道数据什么时候被读取了或数据什么时候被改写了，其实不难，`JS`为我们提供了`Object.defineProperty`方法，通过该方法我们就可以轻松的知道数据在什么时候发生变化。\n\n## 2. 使Object数据变得“可观测”\n\n数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。\n\n要将数据变的‘可观测’，我们就要借助前言中提到的`Object.defineProperty`方法了，在本文中，我们就使用这个方法使数据变得“可观测”。\n\n首先，我们定义一个数据对象`car`：\n\n```javascript\nlet car = {\n\t\t'brand':'BMW',\n\t\t'price':3000\n\t}\n```\n\n我们定义了这个`car`的品牌`brand`是`BMW`,价格`price`是3000。现在我们可以通过`car.brand`和`car.price`直接读写这个`car`对应的属性值。但是，当这个`car`的属性被读取或修改时，我们并不知情。那么应该如何做才能够让`car`主动告诉我们，它的属性被修改了呢？\n\n接下来，我们使用`Object.defineProperty() `改写上面的例子：\n\n```javascript\n\tlet car = {}\n\tlet val = 3000\n\tObject.defineProperty(car, 'price', {\n        enumerable: true,\n    \tconfigurable: true,\n\t\tget(){\n\t\t\tconsole.log('price属性被读取了')\n\t\t\treturn val\n\t\t},\n\t\tset(newVal){\n\t\t\tconsole.log('price属性被修改了')\n\t\t\tval = newVal\n\t\t}\n\t})\n```\n\n通过`Object.defineProperty() `方法给`car`定义了一个`price`属性，并把这个属性的读和写分别使用`get()`和`set()`进行拦截，每当该属性进行读或写操作的时候就会触发`get()`和`set()`。如下图：\n\n![](/img/reactive/1.png)\n\n可以看到，`car`已经可以主动告诉我们它的属性的读写情况了，这也意味着，这个`car`的数据对象已经是“可观测”的了。\n\n为了把`car`的所有属性都变得可观测，我们可以编写如下代码：\n\n```javascript\n// 源码位置：src/core/observer/index.js\t\n\n/**\n * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象\n */\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    // 给value新增一个__ob__属性，值为该value的Observer实例\n    // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作  \n    def(value,'__ob__',this)    \n    if (Array.isArray(value)) {\n      // 当value为数组时的逻辑\n      // ...  \n    } else {\n      this.walk(value)\n    }\n  }\n\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n}\n/**\n * 使一个对象转化成可观测对象\n * @param { Object } obj 对象\n * @param { String } key 对象的key\n * @param { Any } val 对象的某个key的值\n */\nfunction defineReactive (obj,key,val) {\n  // 如果只传了obj和key，那么val = obj[key]\n  if (arguments.length === 2) {\n    val = obj[key]\n  }\n  if(typeof val === 'object'){\n      new Observer(val)\n  }\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get(){\n      console.log(`${key}属性被读取了`);\n      return val;\n    },\n    set(newVal){\n      if(val === newVal){\n          return\n      }\n      console.log(`${key}属性被修改了`);\n      val = newVal;\n    }\n  })\n}\n```\n\n在上面的代码中，我们定义了`observer`类，它用来将一个正常的`object`转换成可观测的`object`。\n\n并且给`value`新增一个`__ob__`属性，值为该`value`的`Observer`实例。这个操作相当于为`value`打上标记，表示它已经被转化成响应式了，避免重复操作\n\n然后判断数据的类型，只有`object`类型的数据才会调用`walk`将每一个属性转换成`getter/setter`的形式来侦测变化。\n最后，在`defineReactive`中当传入的属性值还是一个`object`时使用` new observer（val）`来递归子属性，这样我们就可以把`obj`中的所有属性（包括子属性）都转换成`getter/seter`的形式来侦测变化。\n也就是说，只要我们将一个`object`传到`observer`中，那么这个`object`就会变成可观测的、响应式的`object`。\n\n`observer`类位于源码的`src/core/observer/index.js`中。\n\n那么现在，我们就可以这样定义`car`:\n\n```javascript\nlet car = new Observer({\n  'brand':'BMW',\n  'price':3000\n})\n```\n\n这样，`car`的两个属性都变得可观测了。\n\n## 3. 依赖收集\n\n### 3.1 什么是依赖收集\n\n在上一章中，我们迈出了第一步：让`object`数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。\n\n视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把\"谁用到了这个数据\"称为\"谁依赖了这个数据\",我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：\"你们依赖的数据变啦，你们该更新啦！\"。这个过程就是依赖收集。\n\n### 3.2 何时收集依赖？何时通知依赖更新？\n\n明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？\n\n其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发`getter`属性，那么我们就可以在`getter`中收集这个依赖。同样，当这个数据变化时会触发`setter`属性，那么我们就可以在`setter`中通知依赖更新。\n\n总结一句话就是：**在getter中收集依赖，在setter中通知依赖更新**。\n\n### 3.3 把依赖收集到哪里\n\n明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？\n\n在3.1小节中也说了，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器`Dep`类应运而生，代码如下：\n\n```javascript\n// 源码位置：src/core/observer/dep.js\t\nexport default class Dep {\n  constructor () {\n    this.subs = []\n  }\n  \n  addSub (sub) {\n    this.subs.push(sub)\n  }\n  // 删除一个依赖\n  removeSub (sub) {\n    remove(this.subs, sub)\n  }\n  // 添加一个依赖\n  depend () {\n    if (window.target) {\n      this.addSub(window.target)\n    }\n  }\n  // 通知所有依赖更新\n  notify () {\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n/**\n * Remove an item from an array\n */\nexport function remove (arr, item) {\n  if (arr.length) {\n    const index = arr.indexOf(item)\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n```\n\n在上面的依赖管理器`Dep`类中，我们先初始化了一个`subs`数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。\n\n有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：\n\n```javascript\nfunction defineReactive (obj,key,val) {\n  if (arguments.length === 2) {\n    val = obj[key]\n  }\n  if(typeof val === 'object'){\n    new Observer(val)\n  }\n  const dep = new Dep()  //实例化一个依赖管理器，生成一个依赖管理数组dep\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get(){\n      dep.depend()    // 在getter中收集依赖\n      return val;\n    },\n    set(newVal){\n      if(val === newVal){\n          return\n      }\n      val = newVal;\n      dep.notify()   // 在setter中通知依赖更新\n    }\n  })\n}\n```\n\n在上述代码中，我们在`getter`中调用了`dep.depend()`方法收集依赖，在`setter`中调用`dep.notify()`方法通知所有依赖更新。\n\n## 4. 依赖到底是谁\n\n通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？\n\n虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？\n\n其实在`Vue`中还实现了一个叫做`Watcher`的类，而`Watcher`类的实例就是我们上面所说的那个\"谁\"。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个`Watcher`实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的`Watch`实例，由`Watcher`实例去通知真正的视图。\n\n`Watcher`类的具体实现如下：\n\n```javascript\nexport default class Watcher {\n  constructor (vm,expOrFn,cb) {\n    this.vm = vm;\n    this.cb = cb;\n    this.getter = parsePath(expOrFn)\n    this.value = this.get()\n  }\n  get () {\n    window.target = this;\n    const vm = this.vm\n    let value = this.getter.call(vm, vm)\n    window.target = undefined;\n    return value\n  }\n  update () {\n    const oldValue = this.value\n    this.value = this.get()\n    this.cb.call(this.vm, this.value, oldValue)\n  }\n}\n\n/**\n * Parse simple path.\n * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来\n * 例如：\n * data = {a:{b:{c:2}}}\n * parsePath('a.b.c')(data)  // 2\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  const segments = path.split('.')\n  return function (obj) {\n    for (let i = 0; i < segments.length; i++) {\n      if (!obj) return\n      obj = obj[segments[i]]\n    }\n    return obj\n  }\n}\n```\n\n谁用到了数据，谁就是依赖，我们就为谁创建一个`Watcher`实例，在创建`Watcher`实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个`Watcher`实例就代表这个依赖，当数据变化时，我们就通知`Watcher`实例，由`Watcher`实例再去通知真正的依赖。\n\n那么，在创建`Watcher`实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？\n\n下面我们分析`Watcher`类的代码实现逻辑：\n\n1. 当实例化`Watcher`类时，会先执行其构造函数；\n2. 在构造函数中调用了`this.get()`实例方法；\n3. 在`get()`方法中，首先通过`window.target = this`把实例自身赋给了全局的一个唯一对象`window.target`上，然后通过`let value = this.getter.call(vm, vm)`获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的`getter`，上文我们说过，在`getter`里会调用`dep.depend()`收集依赖，而在`dep.depend()`中取到挂载`window.target`上的值并将其存入依赖数组中，在`get()`方法最后将`window.target`释放掉。\n4. 而当数据变化时，会触发数据的`setter`，在`setter`中调用了`dep.notify()`方法，在`dep.notify()`方法中，遍历所有依赖(即watcher实例)，执行依赖的`update()`方法，也就是`Watcher`类中的`update()`实例方法，在`update()`方法中调用数据变化的更新回调函数，从而更新视图。\n\n简单总结一下就是：`Watcher`先把自己设置到全局唯一的指定位置（`window.target`），然后读取数据。因为读取了数据，所以会触发这个数据的`getter`。接着，在`getter`中就会从全局唯一的那个位置读取当前正在读取数据的`Watcher`，并把这个`watcher`收集到`Dep`中去。收集好之后，当数据发生变化时，会向`Dep`中的每个`Watcher`发送通知。通过这样的方式，`Watcher `可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图：\n\n![](~@/reactive/3.jpg)\n\n以上，就彻底完成了对`Object`数据的侦测，依赖收集，依赖的更新等所有操作。\n\n## 5. 不足之处\n\n虽然我们通过`Object.defineProperty`方法实现了对`object`数据的可观测，但是这个方法仅仅只能观测到`object`数据的取值及设置值，当我们向`object`数据里添加一对新的`key/value`或删除一对已有的`key/value`时，它是无法观测到的，导致当我们对`object`数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。\n\n当然，`Vue`也注意到了这一点，为了解决这一问题，`Vue`增加了两个全局API:`Vue.set`和`Vue.delete`，这两个API的实现原理将会在后面学习全局API的时候说到。\n\n## 6. 总结\n\n首先，我们通过`Object.defineProperty`方法实现了对`object`数据的可观测，并且封装了`Observer`类，让我们能够方便的把`object`数据中的所有属性（包括子属性）都转换成`getter/seter`的形式来侦测变化。\n\n接着，我们学习了什么是依赖收集？并且知道了在`getter`中收集依赖，在`setter`中通知依赖更新，以及封装了依赖管理器`Dep`，用于存储收集到的依赖。\n\n最后，我们为每一个依赖都创建了一个`Watcher`实例，当数据发生变化时，通知`Watcher`实例，由`Watcher`实例去做真实的更新操作。\n\n其整个流程大致如下：\n\n1. `Data`通过`observer`转换成了`getter/setter`的形式来追踪变化。\n2. 当外界通过`Watcher`读取数据时，会触发`getter`从而将`Watcher`添加到依赖中。\n3. 当数据发生了变化时，会触发`setter`，从而向`Dep`中的依赖（即Watcher）发送通知。\n4. `Watcher`接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。\n","slug":"Vue 源码阅读 深入响应式原理(二)","published":1,"updated":"2019-12-31T03:27:31.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj84006wzws6o9or81a4","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在上一篇文章中，我们知道：数据驱动视图的关键点则在于我们如何知道数据发生了变化，只要知道数据在什么时候变了，那么问题就变得迎刃而解，我们只需在数据变化的时候去通知视图更新即可。</p>\n<p>要想知道数据什么时候被读取了或数据什么时候被改写了，其实不难，<code>JS</code>为我们提供了<code>Object.defineProperty</code>方法，通过该方法我们就可以轻松的知道数据在什么时候发生变化。</p>\n<h2><span id=\"2-使object数据变得可观测\">2. 使Object数据变得“可观测”</span></h2>\n<p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。</p>\n<p>要将数据变的‘可观测’，我们就要借助前言中提到的<code>Object.defineProperty</code>方法了，在本文中，我们就使用这个方法使数据变得“可观测”。</p>\n<p>首先，我们定义一个数据对象<code>car</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> car = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">'brand'</span>:<span class=\"string\">'BMW'</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">'price'</span>:<span class=\"number\">3000</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义了这个<code>car</code>的品牌<code>brand</code>是<code>BMW</code>,价格<code>price</code>是3000。现在我们可以通过<code>car.brand</code>和<code>car.price</code>直接读写这个<code>car</code>对应的属性值。但是，当这个<code>car</code>的属性被读取或修改时，我们并不知情。那么应该如何做才能够让<code>car</code>主动告诉我们，它的属性被修改了呢？</p>\n<p>接下来，我们使用<code>Object.defineProperty()</code>改写上面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> car = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> val = <span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(car, <span class=\"string\">'price'</span>, &#123;</span><br><span class=\"line\">       enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">   \tconfigurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'price属性被读取了'</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> val</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'price属性被修改了'</span>)</span><br><span class=\"line\">\t\tval = newVal</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>通过<code>Object.defineProperty()</code>方法给<code>car</code>定义了一个<code>price</code>属性，并把这个属性的读和写分别使用<code>get()</code>和<code>set()</code>进行拦截，每当该属性进行读或写操作的时候就会触发<code>get()</code>和<code>set()</code>。如下图：</p>\n<p><img src=\"/img/reactive/1.png\" alt></p>\n<p>可以看到，<code>car</code>已经可以主动告诉我们它的属性的读写情况了，这也意味着，这个<code>car</code>的数据对象已经是“可观测”的了。</p>\n<p>为了把<code>car</code>的所有属性都变得可观测，我们可以编写如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：src/core/observer/index.js\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"comment\">// 给value新增一个__ob__属性，值为该value的Observer实例</span></span><br><span class=\"line\">    <span class=\"comment\">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作  </span></span><br><span class=\"line\">    def(value,<span class=\"string\">'__ob__'</span>,<span class=\"keyword\">this</span>)    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当value为数组时的逻辑</span></span><br><span class=\"line\">      <span class=\"comment\">// ...  </span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  walk (obj: <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使一个对象转化成可观测对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123; Object &#125; obj 对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123; String &#125; key 对象的key</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123; Any &#125; val 对象的某个key的值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\">obj,key,val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果只传了obj和key，那么val = obj[key]</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Observer(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>属性被读取了`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(val === newVal)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>属性被修改了`</span>);</span><br><span class=\"line\">      val = newVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p>\n<p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p>\n<p>然后判断数据的类型，只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。<br>\n最后，在<code>defineReactive</code>中当传入的属性值还是一个<code>object</code>时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把<code>obj</code>中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。<br>\n也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。</p>\n<p><code>observer</code>类位于源码的<code>src/core/observer/index.js</code>中。</p>\n<p>那么现在，我们就可以这样定义<code>car</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"keyword\">new</span> Observer(&#123;</span><br><span class=\"line\">  <span class=\"string\">'brand'</span>:<span class=\"string\">'BMW'</span>,</span><br><span class=\"line\">  <span class=\"string\">'price'</span>:<span class=\"number\">3000</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样，<code>car</code>的两个属性都变得可观测了。</p>\n<h2><span id=\"3-依赖收集\">3. 依赖收集</span></h2>\n<h3><span id=\"31-什么是依赖收集\">3.1 什么是依赖收集</span></h3>\n<p>在上一章中，我们迈出了第一步：让<code>object</code>数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。</p>\n<p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把&quot;谁用到了这个数据&quot;称为&quot;谁依赖了这个数据&quot;,我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：“你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p>\n<h3><span id=\"32-何时收集依赖何时通知依赖更新\">3.2 何时收集依赖？何时通知依赖更新？</span></h3>\n<p>明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？</p>\n<p>其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发<code>getter</code>属性，那么我们就可以在<code>getter</code>中收集这个依赖。同样，当这个数据变化时会触发<code>setter</code>属性，那么我们就可以在<code>setter</code>中通知依赖更新。</p>\n<p>总结一句话就是：<strong>在getter中收集依赖，在setter中通知依赖更新</strong>。</p>\n<h3><span id=\"33-把依赖收集到哪里\">3.3 把依赖收集到哪里</span></h3>\n<p>明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？</p>\n<p>在3.1小节中也说了，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器<code>Dep</code>类应运而生，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：src/core/observer/dep.js\t</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  addSub (sub) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除一个依赖</span></span><br><span class=\"line\">  removeSub (sub) &#123;</span><br><span class=\"line\">    remove(<span class=\"keyword\">this</span>.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个依赖</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.addSub(<span class=\"built_in\">window</span>.target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 通知所有依赖更新</span></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>.subs.slice()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove an item from an array</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span> (<span class=\"params\">arr, item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = arr.indexOf(item)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> arr.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。</p>\n<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\">obj,key,val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Observer(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep()  <span class=\"comment\">//实例化一个依赖管理器，生成一个依赖管理数组dep</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">      dep.depend()    <span class=\"comment\">// 在getter中收集依赖</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(val === newVal)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal;</span><br><span class=\"line\">      dep.notify()   <span class=\"comment\">// 在setter中通知依赖更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p>\n<h2><span id=\"4-依赖到底是谁\">4. 依赖到底是谁</span></h2>\n<p>通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p>\n<p>虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？</p>\n<p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个&quot;谁&quot;。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>\n<p><code>Watcher</code>类的具体实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (vm,expOrFn,cb) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vm = vm;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cb = cb;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getter = parsePath(expOrFn)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">this</span>.vm</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.getter.call(vm, vm)</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.target = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  update () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> oldValue = <span class=\"keyword\">this</span>.value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, <span class=\"keyword\">this</span>.value, oldValue)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Parse simple path.</span></span><br><span class=\"line\"><span class=\"comment\"> * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：</span></span><br><span class=\"line\"><span class=\"comment\"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * parsePath('a.b.c')(data)  // 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bailRE = <span class=\"regexp\">/[^\\w.$]/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parsePath</span> (<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bailRE.test(path)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> segments = path.split(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span></span><br><span class=\"line\">      obj = obj[segments[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例，在创建<code>Watcher</code>实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个<code>Watcher</code>实例就代表这个依赖，当数据变化时，我们就通知<code>Watcher</code>实例，由<code>Watcher</code>实例再去通知真正的依赖。</p>\n<p>那么，在创建<code>Watcher</code>实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？</p>\n<p>下面我们分析<code>Watcher</code>类的代码实现逻辑：</p>\n<ol>\n<li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li>\n<li>在构造函数中调用了<code>this.get()</code>实例方法；</li>\n<li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li>\n<li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li>\n</ol>\n<p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图：</p>\n<p><img src=\"~@/reactive/3.jpg\" alt></p>\n<p>以上，就彻底完成了对<code>Object</code>数据的侦测，依赖收集，依赖的更新等所有操作。</p>\n<h2><span id=\"5-不足之处\">5. 不足之处</span></h2>\n<p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>\n<p>当然，<code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到。</p>\n<h2><span id=\"6-总结\">6. 总结</span></h2>\n<p>首先，我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。</p>\n<p>接着，我们学习了什么是依赖收集？并且知道了在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖更新，以及封装了依赖管理器<code>Dep</code>，用于存储收集到的依赖。</p>\n<p>最后，我们为每一个依赖都创建了一个<code>Watcher</code>实例，当数据发生变化时，通知<code>Watcher</code>实例，由<code>Watcher</code>实例去做真实的更新操作。</p>\n<p>其整个流程大致如下：</p>\n<ol>\n<li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li>\n<li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li>\n<li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li>\n<li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在上一篇文章中，我们知道：数据驱动视图的关键点则在于我们如何知道数据发生了变化，只要知道数据在什么时候变了，那么问题就变得迎刃而解，我们只需在数据变化的时候去通知视图更新即可。</p>\n<p>要想知道数据什么时候被读取了或数据什么时候被改写了，其实不难，<code>JS</code>为我们提供了<code>Object.defineProperty</code>方法，通过该方法我们就可以轻松的知道数据在什么时候发生变化。</p>\n<h2>2. 使Object数据变得“可观测”</h2>\n<p>数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。</p>\n<p>要将数据变的‘可观测’，我们就要借助前言中提到的<code>Object.defineProperty</code>方法了，在本文中，我们就使用这个方法使数据变得“可观测”。</p>\n<p>首先，我们定义一个数据对象<code>car</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> car = &#123;</span><br><span class=\"line\">\t\t<span class=\"string\">'brand'</span>:<span class=\"string\">'BMW'</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">'price'</span>:<span class=\"number\">3000</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义了这个<code>car</code>的品牌<code>brand</code>是<code>BMW</code>,价格<code>price</code>是3000。现在我们可以通过<code>car.brand</code>和<code>car.price</code>直接读写这个<code>car</code>对应的属性值。但是，当这个<code>car</code>的属性被读取或修改时，我们并不知情。那么应该如何做才能够让<code>car</code>主动告诉我们，它的属性被修改了呢？</p>\n<p>接下来，我们使用<code>Object.defineProperty()</code>改写上面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> car = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> val = <span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(car, <span class=\"string\">'price'</span>, &#123;</span><br><span class=\"line\">       enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">   \tconfigurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t<span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'price属性被读取了'</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> val</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'price属性被修改了'</span>)</span><br><span class=\"line\">\t\tval = newVal</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>通过<code>Object.defineProperty()</code>方法给<code>car</code>定义了一个<code>price</code>属性，并把这个属性的读和写分别使用<code>get()</code>和<code>set()</code>进行拦截，每当该属性进行读或写操作的时候就会触发<code>get()</code>和<code>set()</code>。如下图：</p>\n<p><img src=\"/img/reactive/1.png\" alt></p>\n<p>可以看到，<code>car</code>已经可以主动告诉我们它的属性的读写情况了，这也意味着，这个<code>car</code>的数据对象已经是“可观测”的了。</p>\n<p>为了把<code>car</code>的所有属性都变得可观测，我们可以编写如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：src/core/observer/index.js\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"comment\">// 给value新增一个__ob__属性，值为该value的Observer实例</span></span><br><span class=\"line\">    <span class=\"comment\">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作  </span></span><br><span class=\"line\">    def(value,<span class=\"string\">'__ob__'</span>,<span class=\"keyword\">this</span>)    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 当value为数组时的逻辑</span></span><br><span class=\"line\">      <span class=\"comment\">// ...  </span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  walk (obj: <span class=\"built_in\">Object</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(obj)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使一个对象转化成可观测对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123; Object &#125; obj 对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123; String &#125; key 对象的key</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123; Any &#125; val 对象的某个key的值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\">obj,key,val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果只传了obj和key，那么val = obj[key]</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Observer(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>属性被读取了`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(val === newVal)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>属性被修改了`</span>);</span><br><span class=\"line\">      val = newVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们定义了<code>observer</code>类，它用来将一个正常的<code>object</code>转换成可观测的<code>object</code>。</p>\n<p>并且给<code>value</code>新增一个<code>__ob__</code>属性，值为该<code>value</code>的<code>Observer</code>实例。这个操作相当于为<code>value</code>打上标记，表示它已经被转化成响应式了，避免重复操作</p>\n<p>然后判断数据的类型，只有<code>object</code>类型的数据才会调用<code>walk</code>将每一个属性转换成<code>getter/setter</code>的形式来侦测变化。<br>\n最后，在<code>defineReactive</code>中当传入的属性值还是一个<code>object</code>时使用<code>new observer（val）</code>来递归子属性，这样我们就可以把<code>obj</code>中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。<br>\n也就是说，只要我们将一个<code>object</code>传到<code>observer</code>中，那么这个<code>object</code>就会变成可观测的、响应式的<code>object</code>。</p>\n<p><code>observer</code>类位于源码的<code>src/core/observer/index.js</code>中。</p>\n<p>那么现在，我们就可以这样定义<code>car</code>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"keyword\">new</span> Observer(&#123;</span><br><span class=\"line\">  <span class=\"string\">'brand'</span>:<span class=\"string\">'BMW'</span>,</span><br><span class=\"line\">  <span class=\"string\">'price'</span>:<span class=\"number\">3000</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样，<code>car</code>的两个属性都变得可观测了。</p>\n<h2>3. 依赖收集</h2>\n<h3>3.1 什么是依赖收集</h3>\n<p>在上一章中，我们迈出了第一步：让<code>object</code>数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。</p>\n<p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把&quot;谁用到了这个数据&quot;称为&quot;谁依赖了这个数据&quot;,我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：“你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p>\n<h3>3.2 何时收集依赖？何时通知依赖更新？</h3>\n<p>明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？</p>\n<p>其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发<code>getter</code>属性，那么我们就可以在<code>getter</code>中收集这个依赖。同样，当这个数据变化时会触发<code>setter</code>属性，那么我们就可以在<code>setter</code>中通知依赖更新。</p>\n<p>总结一句话就是：<strong>在getter中收集依赖，在setter中通知依赖更新</strong>。</p>\n<h3>3.3 把依赖收集到哪里</h3>\n<p>明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？</p>\n<p>在3.1小节中也说了，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器<code>Dep</code>类应运而生，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：src/core/observer/dep.js\t</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  addSub (sub) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除一个依赖</span></span><br><span class=\"line\">  removeSub (sub) &#123;</span><br><span class=\"line\">    remove(<span class=\"keyword\">this</span>.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 添加一个依赖</span></span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.addSub(<span class=\"built_in\">window</span>.target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 通知所有依赖更新</span></span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>.subs.slice()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove an item from an array</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span> (<span class=\"params\">arr, item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> index = arr.indexOf(item)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> arr.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的依赖管理器<code>Dep</code>类中，我们先初始化了一个<code>subs</code>数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。</p>\n<p>有了依赖管理器后，我们就可以在getter中收集依赖，在setter中通知依赖更新了，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\">obj,key,val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    val = obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Observer(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> Dep()  <span class=\"comment\">//实例化一个依赖管理器，生成一个依赖管理数组dep</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">      dep.depend()    <span class=\"comment\">// 在getter中收集依赖</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(val === newVal)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal;</span><br><span class=\"line\">      dep.notify()   <span class=\"comment\">// 在setter中通知依赖更新</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述代码中，我们在<code>getter</code>中调用了<code>dep.depend()</code>方法收集依赖，在<code>setter</code>中调用<code>dep.notify()</code>方法通知所有依赖更新。</p>\n<h2>4. 依赖到底是谁</h2>\n<p>通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？</p>\n<p>虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？</p>\n<p>其实在<code>Vue</code>中还实现了一个叫做<code>Watcher</code>的类，而<code>Watcher</code>类的实例就是我们上面所说的那个&quot;谁&quot;。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的<code>Watch</code>实例，由<code>Watcher</code>实例去通知真正的视图。</p>\n<p><code>Watcher</code>类的具体实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (vm,expOrFn,cb) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vm = vm;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cb = cb;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getter = parsePath(expOrFn)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">this</span>.vm</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value = <span class=\"keyword\">this</span>.getter.call(vm, vm)</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.target = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  update () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> oldValue = <span class=\"keyword\">this</span>.value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, <span class=\"keyword\">this</span>.value, oldValue)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Parse simple path.</span></span><br><span class=\"line\"><span class=\"comment\"> * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：</span></span><br><span class=\"line\"><span class=\"comment\"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * parsePath('a.b.c')(data)  // 2</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> bailRE = <span class=\"regexp\">/[^\\w.$]/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parsePath</span> (<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bailRE.test(path)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> segments = path.split(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span></span><br><span class=\"line\">      obj = obj[segments[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>谁用到了数据，谁就是依赖，我们就为谁创建一个<code>Watcher</code>实例，在创建<code>Watcher</code>实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个<code>Watcher</code>实例就代表这个依赖，当数据变化时，我们就通知<code>Watcher</code>实例，由<code>Watcher</code>实例再去通知真正的依赖。</p>\n<p>那么，在创建<code>Watcher</code>实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？</p>\n<p>下面我们分析<code>Watcher</code>类的代码实现逻辑：</p>\n<ol>\n<li>当实例化<code>Watcher</code>类时，会先执行其构造函数；</li>\n<li>在构造函数中调用了<code>this.get()</code>实例方法；</li>\n<li>在<code>get()</code>方法中，首先通过<code>window.target = this</code>把实例自身赋给了全局的一个唯一对象<code>window.target</code>上，然后通过<code>let value = this.getter.call(vm, vm)</code>获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的<code>getter</code>，上文我们说过，在<code>getter</code>里会调用<code>dep.depend()</code>收集依赖，而在<code>dep.depend()</code>中取到挂载<code>window.target</code>上的值并将其存入依赖数组中，在<code>get()</code>方法最后将<code>window.target</code>释放掉。</li>\n<li>而当数据变化时，会触发数据的<code>setter</code>，在<code>setter</code>中调用了<code>dep.notify()</code>方法，在<code>dep.notify()</code>方法中，遍历所有依赖(即watcher实例)，执行依赖的<code>update()</code>方法，也就是<code>Watcher</code>类中的<code>update()</code>实例方法，在<code>update()</code>方法中调用数据变化的更新回调函数，从而更新视图。</li>\n</ol>\n<p>简单总结一下就是：<code>Watcher</code>先把自己设置到全局唯一的指定位置（<code>window.target</code>），然后读取数据。因为读取了数据，所以会触发这个数据的<code>getter</code>。接着，在<code>getter</code>中就会从全局唯一的那个位置读取当前正在读取数据的<code>Watcher</code>，并把这个<code>watcher</code>收集到<code>Dep</code>中去。收集好之后，当数据发生变化时，会向<code>Dep</code>中的每个<code>Watcher</code>发送通知。通过这样的方式，<code>Watcher</code>可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图：</p>\n<p><img src=\"~@/reactive/3.jpg\" alt></p>\n<p>以上，就彻底完成了对<code>Object</code>数据的侦测，依赖收集，依赖的更新等所有操作。</p>\n<h2>5. 不足之处</h2>\n<p>虽然我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，但是这个方法仅仅只能观测到<code>object</code>数据的取值及设置值，当我们向<code>object</code>数据里添加一对新的<code>key/value</code>或删除一对已有的<code>key/value</code>时，它是无法观测到的，导致当我们对<code>object</code>数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。</p>\n<p>当然，<code>Vue</code>也注意到了这一点，为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到。</p>\n<h2>6. 总结</h2>\n<p>首先，我们通过<code>Object.defineProperty</code>方法实现了对<code>object</code>数据的可观测，并且封装了<code>Observer</code>类，让我们能够方便的把<code>object</code>数据中的所有属性（包括子属性）都转换成<code>getter/seter</code>的形式来侦测变化。</p>\n<p>接着，我们学习了什么是依赖收集？并且知道了在<code>getter</code>中收集依赖，在<code>setter</code>中通知依赖更新，以及封装了依赖管理器<code>Dep</code>，用于存储收集到的依赖。</p>\n<p>最后，我们为每一个依赖都创建了一个<code>Watcher</code>实例，当数据发生变化时，通知<code>Watcher</code>实例，由<code>Watcher</code>实例去做真实的更新操作。</p>\n<p>其整个流程大致如下：</p>\n<ol>\n<li><code>Data</code>通过<code>observer</code>转换成了<code>getter/setter</code>的形式来追踪变化。</li>\n<li>当外界通过<code>Watcher</code>读取数据时，会触发<code>getter</code>从而将<code>Watcher</code>添加到依赖中。</li>\n<li>当数据发生了变化时，会触发<code>setter</code>，从而向<code>Dep</code>中的依赖（即Watcher）发送通知。</li>\n<li><code>Watcher</code>接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。</li>\n</ol>\n"},{"title":"Vue 源码阅读 虚拟DOM （三）","catalog":true,"date":"2019-10-28T11:12:43.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n在上一篇文章中，我们了解了`Vue`中的`patch`过程，即`DOM-Diff`算法。并且知道了在`patch`过程中基本会干三件事，分别是：创建节点，删除节点和更新节点。创建节点和删除节点都比较简单，而更新节点因为要处理各种可能出现的情况所以逻辑略微复杂一些，但是没关系，我们通过分析过程，对照源码，画逻辑流程图来帮助我们理解了其中的过程。最后我们还遗留了一个问题，那就是在更新节点过程中，新旧`VNode`可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑，那么在本篇文章中我们就来学习在`Vue`中是怎么对比更新子节点的。\n\n## 2. 更新子节点\n\n当新的`VNode`与旧的`oldVNode`都是元素节点并且都包含子节点时，那么这两个节点的`VNode`实例上的`children`属性就是所包含的子节点数组。我们把新的`VNode`上的子节点数组记为`newChildren`，把旧的`oldVNode`上的子节点数组记为`oldChildren`，我们把`newChildren`里面的元素与`oldChildren`里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环`newChildren`数组，内层循环`oldChildren`数组，每循环外层`newChildren`数组里的一个子节点，就去内层`oldChildren`数组里找看有没有与之相同的子节点，伪代码如下：\n\n```javascript\nfor (let i = 0; i < newChildren.length; i++) {\n  const newChild = newChildren[i];\n  for (let j = 0; j < oldChildren.length; j++) {\n    const oldChild = oldChildren[j];\n    if (newChild === oldChild) {\n      // ...\n    }\n  }\n}\n```\n\n\n\n那么以上这个过程将会存在以下四种情况：\n\n- 创建子节点\n\n  如果`newChildren`里面的某个子节点在`oldChildren`里找不到与之相同的子节点，那么说明`newChildren`里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。\n\n- 删除子节点\n\n  如果把`newChildren`里面的每一个子节点都循环完毕后，发现在`oldChildren`还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。\n\n- 移动子节点\n\n  如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以`newChildren`里子节点的位置为基准，调整`oldChildren`里该节点的位置，使之与在`newChildren`里的位置相同。\n\n- 更新节点\n\n  如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，并且所处的位置也相同，那么就更新`oldChildren`里该节点，使之与`newChildren`里的该节点相同。\n\nOK，到这里，逻辑就相对清晰了，接下来我们只需分门别类的处理这四种情况就好了。\n\n## 3. 创建子节点\n\n如果`newChildren`里面的某个子节点在`oldChildren`里找不到与之相同的子节点，那么说明`newChildren`里面的这个子节点是之前没有的，是需要此次新增的节点，那么我们就创建这个节点，创建好之后再把它插入到`DOM`中合适的位置。\n\n创建节点这个很容易，我们在上一篇文章的第三章已经介绍过了，这里就不再赘述了。\n\n那么创建好之后如何插入到`DOM`中的合适的位置呢？显然，把节点插入到`DOM`中是很容易的，找到合适的位置是关键。接下来我们分析一下如何找这个合适的位置。我们看下面这个图：\n![](/img/virtualDOM/4.png)\n\n上图中左边是新的`VNode`，右边是旧的`oldVNode`，同时也是真实的`DOM`。这个图意思是当我们循环`newChildren`数组里面的子节点，前两个子节点都在`oldChildren`里找到了与之对应的子节点，那么我们将其处理，处理过后把它们标志为已处理，当循环到`newChildren`数组里第三个子节点时，发现在`oldChildren`里找不到与之对应的子节点，那么我们就需要创建这个节点，创建好之后我们发现这个节点本是`newChildren`数组里左起第三个子节点，那么我们就把创建好的节点插入到真实`DOM`里的第三个节点位置，也就是所有已处理节点之后，OK，此时我们拍手称快，所有已处理节点之后就是我们要找的合适的位置，但是真的是这样吗？我们再来看下面这个图：\n![](/img/virtualDOM/5.png)\n\n假如我们按照上面的方法把第三个节点插入到所有已处理节点之后，此时如果第四个节点也在`oldChildren`里找不到与之对应的节点，也是需要创建的节点，那么当我们把第四个节点也按照上面的说的插入到已处理节点之后，发现怎么插入到第三个位置了，可明明这个节点在`newChildren`数组里是第四个啊！\n\n这就是问题所在，其实，我们应该把新创建的节点插入到所有未处理节点之前，这样以来逻辑才正确。后面不管有多少个新增的节点，每一个都插入到所有未处理节点之前，位置才不会错。\n\n所以，**合适的位置是所有未处理节点之前，而并非所有已处理节点之后**。\n\n## 4. 删除子节点\n\n如果把`newChildren`里面的每一个子节点都循环一遍，能在`oldChildren`数组里找到的就处理它，找不到的就新增，直到把`newChildren`里面所有子节点都过一遍后，发现在`oldChildren`还存在未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。\n\n删除节点这个也很容易，我们在上一篇文章的第四章已经介绍过了，这里就不再赘述了。\n\n## 5. 更新子节点\n\n如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，并且所处的位置也相同，那么就更新`oldChildren`里该节点，使之与`newChildren`里的该节点相同。\n\n关于更新节点，我们在上一篇文章的第五章已经介绍过了，这里就不再赘述了。\n\n## 6. 移动子节点\n\n如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以`newChildren`里子节点的位置为基准，调整`oldChildren`里该节点的位置，使之与在`newChildren`里的位置相同。\n\n同样，移动一个节点不难，关键在于该移动到哪，或者说关键在于移动到哪个位置，这个位置才是关键。我们看下图：\n![](/img/virtualDOM/6.png)\n\n在上图中，绿色的两个节点是相同节点但是所处位置不同，即`newChildren`里面的第三个子节点与真实`DOM`即`oldChildren`里面的第四个子节点相同但是所处位置不同，按照上面所说的，我们应该以`newChildren`里子节点的位置为基准，调整`oldChildren`里该节点的位置，所以我们应该把真实`DOM`即`oldChildren`里面的第四个节点移动到第三个节点的位置，通过上图中的标注我们不难发现，**所有未处理节点之前就是我们要移动的目的位置**。如果此时你说那可不可以移动到所有已处理节点之后呢？那就又回到了更新节点时所遇到的那个问题了：如果前面有新增的节点呢？\n\n## 7. 回到源码\n\nOK，以上就是更新子节点时所要考虑的所有情况了，分析完以后，我们回到源码里看看实际情况是不是我们分析的这样子的，源码如下：\n\n```javascript\n// 源码位置： /src/core/vdom/patch.js\n\nif (isUndef(idxInOld)) {    // 如果在oldChildren里找不到当前循环的newChildren里的子节点\n    // 新增节点并插入到合适位置\n    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n} else {\n    // 如果在oldChildren里找到了当前循环的newChildren里的子节点\n    vnodeToMove = oldCh[idxInOld]\n    // 如果两个节点相同\n    if (sameVnode(vnodeToMove, newStartVnode)) {\n        // 调用patchVnode更新节点\n        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n        oldCh[idxInOld] = undefined\n        // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动\n        canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n    } \n}\n```\n\n以上代码中，首先判断在`oldChildren`里能否找到当前循环的`newChildren`里的子节点，如果找不到，那就是新增节点并插入到合适位置；如果找到了，先对比两个节点是否相同，若相同则先调用`patchVnode`更新节点，更新完之后再看是否需要移动节点，注意，源码里在判断是否需要移动子节点时用了简写的方式，下面这两种写法是等价的：\n\n```javascript\ncanMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n// 等同于\nif(canMove){\n    nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n}\n```\n\n我们看到，源码里的实现跟我们分析的是一样一样的。\n\n## 8. 总结\n\n本篇文章我们分析了`Vue`在更新子节点时是外层循环`newChildren`数组，内层循环`oldChildren`数组，把`newChildren`数组里的每一个元素分别与`oldChildren`数组里的每一个元素匹配，根据不同情况作出创建子节点、删除子节点、更新子节点以及移动子节点的操作。并且我们对不同情况的不同操作都进行了深入分析，分析之后我们回到源码验证我们分析的正确性，发现我们的分析跟源码的实现是一致的。\n\n最后，我们再思考一个问题：这样双层循环虽然能解决问题，但是如果节点数量很多，这样循环算法的时间复杂度会不会很高？有没有什么可以优化的办法？答案当然是有的，并且`Vue`也意识到了这点，也进行了优化，那么下篇文章我们就来分析当节点数量很多时`Vue`是怎么优化算法的。\n\n","source":"_posts/Vue 源码阅读 虚拟DOM （三）.md","raw":"---\ntitle: Vue 源码阅读 虚拟DOM （三） \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-28 19:12:43\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n在上一篇文章中，我们了解了`Vue`中的`patch`过程，即`DOM-Diff`算法。并且知道了在`patch`过程中基本会干三件事，分别是：创建节点，删除节点和更新节点。创建节点和删除节点都比较简单，而更新节点因为要处理各种可能出现的情况所以逻辑略微复杂一些，但是没关系，我们通过分析过程，对照源码，画逻辑流程图来帮助我们理解了其中的过程。最后我们还遗留了一个问题，那就是在更新节点过程中，新旧`VNode`可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑，那么在本篇文章中我们就来学习在`Vue`中是怎么对比更新子节点的。\n\n## 2. 更新子节点\n\n当新的`VNode`与旧的`oldVNode`都是元素节点并且都包含子节点时，那么这两个节点的`VNode`实例上的`children`属性就是所包含的子节点数组。我们把新的`VNode`上的子节点数组记为`newChildren`，把旧的`oldVNode`上的子节点数组记为`oldChildren`，我们把`newChildren`里面的元素与`oldChildren`里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环`newChildren`数组，内层循环`oldChildren`数组，每循环外层`newChildren`数组里的一个子节点，就去内层`oldChildren`数组里找看有没有与之相同的子节点，伪代码如下：\n\n```javascript\nfor (let i = 0; i < newChildren.length; i++) {\n  const newChild = newChildren[i];\n  for (let j = 0; j < oldChildren.length; j++) {\n    const oldChild = oldChildren[j];\n    if (newChild === oldChild) {\n      // ...\n    }\n  }\n}\n```\n\n\n\n那么以上这个过程将会存在以下四种情况：\n\n- 创建子节点\n\n  如果`newChildren`里面的某个子节点在`oldChildren`里找不到与之相同的子节点，那么说明`newChildren`里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。\n\n- 删除子节点\n\n  如果把`newChildren`里面的每一个子节点都循环完毕后，发现在`oldChildren`还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。\n\n- 移动子节点\n\n  如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以`newChildren`里子节点的位置为基准，调整`oldChildren`里该节点的位置，使之与在`newChildren`里的位置相同。\n\n- 更新节点\n\n  如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，并且所处的位置也相同，那么就更新`oldChildren`里该节点，使之与`newChildren`里的该节点相同。\n\nOK，到这里，逻辑就相对清晰了，接下来我们只需分门别类的处理这四种情况就好了。\n\n## 3. 创建子节点\n\n如果`newChildren`里面的某个子节点在`oldChildren`里找不到与之相同的子节点，那么说明`newChildren`里面的这个子节点是之前没有的，是需要此次新增的节点，那么我们就创建这个节点，创建好之后再把它插入到`DOM`中合适的位置。\n\n创建节点这个很容易，我们在上一篇文章的第三章已经介绍过了，这里就不再赘述了。\n\n那么创建好之后如何插入到`DOM`中的合适的位置呢？显然，把节点插入到`DOM`中是很容易的，找到合适的位置是关键。接下来我们分析一下如何找这个合适的位置。我们看下面这个图：\n![](/img/virtualDOM/4.png)\n\n上图中左边是新的`VNode`，右边是旧的`oldVNode`，同时也是真实的`DOM`。这个图意思是当我们循环`newChildren`数组里面的子节点，前两个子节点都在`oldChildren`里找到了与之对应的子节点，那么我们将其处理，处理过后把它们标志为已处理，当循环到`newChildren`数组里第三个子节点时，发现在`oldChildren`里找不到与之对应的子节点，那么我们就需要创建这个节点，创建好之后我们发现这个节点本是`newChildren`数组里左起第三个子节点，那么我们就把创建好的节点插入到真实`DOM`里的第三个节点位置，也就是所有已处理节点之后，OK，此时我们拍手称快，所有已处理节点之后就是我们要找的合适的位置，但是真的是这样吗？我们再来看下面这个图：\n![](/img/virtualDOM/5.png)\n\n假如我们按照上面的方法把第三个节点插入到所有已处理节点之后，此时如果第四个节点也在`oldChildren`里找不到与之对应的节点，也是需要创建的节点，那么当我们把第四个节点也按照上面的说的插入到已处理节点之后，发现怎么插入到第三个位置了，可明明这个节点在`newChildren`数组里是第四个啊！\n\n这就是问题所在，其实，我们应该把新创建的节点插入到所有未处理节点之前，这样以来逻辑才正确。后面不管有多少个新增的节点，每一个都插入到所有未处理节点之前，位置才不会错。\n\n所以，**合适的位置是所有未处理节点之前，而并非所有已处理节点之后**。\n\n## 4. 删除子节点\n\n如果把`newChildren`里面的每一个子节点都循环一遍，能在`oldChildren`数组里找到的就处理它，找不到的就新增，直到把`newChildren`里面所有子节点都过一遍后，发现在`oldChildren`还存在未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。\n\n删除节点这个也很容易，我们在上一篇文章的第四章已经介绍过了，这里就不再赘述了。\n\n## 5. 更新子节点\n\n如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，并且所处的位置也相同，那么就更新`oldChildren`里该节点，使之与`newChildren`里的该节点相同。\n\n关于更新节点，我们在上一篇文章的第五章已经介绍过了，这里就不再赘述了。\n\n## 6. 移动子节点\n\n如果`newChildren`里面的某个子节点在`oldChildren`里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以`newChildren`里子节点的位置为基准，调整`oldChildren`里该节点的位置，使之与在`newChildren`里的位置相同。\n\n同样，移动一个节点不难，关键在于该移动到哪，或者说关键在于移动到哪个位置，这个位置才是关键。我们看下图：\n![](/img/virtualDOM/6.png)\n\n在上图中，绿色的两个节点是相同节点但是所处位置不同，即`newChildren`里面的第三个子节点与真实`DOM`即`oldChildren`里面的第四个子节点相同但是所处位置不同，按照上面所说的，我们应该以`newChildren`里子节点的位置为基准，调整`oldChildren`里该节点的位置，所以我们应该把真实`DOM`即`oldChildren`里面的第四个节点移动到第三个节点的位置，通过上图中的标注我们不难发现，**所有未处理节点之前就是我们要移动的目的位置**。如果此时你说那可不可以移动到所有已处理节点之后呢？那就又回到了更新节点时所遇到的那个问题了：如果前面有新增的节点呢？\n\n## 7. 回到源码\n\nOK，以上就是更新子节点时所要考虑的所有情况了，分析完以后，我们回到源码里看看实际情况是不是我们分析的这样子的，源码如下：\n\n```javascript\n// 源码位置： /src/core/vdom/patch.js\n\nif (isUndef(idxInOld)) {    // 如果在oldChildren里找不到当前循环的newChildren里的子节点\n    // 新增节点并插入到合适位置\n    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n} else {\n    // 如果在oldChildren里找到了当前循环的newChildren里的子节点\n    vnodeToMove = oldCh[idxInOld]\n    // 如果两个节点相同\n    if (sameVnode(vnodeToMove, newStartVnode)) {\n        // 调用patchVnode更新节点\n        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n        oldCh[idxInOld] = undefined\n        // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动\n        canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n    } \n}\n```\n\n以上代码中，首先判断在`oldChildren`里能否找到当前循环的`newChildren`里的子节点，如果找不到，那就是新增节点并插入到合适位置；如果找到了，先对比两个节点是否相同，若相同则先调用`patchVnode`更新节点，更新完之后再看是否需要移动节点，注意，源码里在判断是否需要移动子节点时用了简写的方式，下面这两种写法是等价的：\n\n```javascript\ncanMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n// 等同于\nif(canMove){\n    nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n}\n```\n\n我们看到，源码里的实现跟我们分析的是一样一样的。\n\n## 8. 总结\n\n本篇文章我们分析了`Vue`在更新子节点时是外层循环`newChildren`数组，内层循环`oldChildren`数组，把`newChildren`数组里的每一个元素分别与`oldChildren`数组里的每一个元素匹配，根据不同情况作出创建子节点、删除子节点、更新子节点以及移动子节点的操作。并且我们对不同情况的不同操作都进行了深入分析，分析之后我们回到源码验证我们分析的正确性，发现我们的分析跟源码的实现是一致的。\n\n最后，我们再思考一个问题：这样双层循环虽然能解决问题，但是如果节点数量很多，这样循环算法的时间复杂度会不会很高？有没有什么可以优化的办法？答案当然是有的，并且`Vue`也意识到了这点，也进行了优化，那么下篇文章我们就来分析当节点数量很多时`Vue`是怎么优化算法的。\n\n","slug":"Vue 源码阅读 虚拟DOM （三）","published":1,"updated":"2019-12-31T03:26:19.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj85006zzws6kdmbojao","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在上一篇文章中，我们了解了<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法。并且知道了在<code>patch</code>过程中基本会干三件事，分别是：创建节点，删除节点和更新节点。创建节点和删除节点都比较简单，而更新节点因为要处理各种可能出现的情况所以逻辑略微复杂一些，但是没关系，我们通过分析过程，对照源码，画逻辑流程图来帮助我们理解了其中的过程。最后我们还遗留了一个问题，那就是在更新节点过程中，新旧<code>VNode</code>可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑，那么在本篇文章中我们就来学习在<code>Vue</code>中是怎么对比更新子节点的。</p>\n<h2><span id=\"2-更新子节点\">2. 更新子节点</span></h2>\n<p>当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，那么这两个节点的<code>VNode</code>实例上的<code>children</code>属性就是所包含的子节点数组。我们把新的<code>VNode</code>上的子节点数组记为<code>newChildren</code>，把旧的<code>oldVNode</code>上的子节点数组记为<code>oldChildren</code>，我们把<code>newChildren</code>里面的元素与<code>oldChildren</code>里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，伪代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; newChildren.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newChild = newChildren[i];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; oldChildren.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> oldChild = oldChildren[j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newChild === oldChild) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么以上这个过程将会存在以下四种情况：</p>\n<ul>\n<li>\n<p>创建子节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。</p>\n</li>\n<li>\n<p>删除子节点</p>\n<p>如果把<code>newChildren</code>里面的每一个子节点都循环完毕后，发现在<code>oldChildren</code>还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>\n</li>\n<li>\n<p>移动子节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>\n</li>\n<li>\n<p>更新节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>\n</li>\n</ul>\n<p>OK，到这里，逻辑就相对清晰了，接下来我们只需分门别类的处理这四种情况就好了。</p>\n<h2><span id=\"3-创建子节点\">3. 创建子节点</span></h2>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么我们就创建这个节点，创建好之后再把它插入到<code>DOM</code>中合适的位置。</p>\n<p>创建节点这个很容易，我们在上一篇文章的第三章已经介绍过了，这里就不再赘述了。</p>\n<p>那么创建好之后如何插入到<code>DOM</code>中的合适的位置呢？显然，把节点插入到<code>DOM</code>中是很容易的，找到合适的位置是关键。接下来我们分析一下如何找这个合适的位置。我们看下面这个图：<br>\n<img src=\"/img/virtualDOM/4.png\" alt></p>\n<p>上图中左边是新的<code>VNode</code>，右边是旧的<code>oldVNode</code>，同时也是真实的<code>DOM</code>。这个图意思是当我们循环<code>newChildren</code>数组里面的子节点，前两个子节点都在<code>oldChildren</code>里找到了与之对应的子节点，那么我们将其处理，处理过后把它们标志为已处理，当循环到<code>newChildren</code>数组里第三个子节点时，发现在<code>oldChildren</code>里找不到与之对应的子节点，那么我们就需要创建这个节点，创建好之后我们发现这个节点本是<code>newChildren</code>数组里左起第三个子节点，那么我们就把创建好的节点插入到真实<code>DOM</code>里的第三个节点位置，也就是所有已处理节点之后，OK，此时我们拍手称快，所有已处理节点之后就是我们要找的合适的位置，但是真的是这样吗？我们再来看下面这个图：<br>\n<img src=\"/img/virtualDOM/5.png\" alt></p>\n<p>假如我们按照上面的方法把第三个节点插入到所有已处理节点之后，此时如果第四个节点也在<code>oldChildren</code>里找不到与之对应的节点，也是需要创建的节点，那么当我们把第四个节点也按照上面的说的插入到已处理节点之后，发现怎么插入到第三个位置了，可明明这个节点在<code>newChildren</code>数组里是第四个啊！</p>\n<p>这就是问题所在，其实，我们应该把新创建的节点插入到所有未处理节点之前，这样以来逻辑才正确。后面不管有多少个新增的节点，每一个都插入到所有未处理节点之前，位置才不会错。</p>\n<p>所以，<strong>合适的位置是所有未处理节点之前，而并非所有已处理节点之后</strong>。</p>\n<h2><span id=\"4-删除子节点\">4. 删除子节点</span></h2>\n<p>如果把<code>newChildren</code>里面的每一个子节点都循环一遍，能在<code>oldChildren</code>数组里找到的就处理它，找不到的就新增，直到把<code>newChildren</code>里面所有子节点都过一遍后，发现在<code>oldChildren</code>还存在未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>\n<p>删除节点这个也很容易，我们在上一篇文章的第四章已经介绍过了，这里就不再赘述了。</p>\n<h2><span id=\"5-更新子节点\">5. 更新子节点</span></h2>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>\n<p>关于更新节点，我们在上一篇文章的第五章已经介绍过了，这里就不再赘述了。</p>\n<h2><span id=\"6-移动子节点\">6. 移动子节点</span></h2>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>\n<p>同样，移动一个节点不难，关键在于该移动到哪，或者说关键在于移动到哪个位置，这个位置才是关键。我们看下图：<br>\n<img src=\"/img/virtualDOM/6.png\" alt></p>\n<p>在上图中，绿色的两个节点是相同节点但是所处位置不同，即<code>newChildren</code>里面的第三个子节点与真实<code>DOM</code>即<code>oldChildren</code>里面的第四个子节点相同但是所处位置不同，按照上面所说的，我们应该以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，所以我们应该把真实<code>DOM</code>即<code>oldChildren</code>里面的第四个节点移动到第三个节点的位置，通过上图中的标注我们不难发现，<strong>所有未处理节点之前就是我们要移动的目的位置</strong>。如果此时你说那可不可以移动到所有已处理节点之后呢？那就又回到了更新节点时所遇到的那个问题了：如果前面有新增的节点呢？</p>\n<h2><span id=\"7-回到源码\">7. 回到源码</span></h2>\n<p>OK，以上就是更新子节点时所要考虑的所有情况了，分析完以后，我们回到源码里看看实际情况是不是我们分析的这样子的，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置： /src/core/vdom/patch.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123;    <span class=\"comment\">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 新增节点并插入到合适位置</span></span><br><span class=\"line\">    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span></span><br><span class=\"line\">    vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">    <span class=\"comment\">// 如果两个节点相同</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用patchVnode更新节点</span></span><br><span class=\"line\">        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">        oldCh[idxInOld] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">        <span class=\"comment\">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span></span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码中，首先判断在<code>oldChildren</code>里能否找到当前循环的<code>newChildren</code>里的子节点，如果找不到，那就是新增节点并插入到合适位置；如果找到了，先对比两个节点是否相同，若相同则先调用<code>patchVnode</code>更新节点，更新完之后再看是否需要移动节点，注意，源码里在判断是否需要移动子节点时用了简写的方式，下面这两种写法是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(canMove)&#123;</span><br><span class=\"line\">    nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，源码里的实现跟我们分析的是一样一样的。</p>\n<h2><span id=\"8-总结\">8. 总结</span></h2>\n<p>本篇文章我们分析了<code>Vue</code>在更新子节点时是外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，把<code>newChildren</code>数组里的每一个元素分别与<code>oldChildren</code>数组里的每一个元素匹配，根据不同情况作出创建子节点、删除子节点、更新子节点以及移动子节点的操作。并且我们对不同情况的不同操作都进行了深入分析，分析之后我们回到源码验证我们分析的正确性，发现我们的分析跟源码的实现是一致的。</p>\n<p>最后，我们再思考一个问题：这样双层循环虽然能解决问题，但是如果节点数量很多，这样循环算法的时间复杂度会不会很高？有没有什么可以优化的办法？答案当然是有的，并且<code>Vue</code>也意识到了这点，也进行了优化，那么下篇文章我们就来分析当节点数量很多时<code>Vue</code>是怎么优化算法的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在上一篇文章中，我们了解了<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法。并且知道了在<code>patch</code>过程中基本会干三件事，分别是：创建节点，删除节点和更新节点。创建节点和删除节点都比较简单，而更新节点因为要处理各种可能出现的情况所以逻辑略微复杂一些，但是没关系，我们通过分析过程，对照源码，画逻辑流程图来帮助我们理解了其中的过程。最后我们还遗留了一个问题，那就是在更新节点过程中，新旧<code>VNode</code>可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑，那么在本篇文章中我们就来学习在<code>Vue</code>中是怎么对比更新子节点的。</p>\n<h2>2. 更新子节点</h2>\n<p>当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，那么这两个节点的<code>VNode</code>实例上的<code>children</code>属性就是所包含的子节点数组。我们把新的<code>VNode</code>上的子节点数组记为<code>newChildren</code>，把旧的<code>oldVNode</code>上的子节点数组记为<code>oldChildren</code>，我们把<code>newChildren</code>里面的元素与<code>oldChildren</code>里的元素一一进行对比，对比两个子节点数组肯定是要通过循环，外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，伪代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; newChildren.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newChild = newChildren[i];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; oldChildren.length; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> oldChild = oldChildren[j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newChild === oldChild) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么以上这个过程将会存在以下四种情况：</p>\n<ul>\n<li>\n<p>创建子节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。</p>\n</li>\n<li>\n<p>删除子节点</p>\n<p>如果把<code>newChildren</code>里面的每一个子节点都循环完毕后，发现在<code>oldChildren</code>还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>\n</li>\n<li>\n<p>移动子节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>\n</li>\n<li>\n<p>更新节点</p>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>\n</li>\n</ul>\n<p>OK，到这里，逻辑就相对清晰了，接下来我们只需分门别类的处理这四种情况就好了。</p>\n<h2>3. 创建子节点</h2>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找不到与之相同的子节点，那么说明<code>newChildren</code>里面的这个子节点是之前没有的，是需要此次新增的节点，那么我们就创建这个节点，创建好之后再把它插入到<code>DOM</code>中合适的位置。</p>\n<p>创建节点这个很容易，我们在上一篇文章的第三章已经介绍过了，这里就不再赘述了。</p>\n<p>那么创建好之后如何插入到<code>DOM</code>中的合适的位置呢？显然，把节点插入到<code>DOM</code>中是很容易的，找到合适的位置是关键。接下来我们分析一下如何找这个合适的位置。我们看下面这个图：<br>\n<img src=\"/img/virtualDOM/4.png\" alt></p>\n<p>上图中左边是新的<code>VNode</code>，右边是旧的<code>oldVNode</code>，同时也是真实的<code>DOM</code>。这个图意思是当我们循环<code>newChildren</code>数组里面的子节点，前两个子节点都在<code>oldChildren</code>里找到了与之对应的子节点，那么我们将其处理，处理过后把它们标志为已处理，当循环到<code>newChildren</code>数组里第三个子节点时，发现在<code>oldChildren</code>里找不到与之对应的子节点，那么我们就需要创建这个节点，创建好之后我们发现这个节点本是<code>newChildren</code>数组里左起第三个子节点，那么我们就把创建好的节点插入到真实<code>DOM</code>里的第三个节点位置，也就是所有已处理节点之后，OK，此时我们拍手称快，所有已处理节点之后就是我们要找的合适的位置，但是真的是这样吗？我们再来看下面这个图：<br>\n<img src=\"/img/virtualDOM/5.png\" alt></p>\n<p>假如我们按照上面的方法把第三个节点插入到所有已处理节点之后，此时如果第四个节点也在<code>oldChildren</code>里找不到与之对应的节点，也是需要创建的节点，那么当我们把第四个节点也按照上面的说的插入到已处理节点之后，发现怎么插入到第三个位置了，可明明这个节点在<code>newChildren</code>数组里是第四个啊！</p>\n<p>这就是问题所在，其实，我们应该把新创建的节点插入到所有未处理节点之前，这样以来逻辑才正确。后面不管有多少个新增的节点，每一个都插入到所有未处理节点之前，位置才不会错。</p>\n<p>所以，<strong>合适的位置是所有未处理节点之前，而并非所有已处理节点之后</strong>。</p>\n<h2>4. 删除子节点</h2>\n<p>如果把<code>newChildren</code>里面的每一个子节点都循环一遍，能在<code>oldChildren</code>数组里找到的就处理它，找不到的就新增，直到把<code>newChildren</code>里面所有子节点都过一遍后，发现在<code>oldChildren</code>还存在未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</p>\n<p>删除节点这个也很容易，我们在上一篇文章的第四章已经介绍过了，这里就不再赘述了。</p>\n<h2>5. 更新子节点</h2>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，并且所处的位置也相同，那么就更新<code>oldChildren</code>里该节点，使之与<code>newChildren</code>里的该节点相同。</p>\n<p>关于更新节点，我们在上一篇文章的第五章已经介绍过了，这里就不再赘述了。</p>\n<h2>6. 移动子节点</h2>\n<p>如果<code>newChildren</code>里面的某个子节点在<code>oldChildren</code>里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，使之与在<code>newChildren</code>里的位置相同。</p>\n<p>同样，移动一个节点不难，关键在于该移动到哪，或者说关键在于移动到哪个位置，这个位置才是关键。我们看下图：<br>\n<img src=\"/img/virtualDOM/6.png\" alt></p>\n<p>在上图中，绿色的两个节点是相同节点但是所处位置不同，即<code>newChildren</code>里面的第三个子节点与真实<code>DOM</code>即<code>oldChildren</code>里面的第四个子节点相同但是所处位置不同，按照上面所说的，我们应该以<code>newChildren</code>里子节点的位置为基准，调整<code>oldChildren</code>里该节点的位置，所以我们应该把真实<code>DOM</code>即<code>oldChildren</code>里面的第四个节点移动到第三个节点的位置，通过上图中的标注我们不难发现，<strong>所有未处理节点之前就是我们要移动的目的位置</strong>。如果此时你说那可不可以移动到所有已处理节点之后呢？那就又回到了更新节点时所遇到的那个问题了：如果前面有新增的节点呢？</p>\n<h2>7. 回到源码</h2>\n<p>OK，以上就是更新子节点时所要考虑的所有情况了，分析完以后，我们回到源码里看看实际情况是不是我们分析的这样子的，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置： /src/core/vdom/patch.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123;    <span class=\"comment\">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 新增节点并插入到合适位置</span></span><br><span class=\"line\">    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span></span><br><span class=\"line\">    vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">    <span class=\"comment\">// 如果两个节点相同</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用patchVnode更新节点</span></span><br><span class=\"line\">        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">        oldCh[idxInOld] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">        <span class=\"comment\">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span></span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码中，首先判断在<code>oldChildren</code>里能否找到当前循环的<code>newChildren</code>里的子节点，如果找不到，那就是新增节点并插入到合适位置；如果找到了，先对比两个节点是否相同，若相同则先调用<code>patchVnode</code>更新节点，更新完之后再看是否需要移动节点，注意，源码里在判断是否需要移动子节点时用了简写的方式，下面这两种写法是等价的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(canMove)&#123;</span><br><span class=\"line\">    nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，源码里的实现跟我们分析的是一样一样的。</p>\n<h2>8. 总结</h2>\n<p>本篇文章我们分析了<code>Vue</code>在更新子节点时是外层循环<code>newChildren</code>数组，内层循环<code>oldChildren</code>数组，把<code>newChildren</code>数组里的每一个元素分别与<code>oldChildren</code>数组里的每一个元素匹配，根据不同情况作出创建子节点、删除子节点、更新子节点以及移动子节点的操作。并且我们对不同情况的不同操作都进行了深入分析，分析之后我们回到源码验证我们分析的正确性，发现我们的分析跟源码的实现是一致的。</p>\n<p>最后，我们再思考一个问题：这样双层循环虽然能解决问题，但是如果节点数量很多，这样循环算法的时间复杂度会不会很高？有没有什么可以优化的办法？答案当然是有的，并且<code>Vue</code>也意识到了这点，也进行了优化，那么下篇文章我们就来分析当节点数量很多时<code>Vue</code>是怎么优化算法的。</p>\n"},{"title":"Vue 源码阅读 虚拟DOM （二）","catalog":true,"date":"2019-10-27T15:52:50.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n在上一篇文章介绍`VNode`的时候我们说了，`VNode`最大的用途就是在数据变化前后生成真实`DOM`对应的虚拟`DOM`节点，然后就可以对比新旧两份`VNode`，找出差异所在，然后更新有差异的`DOM`节点，最终达到以最少操作真实`DOM`更新视图的目的。而对比新旧两份`VNode`并找出差异的过程就是所谓的`DOM-Diff`过程。`DOM-Diff`算法时整个虚拟`DOM`的核心所在，那么接下来，我们就以源码出发，深入研究一下`Vue`中的`DOM-Diff`过程是怎样的。\n\n## 2. patch\n\n在`Vue`中，把 `DOM-Diff`过程叫做`patch`过程。patch,意为“补丁”，即指对旧的`VNode`修补，打补丁从而得到新的`VNode`，非常形象哈。那不管叫什么，其本质都是把对比新旧两份`VNode`的过程。我们在下面研究`patch`过程的时候，一定把握住这样一个思想：所谓旧的`VNode`(即`oldVNode`)就是数据变化之前视图所对应的虚拟`DOM`节点，而新的`VNode`是数据变化之后将要渲染的新的视图所对应的虚拟`DOM`节点，所以我们要以生成的新的`VNode`为基准，对比旧的`oldVNode`，如果新的`VNode`上有的节点而旧的`oldVNode`上没有，那么就在旧的`oldVNode`上加上去；如果新的`VNode`上没有的节点而旧的`oldVNode`上有，那么就在旧的`oldVNode`上去掉；如果某些节点在新的`VNode`和旧的`oldVNode`上都有，那么就以新的`VNode`为准，更新旧的`oldVNode`，从而让新旧`VNode`相同。\n\n可能你感觉有点绕，没关系，我们在说的通俗一点，你可以这样理解：假设你电脑上现在有一份旧的电子版文档，此时老板又给了你一份新的纸质板文档，并告诉你这两份文档内容大部分都是一样的，让你以新的纸质版文档为准，把纸质版文档做一份新的电子版文档发给老板。对于这个任务此时，你应该有两种解决方案：一种方案是不管它旧的文档内容是什么样的，统统删掉，然后对着新的纸质版文档一个字一个字的敲进去，这种方案就是不用费脑，就是受点累也能解决问题。而另外一种方案是以新的纸质版文档为基准，对比看旧的电子版文档跟新的纸质版文档有什么差异，如果某些部分在新的文档里有而旧的文档里没有，那就在旧的文档里面把这些部分加上；如果某些部分在新的文档里没有而旧的文档里有，那就在旧的文档里把这些部分删掉；如果某些部分在新旧文档里都有，那就对比看有没有需要更新的，最后在旧的文档里更新一下，最终达到把旧的文档变成跟手里纸质版文档一样，完美解决。\n\n对比以上两种方案，显然你和`Vue`一样聪明，肯定会选择第二种方案。第二种方案里的旧的电子版文档对应就是已经渲染在视图上的`oldVNode`，新的纸质版文档对应的是将要渲染在视图上的新的`VNode`。总之一句话：**以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事**。\n\n说了这么多，听起来感觉好像很复杂的样子，其实不然，我们仔细想想，整个`patch`无非就是干三件事：\n\n- 创建节点：新的`VNode`中有而旧的`oldVNode`中没有，就在旧的`oldVNode`中创建。\n- 删除节点：新的`VNode`中没有而旧的`oldVNode`中有，就从旧的`oldVNode`中删除。\n- 更新节点：新的`VNode`和旧的`oldVNode`中都有，就以新的`VNode`为准，更新旧的`oldVNode`。\n\nOK，到这里，你就对`Vue`中的`patch`过程理解了一半了，接下来，我们就逐个分析，看`Vue`对于以上三件事都是怎么做的。\n\n## 3. 创建节点\n\n在上篇文章中我们分析了，`VNode`类可以描述6种类型的节点，而实际上只有3种类型的节点能够被创建并插入到`DOM`中，它们分别是：元素节点、文本节点、注释节点。所以`Vue`在创建节点的时候会判断在新的`VNode`中有而旧的`oldVNode`中没有的这个节点是属于哪种类型的节点，从而调用不同的方法创建并插入到`DOM`中。\n\n其实判断起来也不难，因为这三种类型的节点其特点非常明显，在源码中是怎么判断的：\n\n```javascript\n// 源码位置: /src/core/vdom/patch.js\nfunction createElm (vnode, parentElm, refElm) {\n    const data = vnode.data\n    const children = vnode.children\n    const tag = vnode.tag\n    if (isDef(tag)) {\n      \tvnode.elm = nodeOps.createElement(tag, vnode)   // 创建元素节点\n        createChildren(vnode, children, insertedVnodeQueue) // 创建元素节点的子节点\n        insert(parentElm, vnode.elm, refElm)       // 插入到DOM中\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text)  // 创建注释节点\n      insert(parentElm, vnode.elm, refElm)           // 插入到DOM中\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text)  // 创建文本节点\n      insert(parentElm, vnode.elm, refElm)           // 插入到DOM中\n    }\n  }\n\n```\n\n从上面代码中，我们可以看出：\n\n- 判断是否为元素节点只需判断该`VNode`节点是否有`tag`标签即可。如果有`tag`属性即认为是元素节点，则调用`createElement`方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后`insert`插入到当前元素节点里面，最后把当前元素节点插入到`DOM`中。\n- 判断是否为注释节点，只需判断`VNode`的`isComment`属性是否为`true`即可，若为`true`则为注释节点，则调用`createComment`方法创建注释节点，再插入到`DOM`中。\n- 如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用`createTextNode`方法创建文本节点，再插入到`DOM`中。\n\n> 代码中的`nodeOps`是`Vue`为了跨平台兼容性，对所有节点操作进行了封装，例如`nodeOps.createTextNode()`在浏览器端等同于`document.createTextNode()`\n\n以上就完成了创建节点的操作，其完整流程图如下：\n![](/img/virtualDOM/2.png)\n\n\n## 4. 删除节点\n\n如果某些节点再新的`VNode`中没有而在旧的`oldVNode`中有，那么就需要把这些节点从旧的`oldVNode`中删除。删除节点非常简单，只需在要删除节点的父元素上调用`removeChild`方法即可。源码如下：\n\n```javascript\nfunction removeNode (el) {\n    const parent = nodeOps.parentNode(el)  // 获取父节点\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el)  // 调用父节点的removeChild方法\n    }\n  }\n```\n\n## 5. 更新节点\n\n创建节点和删除节点都比较简单，而更新节点就相对较为复杂一点了，其实也不算多复杂，只要理清逻辑就能理解了。\n\n更新节点就是当某些节点在新的`VNode`和旧的`oldVNode`中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。\n\n介绍更新节点之前，我们先介绍一个小的概念，就是什么是静态节点？我们看个例子：\n\n```html\n<p>我是不会变化的文字</p>\n```\n\n上面这个节点里面只包含了纯文字，没有任何可变的变量，这也就是说，不管数据再怎么变化，只要这个节点第一次渲染了，那么它以后就永远不会发生变化，这是因为它不包含任何变量，所以数据发生任何变化都与它无关。我们把这种节点称之为静态节点。\n\nOK，有了这个概念以后，我们开始更新节点。更新节点的时候我们需要对以下3种情况进行判断并分别处理：\n\n1. 如果`VNode`和`oldVNode`均为静态节点\n\n   我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。\n\n2. 如果`VNode`是文本节点\n\n   如果`VNode`是文本节点即表示这个节点内只包含纯文本，那么只需看`oldVNode`是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把`oldVNode`里的文本改成跟`VNode`的文本一样。如果`oldVNode`不是文本节点，那么不论它是什么，直接调用`setTextNode`方法把它改成文本节点，并且文本内容跟`VNode`相同。\n\n3. 如果`VNode`是元素节点\n\n   如果`VNode`是元素节点，则又细分以下两种情况：\n\n   - 该节点包含子节点\n\n     如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。\n\n   - 该节点不包含子节点\n\n     如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。\n\nOK，处理完以上3种情况，更新节点就算基本完成了，接下来我们看下源码中具体是怎么实现的，源码如下：\n\n```javascript\n// 更新节点\nfunction patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n  // vnode与oldVnode是否完全一样？若是，退出程序\n  if (oldVnode === vnode) {\n    return\n  }\n  const elm = vnode.elm = oldVnode.elm\n\n  // vnode与oldVnode是否都是静态节点？若是，退出程序\n  if (isTrue(vnode.isStatic) &&\n    isTrue(oldVnode.isStatic) &&\n    vnode.key === oldVnode.key &&\n    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n  ) {\n    return\n  }\n\n  const oldCh = oldVnode.children\n  const ch = vnode.children\n  // vnode有text属性？若没有：\n  if (isUndef(vnode.text)) {\n    // vnode的子节点与oldVnode的子节点是否都存在？\n    if (isDef(oldCh) && isDef(ch)) {\n      // 若都存在，判断子节点是否相同，不同则更新子节点\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    }\n    // 若只有vnode的子节点存在\n    else if (isDef(ch)) {\n      /**\n       * 判断oldVnode是否有文本？\n       * 若没有，则把vnode的子节点添加到真实DOM中\n       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中\n       */\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } \n    // 若只有oldnode的子节点存在\n    else if (isDef(oldCh)) {\n      // 清空DOM中的子节点\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } \n    // 若vnode和oldnode都没有子节点，但是oldnode中有文本\n    else if (isDef(oldVnode.text)) {\n      // 清空oldnode文本\n      nodeOps.setTextContent(elm, '')\n    }\n    // 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么\n  } \n  // 若有，vnode的text属性与oldVnode的text属性是否相同？\n  else if (oldVnode.text !== vnode.text) {\n    // 若相同：用vnode的text替换真实DOM的文本\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n}\n```\n\n上面代码里注释已经写得很清晰了，接下来我们画流程图来梳理一下整个过程，流程图如下：\n![](/img/virtualDOM/3.png)\n\n\n通过对照着流程图以及代码，相信更新节点这部分逻辑你很容易就能理解了。\n\n另外，你可能注意到了，如果新旧`VNode`里都包含了子节点，那么对于子节点的更新在代码里调用了`updateChildren`方法，而这个方法的逻辑到底是怎样的我们放在下一篇文章中展开学习。\n\n## 6. 总结\n\n在本篇文章中我们介绍了`Vue`中的`DOM-Diff`算法：patch过程。我们先介绍了算法的整个思想流程，然后通过梳理算法思想，了解了整个`patch`过程干了三件事，分别是：创建节点，删除节点，更新节点。并且对每件事情都对照源码展开了细致的学习，画出了其逻辑流程图。另外对于更新节点中，如果新旧`VNode`里都包含了子节点，我们就需要细致的去更新子节点，关于更新子节点的过程我们在下一篇文章中展开学习。\n","source":"_posts/Vue 源码阅读 虚拟DOM （二）.md","raw":"---\ntitle: Vue 源码阅读 虚拟DOM （二） \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-27 23:52:50\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n在上一篇文章介绍`VNode`的时候我们说了，`VNode`最大的用途就是在数据变化前后生成真实`DOM`对应的虚拟`DOM`节点，然后就可以对比新旧两份`VNode`，找出差异所在，然后更新有差异的`DOM`节点，最终达到以最少操作真实`DOM`更新视图的目的。而对比新旧两份`VNode`并找出差异的过程就是所谓的`DOM-Diff`过程。`DOM-Diff`算法时整个虚拟`DOM`的核心所在，那么接下来，我们就以源码出发，深入研究一下`Vue`中的`DOM-Diff`过程是怎样的。\n\n## 2. patch\n\n在`Vue`中，把 `DOM-Diff`过程叫做`patch`过程。patch,意为“补丁”，即指对旧的`VNode`修补，打补丁从而得到新的`VNode`，非常形象哈。那不管叫什么，其本质都是把对比新旧两份`VNode`的过程。我们在下面研究`patch`过程的时候，一定把握住这样一个思想：所谓旧的`VNode`(即`oldVNode`)就是数据变化之前视图所对应的虚拟`DOM`节点，而新的`VNode`是数据变化之后将要渲染的新的视图所对应的虚拟`DOM`节点，所以我们要以生成的新的`VNode`为基准，对比旧的`oldVNode`，如果新的`VNode`上有的节点而旧的`oldVNode`上没有，那么就在旧的`oldVNode`上加上去；如果新的`VNode`上没有的节点而旧的`oldVNode`上有，那么就在旧的`oldVNode`上去掉；如果某些节点在新的`VNode`和旧的`oldVNode`上都有，那么就以新的`VNode`为准，更新旧的`oldVNode`，从而让新旧`VNode`相同。\n\n可能你感觉有点绕，没关系，我们在说的通俗一点，你可以这样理解：假设你电脑上现在有一份旧的电子版文档，此时老板又给了你一份新的纸质板文档，并告诉你这两份文档内容大部分都是一样的，让你以新的纸质版文档为准，把纸质版文档做一份新的电子版文档发给老板。对于这个任务此时，你应该有两种解决方案：一种方案是不管它旧的文档内容是什么样的，统统删掉，然后对着新的纸质版文档一个字一个字的敲进去，这种方案就是不用费脑，就是受点累也能解决问题。而另外一种方案是以新的纸质版文档为基准，对比看旧的电子版文档跟新的纸质版文档有什么差异，如果某些部分在新的文档里有而旧的文档里没有，那就在旧的文档里面把这些部分加上；如果某些部分在新的文档里没有而旧的文档里有，那就在旧的文档里把这些部分删掉；如果某些部分在新旧文档里都有，那就对比看有没有需要更新的，最后在旧的文档里更新一下，最终达到把旧的文档变成跟手里纸质版文档一样，完美解决。\n\n对比以上两种方案，显然你和`Vue`一样聪明，肯定会选择第二种方案。第二种方案里的旧的电子版文档对应就是已经渲染在视图上的`oldVNode`，新的纸质版文档对应的是将要渲染在视图上的新的`VNode`。总之一句话：**以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事**。\n\n说了这么多，听起来感觉好像很复杂的样子，其实不然，我们仔细想想，整个`patch`无非就是干三件事：\n\n- 创建节点：新的`VNode`中有而旧的`oldVNode`中没有，就在旧的`oldVNode`中创建。\n- 删除节点：新的`VNode`中没有而旧的`oldVNode`中有，就从旧的`oldVNode`中删除。\n- 更新节点：新的`VNode`和旧的`oldVNode`中都有，就以新的`VNode`为准，更新旧的`oldVNode`。\n\nOK，到这里，你就对`Vue`中的`patch`过程理解了一半了，接下来，我们就逐个分析，看`Vue`对于以上三件事都是怎么做的。\n\n## 3. 创建节点\n\n在上篇文章中我们分析了，`VNode`类可以描述6种类型的节点，而实际上只有3种类型的节点能够被创建并插入到`DOM`中，它们分别是：元素节点、文本节点、注释节点。所以`Vue`在创建节点的时候会判断在新的`VNode`中有而旧的`oldVNode`中没有的这个节点是属于哪种类型的节点，从而调用不同的方法创建并插入到`DOM`中。\n\n其实判断起来也不难，因为这三种类型的节点其特点非常明显，在源码中是怎么判断的：\n\n```javascript\n// 源码位置: /src/core/vdom/patch.js\nfunction createElm (vnode, parentElm, refElm) {\n    const data = vnode.data\n    const children = vnode.children\n    const tag = vnode.tag\n    if (isDef(tag)) {\n      \tvnode.elm = nodeOps.createElement(tag, vnode)   // 创建元素节点\n        createChildren(vnode, children, insertedVnodeQueue) // 创建元素节点的子节点\n        insert(parentElm, vnode.elm, refElm)       // 插入到DOM中\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text)  // 创建注释节点\n      insert(parentElm, vnode.elm, refElm)           // 插入到DOM中\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text)  // 创建文本节点\n      insert(parentElm, vnode.elm, refElm)           // 插入到DOM中\n    }\n  }\n\n```\n\n从上面代码中，我们可以看出：\n\n- 判断是否为元素节点只需判断该`VNode`节点是否有`tag`标签即可。如果有`tag`属性即认为是元素节点，则调用`createElement`方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后`insert`插入到当前元素节点里面，最后把当前元素节点插入到`DOM`中。\n- 判断是否为注释节点，只需判断`VNode`的`isComment`属性是否为`true`即可，若为`true`则为注释节点，则调用`createComment`方法创建注释节点，再插入到`DOM`中。\n- 如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用`createTextNode`方法创建文本节点，再插入到`DOM`中。\n\n> 代码中的`nodeOps`是`Vue`为了跨平台兼容性，对所有节点操作进行了封装，例如`nodeOps.createTextNode()`在浏览器端等同于`document.createTextNode()`\n\n以上就完成了创建节点的操作，其完整流程图如下：\n![](/img/virtualDOM/2.png)\n\n\n## 4. 删除节点\n\n如果某些节点再新的`VNode`中没有而在旧的`oldVNode`中有，那么就需要把这些节点从旧的`oldVNode`中删除。删除节点非常简单，只需在要删除节点的父元素上调用`removeChild`方法即可。源码如下：\n\n```javascript\nfunction removeNode (el) {\n    const parent = nodeOps.parentNode(el)  // 获取父节点\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el)  // 调用父节点的removeChild方法\n    }\n  }\n```\n\n## 5. 更新节点\n\n创建节点和删除节点都比较简单，而更新节点就相对较为复杂一点了，其实也不算多复杂，只要理清逻辑就能理解了。\n\n更新节点就是当某些节点在新的`VNode`和旧的`oldVNode`中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。\n\n介绍更新节点之前，我们先介绍一个小的概念，就是什么是静态节点？我们看个例子：\n\n```html\n<p>我是不会变化的文字</p>\n```\n\n上面这个节点里面只包含了纯文字，没有任何可变的变量，这也就是说，不管数据再怎么变化，只要这个节点第一次渲染了，那么它以后就永远不会发生变化，这是因为它不包含任何变量，所以数据发生任何变化都与它无关。我们把这种节点称之为静态节点。\n\nOK，有了这个概念以后，我们开始更新节点。更新节点的时候我们需要对以下3种情况进行判断并分别处理：\n\n1. 如果`VNode`和`oldVNode`均为静态节点\n\n   我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。\n\n2. 如果`VNode`是文本节点\n\n   如果`VNode`是文本节点即表示这个节点内只包含纯文本，那么只需看`oldVNode`是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把`oldVNode`里的文本改成跟`VNode`的文本一样。如果`oldVNode`不是文本节点，那么不论它是什么，直接调用`setTextNode`方法把它改成文本节点，并且文本内容跟`VNode`相同。\n\n3. 如果`VNode`是元素节点\n\n   如果`VNode`是元素节点，则又细分以下两种情况：\n\n   - 该节点包含子节点\n\n     如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。\n\n   - 该节点不包含子节点\n\n     如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。\n\nOK，处理完以上3种情况，更新节点就算基本完成了，接下来我们看下源码中具体是怎么实现的，源码如下：\n\n```javascript\n// 更新节点\nfunction patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n  // vnode与oldVnode是否完全一样？若是，退出程序\n  if (oldVnode === vnode) {\n    return\n  }\n  const elm = vnode.elm = oldVnode.elm\n\n  // vnode与oldVnode是否都是静态节点？若是，退出程序\n  if (isTrue(vnode.isStatic) &&\n    isTrue(oldVnode.isStatic) &&\n    vnode.key === oldVnode.key &&\n    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n  ) {\n    return\n  }\n\n  const oldCh = oldVnode.children\n  const ch = vnode.children\n  // vnode有text属性？若没有：\n  if (isUndef(vnode.text)) {\n    // vnode的子节点与oldVnode的子节点是否都存在？\n    if (isDef(oldCh) && isDef(ch)) {\n      // 若都存在，判断子节点是否相同，不同则更新子节点\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    }\n    // 若只有vnode的子节点存在\n    else if (isDef(ch)) {\n      /**\n       * 判断oldVnode是否有文本？\n       * 若没有，则把vnode的子节点添加到真实DOM中\n       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中\n       */\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } \n    // 若只有oldnode的子节点存在\n    else if (isDef(oldCh)) {\n      // 清空DOM中的子节点\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } \n    // 若vnode和oldnode都没有子节点，但是oldnode中有文本\n    else if (isDef(oldVnode.text)) {\n      // 清空oldnode文本\n      nodeOps.setTextContent(elm, '')\n    }\n    // 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么\n  } \n  // 若有，vnode的text属性与oldVnode的text属性是否相同？\n  else if (oldVnode.text !== vnode.text) {\n    // 若相同：用vnode的text替换真实DOM的文本\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n}\n```\n\n上面代码里注释已经写得很清晰了，接下来我们画流程图来梳理一下整个过程，流程图如下：\n![](/img/virtualDOM/3.png)\n\n\n通过对照着流程图以及代码，相信更新节点这部分逻辑你很容易就能理解了。\n\n另外，你可能注意到了，如果新旧`VNode`里都包含了子节点，那么对于子节点的更新在代码里调用了`updateChildren`方法，而这个方法的逻辑到底是怎样的我们放在下一篇文章中展开学习。\n\n## 6. 总结\n\n在本篇文章中我们介绍了`Vue`中的`DOM-Diff`算法：patch过程。我们先介绍了算法的整个思想流程，然后通过梳理算法思想，了解了整个`patch`过程干了三件事，分别是：创建节点，删除节点，更新节点。并且对每件事情都对照源码展开了细致的学习，画出了其逻辑流程图。另外对于更新节点中，如果新旧`VNode`里都包含了子节点，我们就需要细致的去更新子节点，关于更新子节点的过程我们在下一篇文章中展开学习。\n","slug":"Vue 源码阅读 虚拟DOM （二）","published":1,"updated":"2019-12-31T03:27:34.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj860072zws6rsjh6jri","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在上一篇文章介绍<code>VNode</code>的时候我们说了，<code>VNode</code>最大的用途就是在数据变化前后生成真实<code>DOM</code>对应的虚拟<code>DOM</code>节点，然后就可以对比新旧两份<code>VNode</code>，找出差异所在，然后更新有差异的<code>DOM</code>节点，最终达到以最少操作真实<code>DOM</code>更新视图的目的。而对比新旧两份<code>VNode</code>并找出差异的过程就是所谓的<code>DOM-Diff</code>过程。<code>DOM-Diff</code>算法时整个虚拟<code>DOM</code>的核心所在，那么接下来，我们就以源码出发，深入研究一下<code>Vue</code>中的<code>DOM-Diff</code>过程是怎样的。</p>\n<h2><span id=\"2-patch\">2. patch</span></h2>\n<p>在<code>Vue</code>中，把 <code>DOM-Diff</code>过程叫做<code>patch</code>过程。patch,意为“补丁”，即指对旧的<code>VNode</code>修补，打补丁从而得到新的<code>VNode</code>，非常形象哈。那不管叫什么，其本质都是把对比新旧两份<code>VNode</code>的过程。我们在下面研究<code>patch</code>过程的时候，一定把握住这样一个思想：所谓旧的<code>VNode</code>(即<code>oldVNode</code>)就是数据变化之前视图所对应的虚拟<code>DOM</code>节点，而新的<code>VNode</code>是数据变化之后将要渲染的新的视图所对应的虚拟<code>DOM</code>节点，所以我们要以生成的新的<code>VNode</code>为基准，对比旧的<code>oldVNode</code>，如果新的<code>VNode</code>上有的节点而旧的<code>oldVNode</code>上没有，那么就在旧的<code>oldVNode</code>上加上去；如果新的<code>VNode</code>上没有的节点而旧的<code>oldVNode</code>上有，那么就在旧的<code>oldVNode</code>上去掉；如果某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>上都有，那么就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>，从而让新旧<code>VNode</code>相同。</p>\n<p>可能你感觉有点绕，没关系，我们在说的通俗一点，你可以这样理解：假设你电脑上现在有一份旧的电子版文档，此时老板又给了你一份新的纸质板文档，并告诉你这两份文档内容大部分都是一样的，让你以新的纸质版文档为准，把纸质版文档做一份新的电子版文档发给老板。对于这个任务此时，你应该有两种解决方案：一种方案是不管它旧的文档内容是什么样的，统统删掉，然后对着新的纸质版文档一个字一个字的敲进去，这种方案就是不用费脑，就是受点累也能解决问题。而另外一种方案是以新的纸质版文档为基准，对比看旧的电子版文档跟新的纸质版文档有什么差异，如果某些部分在新的文档里有而旧的文档里没有，那就在旧的文档里面把这些部分加上；如果某些部分在新的文档里没有而旧的文档里有，那就在旧的文档里把这些部分删掉；如果某些部分在新旧文档里都有，那就对比看有没有需要更新的，最后在旧的文档里更新一下，最终达到把旧的文档变成跟手里纸质版文档一样，完美解决。</p>\n<p>对比以上两种方案，显然你和<code>Vue</code>一样聪明，肯定会选择第二种方案。第二种方案里的旧的电子版文档对应就是已经渲染在视图上的<code>oldVNode</code>，新的纸质版文档对应的是将要渲染在视图上的新的<code>VNode</code>。总之一句话：<strong>以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事</strong>。</p>\n<p>说了这么多，听起来感觉好像很复杂的样子，其实不然，我们仔细想想，整个<code>patch</code>无非就是干三件事：</p>\n<ul>\n<li>创建节点：新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有，就在旧的<code>oldVNode</code>中创建。</li>\n<li>删除节点：新的<code>VNode</code>中没有而旧的<code>oldVNode</code>中有，就从旧的<code>oldVNode</code>中删除。</li>\n<li>更新节点：新的<code>VNode</code>和旧的<code>oldVNode</code>中都有，就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>。</li>\n</ul>\n<p>OK，到这里，你就对<code>Vue</code>中的<code>patch</code>过程理解了一半了，接下来，我们就逐个分析，看<code>Vue</code>对于以上三件事都是怎么做的。</p>\n<h2><span id=\"3-创建节点\">3. 创建节点</span></h2>\n<p>在上篇文章中我们分析了，<code>VNode</code>类可以描述6种类型的节点，而实际上只有3种类型的节点能够被创建并插入到<code>DOM</code>中，它们分别是：元素节点、文本节点、注释节点。所以<code>Vue</code>在创建节点的时候会判断在新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有的这个节点是属于哪种类型的节点，从而调用不同的方法创建并插入到<code>DOM</code>中。</p>\n<p>其实判断起来也不难，因为这三种类型的节点其特点非常明显，在源码中是怎么判断的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置: /src/core/vdom/patch.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElm</span> (<span class=\"params\">vnode, parentElm, refElm</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = vnode.data</span><br><span class=\"line\">    <span class=\"keyword\">const</span> children = vnode.children</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tag = vnode.tag</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(tag)) &#123;</span><br><span class=\"line\">      \tvnode.elm = nodeOps.createElement(tag, vnode)   <span class=\"comment\">// 创建元素节点</span></span><br><span class=\"line\">        createChildren(vnode, children, insertedVnodeQueue) <span class=\"comment\">// 创建元素节点的子节点</span></span><br><span class=\"line\">        insert(parentElm, vnode.elm, refElm)       <span class=\"comment\">// 插入到DOM中</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class=\"line\">      vnode.elm = nodeOps.createComment(vnode.text)  <span class=\"comment\">// 创建注释节点</span></span><br><span class=\"line\">      insert(parentElm, vnode.elm, refElm)           <span class=\"comment\">// 插入到DOM中</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vnode.elm = nodeOps.createTextNode(vnode.text)  <span class=\"comment\">// 创建文本节点</span></span><br><span class=\"line\">      insert(parentElm, vnode.elm, refElm)           <span class=\"comment\">// 插入到DOM中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中，我们可以看出：</p>\n<ul>\n<li>判断是否为元素节点只需判断该<code>VNode</code>节点是否有<code>tag</code>标签即可。如果有<code>tag</code>属性即认为是元素节点，则调用<code>createElement</code>方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后<code>insert</code>插入到当前元素节点里面，最后把当前元素节点插入到<code>DOM</code>中。</li>\n<li>判断是否为注释节点，只需判断<code>VNode</code>的<code>isComment</code>属性是否为<code>true</code>即可，若为<code>true</code>则为注释节点，则调用<code>createComment</code>方法创建注释节点，再插入到<code>DOM</code>中。</li>\n<li>如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用<code>createTextNode</code>方法创建文本节点，再插入到<code>DOM</code>中。</li>\n</ul>\n<blockquote>\n<p>代码中的<code>nodeOps</code>是<code>Vue</code>为了跨平台兼容性，对所有节点操作进行了封装，例如<code>nodeOps.createTextNode()</code>在浏览器端等同于<code>document.createTextNode()</code></p>\n</blockquote>\n<p>以上就完成了创建节点的操作，其完整流程图如下：<br>\n<img src=\"/img/virtualDOM/2.png\" alt></p>\n<h2><span id=\"4-删除节点\">4. 删除节点</span></h2>\n<p>如果某些节点再新的<code>VNode</code>中没有而在旧的<code>oldVNode</code>中有，那么就需要把这些节点从旧的<code>oldVNode</code>中删除。删除节点非常简单，只需在要删除节点的父元素上调用<code>removeChild</code>方法即可。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeNode</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parent = nodeOps.parentNode(el)  <span class=\"comment\">// 获取父节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(parent)) &#123;</span><br><span class=\"line\">      nodeOps.removeChild(parent, el)  <span class=\"comment\">// 调用父节点的removeChild方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"5-更新节点\">5. 更新节点</span></h2>\n<p>创建节点和删除节点都比较简单，而更新节点就相对较为复杂一点了，其实也不算多复杂，只要理清逻辑就能理解了。</p>\n<p>更新节点就是当某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。</p>\n<p>介绍更新节点之前，我们先介绍一个小的概念，就是什么是静态节点？我们看个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是不会变化的文字<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面这个节点里面只包含了纯文字，没有任何可变的变量，这也就是说，不管数据再怎么变化，只要这个节点第一次渲染了，那么它以后就永远不会发生变化，这是因为它不包含任何变量，所以数据发生任何变化都与它无关。我们把这种节点称之为静态节点。</p>\n<p>OK，有了这个概念以后，我们开始更新节点。更新节点的时候我们需要对以下3种情况进行判断并分别处理：</p>\n<ol>\n<li>\n<p>如果<code>VNode</code>和<code>oldVNode</code>均为静态节点</p>\n<p>我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。</p>\n</li>\n<li>\n<p>如果<code>VNode</code>是文本节点</p>\n<p>如果<code>VNode</code>是文本节点即表示这个节点内只包含纯文本，那么只需看<code>oldVNode</code>是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把<code>oldVNode</code>里的文本改成跟<code>VNode</code>的文本一样。如果<code>oldVNode</code>不是文本节点，那么不论它是什么，直接调用<code>setTextNode</code>方法把它改成文本节点，并且文本内容跟<code>VNode</code>相同。</p>\n</li>\n<li>\n<p>如果<code>VNode</code>是元素节点</p>\n<p>如果<code>VNode</code>是元素节点，则又细分以下两种情况：</p>\n<ul>\n<li>\n<p>该节点包含子节点</p>\n<p>如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</p>\n</li>\n<li>\n<p>该节点不包含子节点</p>\n<p>如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>OK，处理完以上3种情况，更新节点就算基本完成了，接下来我们看下源码中具体是怎么实现的，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patchVnode</span> (<span class=\"params\">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// vnode与oldVnode是否完全一样？若是，退出程序</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldVnode === vnode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// vnode与oldVnode是否都是静态节点？若是，退出程序</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class=\"line\">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class=\"line\">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class=\"line\">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldCh = oldVnode.children</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ch = vnode.children</span><br><span class=\"line\">  <span class=\"comment\">// vnode有text属性？若没有：</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isUndef(vnode.text)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// vnode的子节点与oldVnode的子节点是否都存在？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若都存在，判断子节点是否相同，不同则更新子节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若只有vnode的子节点存在</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isDef(ch)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 判断oldVnode是否有文本？</span></span><br><span class=\"line\"><span class=\"comment\">       * 若没有，则把vnode的子节点添加到真实DOM中</span></span><br><span class=\"line\"><span class=\"comment\">       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class=\"string\">''</span>)</span><br><span class=\"line\">      addVnodes(elm, <span class=\"literal\">null</span>, ch, <span class=\"number\">0</span>, ch.length - <span class=\"number\">1</span>, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 若只有oldnode的子节点存在</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isDef(oldCh)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 清空DOM中的子节点</span></span><br><span class=\"line\">      removeVnodes(elm, oldCh, <span class=\"number\">0</span>, oldCh.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 若vnode和oldnode都没有子节点，但是oldnode中有文本</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 清空oldnode文本</span></span><br><span class=\"line\">      nodeOps.setTextContent(elm, <span class=\"string\">''</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"comment\">// 若有，vnode的text属性与oldVnode的text属性是否相同？</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若相同：用vnode的text替换真实DOM的文本</span></span><br><span class=\"line\">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码里注释已经写得很清晰了，接下来我们画流程图来梳理一下整个过程，流程图如下：<br>\n<img src=\"/img/virtualDOM/3.png\" alt></p>\n<p>通过对照着流程图以及代码，相信更新节点这部分逻辑你很容易就能理解了。</p>\n<p>另外，你可能注意到了，如果新旧<code>VNode</code>里都包含了子节点，那么对于子节点的更新在代码里调用了<code>updateChildren</code>方法，而这个方法的逻辑到底是怎样的我们放在下一篇文章中展开学习。</p>\n<h2><span id=\"6-总结\">6. 总结</span></h2>\n<p>在本篇文章中我们介绍了<code>Vue</code>中的<code>DOM-Diff</code>算法：patch过程。我们先介绍了算法的整个思想流程，然后通过梳理算法思想，了解了整个<code>patch</code>过程干了三件事，分别是：创建节点，删除节点，更新节点。并且对每件事情都对照源码展开了细致的学习，画出了其逻辑流程图。另外对于更新节点中，如果新旧<code>VNode</code>里都包含了子节点，我们就需要细致的去更新子节点，关于更新子节点的过程我们在下一篇文章中展开学习。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在上一篇文章介绍<code>VNode</code>的时候我们说了，<code>VNode</code>最大的用途就是在数据变化前后生成真实<code>DOM</code>对应的虚拟<code>DOM</code>节点，然后就可以对比新旧两份<code>VNode</code>，找出差异所在，然后更新有差异的<code>DOM</code>节点，最终达到以最少操作真实<code>DOM</code>更新视图的目的。而对比新旧两份<code>VNode</code>并找出差异的过程就是所谓的<code>DOM-Diff</code>过程。<code>DOM-Diff</code>算法时整个虚拟<code>DOM</code>的核心所在，那么接下来，我们就以源码出发，深入研究一下<code>Vue</code>中的<code>DOM-Diff</code>过程是怎样的。</p>\n<h2>2. patch</h2>\n<p>在<code>Vue</code>中，把 <code>DOM-Diff</code>过程叫做<code>patch</code>过程。patch,意为“补丁”，即指对旧的<code>VNode</code>修补，打补丁从而得到新的<code>VNode</code>，非常形象哈。那不管叫什么，其本质都是把对比新旧两份<code>VNode</code>的过程。我们在下面研究<code>patch</code>过程的时候，一定把握住这样一个思想：所谓旧的<code>VNode</code>(即<code>oldVNode</code>)就是数据变化之前视图所对应的虚拟<code>DOM</code>节点，而新的<code>VNode</code>是数据变化之后将要渲染的新的视图所对应的虚拟<code>DOM</code>节点，所以我们要以生成的新的<code>VNode</code>为基准，对比旧的<code>oldVNode</code>，如果新的<code>VNode</code>上有的节点而旧的<code>oldVNode</code>上没有，那么就在旧的<code>oldVNode</code>上加上去；如果新的<code>VNode</code>上没有的节点而旧的<code>oldVNode</code>上有，那么就在旧的<code>oldVNode</code>上去掉；如果某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>上都有，那么就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>，从而让新旧<code>VNode</code>相同。</p>\n<p>可能你感觉有点绕，没关系，我们在说的通俗一点，你可以这样理解：假设你电脑上现在有一份旧的电子版文档，此时老板又给了你一份新的纸质板文档，并告诉你这两份文档内容大部分都是一样的，让你以新的纸质版文档为准，把纸质版文档做一份新的电子版文档发给老板。对于这个任务此时，你应该有两种解决方案：一种方案是不管它旧的文档内容是什么样的，统统删掉，然后对着新的纸质版文档一个字一个字的敲进去，这种方案就是不用费脑，就是受点累也能解决问题。而另外一种方案是以新的纸质版文档为基准，对比看旧的电子版文档跟新的纸质版文档有什么差异，如果某些部分在新的文档里有而旧的文档里没有，那就在旧的文档里面把这些部分加上；如果某些部分在新的文档里没有而旧的文档里有，那就在旧的文档里把这些部分删掉；如果某些部分在新旧文档里都有，那就对比看有没有需要更新的，最后在旧的文档里更新一下，最终达到把旧的文档变成跟手里纸质版文档一样，完美解决。</p>\n<p>对比以上两种方案，显然你和<code>Vue</code>一样聪明，肯定会选择第二种方案。第二种方案里的旧的电子版文档对应就是已经渲染在视图上的<code>oldVNode</code>，新的纸质版文档对应的是将要渲染在视图上的新的<code>VNode</code>。总之一句话：<strong>以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事</strong>。</p>\n<p>说了这么多，听起来感觉好像很复杂的样子，其实不然，我们仔细想想，整个<code>patch</code>无非就是干三件事：</p>\n<ul>\n<li>创建节点：新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有，就在旧的<code>oldVNode</code>中创建。</li>\n<li>删除节点：新的<code>VNode</code>中没有而旧的<code>oldVNode</code>中有，就从旧的<code>oldVNode</code>中删除。</li>\n<li>更新节点：新的<code>VNode</code>和旧的<code>oldVNode</code>中都有，就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>。</li>\n</ul>\n<p>OK，到这里，你就对<code>Vue</code>中的<code>patch</code>过程理解了一半了，接下来，我们就逐个分析，看<code>Vue</code>对于以上三件事都是怎么做的。</p>\n<h2>3. 创建节点</h2>\n<p>在上篇文章中我们分析了，<code>VNode</code>类可以描述6种类型的节点，而实际上只有3种类型的节点能够被创建并插入到<code>DOM</code>中，它们分别是：元素节点、文本节点、注释节点。所以<code>Vue</code>在创建节点的时候会判断在新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有的这个节点是属于哪种类型的节点，从而调用不同的方法创建并插入到<code>DOM</code>中。</p>\n<p>其实判断起来也不难，因为这三种类型的节点其特点非常明显，在源码中是怎么判断的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置: /src/core/vdom/patch.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElm</span> (<span class=\"params\">vnode, parentElm, refElm</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = vnode.data</span><br><span class=\"line\">    <span class=\"keyword\">const</span> children = vnode.children</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tag = vnode.tag</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(tag)) &#123;</span><br><span class=\"line\">      \tvnode.elm = nodeOps.createElement(tag, vnode)   <span class=\"comment\">// 创建元素节点</span></span><br><span class=\"line\">        createChildren(vnode, children, insertedVnodeQueue) <span class=\"comment\">// 创建元素节点的子节点</span></span><br><span class=\"line\">        insert(parentElm, vnode.elm, refElm)       <span class=\"comment\">// 插入到DOM中</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class=\"line\">      vnode.elm = nodeOps.createComment(vnode.text)  <span class=\"comment\">// 创建注释节点</span></span><br><span class=\"line\">      insert(parentElm, vnode.elm, refElm)           <span class=\"comment\">// 插入到DOM中</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      vnode.elm = nodeOps.createTextNode(vnode.text)  <span class=\"comment\">// 创建文本节点</span></span><br><span class=\"line\">      insert(parentElm, vnode.elm, refElm)           <span class=\"comment\">// 插入到DOM中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中，我们可以看出：</p>\n<ul>\n<li>判断是否为元素节点只需判断该<code>VNode</code>节点是否有<code>tag</code>标签即可。如果有<code>tag</code>属性即认为是元素节点，则调用<code>createElement</code>方法创建元素节点，通常元素节点还会有子节点，那就递归遍历创建所有子节点，将所有子节点创建好之后<code>insert</code>插入到当前元素节点里面，最后把当前元素节点插入到<code>DOM</code>中。</li>\n<li>判断是否为注释节点，只需判断<code>VNode</code>的<code>isComment</code>属性是否为<code>true</code>即可，若为<code>true</code>则为注释节点，则调用<code>createComment</code>方法创建注释节点，再插入到<code>DOM</code>中。</li>\n<li>如果既不是元素节点，也不是注释节点，那就认为是文本节点，则调用<code>createTextNode</code>方法创建文本节点，再插入到<code>DOM</code>中。</li>\n</ul>\n<blockquote>\n<p>代码中的<code>nodeOps</code>是<code>Vue</code>为了跨平台兼容性，对所有节点操作进行了封装，例如<code>nodeOps.createTextNode()</code>在浏览器端等同于<code>document.createTextNode()</code></p>\n</blockquote>\n<p>以上就完成了创建节点的操作，其完整流程图如下：<br>\n<img src=\"/img/virtualDOM/2.png\" alt></p>\n<h2>4. 删除节点</h2>\n<p>如果某些节点再新的<code>VNode</code>中没有而在旧的<code>oldVNode</code>中有，那么就需要把这些节点从旧的<code>oldVNode</code>中删除。删除节点非常简单，只需在要删除节点的父元素上调用<code>removeChild</code>方法即可。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeNode</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> parent = nodeOps.parentNode(el)  <span class=\"comment\">// 获取父节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(parent)) &#123;</span><br><span class=\"line\">      nodeOps.removeChild(parent, el)  <span class=\"comment\">// 调用父节点的removeChild方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2>5. 更新节点</h2>\n<p>创建节点和删除节点都比较简单，而更新节点就相对较为复杂一点了，其实也不算多复杂，只要理清逻辑就能理解了。</p>\n<p>更新节点就是当某些节点在新的<code>VNode</code>和旧的<code>oldVNode</code>中都有时，我们就需要细致比较一下，找出不一样的地方进行更新。</p>\n<p>介绍更新节点之前，我们先介绍一个小的概念，就是什么是静态节点？我们看个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是不会变化的文字<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面这个节点里面只包含了纯文字，没有任何可变的变量，这也就是说，不管数据再怎么变化，只要这个节点第一次渲染了，那么它以后就永远不会发生变化，这是因为它不包含任何变量，所以数据发生任何变化都与它无关。我们把这种节点称之为静态节点。</p>\n<p>OK，有了这个概念以后，我们开始更新节点。更新节点的时候我们需要对以下3种情况进行判断并分别处理：</p>\n<ol>\n<li>\n<p>如果<code>VNode</code>和<code>oldVNode</code>均为静态节点</p>\n<p>我们说了，静态节点无论数据发生任何变化都与它无关，所以都为静态节点的话则直接跳过，无需处理。</p>\n</li>\n<li>\n<p>如果<code>VNode</code>是文本节点</p>\n<p>如果<code>VNode</code>是文本节点即表示这个节点内只包含纯文本，那么只需看<code>oldVNode</code>是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把<code>oldVNode</code>里的文本改成跟<code>VNode</code>的文本一样。如果<code>oldVNode</code>不是文本节点，那么不论它是什么，直接调用<code>setTextNode</code>方法把它改成文本节点，并且文本内容跟<code>VNode</code>相同。</p>\n</li>\n<li>\n<p>如果<code>VNode</code>是元素节点</p>\n<p>如果<code>VNode</code>是元素节点，则又细分以下两种情况：</p>\n<ul>\n<li>\n<p>该节点包含子节点</p>\n<p>如果新的节点内包含了子节点，那么此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</p>\n</li>\n<li>\n<p>该节点不包含子节点</p>\n<p>如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>OK，处理完以上3种情况，更新节点就算基本完成了，接下来我们看下源码中具体是怎么实现的，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patchVnode</span> (<span class=\"params\">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// vnode与oldVnode是否完全一样？若是，退出程序</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldVnode === vnode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// vnode与oldVnode是否都是静态节点？若是，退出程序</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class=\"line\">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class=\"line\">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class=\"line\">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldCh = oldVnode.children</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ch = vnode.children</span><br><span class=\"line\">  <span class=\"comment\">// vnode有text属性？若没有：</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isUndef(vnode.text)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// vnode的子节点与oldVnode的子节点是否都存在？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 若都存在，判断子节点是否相同，不同则更新子节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若只有vnode的子节点存在</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isDef(ch)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 判断oldVnode是否有文本？</span></span><br><span class=\"line\"><span class=\"comment\">       * 若没有，则把vnode的子节点添加到真实DOM中</span></span><br><span class=\"line\"><span class=\"comment\">       * 若有，则清空Dom中的文本，再把vnode的子节点添加到真实DOM中</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class=\"string\">''</span>)</span><br><span class=\"line\">      addVnodes(elm, <span class=\"literal\">null</span>, ch, <span class=\"number\">0</span>, ch.length - <span class=\"number\">1</span>, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 若只有oldnode的子节点存在</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isDef(oldCh)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 清空DOM中的子节点</span></span><br><span class=\"line\">      removeVnodes(elm, oldCh, <span class=\"number\">0</span>, oldCh.length - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 若vnode和oldnode都没有子节点，但是oldnode中有文本</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 清空oldnode文本</span></span><br><span class=\"line\">      nodeOps.setTextContent(elm, <span class=\"string\">''</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 上面两个判断一句话概括就是，如果vnode中既没有text，也没有子节点，那么对应的oldnode中有什么就清空什么</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"comment\">// 若有，vnode的text属性与oldVnode的text属性是否相同？</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若相同：用vnode的text替换真实DOM的文本</span></span><br><span class=\"line\">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码里注释已经写得很清晰了，接下来我们画流程图来梳理一下整个过程，流程图如下：<br>\n<img src=\"/img/virtualDOM/3.png\" alt></p>\n<p>通过对照着流程图以及代码，相信更新节点这部分逻辑你很容易就能理解了。</p>\n<p>另外，你可能注意到了，如果新旧<code>VNode</code>里都包含了子节点，那么对于子节点的更新在代码里调用了<code>updateChildren</code>方法，而这个方法的逻辑到底是怎样的我们放在下一篇文章中展开学习。</p>\n<h2>6. 总结</h2>\n<p>在本篇文章中我们介绍了<code>Vue</code>中的<code>DOM-Diff</code>算法：patch过程。我们先介绍了算法的整个思想流程，然后通过梳理算法思想，了解了整个<code>patch</code>过程干了三件事，分别是：创建节点，删除节点，更新节点。并且对每件事情都对照源码展开了细致的学习，画出了其逻辑流程图。另外对于更新节点中，如果新旧<code>VNode</code>里都包含了子节点，我们就需要细致的去更新子节点，关于更新子节点的过程我们在下一篇文章中展开学习。</p>\n"},{"title":"Vue 源码阅读 虚拟DOM （一）","catalog":true,"date":"2019-10-26T19:22:10.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n虚拟DOM，这个名词作为当下的前端开发人员你一定不会陌生，至少会略有耳闻，但不会闻所未闻吧。这也是现在求职面试考察中非常高频的一个考点了。因为在当下的前端三大框架中关于虚拟DOM或多或少都有所涉及，那么接下来，我们就从源码角度出发，看看`Vue`中的虚拟DOM时怎样的。\n\n## 2. 虚拟DOM简介\n\n由于本系列文章是针对`Vue`源码深入学习的，所以着重分析在`Vue`中对虚拟DOM是如何实现的，而对于虚拟DOM本身这个概念不做大篇幅的展开讨论，仅从以下几个问题简单介绍：\n\n1. 什么是虚拟DOM？\n\n   所谓虚拟DOM，就是用一个`JS`对象来描述一个`DOM`节点，像如下示例：\n\n   ```javascript\n   <div class=\"a\" id=\"b\">我是内容</div>\n   \n   {\n     tag:'div',        // 元素标签\n     attrs:{           // 属性\n       class:'a',\n       id:'b'\n     },\n     text:'我是内容',  // 文本内容\n     children:[]       // 子元素\n   }\n   ```\n\n   我们把组成一个`DOM`节点的必要东西通过一个`JS`对象表示出来，那么这个`JS`对象就可以用来描述这个`DOM`节点，我们把这个`JS`对象就称为是这个真实`DOM`节点的虚拟`DOM`节点。\n\n2. 为什么要有虚拟DOM？\n\n    我们知道，`Vue`是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作`DOM`,而操作真实`DOM`又是非常耗费性能的，这是因为浏览器的标准就把 `DOM` 设计的非常复杂，所以一个真正的 `DOM` 元素是非常庞大的，如下所示：\n\n   ```javascript\n   let div = document.createElement('div')\n   let str = ''\n   for (const key in div) {\n     str += key + ''\n   }\n   console.log(str)\n   ```\n![](/img/virtualDOM/1.png)\n\n\n   上图中我们打印一个简单的空`div`标签，就打印出这么多东西，更不用说复杂的、深嵌套的`DOM`节点了。由此可见，直接操作真实`DOM`是非常消耗性能的。\n\n   那么有没有什么解决方案呢？当然是有的。我们可以用`JS`的计算性能来换取操作`DOM`所消耗的性能。\n\n   既然我们逃不掉操作`DOM`这道坎,但是我们可以尽可能少的操作`DOM`。那如何在更新视图的时候尽可能少的操作`DOM`呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作`DOM`了。这也就是上面所说的用`JS`的计算性能来换取操作`DOM`的性能。\n\n   我们可以用`JS`模拟出一个`DOM`节点，称之为虚拟`DOM`节点。当数据发生变化时，我们对比变化前后的虚拟`DOM`节点，通过`DOM-Diff`算法计算出需要更新的地方，然后去更新需要更新的视图。\n\n   这就是虚拟`DOM`产生的原因以及最大的用途。\n\n## 3. Vue中的虚拟DOM\n\n前文我们介绍了虚拟`DOM`的概念以及为什么要有虚拟`DOM`，那么在`Vue`中虚拟`DOM`是怎么实现的呢？接下来，我们从源码出发，深入学习一下。\n\n### 3.1 VNode类\n\n我们说了，虚拟`DOM`就是用`JS`来描述一个真实的`DOM`节点。而在`Vue`中就存在了一个`VNode`类，通过这个类，我们就可以实例化出不同类型的虚拟`DOM`节点，源码如下：\n\n```javascript\n// 源码位置：src/core/vdom/vnode.js\n\nexport default class VNode {\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array<VNode>,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions,\n    asyncFactory?: Function\n  ) {\n    this.tag = tag                                /*当前节点的标签名*/\n    this.data = data        /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/\n    this.children = children  /*当前节点的子节点，是一个数组*/\n    this.text = text     /*当前节点的文本*/\n    this.elm = elm       /*当前虚拟节点对应的真实dom节点*/\n    this.ns = undefined            /*当前节点的名字空间*/\n    this.context = context          /*当前组件节点对应的Vue实例*/\n    this.fnContext = undefined       /*函数式组件对应的Vue实例*/\n    this.fnOptions = undefined      \n    this.fnScopeId = undefined          \n    this.key = data && data.key           /*节点的key属性，被当作节点的标志，用以优化*/\n    this.componentOptions = componentOptions   /*组件的option选项*/\n    this.componentInstance = undefined       /*当前节点对应的组件的实例*/\n    this.parent = undefined           /*当前节点的父节点*/\n    this.raw = false         /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/\n    this.isStatic = false         /*静态节点标志*/\n    this.isRootInsert = true      /*是否作为跟节点插入*/\n    this.isComment = false             /*是否为注释节点*/\n    this.isCloned = false           /*是否为克隆节点*/\n    this.isOnce = false                /*是否有v-once指令*/\n    this.asyncFactory = asyncFactory\n    this.asyncMeta = undefined\n    this.isAsyncPlaceholder = false\n  }\n\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n```\n\n从上面的代码中可以看出：`VNode`类中包含了描述一个真实`DOM`节点所需要的一系列属性，如`tag`表示节点的标签名，`text`表示节点中包含的文本，`children`表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实`DOM`节点。\n\n### 3.2 VNode的类型\n\n上一小节最后我们说了，通过属性之间不同的搭配，`VNode`类可以描述出各种类型的真实`DOM`节点。那么它都可以描述出哪些类型的节点呢？通过阅读源码，可以发现通过不同属性的搭配，可以描述出以下几种类型的节点。\n\n- 注释节点\n- 文本节点\n- 元素节点\n- 组件节点\n- 函数式组件节点\n- 克隆节点\n\n接下来，我们就把这几种类型的节点描述方式从源码中一一对应起来。\n\n#### 3.2.1 注释节点\n\n注释节点描述起来相对就非常简单了，它只需两个属性就够了，源码如下：\n\n```javascript\n// 创建注释节点\nexport const createEmptyVNode = (text: string = '') => {\n  const node = new VNode()\n  node.text = text\n  node.isComment = true\n  return node\n}\n```\n\n从上面代码中可以看到，描述一个注释节点只需两个属性，分别是：`text`和`isComment`。其中`text`属性表示具体的注释信息，`isComment`是一个标志，用来标识一个节点是否是注释节点。\n\n#### 3.2.2 文本节点\n\n文本节点描述起来比注释节点更简单，因为它只需要一个属性，那就是`text`属性，用来表示具体的文本信息。源码如下：\n\n```javascript\n// 创建文本节点\nexport function createTextVNode (val: string | number) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n```\n\n#### 3.2.3 克隆节点\n\n克隆节点就是把一个已经存在的节点复制一份出来，它主要是为了做模板编译优化时使用，这个后面我们会说道。关于克隆节点的描述，源码如下：\n\n```javascript\n// 创建克隆节点\nexport function cloneVNode (vnode: VNode): VNode {\n  const cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  )\n  cloned.ns = vnode.ns\n  cloned.isStatic = vnode.isStatic\n  cloned.key = vnode.key\n  cloned.isComment = vnode.isComment\n  cloned.fnContext = vnode.fnContext\n  cloned.fnOptions = vnode.fnOptions\n  cloned.fnScopeId = vnode.fnScopeId\n  cloned.asyncMeta = vnode.asyncMeta\n  cloned.isCloned = true\n  return cloned\n}\n```\n\n从上面代码中可以看到，克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点`isCloned`为`true`。\n\n#### 3.2.4 元素节点\n\n相比之下，元素节点更贴近于我们通常看到的真实`DOM`节点，它有描述节点标签名词的`tag`属性，描述节点属性如`class`、`attributes`等的`data`属性，有描述包含的子节点信息的`children`属性等。由于元素节点所包含的情况相比而言比较复杂，源码中没有像前三种节点一样直接写死（当然也不可能写死），那就举个简单例子说明一下：\n\n```javascript\n// 真实DOM节点\n<div id='a'><span>难凉热血</span></div>\n\n// VNode节点\n{\n  tag:'div',\n  data:{},\n  children:[\n    {\n      tag:'span',\n      text:'难凉热血'\n    }\n  ]\n}\n```\n\n我们可以看到，真实`DOM`节点中:`div`标签里面包含了一个`span`标签，而`span`标签里面有一段文本。反应到`VNode`节点上就如上所示:`tag`表示标签名，`data`表示标签的属性`id`等，`children`表示子节点数组。\n\n#### 3.2.5 组件节点\n\n组件节点除了有元素节点具有的属性之外，它还有两个特有的属性：\n\n- componentOptions :组件的option选项，如组件的`props`等\n- componentInstance :当前组件节点对应的`Vue`实例\n\n#### 3.2.6 函数式组件节点\n\n函数式组件节点相较于组件节点，它又有两个特有的属性：\n\n- fnContext:函数式组件对应的Vue实例\n- fnOptions: 组件的option选项\n\n#### 3.2.7 小结\n\n以上就是`VNode`可以描述的多种节点类型，它们本质上都是`VNode`类的实例，只是在实例化的时候传入的属性参数不同而已。\n\n### 3.3 VNode的作用\n\n说了这么多，那么`VNode`在`Vue`的整个虚拟`DOM`过程起了什么作用呢？\n\n其实`VNode`的作用是相当大的。我们在视图渲染之前，把写好的`template`模板先编译成`VNode`并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的`VNode`与前一次缓存下来的`VNode`进行对比，找出差异，然后有差异的`VNode`对应的真实`DOM`节点就是需要重新渲染的节点，最后根据有差异的`VNode`创建出真实的`DOM`节点再插入到视图中，最终完成一次视图更新。\n\n## 4. 总结\n\n本章首先介绍了虚拟`DOM`的一些基本概念和为什么要有虚拟`DOM`，其实说白了就是以`JS`的计算性能来换取操作真实`DOM`所消耗的性能。接着从源码角度我们知道了在`Vue`中是通过`VNode`类来实例化出不同类型的虚拟`DOM`节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是`VNode`类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了`VNode`的作用，有了数据变化前后的`VNode`，我们才能进行后续的`DOM-Diff`找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实`DOM`的目的，以节省性能。\n\n","source":"_posts/Vue 源码阅读 虚拟DOM （一）.md","raw":"---\ntitle: Vue 源码阅读 虚拟DOM （一） \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-27 03:22:10\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n虚拟DOM，这个名词作为当下的前端开发人员你一定不会陌生，至少会略有耳闻，但不会闻所未闻吧。这也是现在求职面试考察中非常高频的一个考点了。因为在当下的前端三大框架中关于虚拟DOM或多或少都有所涉及，那么接下来，我们就从源码角度出发，看看`Vue`中的虚拟DOM时怎样的。\n\n## 2. 虚拟DOM简介\n\n由于本系列文章是针对`Vue`源码深入学习的，所以着重分析在`Vue`中对虚拟DOM是如何实现的，而对于虚拟DOM本身这个概念不做大篇幅的展开讨论，仅从以下几个问题简单介绍：\n\n1. 什么是虚拟DOM？\n\n   所谓虚拟DOM，就是用一个`JS`对象来描述一个`DOM`节点，像如下示例：\n\n   ```javascript\n   <div class=\"a\" id=\"b\">我是内容</div>\n   \n   {\n     tag:'div',        // 元素标签\n     attrs:{           // 属性\n       class:'a',\n       id:'b'\n     },\n     text:'我是内容',  // 文本内容\n     children:[]       // 子元素\n   }\n   ```\n\n   我们把组成一个`DOM`节点的必要东西通过一个`JS`对象表示出来，那么这个`JS`对象就可以用来描述这个`DOM`节点，我们把这个`JS`对象就称为是这个真实`DOM`节点的虚拟`DOM`节点。\n\n2. 为什么要有虚拟DOM？\n\n    我们知道，`Vue`是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作`DOM`,而操作真实`DOM`又是非常耗费性能的，这是因为浏览器的标准就把 `DOM` 设计的非常复杂，所以一个真正的 `DOM` 元素是非常庞大的，如下所示：\n\n   ```javascript\n   let div = document.createElement('div')\n   let str = ''\n   for (const key in div) {\n     str += key + ''\n   }\n   console.log(str)\n   ```\n![](/img/virtualDOM/1.png)\n\n\n   上图中我们打印一个简单的空`div`标签，就打印出这么多东西，更不用说复杂的、深嵌套的`DOM`节点了。由此可见，直接操作真实`DOM`是非常消耗性能的。\n\n   那么有没有什么解决方案呢？当然是有的。我们可以用`JS`的计算性能来换取操作`DOM`所消耗的性能。\n\n   既然我们逃不掉操作`DOM`这道坎,但是我们可以尽可能少的操作`DOM`。那如何在更新视图的时候尽可能少的操作`DOM`呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作`DOM`了。这也就是上面所说的用`JS`的计算性能来换取操作`DOM`的性能。\n\n   我们可以用`JS`模拟出一个`DOM`节点，称之为虚拟`DOM`节点。当数据发生变化时，我们对比变化前后的虚拟`DOM`节点，通过`DOM-Diff`算法计算出需要更新的地方，然后去更新需要更新的视图。\n\n   这就是虚拟`DOM`产生的原因以及最大的用途。\n\n## 3. Vue中的虚拟DOM\n\n前文我们介绍了虚拟`DOM`的概念以及为什么要有虚拟`DOM`，那么在`Vue`中虚拟`DOM`是怎么实现的呢？接下来，我们从源码出发，深入学习一下。\n\n### 3.1 VNode类\n\n我们说了，虚拟`DOM`就是用`JS`来描述一个真实的`DOM`节点。而在`Vue`中就存在了一个`VNode`类，通过这个类，我们就可以实例化出不同类型的虚拟`DOM`节点，源码如下：\n\n```javascript\n// 源码位置：src/core/vdom/vnode.js\n\nexport default class VNode {\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array<VNode>,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions,\n    asyncFactory?: Function\n  ) {\n    this.tag = tag                                /*当前节点的标签名*/\n    this.data = data        /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/\n    this.children = children  /*当前节点的子节点，是一个数组*/\n    this.text = text     /*当前节点的文本*/\n    this.elm = elm       /*当前虚拟节点对应的真实dom节点*/\n    this.ns = undefined            /*当前节点的名字空间*/\n    this.context = context          /*当前组件节点对应的Vue实例*/\n    this.fnContext = undefined       /*函数式组件对应的Vue实例*/\n    this.fnOptions = undefined      \n    this.fnScopeId = undefined          \n    this.key = data && data.key           /*节点的key属性，被当作节点的标志，用以优化*/\n    this.componentOptions = componentOptions   /*组件的option选项*/\n    this.componentInstance = undefined       /*当前节点对应的组件的实例*/\n    this.parent = undefined           /*当前节点的父节点*/\n    this.raw = false         /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/\n    this.isStatic = false         /*静态节点标志*/\n    this.isRootInsert = true      /*是否作为跟节点插入*/\n    this.isComment = false             /*是否为注释节点*/\n    this.isCloned = false           /*是否为克隆节点*/\n    this.isOnce = false                /*是否有v-once指令*/\n    this.asyncFactory = asyncFactory\n    this.asyncMeta = undefined\n    this.isAsyncPlaceholder = false\n  }\n\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n```\n\n从上面的代码中可以看出：`VNode`类中包含了描述一个真实`DOM`节点所需要的一系列属性，如`tag`表示节点的标签名，`text`表示节点中包含的文本，`children`表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实`DOM`节点。\n\n### 3.2 VNode的类型\n\n上一小节最后我们说了，通过属性之间不同的搭配，`VNode`类可以描述出各种类型的真实`DOM`节点。那么它都可以描述出哪些类型的节点呢？通过阅读源码，可以发现通过不同属性的搭配，可以描述出以下几种类型的节点。\n\n- 注释节点\n- 文本节点\n- 元素节点\n- 组件节点\n- 函数式组件节点\n- 克隆节点\n\n接下来，我们就把这几种类型的节点描述方式从源码中一一对应起来。\n\n#### 3.2.1 注释节点\n\n注释节点描述起来相对就非常简单了，它只需两个属性就够了，源码如下：\n\n```javascript\n// 创建注释节点\nexport const createEmptyVNode = (text: string = '') => {\n  const node = new VNode()\n  node.text = text\n  node.isComment = true\n  return node\n}\n```\n\n从上面代码中可以看到，描述一个注释节点只需两个属性，分别是：`text`和`isComment`。其中`text`属性表示具体的注释信息，`isComment`是一个标志，用来标识一个节点是否是注释节点。\n\n#### 3.2.2 文本节点\n\n文本节点描述起来比注释节点更简单，因为它只需要一个属性，那就是`text`属性，用来表示具体的文本信息。源码如下：\n\n```javascript\n// 创建文本节点\nexport function createTextVNode (val: string | number) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n```\n\n#### 3.2.3 克隆节点\n\n克隆节点就是把一个已经存在的节点复制一份出来，它主要是为了做模板编译优化时使用，这个后面我们会说道。关于克隆节点的描述，源码如下：\n\n```javascript\n// 创建克隆节点\nexport function cloneVNode (vnode: VNode): VNode {\n  const cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  )\n  cloned.ns = vnode.ns\n  cloned.isStatic = vnode.isStatic\n  cloned.key = vnode.key\n  cloned.isComment = vnode.isComment\n  cloned.fnContext = vnode.fnContext\n  cloned.fnOptions = vnode.fnOptions\n  cloned.fnScopeId = vnode.fnScopeId\n  cloned.asyncMeta = vnode.asyncMeta\n  cloned.isCloned = true\n  return cloned\n}\n```\n\n从上面代码中可以看到，克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点`isCloned`为`true`。\n\n#### 3.2.4 元素节点\n\n相比之下，元素节点更贴近于我们通常看到的真实`DOM`节点，它有描述节点标签名词的`tag`属性，描述节点属性如`class`、`attributes`等的`data`属性，有描述包含的子节点信息的`children`属性等。由于元素节点所包含的情况相比而言比较复杂，源码中没有像前三种节点一样直接写死（当然也不可能写死），那就举个简单例子说明一下：\n\n```javascript\n// 真实DOM节点\n<div id='a'><span>难凉热血</span></div>\n\n// VNode节点\n{\n  tag:'div',\n  data:{},\n  children:[\n    {\n      tag:'span',\n      text:'难凉热血'\n    }\n  ]\n}\n```\n\n我们可以看到，真实`DOM`节点中:`div`标签里面包含了一个`span`标签，而`span`标签里面有一段文本。反应到`VNode`节点上就如上所示:`tag`表示标签名，`data`表示标签的属性`id`等，`children`表示子节点数组。\n\n#### 3.2.5 组件节点\n\n组件节点除了有元素节点具有的属性之外，它还有两个特有的属性：\n\n- componentOptions :组件的option选项，如组件的`props`等\n- componentInstance :当前组件节点对应的`Vue`实例\n\n#### 3.2.6 函数式组件节点\n\n函数式组件节点相较于组件节点，它又有两个特有的属性：\n\n- fnContext:函数式组件对应的Vue实例\n- fnOptions: 组件的option选项\n\n#### 3.2.7 小结\n\n以上就是`VNode`可以描述的多种节点类型，它们本质上都是`VNode`类的实例，只是在实例化的时候传入的属性参数不同而已。\n\n### 3.3 VNode的作用\n\n说了这么多，那么`VNode`在`Vue`的整个虚拟`DOM`过程起了什么作用呢？\n\n其实`VNode`的作用是相当大的。我们在视图渲染之前，把写好的`template`模板先编译成`VNode`并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的`VNode`与前一次缓存下来的`VNode`进行对比，找出差异，然后有差异的`VNode`对应的真实`DOM`节点就是需要重新渲染的节点，最后根据有差异的`VNode`创建出真实的`DOM`节点再插入到视图中，最终完成一次视图更新。\n\n## 4. 总结\n\n本章首先介绍了虚拟`DOM`的一些基本概念和为什么要有虚拟`DOM`，其实说白了就是以`JS`的计算性能来换取操作真实`DOM`所消耗的性能。接着从源码角度我们知道了在`Vue`中是通过`VNode`类来实例化出不同类型的虚拟`DOM`节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是`VNode`类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了`VNode`的作用，有了数据变化前后的`VNode`，我们才能进行后续的`DOM-Diff`找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实`DOM`的目的，以节省性能。\n\n","slug":"Vue 源码阅读 虚拟DOM （一）","published":1,"updated":"2019-12-31T03:27:27.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj870075zws6slwy1atb","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>虚拟DOM，这个名词作为当下的前端开发人员你一定不会陌生，至少会略有耳闻，但不会闻所未闻吧。这也是现在求职面试考察中非常高频的一个考点了。因为在当下的前端三大框架中关于虚拟DOM或多或少都有所涉及，那么接下来，我们就从源码角度出发，看看<code>Vue</code>中的虚拟DOM时怎样的。</p>\n<h2><span id=\"2-虚拟dom简介\">2. 虚拟DOM简介</span></h2>\n<p>由于本系列文章是针对<code>Vue</code>源码深入学习的，所以着重分析在<code>Vue</code>中对虚拟DOM是如何实现的，而对于虚拟DOM本身这个概念不做大篇幅的展开讨论，仅从以下几个问题简单介绍：</p>\n<ol>\n<li>\n<p>什么是虚拟DOM？</p>\n<p>所谓虚拟DOM，就是用一个<code>JS</code>对象来描述一个<code>DOM</code>节点，像如下示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"a\"</span> id=<span class=\"string\">\"b\"</span>&gt;我是内容&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  tag:'div',        /</span><span class=\"regexp\">/ 元素标签</span></span><br><span class=\"line\"><span class=\"regexp\">  attrs:&#123;           /</span><span class=\"regexp\">/ 属性</span></span><br><span class=\"line\"><span class=\"regexp\">    class:'a',</span></span><br><span class=\"line\"><span class=\"regexp\">    id:'b'</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  text:'我是内容',  /</span><span class=\"regexp\">/ 文本内容</span></span><br><span class=\"line\"><span class=\"regexp\">  children:[]       /</span><span class=\"regexp\">/ 子元素</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们把组成一个<code>DOM</code>节点的必要东西通过一个<code>JS</code>对象表示出来，那么这个<code>JS</code>对象就可以用来描述这个<code>DOM</code>节点，我们把这个<code>JS</code>对象就称为是这个真实<code>DOM</code>节点的虚拟<code>DOM</code>节点。</p>\n</li>\n<li>\n<p>为什么要有虚拟DOM？</p>\n<p>我们知道，<code>Vue</code>是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,而操作真实<code>DOM</code>又是非常耗费性能的，这是因为浏览器的标准就把 <code>DOM</code> 设计的非常复杂，所以一个真正的 <code>DOM</code> 元素是非常庞大的，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">''</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> div) &#123;</span><br><span class=\"line\">  str += key + <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"/img/virtualDOM/1.png\" alt></p>\n<p>上图中我们打印一个简单的空<code>div</code>标签，就打印出这么多东西，更不用说复杂的、深嵌套的<code>DOM</code>节点了。由此可见，直接操作真实<code>DOM</code>是非常消耗性能的。</p>\n<p>那么有没有什么解决方案呢？当然是有的。我们可以用<code>JS</code>的计算性能来换取操作<code>DOM</code>所消耗的性能。</p>\n<p>既然我们逃不掉操作<code>DOM</code>这道坎,但是我们可以尽可能少的操作<code>DOM</code>。那如何在更新视图的时候尽可能少的操作<code>DOM</code>呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作<code>DOM</code>了。这也就是上面所说的用<code>JS</code>的计算性能来换取操作<code>DOM</code>的性能。</p>\n<p>我们可以用<code>JS</code>模拟出一个<code>DOM</code>节点，称之为虚拟<code>DOM</code>节点。当数据发生变化时，我们对比变化前后的虚拟<code>DOM</code>节点，通过<code>DOM-Diff</code>算法计算出需要更新的地方，然后去更新需要更新的视图。</p>\n<p>这就是虚拟<code>DOM</code>产生的原因以及最大的用途。</p>\n<h2><span id=\"3-vue中的虚拟dom\">3. Vue中的虚拟DOM</span></h2>\n<p>前文我们介绍了虚拟<code>DOM</code>的概念以及为什么要有虚拟<code>DOM</code>，那么在<code>Vue</code>中虚拟<code>DOM</code>是怎么实现的呢？接下来，我们从源码出发，深入学习一下。</p>\n<h3><span id=\"31-vnode类\">3.1 VNode类</span></h3>\n<p>我们说了，虚拟<code>DOM</code>就是用<code>JS</code>来描述一个真实的<code>DOM</code>节点。而在<code>Vue</code>中就存在了一个<code>VNode</code>类，通过这个类，我们就可以实例化出不同类型的虚拟<code>DOM</code>节点，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：src/core/vdom/vnode.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (</span><br><span class=\"line\">    tag?: string,</span><br><span class=\"line\">    data?: VNodeData,</span><br><span class=\"line\">    children?: ?Array&lt;VNode&gt;,</span><br><span class=\"line\">    text?: string,</span><br><span class=\"line\">    elm?: Node,</span><br><span class=\"line\">    context?: Component,</span><br><span class=\"line\">    componentOptions?: VNodeComponentOptions,</span><br><span class=\"line\">    asyncFactory?: Function</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tag = tag                                <span class=\"comment\">/*当前节点的标签名*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data        <span class=\"comment\">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.children = children  <span class=\"comment\">/*当前节点的子节点，是一个数组*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text     <span class=\"comment\">/*当前节点的文本*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elm = elm       <span class=\"comment\">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ns = <span class=\"literal\">undefined</span>            <span class=\"comment\">/*当前节点的名字空间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.context = context          <span class=\"comment\">/*当前组件节点对应的Vue实例*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fnContext = <span class=\"literal\">undefined</span>       <span class=\"comment\">/*函数式组件对应的Vue实例*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fnOptions = <span class=\"literal\">undefined</span>      </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fnScopeId = <span class=\"literal\">undefined</span>          </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = data &amp;&amp; data.key           <span class=\"comment\">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.componentOptions = componentOptions   <span class=\"comment\">/*组件的option选项*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.componentInstance = <span class=\"literal\">undefined</span>       <span class=\"comment\">/*当前节点对应的组件的实例*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"literal\">undefined</span>           <span class=\"comment\">/*当前节点的父节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.raw = <span class=\"literal\">false</span>         <span class=\"comment\">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isStatic = <span class=\"literal\">false</span>         <span class=\"comment\">/*静态节点标志*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isRootInsert = <span class=\"literal\">true</span>      <span class=\"comment\">/*是否作为跟节点插入*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isComment = <span class=\"literal\">false</span>             <span class=\"comment\">/*是否为注释节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isCloned = <span class=\"literal\">false</span>           <span class=\"comment\">/*是否为克隆节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isOnce = <span class=\"literal\">false</span>                <span class=\"comment\">/*是否有v-once指令*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.asyncFactory = asyncFactory</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.asyncMeta = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isAsyncPlaceholder = <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> child (): Component | void &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.componentInstance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码中可以看出：<code>VNode</code>类中包含了描述一个真实<code>DOM</code>节点所需要的一系列属性，如<code>tag</code>表示节点的标签名，<code>text</code>表示节点中包含的文本，<code>children</code>表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实<code>DOM</code>节点。</p>\n<h3><span id=\"32-vnode的类型\">3.2 VNode的类型</span></h3>\n<p>上一小节最后我们说了，通过属性之间不同的搭配，<code>VNode</code>类可以描述出各种类型的真实<code>DOM</code>节点。那么它都可以描述出哪些类型的节点呢？通过阅读源码，可以发现通过不同属性的搭配，可以描述出以下几种类型的节点。</p>\n<ul>\n<li>注释节点</li>\n<li>文本节点</li>\n<li>元素节点</li>\n<li>组件节点</li>\n<li>函数式组件节点</li>\n<li>克隆节点</li>\n</ul>\n<p>接下来，我们就把这几种类型的节点描述方式从源码中一一对应起来。</p>\n<h4><span id=\"321-注释节点\">3.2.1 注释节点</span></h4>\n<p>注释节点描述起来相对就非常简单了，它只需两个属性就够了，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建注释节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createEmptyVNode = <span class=\"function\">(<span class=\"params\">text: string = <span class=\"string\">''</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> VNode()</span><br><span class=\"line\">  node.text = text</span><br><span class=\"line\">  node.isComment = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> node</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中可以看到，描述一个注释节点只需两个属性，分别是：<code>text</code>和<code>isComment</code>。其中<code>text</code>属性表示具体的注释信息，<code>isComment</code>是一个标志，用来标识一个节点是否是注释节点。</p>\n<h4><span id=\"322-文本节点\">3.2.2 文本节点</span></h4>\n<p>文本节点描述起来比注释节点更简单，因为它只需要一个属性，那就是<code>text</code>属性，用来表示具体的文本信息。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建文本节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTextVNode</span> (<span class=\"params\">val: string | number</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> VNode(<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"built_in\">String</span>(val))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"323-克隆节点\">3.2.3 克隆节点</span></h4>\n<p>克隆节点就是把一个已经存在的节点复制一份出来，它主要是为了做模板编译优化时使用，这个后面我们会说道。关于克隆节点的描述，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建克隆节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneVNode</span> (<span class=\"params\">vnode: VNode</span>): <span class=\"title\">VNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cloned = <span class=\"keyword\">new</span> VNode(</span><br><span class=\"line\">    vnode.tag,</span><br><span class=\"line\">    vnode.data,</span><br><span class=\"line\">    vnode.children,</span><br><span class=\"line\">    vnode.text,</span><br><span class=\"line\">    vnode.elm,</span><br><span class=\"line\">    vnode.context,</span><br><span class=\"line\">    vnode.componentOptions,</span><br><span class=\"line\">    vnode.asyncFactory</span><br><span class=\"line\">  )</span><br><span class=\"line\">  cloned.ns = vnode.ns</span><br><span class=\"line\">  cloned.isStatic = vnode.isStatic</span><br><span class=\"line\">  cloned.key = vnode.key</span><br><span class=\"line\">  cloned.isComment = vnode.isComment</span><br><span class=\"line\">  cloned.fnContext = vnode.fnContext</span><br><span class=\"line\">  cloned.fnOptions = vnode.fnOptions</span><br><span class=\"line\">  cloned.fnScopeId = vnode.fnScopeId</span><br><span class=\"line\">  cloned.asyncMeta = vnode.asyncMeta</span><br><span class=\"line\">  cloned.isCloned = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloned</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中可以看到，克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点<code>isCloned</code>为<code>true</code>。</p>\n<h4><span id=\"324-元素节点\">3.2.4 元素节点</span></h4>\n<p>相比之下，元素节点更贴近于我们通常看到的真实<code>DOM</code>节点，它有描述节点标签名词的<code>tag</code>属性，描述节点属性如<code>class</code>、<code>attributes</code>等的<code>data</code>属性，有描述包含的子节点信息的<code>children</code>属性等。由于元素节点所包含的情况相比而言比较复杂，源码中没有像前三种节点一样直接写死（当然也不可能写死），那就举个简单例子说明一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 真实DOM节点</span></span><br><span class=\"line\">&lt;div id=<span class=\"string\">'a'</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>难凉热血<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VNode节点</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  tag:<span class=\"string\">'div'</span>,</span><br><span class=\"line\">  data:&#123;&#125;,</span><br><span class=\"line\">  children:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      tag:<span class=\"string\">'span'</span>,</span><br><span class=\"line\">      text:<span class=\"string\">'难凉热血'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，真实<code>DOM</code>节点中:<code>div</code>标签里面包含了一个<code>span</code>标签，而<code>span</code>标签里面有一段文本。反应到<code>VNode</code>节点上就如上所示:<code>tag</code>表示标签名，<code>data</code>表示标签的属性<code>id</code>等，<code>children</code>表示子节点数组。</p>\n<h4><span id=\"325-组件节点\">3.2.5 组件节点</span></h4>\n<p>组件节点除了有元素节点具有的属性之外，它还有两个特有的属性：</p>\n<ul>\n<li>componentOptions :组件的option选项，如组件的<code>props</code>等</li>\n<li>componentInstance :当前组件节点对应的<code>Vue</code>实例</li>\n</ul>\n<h4><span id=\"326-函数式组件节点\">3.2.6 函数式组件节点</span></h4>\n<p>函数式组件节点相较于组件节点，它又有两个特有的属性：</p>\n<ul>\n<li>fnContext:函数式组件对应的Vue实例</li>\n<li>fnOptions: 组件的option选项</li>\n</ul>\n<h4><span id=\"327-小结\">3.2.7 小结</span></h4>\n<p>以上就是<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</p>\n<h3><span id=\"33-vnode的作用\">3.3 VNode的作用</span></h3>\n<p>说了这么多，那么<code>VNode</code>在<code>Vue</code>的整个虚拟<code>DOM</code>过程起了什么作用呢？</p>\n<p>其实<code>VNode</code>的作用是相当大的。我们在视图渲染之前，把写好的<code>template</code>模板先编译成<code>VNode</code>并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的<code>VNode</code>与前一次缓存下来的<code>VNode</code>进行对比，找出差异，然后有差异的<code>VNode</code>对应的真实<code>DOM</code>节点就是需要重新渲染的节点，最后根据有差异的<code>VNode</code>创建出真实的<code>DOM</code>节点再插入到视图中，最终完成一次视图更新。</p>\n<h2><span id=\"4-总结\">4. 总结</span></h2>\n<p>本章首先介绍了虚拟<code>DOM</code>的一些基本概念和为什么要有虚拟<code>DOM</code>，其实说白了就是以<code>JS</code>的计算性能来换取操作真实<code>DOM</code>所消耗的性能。接着从源码角度我们知道了在<code>Vue</code>中是通过<code>VNode</code>类来实例化出不同类型的虚拟<code>DOM</code>节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是<code>VNode</code>类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了<code>VNode</code>的作用，有了数据变化前后的<code>VNode</code>，我们才能进行后续的<code>DOM-Diff</code>找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实<code>DOM</code>的目的，以节省性能。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>虚拟DOM，这个名词作为当下的前端开发人员你一定不会陌生，至少会略有耳闻，但不会闻所未闻吧。这也是现在求职面试考察中非常高频的一个考点了。因为在当下的前端三大框架中关于虚拟DOM或多或少都有所涉及，那么接下来，我们就从源码角度出发，看看<code>Vue</code>中的虚拟DOM时怎样的。</p>\n<h2>2. 虚拟DOM简介</h2>\n<p>由于本系列文章是针对<code>Vue</code>源码深入学习的，所以着重分析在<code>Vue</code>中对虚拟DOM是如何实现的，而对于虚拟DOM本身这个概念不做大篇幅的展开讨论，仅从以下几个问题简单介绍：</p>\n<ol>\n<li>\n<p>什么是虚拟DOM？</p>\n<p>所谓虚拟DOM，就是用一个<code>JS</code>对象来描述一个<code>DOM</code>节点，像如下示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"a\"</span> id=<span class=\"string\">\"b\"</span>&gt;我是内容&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  tag:'div',        /</span><span class=\"regexp\">/ 元素标签</span></span><br><span class=\"line\"><span class=\"regexp\">  attrs:&#123;           /</span><span class=\"regexp\">/ 属性</span></span><br><span class=\"line\"><span class=\"regexp\">    class:'a',</span></span><br><span class=\"line\"><span class=\"regexp\">    id:'b'</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;,</span></span><br><span class=\"line\"><span class=\"regexp\">  text:'我是内容',  /</span><span class=\"regexp\">/ 文本内容</span></span><br><span class=\"line\"><span class=\"regexp\">  children:[]       /</span><span class=\"regexp\">/ 子元素</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们把组成一个<code>DOM</code>节点的必要东西通过一个<code>JS</code>对象表示出来，那么这个<code>JS</code>对象就可以用来描述这个<code>DOM</code>节点，我们把这个<code>JS</code>对象就称为是这个真实<code>DOM</code>节点的虚拟<code>DOM</code>节点。</p>\n</li>\n<li>\n<p>为什么要有虚拟DOM？</p>\n<p>我们知道，<code>Vue</code>是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作<code>DOM</code>,而操作真实<code>DOM</code>又是非常耗费性能的，这是因为浏览器的标准就把 <code>DOM</code> 设计的非常复杂，所以一个真正的 <code>DOM</code> 元素是非常庞大的，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">''</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> div) &#123;</span><br><span class=\"line\">  str += key + <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"/img/virtualDOM/1.png\" alt></p>\n<p>上图中我们打印一个简单的空<code>div</code>标签，就打印出这么多东西，更不用说复杂的、深嵌套的<code>DOM</code>节点了。由此可见，直接操作真实<code>DOM</code>是非常消耗性能的。</p>\n<p>那么有没有什么解决方案呢？当然是有的。我们可以用<code>JS</code>的计算性能来换取操作<code>DOM</code>所消耗的性能。</p>\n<p>既然我们逃不掉操作<code>DOM</code>这道坎,但是我们可以尽可能少的操作<code>DOM</code>。那如何在更新视图的时候尽可能少的操作<code>DOM</code>呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作<code>DOM</code>了。这也就是上面所说的用<code>JS</code>的计算性能来换取操作<code>DOM</code>的性能。</p>\n<p>我们可以用<code>JS</code>模拟出一个<code>DOM</code>节点，称之为虚拟<code>DOM</code>节点。当数据发生变化时，我们对比变化前后的虚拟<code>DOM</code>节点，通过<code>DOM-Diff</code>算法计算出需要更新的地方，然后去更新需要更新的视图。</p>\n<p>这就是虚拟<code>DOM</code>产生的原因以及最大的用途。</p>\n<h2>3. Vue中的虚拟DOM</h2>\n<p>前文我们介绍了虚拟<code>DOM</code>的概念以及为什么要有虚拟<code>DOM</code>，那么在<code>Vue</code>中虚拟<code>DOM</code>是怎么实现的呢？接下来，我们从源码出发，深入学习一下。</p>\n<h3>3.1 VNode类</h3>\n<p>我们说了，虚拟<code>DOM</code>就是用<code>JS</code>来描述一个真实的<code>DOM</code>节点。而在<code>Vue</code>中就存在了一个<code>VNode</code>类，通过这个类，我们就可以实例化出不同类型的虚拟<code>DOM</code>节点，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：src/core/vdom/vnode.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (</span><br><span class=\"line\">    tag?: string,</span><br><span class=\"line\">    data?: VNodeData,</span><br><span class=\"line\">    children?: ?Array&lt;VNode&gt;,</span><br><span class=\"line\">    text?: string,</span><br><span class=\"line\">    elm?: Node,</span><br><span class=\"line\">    context?: Component,</span><br><span class=\"line\">    componentOptions?: VNodeComponentOptions,</span><br><span class=\"line\">    asyncFactory?: Function</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.tag = tag                                <span class=\"comment\">/*当前节点的标签名*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data        <span class=\"comment\">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.children = children  <span class=\"comment\">/*当前节点的子节点，是一个数组*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text     <span class=\"comment\">/*当前节点的文本*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elm = elm       <span class=\"comment\">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ns = <span class=\"literal\">undefined</span>            <span class=\"comment\">/*当前节点的名字空间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.context = context          <span class=\"comment\">/*当前组件节点对应的Vue实例*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fnContext = <span class=\"literal\">undefined</span>       <span class=\"comment\">/*函数式组件对应的Vue实例*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fnOptions = <span class=\"literal\">undefined</span>      </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fnScopeId = <span class=\"literal\">undefined</span>          </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = data &amp;&amp; data.key           <span class=\"comment\">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.componentOptions = componentOptions   <span class=\"comment\">/*组件的option选项*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.componentInstance = <span class=\"literal\">undefined</span>       <span class=\"comment\">/*当前节点对应的组件的实例*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.parent = <span class=\"literal\">undefined</span>           <span class=\"comment\">/*当前节点的父节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.raw = <span class=\"literal\">false</span>         <span class=\"comment\">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isStatic = <span class=\"literal\">false</span>         <span class=\"comment\">/*静态节点标志*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isRootInsert = <span class=\"literal\">true</span>      <span class=\"comment\">/*是否作为跟节点插入*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isComment = <span class=\"literal\">false</span>             <span class=\"comment\">/*是否为注释节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isCloned = <span class=\"literal\">false</span>           <span class=\"comment\">/*是否为克隆节点*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isOnce = <span class=\"literal\">false</span>                <span class=\"comment\">/*是否有v-once指令*/</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.asyncFactory = asyncFactory</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.asyncMeta = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isAsyncPlaceholder = <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> child (): Component | void &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.componentInstance</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面的代码中可以看出：<code>VNode</code>类中包含了描述一个真实<code>DOM</code>节点所需要的一系列属性，如<code>tag</code>表示节点的标签名，<code>text</code>表示节点中包含的文本，<code>children</code>表示该节点包含的子节点等。通过属性之间不同的搭配，就可以描述出各种类型的真实<code>DOM</code>节点。</p>\n<h3>3.2 VNode的类型</h3>\n<p>上一小节最后我们说了，通过属性之间不同的搭配，<code>VNode</code>类可以描述出各种类型的真实<code>DOM</code>节点。那么它都可以描述出哪些类型的节点呢？通过阅读源码，可以发现通过不同属性的搭配，可以描述出以下几种类型的节点。</p>\n<ul>\n<li>注释节点</li>\n<li>文本节点</li>\n<li>元素节点</li>\n<li>组件节点</li>\n<li>函数式组件节点</li>\n<li>克隆节点</li>\n</ul>\n<p>接下来，我们就把这几种类型的节点描述方式从源码中一一对应起来。</p>\n<h4>3.2.1 注释节点</h4>\n<p>注释节点描述起来相对就非常简单了，它只需两个属性就够了，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建注释节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createEmptyVNode = <span class=\"function\">(<span class=\"params\">text: string = <span class=\"string\">''</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> VNode()</span><br><span class=\"line\">  node.text = text</span><br><span class=\"line\">  node.isComment = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> node</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中可以看到，描述一个注释节点只需两个属性，分别是：<code>text</code>和<code>isComment</code>。其中<code>text</code>属性表示具体的注释信息，<code>isComment</code>是一个标志，用来标识一个节点是否是注释节点。</p>\n<h4>3.2.2 文本节点</h4>\n<p>文本节点描述起来比注释节点更简单，因为它只需要一个属性，那就是<code>text</code>属性，用来表示具体的文本信息。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建文本节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTextVNode</span> (<span class=\"params\">val: string | number</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> VNode(<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"built_in\">String</span>(val))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>3.2.3 克隆节点</h4>\n<p>克隆节点就是把一个已经存在的节点复制一份出来，它主要是为了做模板编译优化时使用，这个后面我们会说道。关于克隆节点的描述，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建克隆节点</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneVNode</span> (<span class=\"params\">vnode: VNode</span>): <span class=\"title\">VNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cloned = <span class=\"keyword\">new</span> VNode(</span><br><span class=\"line\">    vnode.tag,</span><br><span class=\"line\">    vnode.data,</span><br><span class=\"line\">    vnode.children,</span><br><span class=\"line\">    vnode.text,</span><br><span class=\"line\">    vnode.elm,</span><br><span class=\"line\">    vnode.context,</span><br><span class=\"line\">    vnode.componentOptions,</span><br><span class=\"line\">    vnode.asyncFactory</span><br><span class=\"line\">  )</span><br><span class=\"line\">  cloned.ns = vnode.ns</span><br><span class=\"line\">  cloned.isStatic = vnode.isStatic</span><br><span class=\"line\">  cloned.key = vnode.key</span><br><span class=\"line\">  cloned.isComment = vnode.isComment</span><br><span class=\"line\">  cloned.fnContext = vnode.fnContext</span><br><span class=\"line\">  cloned.fnOptions = vnode.fnOptions</span><br><span class=\"line\">  cloned.fnScopeId = vnode.fnScopeId</span><br><span class=\"line\">  cloned.asyncMeta = vnode.asyncMeta</span><br><span class=\"line\">  cloned.isCloned = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloned</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中可以看到，克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点<code>isCloned</code>为<code>true</code>。</p>\n<h4>3.2.4 元素节点</h4>\n<p>相比之下，元素节点更贴近于我们通常看到的真实<code>DOM</code>节点，它有描述节点标签名词的<code>tag</code>属性，描述节点属性如<code>class</code>、<code>attributes</code>等的<code>data</code>属性，有描述包含的子节点信息的<code>children</code>属性等。由于元素节点所包含的情况相比而言比较复杂，源码中没有像前三种节点一样直接写死（当然也不可能写死），那就举个简单例子说明一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 真实DOM节点</span></span><br><span class=\"line\">&lt;div id=<span class=\"string\">'a'</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>难凉热血<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// VNode节点</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  tag:<span class=\"string\">'div'</span>,</span><br><span class=\"line\">  data:&#123;&#125;,</span><br><span class=\"line\">  children:[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      tag:<span class=\"string\">'span'</span>,</span><br><span class=\"line\">      text:<span class=\"string\">'难凉热血'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，真实<code>DOM</code>节点中:<code>div</code>标签里面包含了一个<code>span</code>标签，而<code>span</code>标签里面有一段文本。反应到<code>VNode</code>节点上就如上所示:<code>tag</code>表示标签名，<code>data</code>表示标签的属性<code>id</code>等，<code>children</code>表示子节点数组。</p>\n<h4>3.2.5 组件节点</h4>\n<p>组件节点除了有元素节点具有的属性之外，它还有两个特有的属性：</p>\n<ul>\n<li>componentOptions :组件的option选项，如组件的<code>props</code>等</li>\n<li>componentInstance :当前组件节点对应的<code>Vue</code>实例</li>\n</ul>\n<h4>3.2.6 函数式组件节点</h4>\n<p>函数式组件节点相较于组件节点，它又有两个特有的属性：</p>\n<ul>\n<li>fnContext:函数式组件对应的Vue实例</li>\n<li>fnOptions: 组件的option选项</li>\n</ul>\n<h4>3.2.7 小结</h4>\n<p>以上就是<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</p>\n<h3>3.3 VNode的作用</h3>\n<p>说了这么多，那么<code>VNode</code>在<code>Vue</code>的整个虚拟<code>DOM</code>过程起了什么作用呢？</p>\n<p>其实<code>VNode</code>的作用是相当大的。我们在视图渲染之前，把写好的<code>template</code>模板先编译成<code>VNode</code>并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的<code>VNode</code>与前一次缓存下来的<code>VNode</code>进行对比，找出差异，然后有差异的<code>VNode</code>对应的真实<code>DOM</code>节点就是需要重新渲染的节点，最后根据有差异的<code>VNode</code>创建出真实的<code>DOM</code>节点再插入到视图中，最终完成一次视图更新。</p>\n<h2>4. 总结</h2>\n<p>本章首先介绍了虚拟<code>DOM</code>的一些基本概念和为什么要有虚拟<code>DOM</code>，其实说白了就是以<code>JS</code>的计算性能来换取操作真实<code>DOM</code>所消耗的性能。接着从源码角度我们知道了在<code>Vue</code>中是通过<code>VNode</code>类来实例化出不同类型的虚拟<code>DOM</code>节点，并且学习了不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是<code>VNode</code>类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了<code>VNode</code>的作用，有了数据变化前后的<code>VNode</code>，我们才能进行后续的<code>DOM-Diff</code>找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实<code>DOM</code>的目的，以节省性能。</p>\n"},{"title":"Vue 源码阅读 生命周期（二）","catalog":true,"date":"2020-01-02T03:04:07.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n上篇文章中介绍了`Vue`实例的生命周期大致分为4个阶段，那么首先我们先从第一个阶段——初始化阶段开始入手分析。从生命周期流程图中我们可以看到，初始化阶段所做的工作也可大致分为两部分：第一部分是`new Vue()`，也就是创建一个`Vue`实例；第二部分是为创建好的`Vue`实例初始化一些事件、属性、响应式数据等。接下来我们就从源码角度来深入分析一下初始化阶段所做的工作及其内部原理。\n\n## 2. new Vue()都干了什么\n\n初始化阶段所做的第一件事就是`new Vue()`创建一个`Vue`实例，那么`new Vue()`的内部都干了什么呢？ 我们知道，`new` 关键字在 `JS`中表示从一个类中实例化出一个对象来，由此可见， `Vue` 实际上是一个类。所以`new Vue()`实际上是执行了`Vue`类的构造函数，那么我们来看一下`Vue`类是如何定义的，`Vue`类的定义是在源码的`src/core/instance/index.js` 中，如下：\n\n```javascript\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n可以看到，`Vue`类的定义非常简单，其构造函数核心就一行代码：\n\n```javascript\nthis._init(options)\n```\n\n调用原型上的`_init(options)`方法并把用户所写的选项`options`传入。那这个`_init`方法是从哪来的呢？在`Vue`类定义的下面还有几行代码，其中之一就是：\n\n```javascript\ninitMixin(Vue)\n```\n\n这一行代码执行了`initMixin`函数，那`initMixin`函数又是从哪儿来的呢？该函数定义位于源码的`src/core/instance/init.js` 中，如下：\n\n```javascript\nexport function initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this\n    vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n    )\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n\n可以看到，在`initMixin`函数内部就只干了一件事，那就是给`Vue`类的原型上绑定`_init`方法，同时`_init`方法的定义也在该函数内部。现在我们知道了，`new Vue()`会执行`Vue`类的构造函数，构造函数内部会执行`_init`方法，所以`new Vue()`所干的事情其实就是`_init`方法所干的事情，那么我们着重来分析下`_init`方法都干了哪些事情。\n\n首先，把`Vue`实例赋值给变量`vm`，并且把用户传递的`options`选项与当前构造函数的`options`属性及其父级构造函数的`options`属性进行合并（关于属性如何合并的问题下面会介绍），得到一个新的`options`选项赋值给`$options`属性，并将`$options`属性挂载到`Vue`实例上，如下：\n\n```javascript\nvm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n)\n```\n\n接着，通过调用一些初始化函数来为`Vue`实例初始化一些属性，事件，响应式数据等，如下：\n\n```javascript\ninitLifecycle(vm)       // 初始化生命周期\ninitEvents(vm)        // 初始化事件\ninitRender(vm)         // 初始化渲染\ncallHook(vm, 'beforeCreate')  // 调用生命周期钩子函数\ninitInjections(vm)   //初始化injections\ninitState(vm)    // 初始化props,methods,data,computed,watch\ninitProvide(vm) // 初始化 provide\ncallHook(vm, 'created')  // 调用生命周期钩子函数\n```\n\n可以看到，除了调用初始化函数来进行相关数据的初始化之外，还在合适的时机调用了`callHook`函数来触发生命周期的钩子，关于`callHook`函数是如何触发生命周期的钩子会在下面介绍，我们先继续往下看：\n\n```javascript\nif (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n}\n```\n\n在所有的初始化工作都完成以后，最后，会判断用户是否传入了`el`选项，如果传入了则调用`$mount`函数进入模板编译与挂载阶段，如果没有传入`el`选项，则不进入下一个生命周期阶段，需要用户手动执行`vm.$mount`方法才进入下一个生命周期阶段。\n\n以上就是`new Vue()`所做的所有事情，可以看到，整个初始化阶段都是在`new Vue()`里完成的，关于`new Vue()`里调用的一些初始化函数具体是如何进行初始化的，我们将在接下来的几篇文章里逐一介绍。下面我们先来看看上文中遗留的属性合并及`callHook`函数是如何触发生命周期的钩子的问题。\n\n## 3. 合并属性\n\n在上文中，`_init`方法里首先会调用`mergeOptions`函数来进行属性合并，如下：\n\n```javascript\nvm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n)\n```\n\n\n\n 它实际上就是把 `resolveConstructorOptions(vm.constructor)` 的返回值和 `options` 做合并，`resolveConstructorOptions` 的实现先不考虑，可简单理解为返回 `vm.constructor.options`，相当于 `Vue.options`，那么这个 `Vue.options`又是什么呢，其实在 `initGlobalAPI(Vue)` 的时候定义了这个值，代码在 `src/core/global-api/index.js` 中： \n\n```javascript\nexport function initGlobalAPI (Vue: GlobalAPI) {\n  // ...\n  Vue.options = Object.create(null)\n  ASSET_TYPES.forEach(type => {\n    Vue.options[type + 's'] = Object.create(null)\n  })\n\n  extend(Vue.options.components, builtInComponents)\n  // ...\n}\n```\n\n 首先通过 `Vue.options = Object.create(null)` 创建一个空对象，然后遍历 `ASSET_TYPES`，`ASSET_TYPES` 的定义在 `src/shared/constants.js` 中： \n\n```javascript\nexport const ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n]\n```\n\n所以上面遍历 `ASSET_TYPES` 后的代码相当于：\n\n```js\nVue.options.components = {}\nVue.options.directives = {}\nVue.options.filters = {}\n```\n\n最后通过 `extend(Vue.options.components, builtInComponents)` 把一些内置组件扩展到 `Vue.options.components` 上，`Vue` 的内置组件目前 有`<keep-alive>`、`<transition>` 和`<transition-group>` 组件，这也就是为什么我们在其它组件中使用这些组件不需要注册的原因。\n\n 那么回到 `mergeOptions` 这个函数，它的定义在 `src/core/util/options.js` 中： \n\n```javascript\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n  \n  if (typeof child === 'function') {\n    child = child.options\n  }\n  const extendsFrom = child.extends\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm)\n  }\n  if (child.mixins) {\n    for (let i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm)\n    }\n  }\n  const options = {}\n  let key\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}\n```\n\n可以看出，`mergeOptions`函数的 主要功能是把 `parent` 和 `child` 这两个对象根据一些合并策略，合并成一个新对象并返回。首先递归把 `extends` 和 `mixins` 合并到 `parent` 上，\n\n```javascript\n const extendsFrom = child.extends\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm)\n  }\n  if (child.mixins) {\n    for (let i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm)\n    }\n  }\n```\n\n然后创建一个空对象`options`，遍历 `parent`，把`parent`中的每一项通过调用 `mergeField`函数合并到空对象`options`里，\n\n```javascript\nconst options = {}\nlet key\nfor (key in parent) {\n    mergeField(key)\n}\n```\n\n接着再遍历 `child`，把存在于`child`里但又不在 `parent`中 的属性继续调用 `mergeField`函数合并到空对象`options`里，\n\n```javascript\nfor (key in child) {\n    if (!hasOwn(parent, key)) {\n        mergeField(key)\n    }\n}\n```\n\n最后，`options`就是最终合并后得到的结果，将其返回。\n\n这里值得一提的是 `mergeField` 函数，它不是简单的把属性从一个对象里复制到另外一个对象里，而是根据被合并的不同的选项有着不同的合并策略。例如，对于`data`有`data`的合并策略，即该文件中的`strats.data`函数；对于`watch`有`watch`的合并策略，即该文件中的`strats.watch`函数等等。这就是设计模式中非常典型的**策略模式**。\n\n关于这些合并策略都很简单，我们不一一展开介绍，仅介绍生命周期钩子函数的合并策略，因为我们后面会用到。生命周期钩子函数的合并策略如下：\n\n```javascript\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (parentVal,childVal):  {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(hook => {\n  strats[hook] = mergeHook\n})\n```\n\n 这其中的 `LIFECYCLE_HOOKS` 的定义在 `src/shared/constants.js` 中： \n\n```javascript\nexport const LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n]\n```\n\n 这里定义了所有钩子函数名称，所以对于钩子函数的合并策略都是 `mergeHook` 函数。`mergeHook` 函数的实现用了一个多层嵌套的三元运算符，如果嵌套太深不好理解的话我们可以将其展开，如下：\n\n ```javascript\nfunction mergeHook (parentVal,childVal):  {\n  if (childVal) {\n    if (parentVal) {\n      return parentVal.concat(childVal)\n    } else {\n      if (Array.isArray(childVal)) {\n        return childVal\n      } else {\n        return [childVal]\n      }\n    }\n  } else {\n    return parentVal\n  }\n}\n ```\n\n 从展开后的代码中可以看到，它的合并策略是这样子的：如果 `childVal`不存在，就返回 `parentVal`；否则再判断是否存在 `parentVal`，如果存在就把 `childVal` 添加到 `parentVal` 后返回新数组；否则返回 `childVal` 的数组。所以回到 `mergeOptions` 函数，一旦 `parent` 和 `child` 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。 \n\n那么问题来了，为什么要把相同的钩子函数转换成数组呢？这是因为`Vue`允许用户使用`Vue.mixin`方法（关于该方法会在后面章节中介绍）向实例混入自定义行为，`Vue`的一些插件通常都是这么做的。所以当`Vue.mixin`和用户在实例化`Vue`时，如果设置了同一个钩子函数，那么在触发钩子函数时，就需要同时触发这个两个函数，所以转换成数组就是为了能在同一个生命周期钩子列表中保存多个钩子函数。\n\n## 4. callHook函数如何触发钩子函数\n\n关于`callHook`函数如何触发钩子函数的问题，我们只需看一下该函数的实现源码即可，该函数的源码位于`src/core/instance/lifecycle.js` 中，如下： \n\n```javascript\nexport function callHook (vm: Component, hook: string) {\n  const handlers = vm.$options[hook]\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm)\n      } catch (e) {\n        handleError(e, vm, `${hook} hook`)\n      }\n    }\n  }\n}\n```\n\n可以看到，`callHook`函数逻辑非常简单。首先从实例的`$options`中获取到需要触发的钩子名称所对应的钩子函数数组`handlers`，我们说过，每个生命周期钩子名称都对应了一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。\n\n## 5. 总结\n\n本篇文章介绍了生命周期第一个阶段——初始化阶段中所做的第一件事：`new Vue()`。\n\n首先，分析了`new Vue()`时其内部都干了些什么。其主要逻辑就是：合并配置，调用一些初始化函数，触发生命周期钩子函数，调用`$mount`开启下一个阶段。\n\n接着，就合并属性进行了详细介绍，知道了对于不同的选项有着不同的合并策略，并挑出钩子函数的合并策略进行了分析。\n\n最后，分析了`callHook`函数的源码，知道了`callHook`函数如何触发钩子函数的。\n\n接下来后面几篇文章将对调用的这些初始化函数进行逐个分析。\n","source":"_posts/Vue 源码阅读 生命周期（二）.md","raw":"---\ntitle: Vue 源码阅读 生命周期（二） \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2020-01-02 11:04:07\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n上篇文章中介绍了`Vue`实例的生命周期大致分为4个阶段，那么首先我们先从第一个阶段——初始化阶段开始入手分析。从生命周期流程图中我们可以看到，初始化阶段所做的工作也可大致分为两部分：第一部分是`new Vue()`，也就是创建一个`Vue`实例；第二部分是为创建好的`Vue`实例初始化一些事件、属性、响应式数据等。接下来我们就从源码角度来深入分析一下初始化阶段所做的工作及其内部原理。\n\n## 2. new Vue()都干了什么\n\n初始化阶段所做的第一件事就是`new Vue()`创建一个`Vue`实例，那么`new Vue()`的内部都干了什么呢？ 我们知道，`new` 关键字在 `JS`中表示从一个类中实例化出一个对象来，由此可见， `Vue` 实际上是一个类。所以`new Vue()`实际上是执行了`Vue`类的构造函数，那么我们来看一下`Vue`类是如何定义的，`Vue`类的定义是在源码的`src/core/instance/index.js` 中，如下：\n\n```javascript\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n可以看到，`Vue`类的定义非常简单，其构造函数核心就一行代码：\n\n```javascript\nthis._init(options)\n```\n\n调用原型上的`_init(options)`方法并把用户所写的选项`options`传入。那这个`_init`方法是从哪来的呢？在`Vue`类定义的下面还有几行代码，其中之一就是：\n\n```javascript\ninitMixin(Vue)\n```\n\n这一行代码执行了`initMixin`函数，那`initMixin`函数又是从哪儿来的呢？该函数定义位于源码的`src/core/instance/init.js` 中，如下：\n\n```javascript\nexport function initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this\n    vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n    )\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n\n可以看到，在`initMixin`函数内部就只干了一件事，那就是给`Vue`类的原型上绑定`_init`方法，同时`_init`方法的定义也在该函数内部。现在我们知道了，`new Vue()`会执行`Vue`类的构造函数，构造函数内部会执行`_init`方法，所以`new Vue()`所干的事情其实就是`_init`方法所干的事情，那么我们着重来分析下`_init`方法都干了哪些事情。\n\n首先，把`Vue`实例赋值给变量`vm`，并且把用户传递的`options`选项与当前构造函数的`options`属性及其父级构造函数的`options`属性进行合并（关于属性如何合并的问题下面会介绍），得到一个新的`options`选项赋值给`$options`属性，并将`$options`属性挂载到`Vue`实例上，如下：\n\n```javascript\nvm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n)\n```\n\n接着，通过调用一些初始化函数来为`Vue`实例初始化一些属性，事件，响应式数据等，如下：\n\n```javascript\ninitLifecycle(vm)       // 初始化生命周期\ninitEvents(vm)        // 初始化事件\ninitRender(vm)         // 初始化渲染\ncallHook(vm, 'beforeCreate')  // 调用生命周期钩子函数\ninitInjections(vm)   //初始化injections\ninitState(vm)    // 初始化props,methods,data,computed,watch\ninitProvide(vm) // 初始化 provide\ncallHook(vm, 'created')  // 调用生命周期钩子函数\n```\n\n可以看到，除了调用初始化函数来进行相关数据的初始化之外，还在合适的时机调用了`callHook`函数来触发生命周期的钩子，关于`callHook`函数是如何触发生命周期的钩子会在下面介绍，我们先继续往下看：\n\n```javascript\nif (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n}\n```\n\n在所有的初始化工作都完成以后，最后，会判断用户是否传入了`el`选项，如果传入了则调用`$mount`函数进入模板编译与挂载阶段，如果没有传入`el`选项，则不进入下一个生命周期阶段，需要用户手动执行`vm.$mount`方法才进入下一个生命周期阶段。\n\n以上就是`new Vue()`所做的所有事情，可以看到，整个初始化阶段都是在`new Vue()`里完成的，关于`new Vue()`里调用的一些初始化函数具体是如何进行初始化的，我们将在接下来的几篇文章里逐一介绍。下面我们先来看看上文中遗留的属性合并及`callHook`函数是如何触发生命周期的钩子的问题。\n\n## 3. 合并属性\n\n在上文中，`_init`方法里首先会调用`mergeOptions`函数来进行属性合并，如下：\n\n```javascript\nvm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n)\n```\n\n\n\n 它实际上就是把 `resolveConstructorOptions(vm.constructor)` 的返回值和 `options` 做合并，`resolveConstructorOptions` 的实现先不考虑，可简单理解为返回 `vm.constructor.options`，相当于 `Vue.options`，那么这个 `Vue.options`又是什么呢，其实在 `initGlobalAPI(Vue)` 的时候定义了这个值，代码在 `src/core/global-api/index.js` 中： \n\n```javascript\nexport function initGlobalAPI (Vue: GlobalAPI) {\n  // ...\n  Vue.options = Object.create(null)\n  ASSET_TYPES.forEach(type => {\n    Vue.options[type + 's'] = Object.create(null)\n  })\n\n  extend(Vue.options.components, builtInComponents)\n  // ...\n}\n```\n\n 首先通过 `Vue.options = Object.create(null)` 创建一个空对象，然后遍历 `ASSET_TYPES`，`ASSET_TYPES` 的定义在 `src/shared/constants.js` 中： \n\n```javascript\nexport const ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n]\n```\n\n所以上面遍历 `ASSET_TYPES` 后的代码相当于：\n\n```js\nVue.options.components = {}\nVue.options.directives = {}\nVue.options.filters = {}\n```\n\n最后通过 `extend(Vue.options.components, builtInComponents)` 把一些内置组件扩展到 `Vue.options.components` 上，`Vue` 的内置组件目前 有`<keep-alive>`、`<transition>` 和`<transition-group>` 组件，这也就是为什么我们在其它组件中使用这些组件不需要注册的原因。\n\n 那么回到 `mergeOptions` 这个函数，它的定义在 `src/core/util/options.js` 中： \n\n```javascript\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n  \n  if (typeof child === 'function') {\n    child = child.options\n  }\n  const extendsFrom = child.extends\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm)\n  }\n  if (child.mixins) {\n    for (let i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm)\n    }\n  }\n  const options = {}\n  let key\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}\n```\n\n可以看出，`mergeOptions`函数的 主要功能是把 `parent` 和 `child` 这两个对象根据一些合并策略，合并成一个新对象并返回。首先递归把 `extends` 和 `mixins` 合并到 `parent` 上，\n\n```javascript\n const extendsFrom = child.extends\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm)\n  }\n  if (child.mixins) {\n    for (let i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm)\n    }\n  }\n```\n\n然后创建一个空对象`options`，遍历 `parent`，把`parent`中的每一项通过调用 `mergeField`函数合并到空对象`options`里，\n\n```javascript\nconst options = {}\nlet key\nfor (key in parent) {\n    mergeField(key)\n}\n```\n\n接着再遍历 `child`，把存在于`child`里但又不在 `parent`中 的属性继续调用 `mergeField`函数合并到空对象`options`里，\n\n```javascript\nfor (key in child) {\n    if (!hasOwn(parent, key)) {\n        mergeField(key)\n    }\n}\n```\n\n最后，`options`就是最终合并后得到的结果，将其返回。\n\n这里值得一提的是 `mergeField` 函数，它不是简单的把属性从一个对象里复制到另外一个对象里，而是根据被合并的不同的选项有着不同的合并策略。例如，对于`data`有`data`的合并策略，即该文件中的`strats.data`函数；对于`watch`有`watch`的合并策略，即该文件中的`strats.watch`函数等等。这就是设计模式中非常典型的**策略模式**。\n\n关于这些合并策略都很简单，我们不一一展开介绍，仅介绍生命周期钩子函数的合并策略，因为我们后面会用到。生命周期钩子函数的合并策略如下：\n\n```javascript\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (parentVal,childVal):  {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(hook => {\n  strats[hook] = mergeHook\n})\n```\n\n 这其中的 `LIFECYCLE_HOOKS` 的定义在 `src/shared/constants.js` 中： \n\n```javascript\nexport const LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n]\n```\n\n 这里定义了所有钩子函数名称，所以对于钩子函数的合并策略都是 `mergeHook` 函数。`mergeHook` 函数的实现用了一个多层嵌套的三元运算符，如果嵌套太深不好理解的话我们可以将其展开，如下：\n\n ```javascript\nfunction mergeHook (parentVal,childVal):  {\n  if (childVal) {\n    if (parentVal) {\n      return parentVal.concat(childVal)\n    } else {\n      if (Array.isArray(childVal)) {\n        return childVal\n      } else {\n        return [childVal]\n      }\n    }\n  } else {\n    return parentVal\n  }\n}\n ```\n\n 从展开后的代码中可以看到，它的合并策略是这样子的：如果 `childVal`不存在，就返回 `parentVal`；否则再判断是否存在 `parentVal`，如果存在就把 `childVal` 添加到 `parentVal` 后返回新数组；否则返回 `childVal` 的数组。所以回到 `mergeOptions` 函数，一旦 `parent` 和 `child` 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。 \n\n那么问题来了，为什么要把相同的钩子函数转换成数组呢？这是因为`Vue`允许用户使用`Vue.mixin`方法（关于该方法会在后面章节中介绍）向实例混入自定义行为，`Vue`的一些插件通常都是这么做的。所以当`Vue.mixin`和用户在实例化`Vue`时，如果设置了同一个钩子函数，那么在触发钩子函数时，就需要同时触发这个两个函数，所以转换成数组就是为了能在同一个生命周期钩子列表中保存多个钩子函数。\n\n## 4. callHook函数如何触发钩子函数\n\n关于`callHook`函数如何触发钩子函数的问题，我们只需看一下该函数的实现源码即可，该函数的源码位于`src/core/instance/lifecycle.js` 中，如下： \n\n```javascript\nexport function callHook (vm: Component, hook: string) {\n  const handlers = vm.$options[hook]\n  if (handlers) {\n    for (let i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm)\n      } catch (e) {\n        handleError(e, vm, `${hook} hook`)\n      }\n    }\n  }\n}\n```\n\n可以看到，`callHook`函数逻辑非常简单。首先从实例的`$options`中获取到需要触发的钩子名称所对应的钩子函数数组`handlers`，我们说过，每个生命周期钩子名称都对应了一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。\n\n## 5. 总结\n\n本篇文章介绍了生命周期第一个阶段——初始化阶段中所做的第一件事：`new Vue()`。\n\n首先，分析了`new Vue()`时其内部都干了些什么。其主要逻辑就是：合并配置，调用一些初始化函数，触发生命周期钩子函数，调用`$mount`开启下一个阶段。\n\n接着，就合并属性进行了详细介绍，知道了对于不同的选项有着不同的合并策略，并挑出钩子函数的合并策略进行了分析。\n\n最后，分析了`callHook`函数的源码，知道了`callHook`函数如何触发钩子函数的。\n\n接下来后面几篇文章将对调用的这些初始化函数进行逐个分析。\n","slug":"Vue 源码阅读 生命周期（二）","published":1,"updated":"2020-01-02T10:44:19.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj880078zws6imeum5wh","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>上篇文章中介绍了<code>Vue</code>实例的生命周期大致分为4个阶段，那么首先我们先从第一个阶段——初始化阶段开始入手分析。从生命周期流程图中我们可以看到，初始化阶段所做的工作也可大致分为两部分：第一部分是<code>new Vue()</code>，也就是创建一个<code>Vue</code>实例；第二部分是为创建好的<code>Vue</code>实例初始化一些事件、属性、响应式数据等。接下来我们就从源码角度来深入分析一下初始化阶段所做的工作及其内部原理。</p>\n<h2><span id=\"2-new-vue都干了什么\">2. new Vue()都干了什么</span></h2>\n<p>初始化阶段所做的第一件事就是<code>new Vue()</code>创建一个<code>Vue</code>实例，那么<code>new Vue()</code>的内部都干了什么呢？ 我们知道，<code>new</code> 关键字在 <code>JS</code>中表示从一个类中实例化出一个对象来，由此可见， <code>Vue</code> 实际上是一个类。所以<code>new Vue()</code>实际上是执行了<code>Vue</code>类的构造函数，那么我们来看一下<code>Vue</code>类是如何定义的，<code>Vue</code>类的定义是在源码的<code>src/core/instance/index.js</code> 中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vue</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">    !(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._init(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>Vue</code>类的定义非常简单，其构造函数核心就一行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._init(options)</span><br></pre></td></tr></table></figure>\n<p>调用原型上的<code>_init(options)</code>方法并把用户所写的选项<code>options</code>传入。那这个<code>_init</code>方法是从哪来的呢？在<code>Vue</code>类定义的下面还有几行代码，其中之一就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initMixin(Vue)</span><br></pre></td></tr></table></figure>\n<p>这一行代码执行了<code>initMixin</code>函数，那<code>initMixin</code>函数又是从哪儿来的呢？该函数定义位于源码的<code>src/core/instance/init.js</code> 中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initMixin</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">this</span></span><br><span class=\"line\">    vm.$options = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">    )</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</span><br><span class=\"line\">    initInjections(vm) <span class=\"comment\">// resolve injections before data/props</span></span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) <span class=\"comment\">// resolve provide after data/props</span></span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在<code>initMixin</code>函数内部就只干了一件事，那就是给<code>Vue</code>类的原型上绑定<code>_init</code>方法，同时<code>_init</code>方法的定义也在该函数内部。现在我们知道了，<code>new Vue()</code>会执行<code>Vue</code>类的构造函数，构造函数内部会执行<code>_init</code>方法，所以<code>new Vue()</code>所干的事情其实就是<code>_init</code>方法所干的事情，那么我们着重来分析下<code>_init</code>方法都干了哪些事情。</p>\n<p>首先，把<code>Vue</code>实例赋值给变量<code>vm</code>，并且把用户传递的<code>options</code>选项与当前构造函数的<code>options</code>属性及其父级构造函数的<code>options</code>属性进行合并（关于属性如何合并的问题下面会介绍），得到一个新的<code>options</code>选项赋值给<code>$options</code>属性，并将<code>$options</code>属性挂载到<code>Vue</code>实例上，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$options = mergeOptions(</span><br><span class=\"line\">    resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">    options || &#123;&#125;,</span><br><span class=\"line\">    vm</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>接着，通过调用一些初始化函数来为<code>Vue</code>实例初始化一些属性，事件，响应式数据等，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initLifecycle(vm)       <span class=\"comment\">// 初始化生命周期</span></span><br><span class=\"line\">initEvents(vm)        <span class=\"comment\">// 初始化事件</span></span><br><span class=\"line\">initRender(vm)         <span class=\"comment\">// 初始化渲染</span></span><br><span class=\"line\">callHook(vm, <span class=\"string\">'beforeCreate'</span>)  <span class=\"comment\">// 调用生命周期钩子函数</span></span><br><span class=\"line\">initInjections(vm)   <span class=\"comment\">//初始化injections</span></span><br><span class=\"line\">initState(vm)    <span class=\"comment\">// 初始化props,methods,data,computed,watch</span></span><br><span class=\"line\">initProvide(vm) <span class=\"comment\">// 初始化 provide</span></span><br><span class=\"line\">callHook(vm, <span class=\"string\">'created'</span>)  <span class=\"comment\">// 调用生命周期钩子函数</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，除了调用初始化函数来进行相关数据的初始化之外，还在合适的时机调用了<code>callHook</code>函数来触发生命周期的钩子，关于<code>callHook</code>函数是如何触发生命周期的钩子会在下面介绍，我们先继续往下看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (vm.$options.el) &#123;</span><br><span class=\"line\">    vm.$mount(vm.$options.el)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在所有的初始化工作都完成以后，最后，会判断用户是否传入了<code>el</code>选项，如果传入了则调用<code>$mount</code>函数进入模板编译与挂载阶段，如果没有传入<code>el</code>选项，则不进入下一个生命周期阶段，需要用户手动执行<code>vm.$mount</code>方法才进入下一个生命周期阶段。</p>\n<p>以上就是<code>new Vue()</code>所做的所有事情，可以看到，整个初始化阶段都是在<code>new Vue()</code>里完成的，关于<code>new Vue()</code>里调用的一些初始化函数具体是如何进行初始化的，我们将在接下来的几篇文章里逐一介绍。下面我们先来看看上文中遗留的属性合并及<code>callHook</code>函数是如何触发生命周期的钩子的问题。</p>\n<h2><span id=\"3-合并属性\">3. 合并属性</span></h2>\n<p>在上文中，<code>_init</code>方法里首先会调用<code>mergeOptions</code>函数来进行属性合并，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$options = mergeOptions(</span><br><span class=\"line\">    resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">    options || &#123;&#125;,</span><br><span class=\"line\">    vm</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>它实际上就是把 <code>resolveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，<code>resolveConstructorOptions</code> 的实现先不考虑，可简单理解为返回 <code>vm.constructor.options</code>，相当于 <code>Vue.options</code>，那么这个 <code>Vue.options</code>又是什么呢，其实在 <code>initGlobalAPI(Vue)</code> 的时候定义了这个值，代码在 <code>src/core/global-api/index.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initGlobalAPI</span> (<span class=\"params\">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  Vue.options = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  ASSET_TYPES.forEach(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> &#123;</span><br><span class=\"line\">    Vue.options[type + <span class=\"string\">'s'</span>] = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  extend(Vue.options.components, builtInComponents)</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先通过 <code>Vue.options = Object.create(null)</code> 创建一个空对象，然后遍历 <code>ASSET_TYPES</code>，<code>ASSET_TYPES</code> 的定义在 <code>src/shared/constants.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ASSET_TYPES = [</span><br><span class=\"line\">  <span class=\"string\">'component'</span>,</span><br><span class=\"line\">  <span class=\"string\">'directive'</span>,</span><br><span class=\"line\">  <span class=\"string\">'filter'</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>所以上面遍历 <code>ASSET_TYPES</code> 后的代码相当于：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.options.components = &#123;&#125;</span><br><span class=\"line\">Vue.options.directives = &#123;&#125;</span><br><span class=\"line\">Vue.options.filters = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>最后通过 <code>extend(Vue.options.components, builtInComponents)</code> 把一些内置组件扩展到 <code>Vue.options.components</code> 上，<code>Vue</code> 的内置组件目前 有<code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code> 和<code>&lt;transition-group&gt;</code> 组件，这也就是为什么我们在其它组件中使用这些组件不需要注册的原因。</p>\n<p>那么回到 <code>mergeOptions</code> 这个函数，它的定义在 <code>src/core/util/options.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Merge two option objects into a new one.</span></span><br><span class=\"line\"><span class=\"comment\"> * Core utility used in both instantiation and inheritance.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeOptions</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  parent: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  child: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  vm?: Component</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Object</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> child === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    child = child.options</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> extendsFrom = child.extends</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (extendsFrom) &#123;</span><br><span class=\"line\">    parent = mergeOptions(parent, extendsFrom, vm)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (child.mixins) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> key</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> parent) &#123;</span><br><span class=\"line\">    mergeField(key)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class=\"line\">      mergeField(key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeField</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> strat = strats[key] || defaultStrat</span><br><span class=\"line\">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> options</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，<code>mergeOptions</code>函数的 主要功能是把 <code>parent</code> 和 <code>child</code> 这两个对象根据一些合并策略，合并成一个新对象并返回。首先递归把 <code>extends</code> 和 <code>mixins</code> 合并到 <code>parent</code> 上，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> extendsFrom = child.extends</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (extendsFrom) &#123;</span><br><span class=\"line\">   parent = mergeOptions(parent, extendsFrom, vm)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (child.mixins) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">     parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>然后创建一个空对象<code>options</code>，遍历 <code>parent</code>，把<code>parent</code>中的每一项通过调用 <code>mergeField</code>函数合并到空对象<code>options</code>里，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> options = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> key</span><br><span class=\"line\"><span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> parent) &#123;</span><br><span class=\"line\">    mergeField(key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着再遍历 <code>child</code>，把存在于<code>child</code>里但又不在 <code>parent</code>中 的属性继续调用 <code>mergeField</code>函数合并到空对象<code>options</code>里，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class=\"line\">        mergeField(key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，<code>options</code>就是最终合并后得到的结果，将其返回。</p>\n<p>这里值得一提的是 <code>mergeField</code> 函数，它不是简单的把属性从一个对象里复制到另外一个对象里，而是根据被合并的不同的选项有着不同的合并策略。例如，对于<code>data</code>有<code>data</code>的合并策略，即该文件中的<code>strats.data</code>函数；对于<code>watch</code>有<code>watch</code>的合并策略，即该文件中的<code>strats.watch</code>函数等等。这就是设计模式中非常典型的<strong>策略模式</strong>。</p>\n<p>关于这些合并策略都很简单，我们不一一展开介绍，仅介绍生命周期钩子函数的合并策略，因为我们后面会用到。生命周期钩子函数的合并策略如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Hooks and props are merged as arrays.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeHook</span> (<span class=\"params\">parentVal,childVal</span>):  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> childVal</span><br><span class=\"line\">    ? parentVal</span><br><span class=\"line\">      ? parentVal.concat(childVal)</span><br><span class=\"line\">      : <span class=\"built_in\">Array</span>.isArray(childVal)</span><br><span class=\"line\">        ? childVal</span><br><span class=\"line\">        : [childVal]</span><br><span class=\"line\">    : parentVal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">LIFECYCLE_HOOKS.forEach(<span class=\"function\"><span class=\"params\">hook</span> =&gt;</span> &#123;</span><br><span class=\"line\">  strats[hook] = mergeHook</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这其中的 <code>LIFECYCLE_HOOKS</code> 的定义在 <code>src/shared/constants.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> LIFECYCLE_HOOKS = [</span><br><span class=\"line\">  <span class=\"string\">'beforeCreate'</span>,</span><br><span class=\"line\">  <span class=\"string\">'created'</span>,</span><br><span class=\"line\">  <span class=\"string\">'beforeMount'</span>,</span><br><span class=\"line\">  <span class=\"string\">'mounted'</span>,</span><br><span class=\"line\">  <span class=\"string\">'beforeUpdate'</span>,</span><br><span class=\"line\">  <span class=\"string\">'updated'</span>,</span><br><span class=\"line\">  <span class=\"string\">'beforeDestroy'</span>,</span><br><span class=\"line\">  <span class=\"string\">'destroyed'</span>,</span><br><span class=\"line\">  <span class=\"string\">'activated'</span>,</span><br><span class=\"line\">  <span class=\"string\">'deactivated'</span>,</span><br><span class=\"line\">  <span class=\"string\">'errorCaptured'</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这里定义了所有钩子函数名称，所以对于钩子函数的合并策略都是 <code>mergeHook</code> 函数。<code>mergeHook</code> 函数的实现用了一个多层嵌套的三元运算符，如果嵌套太深不好理解的话我们可以将其展开，如下：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeHook</span> (<span class=\"params\">parentVal,childVal</span>):  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childVal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parentVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> parentVal.concat(childVal)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(childVal)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> childVal</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [childVal]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parentVal</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从展开后的代码中可以看到，它的合并策略是这样子的：如果 <code>childVal</code>不存在，就返回 <code>parentVal</code>；否则再判断是否存在 <code>parentVal</code>，如果存在就把 <code>childVal</code> 添加到 <code>parentVal</code> 后返回新数组；否则返回 <code>childVal</code> 的数组。所以回到 <code>mergeOptions</code> 函数，一旦 <code>parent</code> 和 <code>child</code> 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。</p>\n<p>那么问题来了，为什么要把相同的钩子函数转换成数组呢？这是因为<code>Vue</code>允许用户使用<code>Vue.mixin</code>方法（关于该方法会在后面章节中介绍）向实例混入自定义行为，<code>Vue</code>的一些插件通常都是这么做的。所以当<code>Vue.mixin</code>和用户在实例化<code>Vue</code>时，如果设置了同一个钩子函数，那么在触发钩子函数时，就需要同时触发这个两个函数，所以转换成数组就是为了能在同一个生命周期钩子列表中保存多个钩子函数。</p>\n<h2><span id=\"4-callhook函数如何触发钩子函数\">4. callHook函数如何触发钩子函数</span></h2>\n<p>关于<code>callHook</code>函数如何触发钩子函数的问题，我们只需看一下该函数的实现源码即可，该函数的源码位于<code>src/core/instance/lifecycle.js</code> 中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callHook</span> (<span class=\"params\">vm: Component, hook: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handlers = vm.$options[hook]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handlers) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handlers[i].call(vm)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        handleError(e, vm, <span class=\"string\">`<span class=\"subst\">$&#123;hook&#125;</span> hook`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>callHook</code>函数逻辑非常简单。首先从实例的<code>$options</code>中获取到需要触发的钩子名称所对应的钩子函数数组<code>handlers</code>，我们说过，每个生命周期钩子名称都对应了一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。</p>\n<h2><span id=\"5-总结\">5. 总结</span></h2>\n<p>本篇文章介绍了生命周期第一个阶段——初始化阶段中所做的第一件事：<code>new Vue()</code>。</p>\n<p>首先，分析了<code>new Vue()</code>时其内部都干了些什么。其主要逻辑就是：合并配置，调用一些初始化函数，触发生命周期钩子函数，调用<code>$mount</code>开启下一个阶段。</p>\n<p>接着，就合并属性进行了详细介绍，知道了对于不同的选项有着不同的合并策略，并挑出钩子函数的合并策略进行了分析。</p>\n<p>最后，分析了<code>callHook</code>函数的源码，知道了<code>callHook</code>函数如何触发钩子函数的。</p>\n<p>接下来后面几篇文章将对调用的这些初始化函数进行逐个分析。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>上篇文章中介绍了<code>Vue</code>实例的生命周期大致分为4个阶段，那么首先我们先从第一个阶段——初始化阶段开始入手分析。从生命周期流程图中我们可以看到，初始化阶段所做的工作也可大致分为两部分：第一部分是<code>new Vue()</code>，也就是创建一个<code>Vue</code>实例；第二部分是为创建好的<code>Vue</code>实例初始化一些事件、属性、响应式数据等。接下来我们就从源码角度来深入分析一下初始化阶段所做的工作及其内部原理。</p>\n<h2>2. new Vue()都干了什么</h2>\n<p>初始化阶段所做的第一件事就是<code>new Vue()</code>创建一个<code>Vue</code>实例，那么<code>new Vue()</code>的内部都干了什么呢？ 我们知道，<code>new</code> 关键字在 <code>JS</code>中表示从一个类中实例化出一个对象来，由此可见， <code>Vue</code> 实际上是一个类。所以<code>new Vue()</code>实际上是执行了<code>Vue</code>类的构造函数，那么我们来看一下<code>Vue</code>类是如何定义的，<code>Vue</code>类的定义是在源码的<code>src/core/instance/index.js</code> 中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Vue</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">    !(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._init(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>Vue</code>类的定义非常简单，其构造函数核心就一行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>._init(options)</span><br></pre></td></tr></table></figure>\n<p>调用原型上的<code>_init(options)</code>方法并把用户所写的选项<code>options</code>传入。那这个<code>_init</code>方法是从哪来的呢？在<code>Vue</code>类定义的下面还有几行代码，其中之一就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initMixin(Vue)</span><br></pre></td></tr></table></figure>\n<p>这一行代码执行了<code>initMixin</code>函数，那<code>initMixin</code>函数又是从哪儿来的呢？该函数定义位于源码的<code>src/core/instance/init.js</code> 中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initMixin</span> (<span class=\"params\">Vue</span>) </span>&#123;</span><br><span class=\"line\">  Vue.prototype._init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> vm = <span class=\"keyword\">this</span></span><br><span class=\"line\">    vm.$options = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">    )</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'beforeCreate'</span>)</span><br><span class=\"line\">    initInjections(vm) <span class=\"comment\">// resolve injections before data/props</span></span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) <span class=\"comment\">// resolve provide after data/props</span></span><br><span class=\"line\">    callHook(vm, <span class=\"string\">'created'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在<code>initMixin</code>函数内部就只干了一件事，那就是给<code>Vue</code>类的原型上绑定<code>_init</code>方法，同时<code>_init</code>方法的定义也在该函数内部。现在我们知道了，<code>new Vue()</code>会执行<code>Vue</code>类的构造函数，构造函数内部会执行<code>_init</code>方法，所以<code>new Vue()</code>所干的事情其实就是<code>_init</code>方法所干的事情，那么我们着重来分析下<code>_init</code>方法都干了哪些事情。</p>\n<p>首先，把<code>Vue</code>实例赋值给变量<code>vm</code>，并且把用户传递的<code>options</code>选项与当前构造函数的<code>options</code>属性及其父级构造函数的<code>options</code>属性进行合并（关于属性如何合并的问题下面会介绍），得到一个新的<code>options</code>选项赋值给<code>$options</code>属性，并将<code>$options</code>属性挂载到<code>Vue</code>实例上，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$options = mergeOptions(</span><br><span class=\"line\">    resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">    options || &#123;&#125;,</span><br><span class=\"line\">    vm</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>接着，通过调用一些初始化函数来为<code>Vue</code>实例初始化一些属性，事件，响应式数据等，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initLifecycle(vm)       <span class=\"comment\">// 初始化生命周期</span></span><br><span class=\"line\">initEvents(vm)        <span class=\"comment\">// 初始化事件</span></span><br><span class=\"line\">initRender(vm)         <span class=\"comment\">// 初始化渲染</span></span><br><span class=\"line\">callHook(vm, <span class=\"string\">'beforeCreate'</span>)  <span class=\"comment\">// 调用生命周期钩子函数</span></span><br><span class=\"line\">initInjections(vm)   <span class=\"comment\">//初始化injections</span></span><br><span class=\"line\">initState(vm)    <span class=\"comment\">// 初始化props,methods,data,computed,watch</span></span><br><span class=\"line\">initProvide(vm) <span class=\"comment\">// 初始化 provide</span></span><br><span class=\"line\">callHook(vm, <span class=\"string\">'created'</span>)  <span class=\"comment\">// 调用生命周期钩子函数</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，除了调用初始化函数来进行相关数据的初始化之外，还在合适的时机调用了<code>callHook</code>函数来触发生命周期的钩子，关于<code>callHook</code>函数是如何触发生命周期的钩子会在下面介绍，我们先继续往下看：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (vm.$options.el) &#123;</span><br><span class=\"line\">    vm.$mount(vm.$options.el)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在所有的初始化工作都完成以后，最后，会判断用户是否传入了<code>el</code>选项，如果传入了则调用<code>$mount</code>函数进入模板编译与挂载阶段，如果没有传入<code>el</code>选项，则不进入下一个生命周期阶段，需要用户手动执行<code>vm.$mount</code>方法才进入下一个生命周期阶段。</p>\n<p>以上就是<code>new Vue()</code>所做的所有事情，可以看到，整个初始化阶段都是在<code>new Vue()</code>里完成的，关于<code>new Vue()</code>里调用的一些初始化函数具体是如何进行初始化的，我们将在接下来的几篇文章里逐一介绍。下面我们先来看看上文中遗留的属性合并及<code>callHook</code>函数是如何触发生命周期的钩子的问题。</p>\n<h2>3. 合并属性</h2>\n<p>在上文中，<code>_init</code>方法里首先会调用<code>mergeOptions</code>函数来进行属性合并，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$options = mergeOptions(</span><br><span class=\"line\">    resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">    options || &#123;&#125;,</span><br><span class=\"line\">    vm</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>它实际上就是把 <code>resolveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，<code>resolveConstructorOptions</code> 的实现先不考虑，可简单理解为返回 <code>vm.constructor.options</code>，相当于 <code>Vue.options</code>，那么这个 <code>Vue.options</code>又是什么呢，其实在 <code>initGlobalAPI(Vue)</code> 的时候定义了这个值，代码在 <code>src/core/global-api/index.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initGlobalAPI</span> (<span class=\"params\">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  Vue.options = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  ASSET_TYPES.forEach(<span class=\"function\"><span class=\"params\">type</span> =&gt;</span> &#123;</span><br><span class=\"line\">    Vue.options[type + <span class=\"string\">'s'</span>] = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  extend(Vue.options.components, builtInComponents)</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先通过 <code>Vue.options = Object.create(null)</code> 创建一个空对象，然后遍历 <code>ASSET_TYPES</code>，<code>ASSET_TYPES</code> 的定义在 <code>src/shared/constants.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ASSET_TYPES = [</span><br><span class=\"line\">  <span class=\"string\">'component'</span>,</span><br><span class=\"line\">  <span class=\"string\">'directive'</span>,</span><br><span class=\"line\">  <span class=\"string\">'filter'</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>所以上面遍历 <code>ASSET_TYPES</code> 后的代码相当于：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.options.components = &#123;&#125;</span><br><span class=\"line\">Vue.options.directives = &#123;&#125;</span><br><span class=\"line\">Vue.options.filters = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>最后通过 <code>extend(Vue.options.components, builtInComponents)</code> 把一些内置组件扩展到 <code>Vue.options.components</code> 上，<code>Vue</code> 的内置组件目前 有<code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code> 和<code>&lt;transition-group&gt;</code> 组件，这也就是为什么我们在其它组件中使用这些组件不需要注册的原因。</p>\n<p>那么回到 <code>mergeOptions</code> 这个函数，它的定义在 <code>src/core/util/options.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Merge two option objects into a new one.</span></span><br><span class=\"line\"><span class=\"comment\"> * Core utility used in both instantiation and inheritance.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeOptions</span> (<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  parent: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  child: Object,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  vm?: Component</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">Object</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> child === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    child = child.options</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> extendsFrom = child.extends</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (extendsFrom) &#123;</span><br><span class=\"line\">    parent = mergeOptions(parent, extendsFrom, vm)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (child.mixins) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> options = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> key</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> parent) &#123;</span><br><span class=\"line\">    mergeField(key)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class=\"line\">      mergeField(key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeField</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> strat = strats[key] || defaultStrat</span><br><span class=\"line\">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> options</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，<code>mergeOptions</code>函数的 主要功能是把 <code>parent</code> 和 <code>child</code> 这两个对象根据一些合并策略，合并成一个新对象并返回。首先递归把 <code>extends</code> 和 <code>mixins</code> 合并到 <code>parent</code> 上，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> extendsFrom = child.extends</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (extendsFrom) &#123;</span><br><span class=\"line\">   parent = mergeOptions(parent, extendsFrom, vm)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (child.mixins) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">     parent = mergeOptions(parent, child.mixins[i], vm)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>然后创建一个空对象<code>options</code>，遍历 <code>parent</code>，把<code>parent</code>中的每一项通过调用 <code>mergeField</code>函数合并到空对象<code>options</code>里，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> options = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> key</span><br><span class=\"line\"><span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> parent) &#123;</span><br><span class=\"line\">    mergeField(key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着再遍历 <code>child</code>，把存在于<code>child</code>里但又不在 <code>parent</code>中 的属性继续调用 <code>mergeField</code>函数合并到空对象<code>options</code>里，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (key <span class=\"keyword\">in</span> child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class=\"line\">        mergeField(key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，<code>options</code>就是最终合并后得到的结果，将其返回。</p>\n<p>这里值得一提的是 <code>mergeField</code> 函数，它不是简单的把属性从一个对象里复制到另外一个对象里，而是根据被合并的不同的选项有着不同的合并策略。例如，对于<code>data</code>有<code>data</code>的合并策略，即该文件中的<code>strats.data</code>函数；对于<code>watch</code>有<code>watch</code>的合并策略，即该文件中的<code>strats.watch</code>函数等等。这就是设计模式中非常典型的<strong>策略模式</strong>。</p>\n<p>关于这些合并策略都很简单，我们不一一展开介绍，仅介绍生命周期钩子函数的合并策略，因为我们后面会用到。生命周期钩子函数的合并策略如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Hooks and props are merged as arrays.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeHook</span> (<span class=\"params\">parentVal,childVal</span>):  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> childVal</span><br><span class=\"line\">    ? parentVal</span><br><span class=\"line\">      ? parentVal.concat(childVal)</span><br><span class=\"line\">      : <span class=\"built_in\">Array</span>.isArray(childVal)</span><br><span class=\"line\">        ? childVal</span><br><span class=\"line\">        : [childVal]</span><br><span class=\"line\">    : parentVal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">LIFECYCLE_HOOKS.forEach(<span class=\"function\"><span class=\"params\">hook</span> =&gt;</span> &#123;</span><br><span class=\"line\">  strats[hook] = mergeHook</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这其中的 <code>LIFECYCLE_HOOKS</code> 的定义在 <code>src/shared/constants.js</code> 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> LIFECYCLE_HOOKS = [</span><br><span class=\"line\">  <span class=\"string\">'beforeCreate'</span>,</span><br><span class=\"line\">  <span class=\"string\">'created'</span>,</span><br><span class=\"line\">  <span class=\"string\">'beforeMount'</span>,</span><br><span class=\"line\">  <span class=\"string\">'mounted'</span>,</span><br><span class=\"line\">  <span class=\"string\">'beforeUpdate'</span>,</span><br><span class=\"line\">  <span class=\"string\">'updated'</span>,</span><br><span class=\"line\">  <span class=\"string\">'beforeDestroy'</span>,</span><br><span class=\"line\">  <span class=\"string\">'destroyed'</span>,</span><br><span class=\"line\">  <span class=\"string\">'activated'</span>,</span><br><span class=\"line\">  <span class=\"string\">'deactivated'</span>,</span><br><span class=\"line\">  <span class=\"string\">'errorCaptured'</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这里定义了所有钩子函数名称，所以对于钩子函数的合并策略都是 <code>mergeHook</code> 函数。<code>mergeHook</code> 函数的实现用了一个多层嵌套的三元运算符，如果嵌套太深不好理解的话我们可以将其展开，如下：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeHook</span> (<span class=\"params\">parentVal,childVal</span>):  </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childVal) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parentVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> parentVal.concat(childVal)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(childVal)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> childVal</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [childVal]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parentVal</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从展开后的代码中可以看到，它的合并策略是这样子的：如果 <code>childVal</code>不存在，就返回 <code>parentVal</code>；否则再判断是否存在 <code>parentVal</code>，如果存在就把 <code>childVal</code> 添加到 <code>parentVal</code> 后返回新数组；否则返回 <code>childVal</code> 的数组。所以回到 <code>mergeOptions</code> 函数，一旦 <code>parent</code> 和 <code>child</code> 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。</p>\n<p>那么问题来了，为什么要把相同的钩子函数转换成数组呢？这是因为<code>Vue</code>允许用户使用<code>Vue.mixin</code>方法（关于该方法会在后面章节中介绍）向实例混入自定义行为，<code>Vue</code>的一些插件通常都是这么做的。所以当<code>Vue.mixin</code>和用户在实例化<code>Vue</code>时，如果设置了同一个钩子函数，那么在触发钩子函数时，就需要同时触发这个两个函数，所以转换成数组就是为了能在同一个生命周期钩子列表中保存多个钩子函数。</p>\n<h2>4. callHook函数如何触发钩子函数</h2>\n<p>关于<code>callHook</code>函数如何触发钩子函数的问题，我们只需看一下该函数的实现源码即可，该函数的源码位于<code>src/core/instance/lifecycle.js</code> 中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callHook</span> (<span class=\"params\">vm: Component, hook: string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handlers = vm.$options[hook]</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (handlers) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handlers[i].call(vm)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        handleError(e, vm, <span class=\"string\">`<span class=\"subst\">$&#123;hook&#125;</span> hook`</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>callHook</code>函数逻辑非常简单。首先从实例的<code>$options</code>中获取到需要触发的钩子名称所对应的钩子函数数组<code>handlers</code>，我们说过，每个生命周期钩子名称都对应了一个钩子函数数组。然后遍历该数组，将数组中的每个钩子函数都执行一遍。</p>\n<h2>5. 总结</h2>\n<p>本篇文章介绍了生命周期第一个阶段——初始化阶段中所做的第一件事：<code>new Vue()</code>。</p>\n<p>首先，分析了<code>new Vue()</code>时其内部都干了些什么。其主要逻辑就是：合并配置，调用一些初始化函数，触发生命周期钩子函数，调用<code>$mount</code>开启下一个阶段。</p>\n<p>接着，就合并属性进行了详细介绍，知道了对于不同的选项有着不同的合并策略，并挑出钩子函数的合并策略进行了分析。</p>\n<p>最后，分析了<code>callHook</code>函数的源码，知道了<code>callHook</code>函数如何触发钩子函数的。</p>\n<p>接下来后面几篇文章将对调用的这些初始化函数进行逐个分析。</p>\n"},{"title":"微信小程序开发技术选型分享","catalog":true,"url":"117.html","id":"117","date":"2019-02-21T04:28:11.000Z","subtitle":null,"header-img":null,"_content":"\n微信小程序开发技术分享:anchor:\n===================\n\n![](http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg)\n\n##### 目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。\n\n### 什么是Taro?\n\n多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。\n\n### 为什么要用Taro?\n\n当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.jpg)\n\n### Taro与其它框架进行对比\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png) ![image](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png)\n\n对比分析\n\n微信小程序\n\nmpuve\n\nwepy\n\nTaro\n\n语法规范\n\n小程序规范\n\nVue.js规范\n\n类Vue.js规范\n\nReact规范\n\n模板系统\n\n字符串模板\n\n字符串模板\n\n字符串模板\n\nJSX\n\n类型系统\n\n不支持\n\n业务代码\n\n业务代码\n\n业务代码 \\+ JSX\n\n组件规范\n\n小程序组件\n\nHTML标签+小程序组件\n\n小程序组件\n\n小程序组件\n\n样式规范\n\nwxss\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\n组件化\n\n小程序组件化\n\nVue组件化\n\n自定义组件化\n\nReact组件化\n\n多端复用\n\n复用，不存在的\n\nH5,APP(Weex)等\n\n没看到有介绍\n\nH5,APP(ReactNative)等\n\n自动构建\n\n无\n\nwebpack\n\n内部构建系统\n\nwebpack+内部构建系统\n\n开发要求\n\n全新学习\n\n熟悉Vue语法即可\n\n熟悉Vue+wepy语法\n\n熟悉React语法\n\n数据流管理\n\n无\n\nVuex\n\nRedux\n\nRedux+React-thunk\n\n> 从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。\n\n### Taro框架设计思想 [具体细节请看官网](https://nervjs.github.io/taro/)\n\n> 图片来源于网络 ![image](http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png)\n\n### Taro特性\n\n*   React 语法风格\n*   快速开发微信小程序\n    *   支持使用 npm/yarn 安装管理第三方依赖\n    *   支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置\n    *   支持使用 CSS 预编译器，例如 Sass 等\n    *   支持使用 Redux进行状态管理\n    *   小程序API优化，异步API Promise化等等\n*   支持多端开发转化\n\n> ### 开发配置\n\n*   环境配置\n    *   sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)\n    *   npm init lavectorApp && cd lavctorApp && npm run dev:weapp/h5\n    *   用微信开发者工具添加项目打开dist目录即可\n*   页面设计尺寸配置\n    *   Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改\n    *   Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位\n*   编辑器\n    *   建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网....\n\n> ### 如何引用fontAwesome字体文件\n\n比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 [查看](https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css) 如何使用： \\`\\`\\`javascript import Taro, { Component } from '@tarojs/taro'; import { View, Icon, Image } from '@tarojs/components'; import 'your/path/fontawesome.css' //引用图片 import img from 'your/path/image.png' export default class Icon extends Taro.Component { ...... render(){ <View className='icon_box'> <Icon className='fa fa-home'/> <Image src={img} /> </View> } } \\`\\`\\`\n\n> ### 页面配置\n\n    //是不是跟小程序入口配置文件差不多?\n    config = {\n    // pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n        pages: [\n          'pages/book/book',\n          'pages/detail/detail',\n          'pages/user/user',\n          'pages/index/index'\n        ],\n        window: {\n          backgroundTextStyle: 'light',\n          navigationBarBackgroundColor: '#f55002',\n          navigationBarTitleText: '首页',\n          navigationBarTextStyle: 'light',\n          enablePullDownRefresh: false,\n          onReachBottomDistance: 30,\n          backgroundColor: '#f55002'\n        },\n        tabBar: {\n          backgroundColor: '#eee',\n          selectedColor: '#f55002',\n          color: '#aaa',\n          borderStyle: '#f55002',\n          list: [\n            {\n              pagePath: 'pages/index/index',\n              iconPath: './static/images/home_default.png',\n              selectedIconPath: './static/images/home_selected.png',\n              text: '首页'\n            },\n            {\n              pagePath: 'pages/book/book',\n              iconPath: './static/images/book_default.png',\n              selectedIconPath: './static/images/book_selected.png',\n              text: '书架'\n            },\n            {\n              pagePath: 'pages/user/user',\n              text: '我的',\n              iconPath: './static/images/user_default.png',\n              selectedIconPath: './static/images/user_selected.png'\n            }\n          ]\n        },\n        networkTimeout: {\n          request: 6000,\n          downloadFile: 10000\n        },\n        debug: true\n      };\n    \n    \n\n> ### 消息机制\n> \n> > #### Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~\n\n    import Taro, {Events} from '@tarojs/taro'\n    const events = new Events()\n    // 监听一个事件，接受参数\n    events.on('eventName', (arg) => {\n      // doSth\n    })\n    // 监听同个事件，同时绑定多个handler\n    events.on('eventName', handler1)\n    events.on('eventName', handler2)\n    events.on('eventName', handler3)\n    // 触发一个事件，传参\n    events.trigger('eventName', arg)\n    // 触发事件，传入多个参数\n    events.trigger('eventName', arg1, arg2, ...)\n    // 取消监听一个事件\n    events.off('eventName')\n    // 取消监听一个事件某个handler\n    events.off('eventName', handler1)\n    // 取消监听所有事件\n    events.off()\n    \n\n同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例\n\n    import Taro from '@tarojs/taro'\n    \n    Taro.eventCenter.on\n    Taro.eventCenter.trigger\n    Taro.eventCenter.off\n    \n\n> ### :checkered_flag: 组件和页面的定义\n\n``javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { <!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--> backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ <!--DOM 只能写在render函数中--> const test = `test` return ( <!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--> <View className='lavectorApp' style='background:#fff'> <Text>hello Lavector<Text> <Text>{test}</Text> // Taro中所有的事件都要以On 开头 <Button onClick={this.toOtherPage.bind(this,'params')}>To Other Page</Button> </View> ); } }``\n\n> ### 配合使用Redux\n> \n> > ##### 在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件\n> > \n> > npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger\n\n    // src/store/index.js\n    import { createStore, applyMiddleware } from 'redux'\n    import thunkMiddleware from 'redux-thunk'\n    import { createLogger } from 'redux-logger'\n    import rootReducer from '../reducers'\n    \n    const middlewares = [\n      thunkMiddleware,\n      createLogger()\n    ]\n    \n    export default function configStore () {\n      const store = createStore(rootReducer, applyMiddleware(...middlewares))\n      return store\n    }\n    \n\n入口文件app.js\n\n    // src/app.js\n    import Taro, { Component } from '@tarojs/taro'\n    import { Provider } from '@tarojs/redux'\n    \n    import configStore from './store'\n    import Index from './pages/index'\n    \n    import './app.scss'\n    \n    const store = configStore()\n    \n    class App extends Component {\n      config = {\n        pages: [\n          'pages/index/index'\n        ],\n        window: {\n          navigationBarTitleText: 'Test'\n        }\n      }\n    \n      render() {\n        return (\n          <Provider store={store}>\n            <Index />\n          </Provider>\n        )\n      }\n    }\n    \n    Taro.render(<App />, document.getElementById('app'))\n    \n    \n\n> 然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)\n\n补充 JSX语法支持程度\n============\n\n*   不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）\n*   不能在包含 JSX 元素的 map 循环中使用 if 表达式\n*   不能使用 Array#map 之外的方法操作 JSX 数组\n*   不能在 JSX 参数中使用匿名函数\n*   暂不支持在 render() 之外的方法定义 JSX\n*   不允许在 JSX 参数(props)中传入 JSX 元素\n*   不能在 JSX 参数中使用对象展开符*   不支持无状态组件\n\n### 结束语\n\n无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。\n\n> 以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网[京东Taro](https://nervjs.github.io/taro/)\n\n### 可能你需要学习的：\n\n【Mpvue】(http://mpvue.com/) 【Mpvue资源合集】(https://github.com/mpvue/awesome-mpvue) 【Taro】(https://nervjs.github.io/taro/) 【Vuejs】(https://cn.vuejs.org/) 【Redux】(http://www.redux.org.cn/)","source":"_posts/微信小程序开发技术选型分享.md","raw":"---\ntitle: 微信小程序开发技术选型分享\ncatalog: true\nurl: 117.html\nid: 117\ncategories:\n  - 微信小程序\ndate: 2019-02-21 12:28:11\nsubtitle:\nheader-img:\ntags:\n---\n\n微信小程序开发技术分享:anchor:\n===================\n\n![](http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg)\n\n##### 目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。\n\n### 什么是Taro?\n\n多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。\n\n### 为什么要用Taro?\n\n当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.jpg)\n\n### Taro与其它框架进行对比\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png) ![image](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png)\n\n对比分析\n\n微信小程序\n\nmpuve\n\nwepy\n\nTaro\n\n语法规范\n\n小程序规范\n\nVue.js规范\n\n类Vue.js规范\n\nReact规范\n\n模板系统\n\n字符串模板\n\n字符串模板\n\n字符串模板\n\nJSX\n\n类型系统\n\n不支持\n\n业务代码\n\n业务代码\n\n业务代码 \\+ JSX\n\n组件规范\n\n小程序组件\n\nHTML标签+小程序组件\n\n小程序组件\n\n小程序组件\n\n样式规范\n\nwxss\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\n组件化\n\n小程序组件化\n\nVue组件化\n\n自定义组件化\n\nReact组件化\n\n多端复用\n\n复用，不存在的\n\nH5,APP(Weex)等\n\n没看到有介绍\n\nH5,APP(ReactNative)等\n\n自动构建\n\n无\n\nwebpack\n\n内部构建系统\n\nwebpack+内部构建系统\n\n开发要求\n\n全新学习\n\n熟悉Vue语法即可\n\n熟悉Vue+wepy语法\n\n熟悉React语法\n\n数据流管理\n\n无\n\nVuex\n\nRedux\n\nRedux+React-thunk\n\n> 从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。\n\n### Taro框架设计思想 [具体细节请看官网](https://nervjs.github.io/taro/)\n\n> 图片来源于网络 ![image](http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png)\n\n### Taro特性\n\n*   React 语法风格\n*   快速开发微信小程序\n    *   支持使用 npm/yarn 安装管理第三方依赖\n    *   支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置\n    *   支持使用 CSS 预编译器，例如 Sass 等\n    *   支持使用 Redux进行状态管理\n    *   小程序API优化，异步API Promise化等等\n*   支持多端开发转化\n\n> ### 开发配置\n\n*   环境配置\n    *   sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)\n    *   npm init lavectorApp && cd lavctorApp && npm run dev:weapp/h5\n    *   用微信开发者工具添加项目打开dist目录即可\n*   页面设计尺寸配置\n    *   Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改\n    *   Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位\n*   编辑器\n    *   建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网....\n\n> ### 如何引用fontAwesome字体文件\n\n比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 [查看](https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css) 如何使用： \\`\\`\\`javascript import Taro, { Component } from '@tarojs/taro'; import { View, Icon, Image } from '@tarojs/components'; import 'your/path/fontawesome.css' //引用图片 import img from 'your/path/image.png' export default class Icon extends Taro.Component { ...... render(){ <View className='icon_box'> <Icon className='fa fa-home'/> <Image src={img} /> </View> } } \\`\\`\\`\n\n> ### 页面配置\n\n    //是不是跟小程序入口配置文件差不多?\n    config = {\n    // pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n        pages: [\n          'pages/book/book',\n          'pages/detail/detail',\n          'pages/user/user',\n          'pages/index/index'\n        ],\n        window: {\n          backgroundTextStyle: 'light',\n          navigationBarBackgroundColor: '#f55002',\n          navigationBarTitleText: '首页',\n          navigationBarTextStyle: 'light',\n          enablePullDownRefresh: false,\n          onReachBottomDistance: 30,\n          backgroundColor: '#f55002'\n        },\n        tabBar: {\n          backgroundColor: '#eee',\n          selectedColor: '#f55002',\n          color: '#aaa',\n          borderStyle: '#f55002',\n          list: [\n            {\n              pagePath: 'pages/index/index',\n              iconPath: './static/images/home_default.png',\n              selectedIconPath: './static/images/home_selected.png',\n              text: '首页'\n            },\n            {\n              pagePath: 'pages/book/book',\n              iconPath: './static/images/book_default.png',\n              selectedIconPath: './static/images/book_selected.png',\n              text: '书架'\n            },\n            {\n              pagePath: 'pages/user/user',\n              text: '我的',\n              iconPath: './static/images/user_default.png',\n              selectedIconPath: './static/images/user_selected.png'\n            }\n          ]\n        },\n        networkTimeout: {\n          request: 6000,\n          downloadFile: 10000\n        },\n        debug: true\n      };\n    \n    \n\n> ### 消息机制\n> \n> > #### Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~\n\n    import Taro, {Events} from '@tarojs/taro'\n    const events = new Events()\n    // 监听一个事件，接受参数\n    events.on('eventName', (arg) => {\n      // doSth\n    })\n    // 监听同个事件，同时绑定多个handler\n    events.on('eventName', handler1)\n    events.on('eventName', handler2)\n    events.on('eventName', handler3)\n    // 触发一个事件，传参\n    events.trigger('eventName', arg)\n    // 触发事件，传入多个参数\n    events.trigger('eventName', arg1, arg2, ...)\n    // 取消监听一个事件\n    events.off('eventName')\n    // 取消监听一个事件某个handler\n    events.off('eventName', handler1)\n    // 取消监听所有事件\n    events.off()\n    \n\n同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例\n\n    import Taro from '@tarojs/taro'\n    \n    Taro.eventCenter.on\n    Taro.eventCenter.trigger\n    Taro.eventCenter.off\n    \n\n> ### :checkered_flag: 组件和页面的定义\n\n``javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { <!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--> backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ <!--DOM 只能写在render函数中--> const test = `test` return ( <!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--> <View className='lavectorApp' style='background:#fff'> <Text>hello Lavector<Text> <Text>{test}</Text> // Taro中所有的事件都要以On 开头 <Button onClick={this.toOtherPage.bind(this,'params')}>To Other Page</Button> </View> ); } }``\n\n> ### 配合使用Redux\n> \n> > ##### 在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件\n> > \n> > npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger\n\n    // src/store/index.js\n    import { createStore, applyMiddleware } from 'redux'\n    import thunkMiddleware from 'redux-thunk'\n    import { createLogger } from 'redux-logger'\n    import rootReducer from '../reducers'\n    \n    const middlewares = [\n      thunkMiddleware,\n      createLogger()\n    ]\n    \n    export default function configStore () {\n      const store = createStore(rootReducer, applyMiddleware(...middlewares))\n      return store\n    }\n    \n\n入口文件app.js\n\n    // src/app.js\n    import Taro, { Component } from '@tarojs/taro'\n    import { Provider } from '@tarojs/redux'\n    \n    import configStore from './store'\n    import Index from './pages/index'\n    \n    import './app.scss'\n    \n    const store = configStore()\n    \n    class App extends Component {\n      config = {\n        pages: [\n          'pages/index/index'\n        ],\n        window: {\n          navigationBarTitleText: 'Test'\n        }\n      }\n    \n      render() {\n        return (\n          <Provider store={store}>\n            <Index />\n          </Provider>\n        )\n      }\n    }\n    \n    Taro.render(<App />, document.getElementById('app'))\n    \n    \n\n> 然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)\n\n补充 JSX语法支持程度\n============\n\n*   不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）\n*   不能在包含 JSX 元素的 map 循环中使用 if 表达式\n*   不能使用 Array#map 之外的方法操作 JSX 数组\n*   不能在 JSX 参数中使用匿名函数\n*   暂不支持在 render() 之外的方法定义 JSX\n*   不允许在 JSX 参数(props)中传入 JSX 元素\n*   不能在 JSX 参数中使用对象展开符*   不支持无状态组件\n\n### 结束语\n\n无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。\n\n> 以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网[京东Taro](https://nervjs.github.io/taro/)\n\n### 可能你需要学习的：\n\n【Mpvue】(http://mpvue.com/) 【Mpvue资源合集】(https://github.com/mpvue/awesome-mpvue) 【Taro】(https://nervjs.github.io/taro/) 【Vuejs】(https://cn.vuejs.org/) 【Redux】(http://www.redux.org.cn/)","slug":"微信小程序开发技术选型分享","published":1,"updated":"2019-12-31T03:00:25.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj8a007bzws6b6e5zpjg","content":"<h1><span id=\"微信小程序开发技术分享anchor\">微信小程序开发技术分享:anchor:</span></h1>\n<p><img src=\"http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg\" alt></p>\n<h5><span id=\"目前编写微信小程序的技术有如下微信开发者工具自带的一套开发技术基于腾讯的wepy框架美团的mpvue京东的taro这四个开发小程序技术目前是应用最为广泛的-今天最主要介绍的是来自京东凹凸团队的taro框架\">目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。</span></h5>\n<h3><span id=\"什么是taro\">什么是Taro?</span></h3>\n<p>多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。</p>\n<h3><span id=\"为什么要用taro\">为什么要用Taro?</span></h3>\n<p>当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.jpg\" alt></p>\n<h3><span id=\"taro与其它框架进行对比\">Taro与其它框架进行对比</span></h3>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png\" alt=\"image\"></p>\n<p>对比分析</p>\n<p>微信小程序</p>\n<p>mpuve</p>\n<p>wepy</p>\n<p>Taro</p>\n<p>语法规范</p>\n<p>小程序规范</p>\n<p>Vue.js规范</p>\n<p>类Vue.js规范</p>\n<p>React规范</p>\n<p>模板系统</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>JSX</p>\n<p>类型系统</p>\n<p>不支持</p>\n<p>业务代码</p>\n<p>业务代码</p>\n<p>业务代码 + JSX</p>\n<p>组件规范</p>\n<p>小程序组件</p>\n<p>HTML标签+小程序组件</p>\n<p>小程序组件</p>\n<p>小程序组件</p>\n<p>样式规范</p>\n<p>wxss</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>组件化</p>\n<p>小程序组件化</p>\n<p>Vue组件化</p>\n<p>自定义组件化</p>\n<p>React组件化</p>\n<p>多端复用</p>\n<p>复用，不存在的</p>\n<p>H5,APP(Weex)等</p>\n<p>没看到有介绍</p>\n<p>H5,APP(ReactNative)等</p>\n<p>自动构建</p>\n<p>无</p>\n<p>webpack</p>\n<p>内部构建系统</p>\n<p>webpack+内部构建系统</p>\n<p>开发要求</p>\n<p>全新学习</p>\n<p>熟悉Vue语法即可</p>\n<p>熟悉Vue+wepy语法</p>\n<p>熟悉React语法</p>\n<p>数据流管理</p>\n<p>无</p>\n<p>Vuex</p>\n<p>Redux</p>\n<p>Redux+React-thunk</p>\n<blockquote>\n<p>从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。</p>\n</blockquote>\n<h3><span id=\"taro框架设计思想-具体细节请看官网\">Taro框架设计思想 </span></h3>\n<blockquote>\n<p>图片来源于网络 <img src=\"http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png\" alt=\"image\"></p>\n</blockquote>\n<h3><span id=\"taro特性\">Taro特性</span></h3>\n<ul>\n<li>React 语法风格</li>\n<li>快速开发微信小程序\n<ul>\n<li>支持使用 npm/yarn 安装管理第三方依赖</li>\n<li>支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置</li>\n<li>支持使用 CSS 预编译器，例如 Sass 等</li>\n<li>支持使用 Redux进行状态管理</li>\n<li>小程序API优化，异步API Promise化等等</li>\n</ul>\n</li>\n<li>支持多端开发转化</li>\n</ul>\n<blockquote>\n<h3><span id=\"开发配置\">开发配置</span></h3>\n</blockquote>\n<ul>\n<li>环境配置\n<ul>\n<li>sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)</li>\n<li>npm init lavectorApp &amp;&amp; cd lavctorApp &amp;&amp; npm run dev:weapp/h5</li>\n<li>用微信开发者工具添加项目打开dist目录即可</li>\n</ul>\n</li>\n<li>页面设计尺寸配置\n<ul>\n<li>Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改</li>\n<li>Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位</li>\n</ul>\n</li>\n<li>编辑器\n<ul>\n<li>建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网…</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h3><span id=\"如何引用fontawesome字体文件\">如何引用fontAwesome字体文件</span></h3>\n</blockquote>\n<p>比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 <a href=\"https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css\" target=\"_blank\" rel=\"noopener\">查看</a> 如何使用： ```javascript import Taro, { Component } from ‘@tarojs/taro’; import { View, Icon, Image } from ‘@tarojs/components’; import ‘your/path/fontawesome.css’ //引用图片 import img from ‘your/path/image.png’ export default class Icon extends Taro.Component { … render(){ <view classname=\"icon_box\"> <icon classname=\"fa fa-home\"> <image src=\"{img}\"> </image></icon></view> } } ```</p>\n<blockquote>\n<h3><span id=\"页面配置\">页面配置</span></h3>\n</blockquote>\n<pre><code>//是不是跟小程序入口配置文件差不多?\nconfig = {\n// pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n    pages: [\n      'pages/book/book',\n      'pages/detail/detail',\n      'pages/user/user',\n      'pages/index/index'\n    ],\n    window: {\n      backgroundTextStyle: 'light',\n      navigationBarBackgroundColor: '#f55002',\n      navigationBarTitleText: '首页',\n      navigationBarTextStyle: 'light',\n      enablePullDownRefresh: false,\n      onReachBottomDistance: 30,\n      backgroundColor: '#f55002'\n    },\n    tabBar: {\n      backgroundColor: '#eee',\n      selectedColor: '#f55002',\n      color: '#aaa',\n      borderStyle: '#f55002',\n      list: [\n        {\n          pagePath: 'pages/index/index',\n          iconPath: './static/images/home_default.png',\n          selectedIconPath: './static/images/home_selected.png',\n          text: '首页'\n        },\n        {\n          pagePath: 'pages/book/book',\n          iconPath: './static/images/book_default.png',\n          selectedIconPath: './static/images/book_selected.png',\n          text: '书架'\n        },\n        {\n          pagePath: 'pages/user/user',\n          text: '我的',\n          iconPath: './static/images/user_default.png',\n          selectedIconPath: './static/images/user_selected.png'\n        }\n      ]\n    },\n    networkTimeout: {\n      request: 6000,\n      downloadFile: 10000\n    },\n    debug: true\n  };\n</code></pre>\n<blockquote>\n<h3><span id=\"消息机制\">消息机制</span></h3>\n<blockquote>\n<h4><span id=\"taro-提供了-taroevents-来实现消息机制使用时需要实例化它看完文档感觉跟vue的global-event-bus很像-可以用作非父子组件间的通讯应用场景看业务需求~\">Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~</span></h4>\n</blockquote>\n</blockquote>\n<pre><code>import Taro, {Events} from '@tarojs/taro'\nconst events = new Events()\n// 监听一个事件，接受参数\nevents.on('eventName', (arg) =&gt; {\n  // doSth\n})\n// 监听同个事件，同时绑定多个handler\nevents.on('eventName', handler1)\nevents.on('eventName', handler2)\nevents.on('eventName', handler3)\n// 触发一个事件，传参\nevents.trigger('eventName', arg)\n// 触发事件，传入多个参数\nevents.trigger('eventName', arg1, arg2, ...)\n// 取消监听一个事件\nevents.off('eventName')\n// 取消监听一个事件某个handler\nevents.off('eventName', handler1)\n// 取消监听所有事件\nevents.off()\n</code></pre>\n<p>同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例</p>\n<pre><code>import Taro from '@tarojs/taro'\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n</code></pre>\n<blockquote>\n<h3><span id=\"checkered_flag-组件和页面的定义\">:checkered_flag: 组件和页面的定义</span></h3>\n</blockquote>\n<p><code>javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { &lt;!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--&gt; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ &lt;!--DOM 只能写在render函数中--&gt; const test = `test` return ( &lt;!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--&gt; &lt;View className='lavectorApp' style='background:#fff'&gt; &lt;Text&gt;hello Lavector&lt;Text&gt; &lt;Text&gt;{test}&lt;/Text&gt; // Taro中所有的事件都要以On 开头 &lt;Button onClick={this.toOtherPage.bind(this,'params')}&gt;To Other Page&lt;/Button&gt; &lt;/View&gt; ); } }</code></p>\n<blockquote>\n<h3><span id=\"配合使用redux\">配合使用Redux</span></h3>\n<blockquote>\n<h5><span id=\"在-taro-中可以自由地使用-react-生态中非常流行的数据流管理工具-redux-来解决复杂项目的数据管理问题-而为了更方便地使用-redux-taro-提供了与-react-redux-api-几乎一致的包-tarojsredux-来让开发人员获得更加良好的开发体验-首先要安装-reduxtarojsredux和tarojsredux-h5以及一些需要用到的redux中间件\">在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件</span></h5>\n<p>npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger</p>\n</blockquote>\n</blockquote>\n<pre><code>// src/store/index.js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport rootReducer from '../reducers'\n\nconst middlewares = [\n  thunkMiddleware,\n  createLogger()\n]\n\nexport default function configStore () {\n  const store = createStore(rootReducer, applyMiddleware(...middlewares))\n  return store\n}\n</code></pre>\n<p>入口文件app.js</p>\n<pre><code>// src/app.js\nimport Taro, { Component } from '@tarojs/taro'\nimport { Provider } from '@tarojs/redux'\n\nimport configStore from './store'\nimport Index from './pages/index'\n\nimport './app.scss'\n\nconst store = configStore()\n\nclass App extends Component {\n  config = {\n    pages: [\n      'pages/index/index'\n    ],\n    window: {\n      navigationBarTitleText: 'Test'\n    }\n  }\n\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;Index /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n\nTaro.render(&lt;App /&gt;, document.getElementById('app'))\n</code></pre>\n<blockquote>\n<p>然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)</p>\n</blockquote>\n<h1><span id=\"补充-jsx语法支持程度\">补充 JSX语法支持程度</span></h1>\n<ul>\n<li>不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）</li>\n<li>不能在包含 JSX 元素的 map 循环中使用 if 表达式</li>\n<li>不能使用 Array#map 之外的方法操作 JSX 数组</li>\n<li>不能在 JSX 参数中使用匿名函数</li>\n<li>暂不支持在 render() 之外的方法定义 JSX</li>\n<li>不允许在 JSX 参数(props)中传入 JSX 元素</li>\n<li>不能在 JSX 参数中使用对象展开符*   不支持无状态组件</li>\n</ul>\n<h3><span id=\"结束语\">结束语</span></h3>\n<p>无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。</p>\n<blockquote>\n<p>以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">京东Taro</a></p>\n</blockquote>\n<h3><span id=\"可能你需要学习的\">可能你需要学习的：</span></h3>\n<p>【Mpvue】(<a href=\"http://mpvue.com/\" target=\"_blank\" rel=\"noopener\">http://mpvue.com/</a>) 【Mpvue资源合集】(<a href=\"https://github.com/mpvue/awesome-mpvue\" target=\"_blank\" rel=\"noopener\">https://github.com/mpvue/awesome-mpvue</a>) 【Taro】(<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">https://nervjs.github.io/taro/</a>) 【Vuejs】(<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/</a>) 【Redux】(<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.redux.org.cn/</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>微信小程序开发技术分享:anchor:</h1>\n<p><img src=\"http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg\" alt></p>\n<h5>目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。</h5>\n<h3>什么是Taro?</h3>\n<p>多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。</p>\n<h3>为什么要用Taro?</h3>\n<p>当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.jpg\" alt></p>\n<h3>Taro与其它框架进行对比</h3>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png\" alt=\"image\"></p>\n<p>对比分析</p>\n<p>微信小程序</p>\n<p>mpuve</p>\n<p>wepy</p>\n<p>Taro</p>\n<p>语法规范</p>\n<p>小程序规范</p>\n<p>Vue.js规范</p>\n<p>类Vue.js规范</p>\n<p>React规范</p>\n<p>模板系统</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>JSX</p>\n<p>类型系统</p>\n<p>不支持</p>\n<p>业务代码</p>\n<p>业务代码</p>\n<p>业务代码 + JSX</p>\n<p>组件规范</p>\n<p>小程序组件</p>\n<p>HTML标签+小程序组件</p>\n<p>小程序组件</p>\n<p>小程序组件</p>\n<p>样式规范</p>\n<p>wxss</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>组件化</p>\n<p>小程序组件化</p>\n<p>Vue组件化</p>\n<p>自定义组件化</p>\n<p>React组件化</p>\n<p>多端复用</p>\n<p>复用，不存在的</p>\n<p>H5,APP(Weex)等</p>\n<p>没看到有介绍</p>\n<p>H5,APP(ReactNative)等</p>\n<p>自动构建</p>\n<p>无</p>\n<p>webpack</p>\n<p>内部构建系统</p>\n<p>webpack+内部构建系统</p>\n<p>开发要求</p>\n<p>全新学习</p>\n<p>熟悉Vue语法即可</p>\n<p>熟悉Vue+wepy语法</p>\n<p>熟悉React语法</p>\n<p>数据流管理</p>\n<p>无</p>\n<p>Vuex</p>\n<p>Redux</p>\n<p>Redux+React-thunk</p>\n<blockquote>\n<p>从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。</p>\n</blockquote>\n<h3>Taro框架设计思想 <a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">具体细节请看官网</a></h3>\n<blockquote>\n<p>图片来源于网络 <img src=\"http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png\" alt=\"image\"></p>\n</blockquote>\n<h3>Taro特性</h3>\n<ul>\n<li>React 语法风格</li>\n<li>快速开发微信小程序\n<ul>\n<li>支持使用 npm/yarn 安装管理第三方依赖</li>\n<li>支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置</li>\n<li>支持使用 CSS 预编译器，例如 Sass 等</li>\n<li>支持使用 Redux进行状态管理</li>\n<li>小程序API优化，异步API Promise化等等</li>\n</ul>\n</li>\n<li>支持多端开发转化</li>\n</ul>\n<blockquote>\n<h3>开发配置</h3>\n</blockquote>\n<ul>\n<li>环境配置\n<ul>\n<li>sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)</li>\n<li>npm init lavectorApp &amp;&amp; cd lavctorApp &amp;&amp; npm run dev:weapp/h5</li>\n<li>用微信开发者工具添加项目打开dist目录即可</li>\n</ul>\n</li>\n<li>页面设计尺寸配置\n<ul>\n<li>Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改</li>\n<li>Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位</li>\n</ul>\n</li>\n<li>编辑器\n<ul>\n<li>建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网…</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h3>如何引用fontAwesome字体文件</h3>\n</blockquote>\n<p>比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 <a href=\"https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css\" target=\"_blank\" rel=\"noopener\">查看</a> 如何使用： ```javascript import Taro, { Component } from ‘@tarojs/taro’; import { View, Icon, Image } from ‘@tarojs/components’; import ‘your/path/fontawesome.css’ //引用图片 import img from ‘your/path/image.png’ export default class Icon extends Taro.Component { … render(){ <view classname=\"icon_box\"> <icon classname=\"fa fa-home\"> <image src=\"{img}\"> </image></icon></view> } } ```</p>\n<blockquote>\n<h3>页面配置</h3>\n</blockquote>\n<pre><code>//是不是跟小程序入口配置文件差不多?\nconfig = {\n// pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n    pages: [\n      'pages/book/book',\n      'pages/detail/detail',\n      'pages/user/user',\n      'pages/index/index'\n    ],\n    window: {\n      backgroundTextStyle: 'light',\n      navigationBarBackgroundColor: '#f55002',\n      navigationBarTitleText: '首页',\n      navigationBarTextStyle: 'light',\n      enablePullDownRefresh: false,\n      onReachBottomDistance: 30,\n      backgroundColor: '#f55002'\n    },\n    tabBar: {\n      backgroundColor: '#eee',\n      selectedColor: '#f55002',\n      color: '#aaa',\n      borderStyle: '#f55002',\n      list: [\n        {\n          pagePath: 'pages/index/index',\n          iconPath: './static/images/home_default.png',\n          selectedIconPath: './static/images/home_selected.png',\n          text: '首页'\n        },\n        {\n          pagePath: 'pages/book/book',\n          iconPath: './static/images/book_default.png',\n          selectedIconPath: './static/images/book_selected.png',\n          text: '书架'\n        },\n        {\n          pagePath: 'pages/user/user',\n          text: '我的',\n          iconPath: './static/images/user_default.png',\n          selectedIconPath: './static/images/user_selected.png'\n        }\n      ]\n    },\n    networkTimeout: {\n      request: 6000,\n      downloadFile: 10000\n    },\n    debug: true\n  };\n</code></pre>\n<blockquote>\n<h3>消息机制</h3>\n<blockquote>\n<h4>Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~</h4>\n</blockquote>\n</blockquote>\n<pre><code>import Taro, {Events} from '@tarojs/taro'\nconst events = new Events()\n// 监听一个事件，接受参数\nevents.on('eventName', (arg) =&gt; {\n  // doSth\n})\n// 监听同个事件，同时绑定多个handler\nevents.on('eventName', handler1)\nevents.on('eventName', handler2)\nevents.on('eventName', handler3)\n// 触发一个事件，传参\nevents.trigger('eventName', arg)\n// 触发事件，传入多个参数\nevents.trigger('eventName', arg1, arg2, ...)\n// 取消监听一个事件\nevents.off('eventName')\n// 取消监听一个事件某个handler\nevents.off('eventName', handler1)\n// 取消监听所有事件\nevents.off()\n</code></pre>\n<p>同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例</p>\n<pre><code>import Taro from '@tarojs/taro'\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n</code></pre>\n<blockquote>\n<h3>:checkered_flag: 组件和页面的定义</h3>\n</blockquote>\n<p><code>javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { &lt;!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--&gt; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ &lt;!--DOM 只能写在render函数中--&gt; const test = `test` return ( &lt;!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--&gt; &lt;View className='lavectorApp' style='background:#fff'&gt; &lt;Text&gt;hello Lavector&lt;Text&gt; &lt;Text&gt;{test}&lt;/Text&gt; // Taro中所有的事件都要以On 开头 &lt;Button onClick={this.toOtherPage.bind(this,'params')}&gt;To Other Page&lt;/Button&gt; &lt;/View&gt; ); } }</code></p>\n<blockquote>\n<h3>配合使用Redux</h3>\n<blockquote>\n<h5>在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件</h5>\n<p>npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger</p>\n</blockquote>\n</blockquote>\n<pre><code>// src/store/index.js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport rootReducer from '../reducers'\n\nconst middlewares = [\n  thunkMiddleware,\n  createLogger()\n]\n\nexport default function configStore () {\n  const store = createStore(rootReducer, applyMiddleware(...middlewares))\n  return store\n}\n</code></pre>\n<p>入口文件app.js</p>\n<pre><code>// src/app.js\nimport Taro, { Component } from '@tarojs/taro'\nimport { Provider } from '@tarojs/redux'\n\nimport configStore from './store'\nimport Index from './pages/index'\n\nimport './app.scss'\n\nconst store = configStore()\n\nclass App extends Component {\n  config = {\n    pages: [\n      'pages/index/index'\n    ],\n    window: {\n      navigationBarTitleText: 'Test'\n    }\n  }\n\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;Index /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n\nTaro.render(&lt;App /&gt;, document.getElementById('app'))\n</code></pre>\n<blockquote>\n<p>然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)</p>\n</blockquote>\n<h1>补充 JSX语法支持程度</h1>\n<ul>\n<li>不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）</li>\n<li>不能在包含 JSX 元素的 map 循环中使用 if 表达式</li>\n<li>不能使用 Array#map 之外的方法操作 JSX 数组</li>\n<li>不能在 JSX 参数中使用匿名函数</li>\n<li>暂不支持在 render() 之外的方法定义 JSX</li>\n<li>不允许在 JSX 参数(props)中传入 JSX 元素</li>\n<li>不能在 JSX 参数中使用对象展开符*   不支持无状态组件</li>\n</ul>\n<h3>结束语</h3>\n<p>无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。</p>\n<blockquote>\n<p>以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">京东Taro</a></p>\n</blockquote>\n<h3>可能你需要学习的：</h3>\n<p>【Mpvue】(<a href=\"http://mpvue.com/\" target=\"_blank\" rel=\"noopener\">http://mpvue.com/</a>) 【Mpvue资源合集】(<a href=\"https://github.com/mpvue/awesome-mpvue\" target=\"_blank\" rel=\"noopener\">https://github.com/mpvue/awesome-mpvue</a>) 【Taro】(<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">https://nervjs.github.io/taro/</a>) 【Vuejs】(<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/</a>) 【Redux】(<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.redux.org.cn/</a>)</p>\n"},{"title":"ThreeJS学习 第一章 创建一个场景","catalog":true,"date":"2019-08-05T08:37:05.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/item/201608/06/20160806232840_WZCjT.jpeg","_content":"\n#### 1.创建基本的页面结构\n\n> 从Threejs官网下载Three.js 到本地并且引入此文件。 [下载地址](https://threejs.org/build/three.js)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n  // TODO\n</script>\n</html>\n\n\n```\n\n#### 2. 创建一个简单的场景\n\n> 为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。\n\n```javascript\n   // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n\n```\n\n我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。\n\n第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。\n\n接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。\n\n接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。\n\n除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。\n\n如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。\n\n最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。\n\n#### 3. 创建一个立方体\n\n```javascript\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n\n```\n要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。\n\n接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。\n\n第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。\n\n默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n\n\n#### 4. 渲染创建的场景，使立方体动起来\n\n```javascript\n      // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n\n```\n\n现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。\n\n在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。\n\n#### 5.结果\n\n![结果图片](https://s2.ax1x.com/2019/08/05/e2WEXF.png)\n\n> 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n    // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1,)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n    // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n</script>\n</html>\n\n```","source":"_posts/第一章 TheeJS 创建场景.md","raw":"---\ntitle: ThreeJS学习 第一章 创建一个场景\ncatalog: true\ntags:\n  - HTML\n  - JavaScript\n  - Threejs\ncategories:\n  - ThreeJS\ndate: 2019-08-05 16:37:05\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/item/201608/06/20160806232840_WZCjT.jpeg\"\n---\n\n#### 1.创建基本的页面结构\n\n> 从Threejs官网下载Three.js 到本地并且引入此文件。 [下载地址](https://threejs.org/build/three.js)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n  // TODO\n</script>\n</html>\n\n\n```\n\n#### 2. 创建一个简单的场景\n\n> 为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。\n\n```javascript\n   // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n\n```\n\n我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。\n\n第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。\n\n接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。\n\n接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。\n\n除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。\n\n如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。\n\n最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。\n\n#### 3. 创建一个立方体\n\n```javascript\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n\n```\n要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。\n\n接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。\n\n第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。\n\n默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n\n\n#### 4. 渲染创建的场景，使立方体动起来\n\n```javascript\n      // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n\n```\n\n现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。\n\n在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。\n\n#### 5.结果\n\n![结果图片](https://s2.ax1x.com/2019/08/05/e2WEXF.png)\n\n> 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n    // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1,)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n    // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n</script>\n</html>\n\n```","slug":"第一章 TheeJS 创建场景","published":1,"updated":"2019-12-31T03:00:25.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj8b007ezws6goawbuks","content":"<h4><span id=\"1创建基本的页面结构\">1.创建基本的页面结构</span></h4>\n<blockquote>\n<p>从Threejs官网下载Three.js 到本地并且引入此文件。 <a href=\"https://threejs.org/build/three.js\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// TODO</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"2-创建一个简单的场景\">2. 创建一个简单的场景</span></h4>\n<blockquote>\n<p>为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个场景</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个相机</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个渲染器</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span><br><span class=\"line\"> <span class=\"comment\">// 设定渲染的区域</span></span><br><span class=\"line\"> renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span><br><span class=\"line\"> <span class=\"comment\">// 添加DOM</span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span><br></pre></td></tr></table></figure>\n<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</p>\n<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>\n<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>\n<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>\n<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>\n<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</canvas></p>\n<p>最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</canvas></p>\n<h4><span id=\"3-创建一个立方体\">3. 创建一个立方体</span></h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个几何体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个材质</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个网格和正方体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span><br><span class=\"line\"><span class=\"comment\">// 将建立的模型放入场景中</span></span><br><span class=\"line\">scene.add( cube )</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span><br><span class=\"line\">camera.position.z = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。</p>\n<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。</p>\n<p>第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>\n<p>默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>\n<h4><span id=\"4-渲染创建的场景使立方体动起来\">4. 渲染创建的场景，使立方体动起来</span></h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 渲染动画</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    requestAnimationFrame(animate)</span><br><span class=\"line\">    cube.rotation.x += <span class=\"number\">0.01</span></span><br><span class=\"line\">    cube.rotation.y += <span class=\"number\">0.01</span></span><br><span class=\"line\">    renderer.render(scene,camera)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用动画，渲染界面</span></span><br><span class=\"line\">animate()</span><br></pre></td></tr></table></figure>\n<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>\n<p>在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。</p>\n<h4><span id=\"5结果\">5.结果</span></h4>\n<p><img src=\"https://s2.ax1x.com/2019/08/05/e2WEXF.png\" alt=\"结果图片\"></p>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个场景</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个相机</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个渲染器</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 设定渲染的区域</span></span></span><br><span class=\"line\"><span class=\"javascript\">    renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 添加DOM</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个几何体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个材质</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个网格和正方体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将建立的模型放入场景中</span></span></span><br><span class=\"line\"><span class=\"undefined\">    scene.add( cube )</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span></span><br><span class=\"line\"><span class=\"undefined\">    camera.position.z = 5</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 渲染动画</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        requestAnimationFrame(animate)</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.x += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.y += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        renderer.render(scene,camera)</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用动画，渲染界面</span></span></span><br><span class=\"line\"><span class=\"undefined\">    animate()</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4>1.创建基本的页面结构</h4>\n<blockquote>\n<p>从Threejs官网下载Three.js 到本地并且引入此文件。 <a href=\"https://threejs.org/build/three.js\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"comment\">// TODO</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4>2. 创建一个简单的场景</h4>\n<blockquote>\n<p>为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个场景</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个相机</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个渲染器</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span><br><span class=\"line\"> <span class=\"comment\">// 设定渲染的区域</span></span><br><span class=\"line\"> renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span><br><span class=\"line\"> <span class=\"comment\">// 添加DOM</span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span><br></pre></td></tr></table></figure>\n<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</p>\n<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>\n<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>\n<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>\n<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>\n<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</canvas></p>\n<p>最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</canvas></p>\n<h4>3. 创建一个立方体</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个几何体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个材质</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个网格和正方体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span><br><span class=\"line\"><span class=\"comment\">// 将建立的模型放入场景中</span></span><br><span class=\"line\">scene.add( cube )</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span><br><span class=\"line\">camera.position.z = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。</p>\n<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。</p>\n<p>第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>\n<p>默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>\n<h4>4. 渲染创建的场景，使立方体动起来</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 渲染动画</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    requestAnimationFrame(animate)</span><br><span class=\"line\">    cube.rotation.x += <span class=\"number\">0.01</span></span><br><span class=\"line\">    cube.rotation.y += <span class=\"number\">0.01</span></span><br><span class=\"line\">    renderer.render(scene,camera)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用动画，渲染界面</span></span><br><span class=\"line\">animate()</span><br></pre></td></tr></table></figure>\n<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>\n<p>在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。</p>\n<h4>5.结果</h4>\n<p><img src=\"https://s2.ax1x.com/2019/08/05/e2WEXF.png\" alt=\"结果图片\"></p>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个场景</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个相机</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个渲染器</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 设定渲染的区域</span></span></span><br><span class=\"line\"><span class=\"javascript\">    renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 添加DOM</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个几何体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个材质</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个网格和正方体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将建立的模型放入场景中</span></span></span><br><span class=\"line\"><span class=\"undefined\">    scene.add( cube )</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span></span><br><span class=\"line\"><span class=\"undefined\">    camera.position.z = 5</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 渲染动画</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        requestAnimationFrame(animate)</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.x += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.y += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        renderer.render(scene,camera)</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用动画，渲染界面</span></span></span><br><span class=\"line\"><span class=\"undefined\">    animate()</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"阅读Vue Composition API 了解Vue3.x的设计思想（上篇）","catalog":true,"date":"2019-10-17T12:39:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n# API Reference \n\n> 要看源码之前，首先要学会TypeScript（前十篇文档有`Typescript`学习指南）,因为vue3.x 版本中+90%的代码是使用的`Typescript`，[Vue3.x 源码地址](https://github.com/vuejs/vue-next)。\n\n## Setup\n  该`setup`功能是新的组件选项。它充当在组件内部使用Composition API的入口点。\n  #### 调用时间\n  `setup`创建组件实例时，在初始道具解析后立即调用。在生命周期方面，在`beforeCreate`挂接之后和挂接之前调用它`created`。\n  #### 和模板配合使用\n  如果`setup`返回一个对象，则该对象上的属性将合并到组件模板的渲染上下文中：\n\n    ```javascript\n    <template>\n      <div>{{ count }} {{ object.foo }}</div>\n    </template>\n\n    <script>\n    import { ref, reactive } from 'vue'\n\n    export default {\n      setup() {\n        const count = ref(0)\n        const object = reactive({ foo: 'bar' })\n\n        // expose to template\n        return {\n          count,\n          object\n        }\n      }\n    }\n    </script>\n    ```\n  请注意，`setup`在模板中访问时，从`ref`返回的引用会自动解包，因此不需要`.valuein`模板。\n  #### 渲染功能/ JSX的用法\n  `setup` 还可以返回一个`render`函数，该函数可以直接使用在同一作用域中声明的反应状态：\n\n    ```javascript\n   import { h, ref, reactive } from 'vue'\n\n    export default {\n      setup() {\n        const count = ref(0)\n        const object = reactive({ foo: 'bar' })\n\n        return () => h('div', [\n          count.value,\n          object.foo\n        ])\n      }\n    }\n    ```\n  #### 参数\n  该函数将接收到的`props`作为其第一个参数：\n\n    ```javascript\n      export default {\n      props: {\n        name: String\n      },\n      setup(props) {\n        console.log(props.name)\n      }\n    }\n    ```\n  请注意，此`props`对象是反应性的-即，当传入新的`props`时会更新该对象，并且可以使用`watch`函数观察并做出反应：\n\n   ```javascript\n      export default {\n      props: {\n        name: String\n      },\n      setup(props) {\n        watch(() => {\n          console.log(`name is: ` + props.name)\n        })\n      }\n    }\n    ```\n\n  `props`在开发过程中，该对象对于用户区代码是不可变的（如果用户代码尝试对其进行更改，则会发出警告）。\n\n  第二个参数提供了一个上下文对象`context`，该对象公开了先前`this`在2.x API中公开的属性的选择性列表：\n\n  ```javascript\n    const MyComponent = {\n    setup(props, context) {\n      context.attrs\n      context.slots\n      context.parent\n      context.root\n      context.emit\n    }\n  }\n  ```\n\n`attrs`并且`slots`是内部组件实例上对应值的代理。这样可以确保即使在更新后它们也始终显示最新值，以便我们可以对它们进行结构分解而不必担心访问陈旧的引用：\n\n  ```javascript\n    const MyComponent = {\n    setup(props, { attrs }) {\n      // a function that may get called at a later stage\n      function onClick() {\n        console.log(attrs.foo) // guaranteed to be the latest reference\n      }\n    }\n  }\n  ```\n\n有很多理由将其放置`props`为单独的第一个参数而不是将其包含在上下文中：\n\n- `props`与其他属性相比，使用一个组件更为常见，并且通常一个组件仅使用`props`。\n- 具有`props`作为单独的参数可以更容易地单独键入它（见仅打字稿-道具打字下文）而对上下文搞乱了其它类型的属性。通过`TSX`支持`setup`，它还可以跨，`render`和普通功能组件保持一致的签名。\n\n#### This\n`this`里面没有`setup()`。由于`setup()`是在解析2.x选项之前调用的，因此`this`内部`setup()`（如果可用）的行为将与`this`其他2.x选项完全不同。`setup()`与其他2.x选项一起使用时，使其可用可能会引起混乱。避免`this`进入的另一个原因`setup()`是对于初学者来说非常常见的陷阱：\n\n ```javascript\n   setup() {\n    function onClick() {\n      this // not the `this` you'd expect!\n    }\n  }\n  ```\n#### Typing(类型)\n\n```typescript\n interface Data {\n    [key: string]: unknown\n  }\n\n  interface SetupContext {\n    attrs: Data\n    slots: Slots\n    parent: ComponentInstance | null\n    root: ComponentInstance\n    emit: ((event: string, ...args: unknown[]) => void)\n  }\n\n  function setup(\n    props: Data,\n    context: SetupContext\n  ): Data\n  ```\n> 要获得传递给的参数的类型推断，需要`setup()`使用`createComponent`。\n\n\n## Reactive\n取得一个对象并返回原始对象的反应式代理。这相当于2.x的`Vue.observable()`。\n\n```javascript\nconst obj = reactive({ count: 0 })\n```\n反应式转换是“深度”的：它将影响所有嵌套属性。在基于ES2015代理的实现中，返回的代理不等于原始对象。建议仅与反应式代理一起使用，并避免依赖原始对象。\n#### typeing 类型\n\n```typescript\n   function reactive<T extends object>(raw: T): T\n```\n\n## Ref\n接受一个内部值并返回一个反应性且可变的`ref`对象。`ref`对象具有`.value`指向内部值的单个属性。\n\n```javascript\n  const count = ref(0)\n  console.log(count.value) // 0\n\n  count.value++\n  console.log(count.value) // 1\n```\n如果将一个对象分配为`ref`的值，则该`reactive`方法会使该对象具有高度的反应性。\n\n#### 模板中访问\n当`ref`作为渲染上下文（从中返回的对象`setup()`）的属性返回并在模板中进行访问时，它会自动展开为内部值。无需`.value`在模板中追加：\n\n```javascript\n  <template>\n    <div>{{ count }}</div>\n  </template>\n\n  <script>\n  export default {\n    setup() {\n      return {\n        count: ref(0)\n      }\n    }\n  }\n  </script>\n```\n#### 反应性对象中的访问\n当ref作为反应对象的属性进行访问或突变时，它会自动展开为内部值，因此其行为类似于普通属性：\n\n```javascript\nconst count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1\n```\n请注意，如果将新的引用分配给链接到现有引用的属性，它将替换旧的引用：\n\n```javascript\nconst otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\nconsole.log(count.value) // 1\n```\n#### typing 类型\n\n```typescript\ninterface Ref<T> {\n  value: T\n}\n\nfunction ref<T>(value: T): Ref<T>\n```\n有时我们可能需要为ref的内部值指定复杂类型。我们可以通过在调用ref以覆盖默认推断时传递泛型参数来简洁地实现此目的：\n\n```typescript\nconst foo = ref<string | number>('foo') // foo's type: Ref<string | number>\n\nfoo.value = 123 // ok!\n```\n\n## isRef\n检查值是否是引用对象。\n\n```javascript\nconst unwrapped = isRef(foo) ? foo.value : foo\n```\n#### typing 类型\n\n```typescript\nfunction isRef(value: any): value is Ref<any>\n```\n\n## toRefs\n将反应对象转换为普通对象，其中结果对象上的每个属性都是指向原始对象中相应属性的`ref`\n\n```javascript\n    const state = reactive({\n      foo: 1,\n      bar: 2\n    })\n\n    const stateAsRefs = toRefs(state)\n    /*\n    Type of stateAsRefs:\n\n    {\n      foo: Ref<1>,\n      bar: Ref<2>\n    }\n    */\n\n    // The ref and the original property is \"linked\"\n    state.foo++\n    console.log(stateAsRefs.foo) // 2\n\n    stateAsRefs.foo.value++\n    console.log(state.foo) // 3\n```\n`toRefs` 从组合函数返回反应对象时，此函数很有用，以便使用组件可以分解/散布返回的对象而不会失去反应性：\n\n```javascript\n    function useFeatureX() {\n      const state = reactive({\n        foo: 1,\n        bar: 2\n      })\n\n      // logic operating on state\n\n      // convert to refs when returning\n      return toRefs(state)\n    }\n\n    export default {\n      setup() {\n        // can destructure without losing reactivity\n        const { foo, bar } = useFeatureX()\n\n        return {\n          foo,\n          bar\n        }\n      }\n    }\n```\n\n## Computed\n采用getter函数，并为getter返回的值返回一个不变的反应性ref对象。\n\n```javascript\n  const count = ref(1)\n  const plusOne = computed(() => count.value + 1)\n\n  console.log(plusOne.value) // 2\n\n  plusOne.value++ // error\n```\n或者，它可以使用具有get和set功能的对象来创建可写的ref对象。\n\n```javascript\n    const count = ref(1)\n    const plusOne = computed({\n      get: () => count.value + 1,\n      set: val => { count.value = val - 1 }\n    })\n\n    plusOne.value = 1\n    console.log(count.value) // 0\n```\n\n#### typing 类型\n\n```typescript\n    // read-only\n    function computed<T>(getter: () => T): Readonly<Ref<Readonly<T>>>\n\n    // writable\n    function computed<T>(options: {\n      get: () => T,\n      set: (value: T) => void\n    }): Ref<T>\n```\n\n\n### 未完待续.......","source":"_posts/阅读Vue Composition API了解Vue3的设计 （上篇）.md","raw":"---\ntitle: 阅读Vue Composition API 了解Vue3.x的设计思想（上篇）\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-17 20:39:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n# API Reference \n\n> 要看源码之前，首先要学会TypeScript（前十篇文档有`Typescript`学习指南）,因为vue3.x 版本中+90%的代码是使用的`Typescript`，[Vue3.x 源码地址](https://github.com/vuejs/vue-next)。\n\n## Setup\n  该`setup`功能是新的组件选项。它充当在组件内部使用Composition API的入口点。\n  #### 调用时间\n  `setup`创建组件实例时，在初始道具解析后立即调用。在生命周期方面，在`beforeCreate`挂接之后和挂接之前调用它`created`。\n  #### 和模板配合使用\n  如果`setup`返回一个对象，则该对象上的属性将合并到组件模板的渲染上下文中：\n\n    ```javascript\n    <template>\n      <div>{{ count }} {{ object.foo }}</div>\n    </template>\n\n    <script>\n    import { ref, reactive } from 'vue'\n\n    export default {\n      setup() {\n        const count = ref(0)\n        const object = reactive({ foo: 'bar' })\n\n        // expose to template\n        return {\n          count,\n          object\n        }\n      }\n    }\n    </script>\n    ```\n  请注意，`setup`在模板中访问时，从`ref`返回的引用会自动解包，因此不需要`.valuein`模板。\n  #### 渲染功能/ JSX的用法\n  `setup` 还可以返回一个`render`函数，该函数可以直接使用在同一作用域中声明的反应状态：\n\n    ```javascript\n   import { h, ref, reactive } from 'vue'\n\n    export default {\n      setup() {\n        const count = ref(0)\n        const object = reactive({ foo: 'bar' })\n\n        return () => h('div', [\n          count.value,\n          object.foo\n        ])\n      }\n    }\n    ```\n  #### 参数\n  该函数将接收到的`props`作为其第一个参数：\n\n    ```javascript\n      export default {\n      props: {\n        name: String\n      },\n      setup(props) {\n        console.log(props.name)\n      }\n    }\n    ```\n  请注意，此`props`对象是反应性的-即，当传入新的`props`时会更新该对象，并且可以使用`watch`函数观察并做出反应：\n\n   ```javascript\n      export default {\n      props: {\n        name: String\n      },\n      setup(props) {\n        watch(() => {\n          console.log(`name is: ` + props.name)\n        })\n      }\n    }\n    ```\n\n  `props`在开发过程中，该对象对于用户区代码是不可变的（如果用户代码尝试对其进行更改，则会发出警告）。\n\n  第二个参数提供了一个上下文对象`context`，该对象公开了先前`this`在2.x API中公开的属性的选择性列表：\n\n  ```javascript\n    const MyComponent = {\n    setup(props, context) {\n      context.attrs\n      context.slots\n      context.parent\n      context.root\n      context.emit\n    }\n  }\n  ```\n\n`attrs`并且`slots`是内部组件实例上对应值的代理。这样可以确保即使在更新后它们也始终显示最新值，以便我们可以对它们进行结构分解而不必担心访问陈旧的引用：\n\n  ```javascript\n    const MyComponent = {\n    setup(props, { attrs }) {\n      // a function that may get called at a later stage\n      function onClick() {\n        console.log(attrs.foo) // guaranteed to be the latest reference\n      }\n    }\n  }\n  ```\n\n有很多理由将其放置`props`为单独的第一个参数而不是将其包含在上下文中：\n\n- `props`与其他属性相比，使用一个组件更为常见，并且通常一个组件仅使用`props`。\n- 具有`props`作为单独的参数可以更容易地单独键入它（见仅打字稿-道具打字下文）而对上下文搞乱了其它类型的属性。通过`TSX`支持`setup`，它还可以跨，`render`和普通功能组件保持一致的签名。\n\n#### This\n`this`里面没有`setup()`。由于`setup()`是在解析2.x选项之前调用的，因此`this`内部`setup()`（如果可用）的行为将与`this`其他2.x选项完全不同。`setup()`与其他2.x选项一起使用时，使其可用可能会引起混乱。避免`this`进入的另一个原因`setup()`是对于初学者来说非常常见的陷阱：\n\n ```javascript\n   setup() {\n    function onClick() {\n      this // not the `this` you'd expect!\n    }\n  }\n  ```\n#### Typing(类型)\n\n```typescript\n interface Data {\n    [key: string]: unknown\n  }\n\n  interface SetupContext {\n    attrs: Data\n    slots: Slots\n    parent: ComponentInstance | null\n    root: ComponentInstance\n    emit: ((event: string, ...args: unknown[]) => void)\n  }\n\n  function setup(\n    props: Data,\n    context: SetupContext\n  ): Data\n  ```\n> 要获得传递给的参数的类型推断，需要`setup()`使用`createComponent`。\n\n\n## Reactive\n取得一个对象并返回原始对象的反应式代理。这相当于2.x的`Vue.observable()`。\n\n```javascript\nconst obj = reactive({ count: 0 })\n```\n反应式转换是“深度”的：它将影响所有嵌套属性。在基于ES2015代理的实现中，返回的代理不等于原始对象。建议仅与反应式代理一起使用，并避免依赖原始对象。\n#### typeing 类型\n\n```typescript\n   function reactive<T extends object>(raw: T): T\n```\n\n## Ref\n接受一个内部值并返回一个反应性且可变的`ref`对象。`ref`对象具有`.value`指向内部值的单个属性。\n\n```javascript\n  const count = ref(0)\n  console.log(count.value) // 0\n\n  count.value++\n  console.log(count.value) // 1\n```\n如果将一个对象分配为`ref`的值，则该`reactive`方法会使该对象具有高度的反应性。\n\n#### 模板中访问\n当`ref`作为渲染上下文（从中返回的对象`setup()`）的属性返回并在模板中进行访问时，它会自动展开为内部值。无需`.value`在模板中追加：\n\n```javascript\n  <template>\n    <div>{{ count }}</div>\n  </template>\n\n  <script>\n  export default {\n    setup() {\n      return {\n        count: ref(0)\n      }\n    }\n  }\n  </script>\n```\n#### 反应性对象中的访问\n当ref作为反应对象的属性进行访问或突变时，它会自动展开为内部值，因此其行为类似于普通属性：\n\n```javascript\nconst count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1\n```\n请注意，如果将新的引用分配给链接到现有引用的属性，它将替换旧的引用：\n\n```javascript\nconst otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\nconsole.log(count.value) // 1\n```\n#### typing 类型\n\n```typescript\ninterface Ref<T> {\n  value: T\n}\n\nfunction ref<T>(value: T): Ref<T>\n```\n有时我们可能需要为ref的内部值指定复杂类型。我们可以通过在调用ref以覆盖默认推断时传递泛型参数来简洁地实现此目的：\n\n```typescript\nconst foo = ref<string | number>('foo') // foo's type: Ref<string | number>\n\nfoo.value = 123 // ok!\n```\n\n## isRef\n检查值是否是引用对象。\n\n```javascript\nconst unwrapped = isRef(foo) ? foo.value : foo\n```\n#### typing 类型\n\n```typescript\nfunction isRef(value: any): value is Ref<any>\n```\n\n## toRefs\n将反应对象转换为普通对象，其中结果对象上的每个属性都是指向原始对象中相应属性的`ref`\n\n```javascript\n    const state = reactive({\n      foo: 1,\n      bar: 2\n    })\n\n    const stateAsRefs = toRefs(state)\n    /*\n    Type of stateAsRefs:\n\n    {\n      foo: Ref<1>,\n      bar: Ref<2>\n    }\n    */\n\n    // The ref and the original property is \"linked\"\n    state.foo++\n    console.log(stateAsRefs.foo) // 2\n\n    stateAsRefs.foo.value++\n    console.log(state.foo) // 3\n```\n`toRefs` 从组合函数返回反应对象时，此函数很有用，以便使用组件可以分解/散布返回的对象而不会失去反应性：\n\n```javascript\n    function useFeatureX() {\n      const state = reactive({\n        foo: 1,\n        bar: 2\n      })\n\n      // logic operating on state\n\n      // convert to refs when returning\n      return toRefs(state)\n    }\n\n    export default {\n      setup() {\n        // can destructure without losing reactivity\n        const { foo, bar } = useFeatureX()\n\n        return {\n          foo,\n          bar\n        }\n      }\n    }\n```\n\n## Computed\n采用getter函数，并为getter返回的值返回一个不变的反应性ref对象。\n\n```javascript\n  const count = ref(1)\n  const plusOne = computed(() => count.value + 1)\n\n  console.log(plusOne.value) // 2\n\n  plusOne.value++ // error\n```\n或者，它可以使用具有get和set功能的对象来创建可写的ref对象。\n\n```javascript\n    const count = ref(1)\n    const plusOne = computed({\n      get: () => count.value + 1,\n      set: val => { count.value = val - 1 }\n    })\n\n    plusOne.value = 1\n    console.log(count.value) // 0\n```\n\n#### typing 类型\n\n```typescript\n    // read-only\n    function computed<T>(getter: () => T): Readonly<Ref<Readonly<T>>>\n\n    // writable\n    function computed<T>(options: {\n      get: () => T,\n      set: (value: T) => void\n    }): Ref<T>\n```\n\n\n### 未完待续.......","slug":"阅读Vue Composition API了解Vue3的设计 （上篇）","published":1,"updated":"2019-12-31T03:00:25.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj8d007izws66kypx68w","content":"<h1><span id=\"api-reference\">API Reference</span></h1>\n<blockquote>\n<p>要看源码之前，首先要学会TypeScript（前十篇文档有<code>Typescript</code>学习指南）,因为vue3.x 版本中+90%的代码是使用的<code>Typescript</code>，<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">Vue3.x 源码地址</a>。</p>\n</blockquote>\n<h2><span id=\"setup\">Setup</span></h2>\n<p>该<code>setup</code>功能是新的组件选项。它充当在组件内部使用Composition API的入口点。</p>\n<h4><span id=\"调用时间\">调用时间</span></h4>\n<p><code>setup</code>创建组件实例时，在初始道具解析后立即调用。在生命周期方面，在<code>beforeCreate</code>挂接之后和挂接之前调用它<code>created</code>。</p>\n<h4><span id=\"和模板配合使用\">和模板配合使用</span></h4>\n<p>如果<code>setup</code>返回一个对象，则该对象上的属性将合并到组件模板的渲染上下文中：</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;&#123;&#123; count &#125;&#125; &#123;&#123; object.foo &#125;&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, reactive &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> object = reactive(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// expose to template</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      object</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>请注意，<code>setup</code>在模板中访问时，从<code>ref</code>返回的引用会自动解包，因此不需要<code>.valuein</code>模板。</p>\n<h4><span id=\"渲染功能-jsx的用法\">渲染功能/ JSX的用法</span></h4>\n<p><code>setup</code> 还可以返回一个<code>render</code>函数，该函数可以直接使用在同一作用域中声明的反应状态：</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; h, ref, reactive &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">   setup() &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">     <span class=\"keyword\">const</span> object = reactive(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> h(<span class=\"string\">'div'</span>, [</span><br><span class=\"line\">       count.value,</span><br><span class=\"line\">       object.foo</span><br><span class=\"line\">     ])</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h4><span id=\"参数\">参数</span></h4>\n<p>该函数将接收到的<code>props</code>作为其第一个参数：</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">String</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>请注意，此<code>props</code>对象是反应性的-即，当传入新的<code>props</code>时会更新该对象，并且可以使用<code>watch</code>函数观察并做出反应：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">String</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`name is: `</span> + props.name)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>props</code>在开发过程中，该对象对于用户区代码是不可变的（如果用户代码尝试对其进行更改，则会发出警告）。</p>\n<p>第二个参数提供了一个上下文对象<code>context</code>，该对象公开了先前<code>this</code>在2.x API中公开的属性的选择性列表：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">const</span> MyComponent = &#123;</span><br><span class=\"line\">  setup(props, context) &#123;</span><br><span class=\"line\">    context.attrs</span><br><span class=\"line\">    context.slots</span><br><span class=\"line\">    context.parent</span><br><span class=\"line\">    context.root</span><br><span class=\"line\">    context.emit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>attrs</code>并且<code>slots</code>是内部组件实例上对应值的代理。这样可以确保即使在更新后它们也始终显示最新值，以便我们可以对它们进行结构分解而不必担心访问陈旧的引用：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">const</span> MyComponent = &#123;</span><br><span class=\"line\">  setup(props, &#123; attrs &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// a function that may get called at a later stage</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(attrs.foo) <span class=\"comment\">// guaranteed to be the latest reference</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有很多理由将其放置<code>props</code>为单独的第一个参数而不是将其包含在上下文中：</p>\n<ul>\n<li><code>props</code>与其他属性相比，使用一个组件更为常见，并且通常一个组件仅使用<code>props</code>。</li>\n<li>具有<code>props</code>作为单独的参数可以更容易地单独键入它（见仅打字稿-道具打字下文）而对上下文搞乱了其它类型的属性。通过<code>TSX</code>支持<code>setup</code>，它还可以跨，<code>render</code>和普通功能组件保持一致的签名。</li>\n</ul>\n<h4><span id=\"this\">This</span></h4>\n<p><code>this</code>里面没有<code>setup()</code>。由于<code>setup()</code>是在解析2.x选项之前调用的，因此<code>this</code>内部<code>setup()</code>（如果可用）的行为将与<code>this</code>其他2.x选项完全不同。<code>setup()</code>与其他2.x选项一起使用时，使其可用可能会引起混乱。避免<code>this</code>进入的另一个原因<code>setup()</code>是对于初学者来说非常常见的陷阱：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> setup() &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span> <span class=\"comment\">// not the `this` you'd expect!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"typing类型\">Typing(类型)</span></h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Data &#123;</span><br><span class=\"line\">   [key: <span class=\"built_in\">string</span>]: unknown</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">interface</span> SetupContext &#123;</span><br><span class=\"line\">   attrs: Data</span><br><span class=\"line\">   slots: Slots</span><br><span class=\"line\">   parent: ComponentInstance | <span class=\"literal\">null</span></span><br><span class=\"line\">   root: ComponentInstance</span><br><span class=\"line\">   emit: <span class=\"function\">(<span class=\"params\">(<span class=\"params\">event: <span class=\"built_in\">string</span>, ...args: unknown[]</span>) =&gt; <span class=\"built_in\">void</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"> &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"params\">function</span> <span class=\"params\">setup</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   props: Data,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   context: SetupContext</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span>): <span class=\"params\">Data</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>要获得传递给的参数的类型推断，需要<code>setup()</code>使用<code>createComponent</code>。</p>\n</blockquote>\n<h2><span id=\"reactive\">Reactive</span></h2>\n<p>取得一个对象并返回原始对象的反应式代理。这相当于2.x的<code>Vue.observable()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>反应式转换是“深度”的：它将影响所有嵌套属性。在基于ES2015代理的实现中，返回的代理不等于原始对象。建议仅与反应式代理一起使用，并避免依赖原始对象。</p>\n<h4><span id=\"typeing-类型\">typeing 类型</span></h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactive</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>&gt;(<span class=\"params\">raw: T</span>): <span class=\"title\">T</span></span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"ref\">Ref</span></h2>\n<p>接受一个内部值并返回一个反应性且可变的<code>ref</code>对象。<code>ref</code>对象具有<code>.value</code>指向内部值的单个属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">count.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如果将一个对象分配为<code>ref</code>的值，则该<code>reactive</code>方法会使该对象具有高度的反应性。</p>\n<h4><span id=\"模板中访问\">模板中访问</span></h4>\n<p>当<code>ref</code>作为渲染上下文（从中返回的对象<code>setup()</code>）的属性返回并在模板中进行访问时，它会自动展开为内部值。无需<code>.value</code>在模板中追加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count: ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"反应性对象中的访问\">反应性对象中的访问</span></h4>\n<p>当ref作为反应对象的属性进行访问或突变时，它会自动展开为内部值，因此其行为类似于普通属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  count</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.count) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">state.count = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>请注意，如果将新的引用分配给链接到现有引用的属性，它将替换旧的引用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> otherCount = ref(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">state.count = otherCount</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.count) <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"typing-类型\">typing 类型</span></h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Ref&lt;T&gt; &#123;</span><br><span class=\"line\">  value: T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ref</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">value: T</span>): <span class=\"title\">Ref</span>&lt;<span class=\"title\">T</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有时我们可能需要为ref的内部值指定复杂类型。我们可以通过在调用ref以覆盖默认推断时传递泛型参数来简洁地实现此目的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = ref&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;(<span class=\"string\">'foo'</span>) <span class=\"comment\">// foo's type: Ref&lt;string | number&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.value = <span class=\"number\">123</span> <span class=\"comment\">// ok!</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"isref\">isRef</span></h2>\n<p>检查值是否是引用对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unwrapped = isRef(foo) ? foo.value : foo</span><br></pre></td></tr></table></figure>\n<h4><span id=\"typing-类型\">typing 类型</span></h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRef</span>(<span class=\"params\">value: <span class=\"built_in\">any</span></span>): <span class=\"title\">value</span> <span class=\"title\">is</span> <span class=\"title\">Ref</span>&lt;<span class=\"title\">any</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"torefs\">toRefs</span></h2>\n<p>将反应对象转换为普通对象，其中结果对象上的每个属性都是指向原始对象中相应属性的<code>ref</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stateAsRefs = toRefs(state)</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Type of stateAsRefs:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  foo: Ref&lt;1&gt;,</span></span><br><span class=\"line\"><span class=\"comment\">  bar: Ref&lt;2&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The ref and the original property is \"linked\"</span></span><br><span class=\"line\">state.foo++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stateAsRefs.foo) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">stateAsRefs.foo.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.foo) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p><code>toRefs</code> 从组合函数返回反应对象时，此函数很有用，以便使用组件可以分解/散布返回的对象而不会失去反应性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFeatureX</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">    bar: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// logic operating on state</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// convert to refs when returning</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> toRefs(state)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// can destructure without losing reactivity</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      foo,</span><br><span class=\"line\">      bar</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"computed\">Computed</span></h2>\n<p>采用getter函数，并为getter返回的值返回一个不变的反应性ref对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusOne.value) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value++ <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>或者，它可以使用具有get和set功能的对象来创建可写的ref对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: () =&gt; count.value + 1,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: val =&gt; &#123; count.value = val - <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"typing-类型\">typing 类型</span></h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// read-only</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computed</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">getter: () =&gt; T</span>): <span class=\"title\">Readonly</span>&lt;<span class=\"title\">Ref</span>&lt;<span class=\"title\">Readonly</span>&lt;<span class=\"title\">T</span>&gt;&gt;&gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">writable</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computed</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">options: &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">get</span>: () =&gt; T,</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">set</span>: (value: T) =&gt; <span class=\"built_in\">void</span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"params\">&#125;</span>): <span class=\"title\">Ref</span>&lt;<span class=\"title\">T</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"未完待续\">未完待续…</span></h3>\n","site":{"data":{}},"excerpt":"","more":"<h1>API Reference</h1>\n<blockquote>\n<p>要看源码之前，首先要学会TypeScript（前十篇文档有<code>Typescript</code>学习指南）,因为vue3.x 版本中+90%的代码是使用的<code>Typescript</code>，<a href=\"https://github.com/vuejs/vue-next\" target=\"_blank\" rel=\"noopener\">Vue3.x 源码地址</a>。</p>\n</blockquote>\n<h2>Setup</h2>\n<p>该<code>setup</code>功能是新的组件选项。它充当在组件内部使用Composition API的入口点。</p>\n<h4>调用时间</h4>\n<p><code>setup</code>创建组件实例时，在初始道具解析后立即调用。在生命周期方面，在<code>beforeCreate</code>挂接之后和挂接之前调用它<code>created</code>。</p>\n<h4>和模板配合使用</h4>\n<p>如果<code>setup</code>返回一个对象，则该对象上的属性将合并到组件模板的渲染上下文中：</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;&#123;&#123; count &#125;&#125; &#123;&#123; object.foo &#125;&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, reactive &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> object = reactive(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// expose to template</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count,</span><br><span class=\"line\">      object</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>请注意，<code>setup</code>在模板中访问时，从<code>ref</code>返回的引用会自动解包，因此不需要<code>.valuein</code>模板。</p>\n<h4>渲染功能/ JSX的用法</h4>\n<p><code>setup</code> 还可以返回一个<code>render</code>函数，该函数可以直接使用在同一作用域中声明的反应状态：</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; h, ref, reactive &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">   setup() &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">     <span class=\"keyword\">const</span> object = reactive(&#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> h(<span class=\"string\">'div'</span>, [</span><br><span class=\"line\">       count.value,</span><br><span class=\"line\">       object.foo</span><br><span class=\"line\">     ])</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h4>参数</h4>\n<p>该函数将接收到的<code>props</code>作为其第一个参数：</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">String</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>请注意，此<code>props</code>对象是反应性的-即，当传入新的<code>props</code>时会更新该对象，并且可以使用<code>watch</code>函数观察并做出反应：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">String</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setup(props) &#123;</span><br><span class=\"line\">    watch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`name is: `</span> + props.name)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>props</code>在开发过程中，该对象对于用户区代码是不可变的（如果用户代码尝试对其进行更改，则会发出警告）。</p>\n<p>第二个参数提供了一个上下文对象<code>context</code>，该对象公开了先前<code>this</code>在2.x API中公开的属性的选择性列表：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">const</span> MyComponent = &#123;</span><br><span class=\"line\">  setup(props, context) &#123;</span><br><span class=\"line\">    context.attrs</span><br><span class=\"line\">    context.slots</span><br><span class=\"line\">    context.parent</span><br><span class=\"line\">    context.root</span><br><span class=\"line\">    context.emit</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>attrs</code>并且<code>slots</code>是内部组件实例上对应值的代理。这样可以确保即使在更新后它们也始终显示最新值，以便我们可以对它们进行结构分解而不必担心访问陈旧的引用：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">const</span> MyComponent = &#123;</span><br><span class=\"line\">  setup(props, &#123; attrs &#125;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// a function that may get called at a later stage</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(attrs.foo) <span class=\"comment\">// guaranteed to be the latest reference</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有很多理由将其放置<code>props</code>为单独的第一个参数而不是将其包含在上下文中：</p>\n<ul>\n<li><code>props</code>与其他属性相比，使用一个组件更为常见，并且通常一个组件仅使用<code>props</code>。</li>\n<li>具有<code>props</code>作为单独的参数可以更容易地单独键入它（见仅打字稿-道具打字下文）而对上下文搞乱了其它类型的属性。通过<code>TSX</code>支持<code>setup</code>，它还可以跨，<code>render</code>和普通功能组件保持一致的签名。</li>\n</ul>\n<h4>This</h4>\n<p><code>this</code>里面没有<code>setup()</code>。由于<code>setup()</code>是在解析2.x选项之前调用的，因此<code>this</code>内部<code>setup()</code>（如果可用）的行为将与<code>this</code>其他2.x选项完全不同。<code>setup()</code>与其他2.x选项一起使用时，使其可用可能会引起混乱。避免<code>this</code>进入的另一个原因<code>setup()</code>是对于初学者来说非常常见的陷阱：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> setup() &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span> <span class=\"comment\">// not the `this` you'd expect!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>Typing(类型)</h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Data &#123;</span><br><span class=\"line\">   [key: <span class=\"built_in\">string</span>]: unknown</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">interface</span> SetupContext &#123;</span><br><span class=\"line\">   attrs: Data</span><br><span class=\"line\">   slots: Slots</span><br><span class=\"line\">   parent: ComponentInstance | <span class=\"literal\">null</span></span><br><span class=\"line\">   root: ComponentInstance</span><br><span class=\"line\">   emit: <span class=\"function\">(<span class=\"params\">(<span class=\"params\">event: <span class=\"built_in\">string</span>, ...args: unknown[]</span>) =&gt; <span class=\"built_in\">void</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"> &#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"params\">function</span> <span class=\"params\">setup</span>(<span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   props: Data,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   context: SetupContext</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> </span>): <span class=\"params\">Data</span></span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>要获得传递给的参数的类型推断，需要<code>setup()</code>使用<code>createComponent</code>。</p>\n</blockquote>\n<h2>Reactive</h2>\n<p>取得一个对象并返回原始对象的反应式代理。这相当于2.x的<code>Vue.observable()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = reactive(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>反应式转换是“深度”的：它将影响所有嵌套属性。在基于ES2015代理的实现中，返回的代理不等于原始对象。建议仅与反应式代理一起使用，并避免依赖原始对象。</p>\n<h4>typeing 类型</h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactive</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">object</span>&gt;(<span class=\"params\">raw: T</span>): <span class=\"title\">T</span></span></span><br></pre></td></tr></table></figure>\n<h2>Ref</h2>\n<p>接受一个内部值并返回一个反应性且可变的<code>ref</code>对象。<code>ref</code>对象具有<code>.value</code>指向内部值的单个属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">count.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如果将一个对象分配为<code>ref</code>的值，则该<code>reactive</code>方法会使该对象具有高度的反应性。</p>\n<h4>模板中访问</h4>\n<p>当<code>ref</code>作为渲染上下文（从中返回的对象<code>setup()</code>）的属性返回并在模板中进行访问时，它会自动展开为内部值。无需<code>.value</code>在模板中追加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      count: ref(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<h4>反应性对象中的访问</h4>\n<p>当ref作为反应对象的属性进行访问或突变时，它会自动展开为内部值，因此其行为类似于普通属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  count</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.count) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">state.count = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>请注意，如果将新的引用分配给链接到现有引用的属性，它将替换旧的引用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> otherCount = ref(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">state.count = otherCount</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.count) <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<h4>typing 类型</h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Ref&lt;T&gt; &#123;</span><br><span class=\"line\">  value: T</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ref</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">value: T</span>): <span class=\"title\">Ref</span>&lt;<span class=\"title\">T</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有时我们可能需要为ref的内部值指定复杂类型。我们可以通过在调用ref以覆盖默认推断时传递泛型参数来简洁地实现此目的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = ref&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span>&gt;(<span class=\"string\">'foo'</span>) <span class=\"comment\">// foo's type: Ref&lt;string | number&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.value = <span class=\"number\">123</span> <span class=\"comment\">// ok!</span></span><br></pre></td></tr></table></figure>\n<h2>isRef</h2>\n<p>检查值是否是引用对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unwrapped = isRef(foo) ? foo.value : foo</span><br></pre></td></tr></table></figure>\n<h4>typing 类型</h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isRef</span>(<span class=\"params\">value: <span class=\"built_in\">any</span></span>): <span class=\"title\">value</span> <span class=\"title\">is</span> <span class=\"title\">Ref</span>&lt;<span class=\"title\">any</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2>toRefs</h2>\n<p>将反应对象转换为普通对象，其中结果对象上的每个属性都是指向原始对象中相应属性的<code>ref</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stateAsRefs = toRefs(state)</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Type of stateAsRefs:</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  foo: Ref&lt;1&gt;,</span></span><br><span class=\"line\"><span class=\"comment\">  bar: Ref&lt;2&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The ref and the original property is \"linked\"</span></span><br><span class=\"line\">state.foo++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stateAsRefs.foo) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">stateAsRefs.foo.value++</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(state.foo) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p><code>toRefs</code> 从组合函数返回反应对象时，此函数很有用，以便使用组件可以分解/散布返回的对象而不会失去反应性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFeatureX</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> state = reactive(&#123;</span><br><span class=\"line\">    foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">    bar: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// logic operating on state</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// convert to refs when returning</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> toRefs(state)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  setup() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// can destructure without losing reactivity</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; foo, bar &#125; = useFeatureX()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      foo,</span><br><span class=\"line\">      bar</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Computed</h2>\n<p>采用getter函数，并为getter返回的值返回一个不变的反应性ref对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value + <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusOne.value) <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value++ <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>或者，它可以使用具有get和set功能的对象来创建可写的ref对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = ref(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> plusOne = computed(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: () =&gt; count.value + 1,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: val =&gt; &#123; count.value = val - <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">plusOne.value = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count.value) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<h4>typing 类型</h4>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// read-only</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computed</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">getter: () =&gt; T</span>): <span class=\"title\">Readonly</span>&lt;<span class=\"title\">Ref</span>&lt;<span class=\"title\">Readonly</span>&lt;<span class=\"title\">T</span>&gt;&gt;&gt;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">writable</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computed</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">options: &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">get</span>: () =&gt; T,</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">set</span>: (value: T) =&gt; <span class=\"built_in\">void</span></span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"function\"><span class=\"params\">&#125;</span>): <span class=\"title\">Ref</span>&lt;<span class=\"title\">T</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h3>未完待续…</h3>\n"},{"title":"TypeScript 学习第五章 TypeScript接口","catalog":true,"date":"2019-08-18T06:09:25.000Z","subtitle":null,"header-img":"http://img2.imgtn.bdimg.com/it/u=1658727450,3910645464&fm=26&gp=0.jpg","_content":"\n\n# 接口\n\nTypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n## 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\n```typescript\nfunction printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = { size: 10, label: 'Size 10 Object' }\nprintLabel(myObj)\n```\n\n类型检查器会查看 `printLabel` 的调用。`printLabel` 有一个参数，并要求这个对象参数有一个名为 `label` 类型为 `string` 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个`label` 属性且类型为 `string`：\n\n```typescript\ninterface LabelledValue {\n  label: string\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = {size: 10, label: 'Size 10 Object'}\nprintLabel(myObj)\n```\n\n`LabelledValue` 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 `label` 属性且类型为`string` 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 `printLabel` 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n## 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n  color?: string\n  width?: number\n}\n\nfunction createSquare (config: SquareConfig): Square {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\nlet mySquare = createSquare({color: 'black'})\n```\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 `?` 符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 `createSquare` 里的 `color` 属性名拼错，就会得到一个错误提示：\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n   color?: string;\n   width?: number;\n}\n \nfunction createSquare(config: SquareConfig): Square {\n   let newSquare = {color: 'white', area: 100}\n   if (config.clor) {\n     // Error: 属性 'clor' 不存在于类型 'SquareConfig' 中\n     newSquare.color = config.clor\n   }\n   if (config.width) {\n     newSquare.area = config.width * config.width\n   }\n   return newSquare\n }\n \n let mySquare = createSquare({color: 'black'})\n```\n\n## 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly` 来指定只读属性:\n\n```typescript\ninterface Point {\n  readonly x: number\n  readonly y: number\n}\n```\n\n你可以通过赋值一个对象字面量来构造一个 `Point`。 赋值后，`x` 和 `y` 再也不能被改变了。\n\n```typescript\nlet p1: Point = { x: 10, y: 20 }\np1.x = 5 // error!\n```\n\nTypeScript 具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n```typescript\nlet a: number[] = [1, 2, 3, 4]\nlet ro: ReadonlyArray<number> = a\nro[0] = 12 // error!\nro.push(5) // error!\nro.length = 100 // error!\na = ro // error!\n```\n\n上面代码的最后一行，可以看到就算把整个 `ReadonlyArray` 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\n```typescript\na = ro as number[]\n```\n\n### readonly vs const\n\n最简单判断该用 `readonly` 还是 `const` 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用 `readonly`。\n\n## 额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript 让我们传入 `{ size: number; label: string; }` 到仅期望得到 `{ label: string; }` 的函数里, 并且我们已经学过了可选属性。\n\n然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 `createSquare` 例子来说：\n\n```typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare (config: SquareConfig): { color: string; area: number } {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\n\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n注意传入 `createSquare` 的参数拼写为 `colour` 而不是 `color`。 在 JavaScript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为 `width` 属性是兼容的，不存在 `color` 属性，而且额外的 `colour` 属性是无意义的。\n\n然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n```typescript\n// error: 'colour' 不存在于类型 'SquareConfig' 中\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\n```typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig)\n```\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 `SquareConfig` 带有上面定义的类型的 `color` 和 `width` 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n\n```typescript\ninterface SquareConfig {\n  color?: string\n  width?: number\n  [propName: string]: any\n}\n```\n\n我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig` 可以有任意数量的属性，并且只要它们不是 `color` 和 `width`，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 `squareOptions` 不会经过额外属性检查，所以编译器不会报错。\n\n```typescript\nlet squareOptions = { colour: 'red', width: 100 }\nlet mySquare = createSquare(squareOptions)\n```\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 `color` 或 `colour` 属性到 `createSquare`，你应该修改 `SquareConfig` 定义来体现出这一点。\n\n\n## 函数类型\n\n接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean\n}\n```\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(source: string, subString: string): boolean {\n  let result = source.search(subString);\n  return result > -1\n}\n```\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1\n}\n```\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  `SearchFunc` 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 `false` 和 `true`）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 `SearchFunc` 接口中的定义不匹配。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src, sub) {\n  let result = src.search(sub)\n  return result > -1\n}\n```\n\n## 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 `a[10]` 或 `ageMap['daniel']`。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```typescript\ninterface StringArray {\n  [index: number]: string\n}\n\nlet myArray: StringArray\nmyArray = ['Bob', 'Fred']\n\nlet myStr: string = myArray[0]\n```\n\n上面例子里，我们定义了 `StringArray` 接口，它具有索引签名。 这个索引签名表示了当用 `number` 去索引 `StringArray` 时会得到 `string` 类型的返回值。\n\nTypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 `number` 来索引时，JavaScript 会将它转换成`string` 然后再去索引对象。 也就是说用 `100`（一个 `number`）去索引等同于使用`'100'`（一个 `string` ）去索引，因此两者需要保持一致。\n\n```typescript\nclass Animal {\n  name: string\n}\nclass Dog extends Animal {\n  breed: string\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n  [x: number]: Animal\n  [x: string]: Dog\n}\n```\n\n字符串索引签名能够很好的描述 `dictionary` 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 `obj.property` 和 `obj['property']` 两种形式都可以。 下面的例子里， `name` 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\n```typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\n```typescript\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = ['Alice', 'Bob'];\nmyArray[2] = 'Mallory'; // error!\n```\n\n## 类类型\n\n### 实现接口\n\n与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的 `setTime` 方法一样：\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n  setTime(d: Date)\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  setTime(d: Date) {\n    this.currentTime = d\n  }\n  constructor(h: number, m: number) { }\n}\n```\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number)\n}\n\n// error\nclass Clock implements ClockConstructor {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。`constructor` 存在于类的静态部分，所以不在检查的范围内。\n\n看下面的例子，我们定义了两个接口，  `ClockConstructor` 为构造函数所用和 `ClockInterface` 为实例方法所用。 为了方便我们定义一个构造函数 `createClock`，它用传入的类型创建实例。\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface\n}\ninterface ClockInterface {\n  tick()\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n  return new ctor(hour, minute)\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('beep beep')\n  }\n}\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('tick tock')\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17)\nlet analog = createClock(AnalogClock, 7, 32)\n```\n\n因为 `createClock` 的第一个参数是 `ClockConstructor` 类型，在 `createClock(AnalogClock, 7, 32)` 里，会检查 `AnalogClock` 是否符合构造函数签名。\n\n\n## 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface Square extends Shape {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\n```\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface PenStroke {\n  penWidth: number\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\nsquare.penWidth = 5.0\n```\n\n## 混合类型\n\n先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\n```typescript\ninterface Counter {\n  (start: number): string\n  interval: number\n  reset(): void\n}\n\nfunction getCounter(): Counter {\n  let counter = (function (start: number) { }) as Counter\n  counter.interval = 123\n  counter.reset = function () { }\n  return counter\n}\n\nlet c = getCounter()\nc(10)\nc.reset()\nc.interval = 5.0\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 `axios` 库就是一个很好的例子。\n\n## 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 `private` 和 `protected` 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：\n\n```typescript\nclass Control {\n  private state: any\n}\n\ninterface SelectableControl extends Control {\n  select(): void\n}\n\nclass Button extends Control implements SelectableControl {\n  select() { }\n}\n\nclass TextBox extends Control {\n  select() { }\n}\n\n// Error：“ImageC”类型缺少“state”属性。\nclass ImageC implements SelectableControl {\n  select() { }\n}\n```\n在上面的例子里，`SelectableControl` 包含了 `Control` 的所有成员，包括私有成员 `state`。 因为 `state` 是私有成员，所以只能够是 `Control` 的子类们才能实现 `SelectableControl` 接口。 因为只有 `Control` 的子类才能够拥有一个声明于`Control` 的私有成员 `state`，这对私有成员的兼容性是必需的。\n\n在 `Control` 类内部，是允许通过 `SelectableControl` 的实例来访问私有成员 `state` 的。 实际上，`SelectableControl` 接口和拥有 `select` 方法的 `Control` 类是一样的。`Button`和 `TextBox` 类是 `SelectableControl` 的子类（因为它们都继承自`Control` 并有 `select` 方法），但 `ImageC` 类并不是这样的。\n\n","source":"_posts/TypeScript 学习第五章 TypeScript接口.md","raw":"---\ntitle: TypeScript 学习第五章 TypeScript接口\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-18 14:09:25\nsubtitle:\nheader-img: \"http://img2.imgtn.bdimg.com/it/u=1658727450,3910645464&fm=26&gp=0.jpg\"\n---\n\n\n# 接口\n\nTypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n\n## 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n\n```typescript\nfunction printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = { size: 10, label: 'Size 10 Object' }\nprintLabel(myObj)\n```\n\n类型检查器会查看 `printLabel` 的调用。`printLabel` 有一个参数，并要求这个对象参数有一个名为 `label` 类型为 `string` 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个`label` 属性且类型为 `string`：\n\n```typescript\ninterface LabelledValue {\n  label: string\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label)\n}\n\nlet myObj = {size: 10, label: 'Size 10 Object'}\nprintLabel(myObj)\n```\n\n`LabelledValue` 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 `label` 属性且类型为`string` 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 `printLabel` 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n\n## 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n  color?: string\n  width?: number\n}\n\nfunction createSquare (config: SquareConfig): Square {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\nlet mySquare = createSquare({color: 'black'})\n```\n\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 `?` 符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 `createSquare` 里的 `color` 属性名拼错，就会得到一个错误提示：\n\n```typescript\ninterface Square {\n  color: string,\n  area: number\n}\n\ninterface SquareConfig {\n   color?: string;\n   width?: number;\n}\n \nfunction createSquare(config: SquareConfig): Square {\n   let newSquare = {color: 'white', area: 100}\n   if (config.clor) {\n     // Error: 属性 'clor' 不存在于类型 'SquareConfig' 中\n     newSquare.color = config.clor\n   }\n   if (config.width) {\n     newSquare.area = config.width * config.width\n   }\n   return newSquare\n }\n \n let mySquare = createSquare({color: 'black'})\n```\n\n## 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly` 来指定只读属性:\n\n```typescript\ninterface Point {\n  readonly x: number\n  readonly y: number\n}\n```\n\n你可以通过赋值一个对象字面量来构造一个 `Point`。 赋值后，`x` 和 `y` 再也不能被改变了。\n\n```typescript\nlet p1: Point = { x: 10, y: 20 }\np1.x = 5 // error!\n```\n\nTypeScript 具有 `ReadonlyArray<T>` 类型，它与 `Array<T>` 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n\n```typescript\nlet a: number[] = [1, 2, 3, 4]\nlet ro: ReadonlyArray<number> = a\nro[0] = 12 // error!\nro.push(5) // error!\nro.length = 100 // error!\na = ro // error!\n```\n\n上面代码的最后一行，可以看到就算把整个 `ReadonlyArray` 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n\n```typescript\na = ro as number[]\n```\n\n### readonly vs const\n\n最简单判断该用 `readonly` 还是 `const` 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 `const`，若做为属性则使用 `readonly`。\n\n## 额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript 让我们传入 `{ size: number; label: string; }` 到仅期望得到 `{ label: string; }` 的函数里, 并且我们已经学过了可选属性。\n\n然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 `createSquare` 例子来说：\n\n```typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare (config: SquareConfig): { color: string; area: number } {\n  let newSquare = {color: 'white', area: 100}\n  if (config.color) {\n    newSquare.color = config.color\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width\n  }\n  return newSquare\n}\n\n\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n注意传入 `createSquare` 的参数拼写为 `colour` 而不是 `color`。 在 JavaScript 里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为 `width` 属性是兼容的，不存在 `color` 属性，而且额外的 `colour` 属性是无意义的。\n\n然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n\n```typescript\n// error: 'colour' 不存在于类型 'SquareConfig' 中\nlet mySquare = createSquare({ colour: 'red', width: 100 })\n```\n\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n\n```typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig)\n```\n\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 `SquareConfig` 带有上面定义的类型的 `color` 和 `width` 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n\n```typescript\ninterface SquareConfig {\n  color?: string\n  width?: number\n  [propName: string]: any\n}\n```\n\n我们稍后会讲到索引签名，但在这我们要表示的是`SquareConfig` 可以有任意数量的属性，并且只要它们不是 `color` 和 `width`，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 `squareOptions` 不会经过额外属性检查，所以编译器不会报错。\n\n```typescript\nlet squareOptions = { colour: 'red', width: 100 }\nlet mySquare = createSquare(squareOptions)\n```\n\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 `color` 或 `colour` 属性到 `createSquare`，你应该修改 `SquareConfig` 定义来体现出这一点。\n\n\n## 函数类型\n\n接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean\n}\n```\n\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(source: string, subString: string): boolean {\n  let result = source.search(subString);\n  return result > -1\n}\n```\n\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1\n}\n```\n\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  `SearchFunc` 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 `false` 和 `true`）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 `SearchFunc` 接口中的定义不匹配。\n\n```typescript\nlet mySearch: SearchFunc\nmySearch = function(src, sub) {\n  let result = src.search(sub)\n  return result > -1\n}\n```\n\n## 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 `a[10]` 或 `ageMap['daniel']`。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```typescript\ninterface StringArray {\n  [index: number]: string\n}\n\nlet myArray: StringArray\nmyArray = ['Bob', 'Fred']\n\nlet myStr: string = myArray[0]\n```\n\n上面例子里，我们定义了 `StringArray` 接口，它具有索引签名。 这个索引签名表示了当用 `number` 去索引 `StringArray` 时会得到 `string` 类型的返回值。\n\nTypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 `number` 来索引时，JavaScript 会将它转换成`string` 然后再去索引对象。 也就是说用 `100`（一个 `number`）去索引等同于使用`'100'`（一个 `string` ）去索引，因此两者需要保持一致。\n\n```typescript\nclass Animal {\n  name: string\n}\nclass Dog extends Animal {\n  breed: string\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n  [x: number]: Animal\n  [x: string]: Dog\n}\n```\n\n字符串索引签名能够很好的描述 `dictionary` 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 `obj.property` 和 `obj['property']` 两种形式都可以。 下面的例子里， `name` 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n\n```typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n\n```typescript\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = ['Alice', 'Bob'];\nmyArray[2] = 'Mallory'; // error!\n```\n\n## 类类型\n\n### 实现接口\n\n与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n你也可以在接口中描述一个方法，在类里实现它，如同下面的 `setTime` 方法一样：\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date\n  setTime(d: Date)\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date\n  setTime(d: Date) {\n    this.currentTime = d\n  }\n  constructor(h: number, m: number) { }\n}\n```\n\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number)\n}\n\n// error\nclass Clock implements ClockConstructor {\n  currentTime: Date\n  constructor(h: number, m: number) { }\n}\n```\n\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。`constructor` 存在于类的静态部分，所以不在检查的范围内。\n\n看下面的例子，我们定义了两个接口，  `ClockConstructor` 为构造函数所用和 `ClockInterface` 为实例方法所用。 为了方便我们定义一个构造函数 `createClock`，它用传入的类型创建实例。\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface\n}\ninterface ClockInterface {\n  tick()\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n  return new ctor(hour, minute)\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('beep beep')\n  }\n}\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) { }\n  tick() {\n    console.log('tick tock')\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17)\nlet analog = createClock(AnalogClock, 7, 32)\n```\n\n因为 `createClock` 的第一个参数是 `ClockConstructor` 类型，在 `createClock(AnalogClock, 7, 32)` 里，会检查 `AnalogClock` 是否符合构造函数签名。\n\n\n## 继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface Square extends Shape {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\n```\n\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n\n```typescript\ninterface Shape {\n  color: string\n}\n\ninterface PenStroke {\n  penWidth: number\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number\n}\n\nlet square = {} as Square\nsquare.color = 'blue'\nsquare.sideLength = 10\nsquare.penWidth = 5.0\n```\n\n## 混合类型\n\n先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n\n```typescript\ninterface Counter {\n  (start: number): string\n  interval: number\n  reset(): void\n}\n\nfunction getCounter(): Counter {\n  let counter = (function (start: number) { }) as Counter\n  counter.interval = 123\n  counter.reset = function () { }\n  return counter\n}\n\nlet c = getCounter()\nc(10)\nc.reset()\nc.interval = 5.0\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 `axios` 库就是一个很好的例子。\n\n## 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 `private` 和 `protected` 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：\n\n```typescript\nclass Control {\n  private state: any\n}\n\ninterface SelectableControl extends Control {\n  select(): void\n}\n\nclass Button extends Control implements SelectableControl {\n  select() { }\n}\n\nclass TextBox extends Control {\n  select() { }\n}\n\n// Error：“ImageC”类型缺少“state”属性。\nclass ImageC implements SelectableControl {\n  select() { }\n}\n```\n在上面的例子里，`SelectableControl` 包含了 `Control` 的所有成员，包括私有成员 `state`。 因为 `state` 是私有成员，所以只能够是 `Control` 的子类们才能实现 `SelectableControl` 接口。 因为只有 `Control` 的子类才能够拥有一个声明于`Control` 的私有成员 `state`，这对私有成员的兼容性是必需的。\n\n在 `Control` 类内部，是允许通过 `SelectableControl` 的实例来访问私有成员 `state` 的。 实际上，`SelectableControl` 接口和拥有 `select` 方法的 `Control` 类是一样的。`Button`和 `TextBox` 类是 `SelectableControl` 的子类（因为它们都继承自`Control` 并有 `select` 方法），但 `ImageC` 类并不是这样的。\n\n","slug":"TypeScript 学习第五章 TypeScript接口","published":1,"updated":"2019-12-31T03:00:25.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj8w008hzws6k0ct8qlj","content":"<h1><span id=\"接口\">接口</span></h1>\n<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<h2><span id=\"接口初探\">接口初探</span></h2>\n<p>下面通过一个简单示例来观察接口是如何工作的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: &#123; label: <span class=\"built_in\">string</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span> &#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p>类型检查器会查看 <code>printLabel</code> 的调用。<code>printLabel</code> 有一个参数，并要求这个对象参数有一个名为 <code>label</code> 类型为 <code>string</code> 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。</p>\n<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code> 属性且类型为 <code>string</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span>&#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p><code>LabelledValue</code> 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 <code>label</code> 属性且类型为<code>string</code> 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code> 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>\n<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<h2><span id=\"可选属性\">可选属性</span></h2>\n<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p>\n<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code> 里的 <code>color</code> 属性名拼错，就会得到一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">   color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">   width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.clor) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Error: 属性 'clor' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\">     newSquare.color = config.clor</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">     newSquare.area = config.width * config.width</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h2><span id=\"只读属性\">只读属性</span></h2>\n<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">  readonly x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  readonly y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以通过赋值一个对象字面量来构造一个 <code>Point</code>。 赋值后，<code>x</code> 和 <code>y</code> 再也不能被改变了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; x: <span class=\"number\">10</span>, y: <span class=\"number\">20</span> &#125;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span> <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = a</span><br><span class=\"line\">ro[<span class=\"number\">0</span>] = <span class=\"number\">12</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.push(<span class=\"number\">5</span>) <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.length = <span class=\"number\">100</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">a = ro <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的最后一行，可以看到就算把整个 <code>ReadonlyArray</code> 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = ro <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>[]</span><br></pre></td></tr></table></figure>\n<h3><span id=\"readonly-vs-const\">readonly vs const</span></h3>\n<p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p>\n<h2><span id=\"额外的属性检查\">额外的属性检查</span></h2>\n<p>我们在第一个例子里使用了接口，TypeScript 让我们传入 <code>{ size: number; label: string; }</code> 到仅期望得到 <code>{ label: string; }</code> 的函数里, 并且我们已经学过了可选属性。</p>\n<p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code> 例子来说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>注意传入 <code>createSquare</code> 的参数拼写为 <code>colour</code> 而不是 <code>color</code>。 在 JavaScript 里，这会默默地失败。</p>\n<p>你可能会争辩这个程序已经正确地类型化了，因为 <code>width</code> 属性是兼容的，不存在 <code>color</code> 属性，而且额外的 <code>colour</code> 属性是无意义的。</p>\n<p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// error: 'colour' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; width: <span class=\"number\">100</span>, opacity: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig)</span><br></pre></td></tr></table></figure>\n<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code> 带有上面定义的类型的 <code>color</code> 和 <code>width</code> 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> 和 <code>width</code>，那么就无所谓它们的类型是什么。</p>\n<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code> 不会经过额外属性检查，所以编译器不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions)</span><br></pre></td></tr></table></figure>\n<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code> 或 <code>colour</code> 属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code> 定义来体现出这一点。</p>\n<h2><span id=\"函数类型\">函数类型</span></h2>\n<p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>\n<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src: <span class=\"built_in\">string</span>, sub: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  <code>SearchFunc</code> 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code> 和 <code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code> 接口中的定义不匹配。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src, sub</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"可索引的类型\">可索引的类型</span></h2>\n<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap['daniel']</code>。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray</span><br><span class=\"line\">myArray = [<span class=\"string\">'Bob'</span>, <span class=\"string\">'Fred'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>上面例子里，我们定义了 <code>StringArray</code> 接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引 <code>StringArray</code> 时会得到 <code>string</code> 类型的返回值。</p>\n<p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code> 来索引时，JavaScript 会将它转换成<code>string</code> 然后再去索引对象。 也就是说用 <code>100</code>（一个 <code>number</code>）去索引等同于使用<code>'100'</code>（一个 <code>string</code> ）去索引，因此两者需要保持一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  breed: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotOkay &#123;</span><br><span class=\"line\">  [x: <span class=\"built_in\">number</span>]: Animal</span><br><span class=\"line\">  [x: <span class=\"built_in\">string</span>]: Dog</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串索引签名能够很好的描述 <code>dictionary</code> 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj['property']</code> 两种形式都可以。 下面的例子里， <code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NumberDictionary &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;    <span class=\"comment\">// 可以，length是number类型</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>       <span class=\"comment\">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyStringArray &#123;</span><br><span class=\"line\">  readonly [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: ReadonlyStringArray = [<span class=\"string\">'Alice'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">'Mallory'</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"类类型\">类类型</span></h2>\n<h3><span id=\"实现接口\">实现接口</span></h3>\n<p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentTime = d</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>\n<h3><span id=\"类静态部分与实例部分的区别\">类静态部分与实例部分的区别</span></h3>\n<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockConstructor &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p>\n<p>看下面的例子，我们定义了两个接口，  <code>ClockConstructor</code> 为构造函数所用和 <code>ClockInterface</code> 为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>): ClockInterface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  tick()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> DigitalClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'beep beep'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> AnalogClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'tick tock'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名。</p>\n<h2><span id=\"继承接口\">继承接口</span></h2>\n<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">  penWidth: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"混合类型\">混合类型</span></h2>\n<p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>\n<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">  (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span></span><br><span class=\"line\">  interval: <span class=\"built_in\">number</span></span><br><span class=\"line\">  reset(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> counter = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;) <span class=\"keyword\">as</span> Counter</span><br><span class=\"line\">  counter.interval = <span class=\"number\">123</span></span><br><span class=\"line\">  counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> counter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter()</span><br><span class=\"line\">c(<span class=\"number\">10</span>)</span><br><span class=\"line\">c.reset()</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 <code>axios</code> 库就是一个很好的例子。</p>\n<h2><span id=\"接口继承类\">接口继承类</span></h2>\n<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>\n<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error：“ImageC”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> ImageC <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员，包括私有成员 <code>state</code>。 因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口。 因为只有 <code>Control</code> 的子类才能够拥有一个声明于<code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。</p>\n<p>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。 实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code>和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类（因为它们都继承自<code>Control</code> 并有 <code>select</code> 方法），但 <code>ImageC</code> 类并不是这样的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>接口</h1>\n<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<h2>接口初探</h2>\n<p>下面通过一个简单示例来观察接口是如何工作的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: &#123; label: <span class=\"built_in\">string</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span> &#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p>类型检查器会查看 <code>printLabel</code> 的调用。<code>printLabel</code> 有一个参数，并要求这个对象参数有一个名为 <code>label</code> 类型为 <code>string</code> 的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，以及其类型是否匹配。 然而，有些时候 TypeScript  却并不会这么宽松，我们下面会稍做讲解。</p>\n<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code> 属性且类型为 <code>string</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;size: <span class=\"number\">10</span>, label: <span class=\"string\">'Size 10 Object'</span>&#125;</span><br><span class=\"line\">printLabel(myObj)</span><br></pre></td></tr></table></figure>\n<p><code>LabelledValue</code> 接口就好比一个名字，用来描述上面例子里的结构。 它代表了有一个 <code>label</code> 属性且类型为<code>string</code> 的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code> 的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>\n<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<h2>可选属性</h2>\n<p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。例如给函数传入的参数对象中只有部分属性赋值了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p>\n<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 <code>createSquare</code> 里的 <code>color</code> 属性名拼错，就会得到一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>,</span><br><span class=\"line\">  area: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">   color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">   width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.clor) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// Error: 属性 'clor' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\">     newSquare.color = config.clor</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">     newSquare.area = config.width * config.width</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">'black'</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h2>只读属性</h2>\n<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">  readonly x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  readonly y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以通过赋值一个对象字面量来构造一个 <code>Point</code>。 赋值后，<code>x</code> 和 <code>y</code> 再也不能被改变了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; x: <span class=\"number\">10</span>, y: <span class=\"number\">20</span> &#125;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span> <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = a</span><br><span class=\"line\">ro[<span class=\"number\">0</span>] = <span class=\"number\">12</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.push(<span class=\"number\">5</span>) <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.length = <span class=\"number\">100</span> <span class=\"comment\">// error!</span></span><br><span class=\"line\">a = ro <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的最后一行，可以看到就算把整个 <code>ReadonlyArray</code> 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = ro <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>[]</span><br></pre></td></tr></table></figure>\n<h3>readonly vs const</h3>\n<p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p>\n<h2>额外的属性检查</h2>\n<p>我们在第一个例子里使用了接口，TypeScript 让我们传入 <code>{ size: number; label: string; }</code> 到仅期望得到 <code>{ label: string; }</code> 的函数里, 并且我们已经学过了可选属性。</p>\n<p>然而，天真地将这两者结合的话就会像在 JavaScript 里那样搬起石头砸自己的脚。 比如，拿 <code>createSquare</code> 例子来说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span> (<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">'white'</span>, area: <span class=\"number\">100</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>注意传入 <code>createSquare</code> 的参数拼写为 <code>colour</code> 而不是 <code>color</code>。 在 JavaScript 里，这会默默地失败。</p>\n<p>你可能会争辩这个程序已经正确地类型化了，因为 <code>width</code> 属性是兼容的，不存在 <code>color</code> 属性，而且额外的 <code>colour</code> 属性是无意义的。</p>\n<p>然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// error: 'colour' 不存在于类型 'SquareConfig' 中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; width: <span class=\"number\">100</span>, opacity: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig)</span><br></pre></td></tr></table></figure>\n<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code> 带有上面定义的类型的 <code>color</code> 和 <code>width</code> 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span></span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span></span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> 和 <code>width</code>，那么就无所谓它们的类型是什么。</p>\n<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code> 不会经过额外属性检查，所以编译器不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; colour: <span class=\"string\">'red'</span>, width: <span class=\"number\">100</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions)</span><br></pre></td></tr></table></figure>\n<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大多数额外属性检查错误是真正的bug。也就是说你遇到了额外类型检查出的错误，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code> 或 <code>colour</code> 属性到 <code>createSquare</code>，你应该修改 <code>SquareConfig</code> 定义来体现出这一点。</p>\n<h2>函数类型</h2>\n<p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>\n<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src: <span class=\"built_in\">string</span>, sub: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了  <code>SearchFunc</code> 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 <code>false</code> 和 <code>true</code>）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code> 接口中的定义不匹配。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src, sub</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>可索引的类型</h2>\n<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap['daniel']</code>。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray</span><br><span class=\"line\">myArray = [<span class=\"string\">'Bob'</span>, <span class=\"string\">'Fred'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n<p>上面例子里，我们定义了 <code>StringArray</code> 接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引 <code>StringArray</code> 时会得到 <code>string</code> 类型的返回值。</p>\n<p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code> 来索引时，JavaScript 会将它转换成<code>string</code> 然后再去索引对象。 也就是说用 <code>100</code>（一个 <code>number</code>）去索引等同于使用<code>'100'</code>（一个 <code>string</code> ）去索引，因此两者需要保持一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  breed: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotOkay &#123;</span><br><span class=\"line\">  [x: <span class=\"built_in\">number</span>]: Animal</span><br><span class=\"line\">  [x: <span class=\"built_in\">string</span>]: Dog</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串索引签名能够很好的描述 <code>dictionary</code> 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code> 和 <code>obj['property']</code> 两种形式都可以。 下面的例子里， <code>name</code> 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NumberDictionary &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;    <span class=\"comment\">// 可以，length是number类型</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>       <span class=\"comment\">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyStringArray &#123;</span><br><span class=\"line\">  readonly [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: ReadonlyStringArray = [<span class=\"string\">'Alice'</span>, <span class=\"string\">'Bob'</span>];</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">'Mallory'</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<h2>类类型</h2>\n<h3>实现接口</h3>\n<p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentTime = d</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>\n<h3>类静态部分与实例部分的区别</h3>\n<p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// error</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockConstructor &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p>\n<p>看下面的例子，我们定义了两个接口，  <code>ClockConstructor</code> 为构造函数所用和 <code>ClockInterface</code> 为实例方法所用。 为了方便我们定义一个构造函数 <code>createClock</code>，它用传入的类型创建实例。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>): ClockInterface</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  tick()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> DigitalClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'beep beep'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> AnalogClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">  tick() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'tick tock'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>)</span><br></pre></td></tr></table></figure>\n<p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名。</p>\n<h2>继承接口</h2>\n<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">  penWidth: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &#123;&#125; <span class=\"keyword\">as</span> Square</span><br><span class=\"line\">square.color = <span class=\"string\">'blue'</span></span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span></span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<h2>混合类型</h2>\n<p>先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>\n<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">  (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span></span><br><span class=\"line\">  interval: <span class=\"built_in\">number</span></span><br><span class=\"line\">  reset(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> counter = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;) <span class=\"keyword\">as</span> Counter</span><br><span class=\"line\">  counter.interval = <span class=\"number\">123</span></span><br><span class=\"line\">  counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> counter</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter()</span><br><span class=\"line\">c(<span class=\"number\">10</span>)</span><br><span class=\"line\">c.reset()</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span></span><br></pre></td></tr></table></figure>\n<p>在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。这门课要重构的 <code>axios</code> 库就是一个很好的例子。</p>\n<h2>接口继承类</h2>\n<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>\n<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error：“ImageC”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> ImageC <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">  select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员，包括私有成员 <code>state</code>。 因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口。 因为只有 <code>Control</code> 的子类才能够拥有一个声明于<code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。</p>\n<p>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。 实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code>和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类（因为它们都继承自<code>Control</code> 并有 <code>select</code> 方法），但 <code>ImageC</code> 类并不是这样的。</p>\n"},{"title":"TypeScript 学习第六章 TypeScript 类Class","catalog":true,"date":"2019-08-19T09:39:02.000Z","subtitle":null,"header-img":"http://img-download.pchome.net/download/1k1/8w/2j/oixa3f-13nt.jpg@0e_0o_960w_600h_90q.src","_content":"\n# 类\n\n对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。\n\n## 基本示例\n\n下面看一个使用类的例子：\n\n```typescript\nclass Greeter {\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter = new Greeter('world')\n```\n\n如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 `Greeter` 类。这个类有 3 个成员：一个叫做 `greeting` 的属性，一个构造函数和一个 `greet` 方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了 `this`。 它表示我们访问的是类的成员。\n\n最后一行，我们使用 `new` 构造了 `Greeter` 类的一个实例。它会调用之前定义的构造函数，创建一个 `Greeter` 类型的新对象，并执行构造函数初始化它。\n\n## 继承\n\n在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\n```typescript\nclass Animal {\n  move(distance: number = 0) {\n    console.log(`Animal moved ${distance}m.`)\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log('Woof! Woof!')\n  }\n}\n\nconst dog = new Dog()\ndog.bark()\ndog.move(10)\n```\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，`Dog` 是一个 派生类，它派生自 `Animal` 基类，通过 `extends` 关键字。 派生类通常被称作*子类*，基类通常被称作*超类*。\n\n因为 `Dog` 继承了 `Animal` 的功能，因此我们可以创建一个 `Dog` 的实例，它能够 `bark()` 和 `move()`。\n\n下面我们来看个更加复杂的例子。\n\n```typescript\nclass Animal {\n  name: string\n  constructor(name: string) { \n    this.name = name\n  }\n  move(distance: number = 0) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) { \n    super(name)\n  }\n  move(distance: number = 5) {\n    console.log('Slithering...')\n    super.move(distance)\n  }\n}\n\nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 45) {\n    console.log('Galloping...')\n    super.move(distance)\n  }\n}\n\nlet sam = new Snake('Sammy')\nlet tom: Animal = new Horse('Tommy')\n\nsam.move()\ntom.move(34)\n```\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用 `extends` 关键字创建了 Animal的两个子类：`Horse` 和 `Snake`。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 `super()`，它会执行基类的构造函数。 而且，在构造函数里访问 `this` 的属性之前，我们 一定要调用 `super()`。 这个是 TypeScript 强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。`Snake`类和 `Horse` 类都创建了 `move` 方法，它们重写了从 `Animal` 继承来的 `move` 方法，使得 `move` 方法根据不同的类而具有不同的功能。注意，即使 `tom` 被声明为 `Animal` 类型，但因为它的值是 `Horse`，调用 `tom.move(34)` 时，它会调用 `Horse` 里重写的方法。\n\n```\nSlithering...\nSammy moved 5m.\nGalloping...\nTommy moved 34m.\n```\n\n## 公共，私有与受保护的修饰符\n\n### 默认为 public\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 `public` 来做修饰；例如，C# 要求必须明确地使用 `public` 指定成员是可见的。 在 TypeScript 里，成员都默认为 `public`。\n\n你也可以明确的将一个成员标记成 `public`。 我们可以用下面的方式来重写上面的 `Animal` 类：\n\n```typescript\nclass Animal {\n  public name: string\n  public constructor(name: string) {\n    this.name = name\n  }\n  public move(distance: number) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n```\n\n### 理解 private\n\n当成员被标记成 `private` 时，它就不能在声明它的类的外部访问。比如：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nnew Animal('Cat').name // 错误: 'name' 是私有的.\n```\n\nTypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有 `private` 或 `protected` 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 `private` 成员，那么只有当另外一个类型中也存在这样一个 `private` 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 `protected` 成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Rhino extends Animal {\n  constructor() { \n    super('Rhino')\n  }\n}\n\nclass Employee {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nlet animal = new Animal('Goat')\nlet rhino = new Rhino()\nlet employee = new Employee('Bob')\n\nanimal = rhino\nanimal = employee // 错误: Animal 与 Employee 不兼容.\n```\n\n这个例子中有 `Animal` 和 `Rhino` 两个类， `Rhino` 是 `Animal` 类的子类。 还有一个 `Employee` 类，其类型看上去与 `Animal` 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 `Animal` 和 `Rhino` 共享了来自 `Animal` 里的私有成员定义 `private name: string`，因此它们是兼容的。然而 `Employee` 却不是这样。当把 `Employee` 赋值给 `Animal` 的时候，得到一个错误，说它们的类型不兼容。尽管 `Employee` 里也有一个私有成员 `name`，但它明显不是 `Animal` 里面定义的那个。\n\n### 理解 protected\n\n`protected` 修饰符与 `private` 修饰符的行为很相似，但有一点不同，`protected`成员在派生类中仍然可以访问。例如：\n\n```typescript\nclass Person {\n  protected name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n  \n  getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nconsole.log(howard.getElevatorPitch())\nconsole.log(howard.name) // error\n```\n\n注意，我们不能在 `Person` 类外使用 `name`，但是我们仍然可以通过 `Employee` 类的实例方法访问，因为 `Employee` 是由 `Person`  派生而来的。\n\n构造函数也可以被标记成 `protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：\n\n```typescript\nclass Person {\n  protected name: string\n  protected constructor(name: string) {\n    this.name = name\n  }\n}\n\n// Employee 能够继承 Person\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nlet john = new Person('John') // 错误: 'Person' 的构造函数是被保护的.\n```\n\n## readonly 修饰符\n\n你可以使用 `readonly` 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\n```typescript\nclass Person {\n  readonly name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet john = new Person('John')\njohn.name = 'peter'\n```\n\n### 参数属性\n\n在上面的例子中，我们必须在 `Person` 类里定义一个只读成员 `name` 和一个参数为 `name` 的构造函数，并且立刻将 `name` 的值赋给 `this.name`，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 `Person` 类的修改版，使用了参数属性：\n\n```typescript\nclass Person {\n  constructor(readonly name: string) {\n  }\n}\n```\n\n注意看我们是如何舍弃参数 `name`，仅在构造函数里使用 `readonly name: string` 参数来创建和初始化 `name` 成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 `private` 限定一个参数属性会声明并初始化一个私有成员；对于 `public` 和 `protected` 来说也是一样。\n\n## 存取器\n\n`TypeScript` 支持通过 `getters/setters` 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用 `get` 和 `set`。 首先，我们从一个没有使用存取器的例子开始。\n\n```typescript\nclass Employee {\n  fullName: string\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以设置 `fullName`，因为它是 `public` 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。\n\n下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 `fullName` 的直接访问改成了可以检查密码的 `set` 方法。 我们也加了一个 `get` 方法，让上面的例子仍然可以工作。\n\n```typescript\nlet passcode = 'secret passcode'\n\nclass Employee {\n  private _fullName: string\n\n  get fullName(): string {\n    return this._fullName\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == 'secret passcode') {\n      this._fullName = newName\n    }\n    else {\n      console.log('Error: Unauthorized update of employee!')\n    }\n  }\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`。这在从代码生成 `.d.ts` 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n## 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 `static` 定义 `origin`，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 `origin` 前面加上类名。 如同在实例属性上使用 `this.xxx` 来访问属性一样，这里我们使用 `Grid.xxx` 来访问静态属性。\n\n```typescript\nclass Grid {\n  static origin = {x: 0, y: 0}\n\n  scale: number\n\n  constructor (scale: number) {\n    this.scale = scale\n  }\n\n  calculateDistanceFromOrigin(point: {x: number; y: number}) {\n    let xDist = point.x - Grid.origin.x\n    let yDist = point.y - Grid.origin.y\n    return Math.sqrt(xDist * xDist + yDist * yDist) * this.scale\n  }\n}\n\nlet grid1 = new Grid(1.0)  // 1x scale\nlet grid2 = new Grid(5.0)  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 3, y: 4}))\nconsole.log(grid2.calculateDistanceFromOrigin({x: 3, y: 4}))\n```\n\n## 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 `abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\n```typescript\nabstract class Animal {\n  abstract makeSound(): void\n  move(): void {\n    console.log('roaming the earth...')\n  }\n}\n```\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 `abstract` 关键字并且可以包含访问修饰符。\n\n```typescript\nabstract class Department {\n  name: string\n\n  constructor(name: string) {\n     this.name = name\n  }\n\n  printName(): void {\n    console.log('Department name: ' + this.name)\n  }\n\n  abstract printMeeting(): void // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n  constructor() {\n    super('Accounting and Auditing') // 在派生类的构造函数中必须调用 super()\n  }\n\n  printMeeting(): void {\n    console.log('The Accounting Department meets each Monday at 10am.')\n  }\n\n  generateReports(): void {\n    console.log('Generating accounting reports...')\n  }\n}\n\nlet department: Department // 允许创建一个对抽象类型的引用\ndepartment = new Department() // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName()\ndepartment.printMeeting()\ndepartment.generateReports() // 错误: 方法在声明的抽象类中不存在\n```\n\n## 高级技巧\n\n### 构造函数\n\n当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的*实例*的类型。\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter('world')\nconsole.log(greeter.greet())\n```\n\n这里，我们写了 `let greeter: Greeter`，意思是 `Greeter` 类的实例的类型是 `Greeter`。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做*构造函数的值*。 这个函数会在我们使用 `new` 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：\n\n```javascript\nvar Greeter = /** @class */ (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n  Greeter.prototype.greet = function () {\n    return 'Hello, ' + this.greeting;\n  };\n  Greeter.standardGreeting = 'Hello, there';\n  return Greeter;\n}());\nvar greeter;\ngreeter = new Greeter('world');\nconsole.log(greeter.greet());\n```\n\n上面的代码里，`var Greeter` 将被构造函数赋值。 当我们调用 `new` 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有*实例部分*与*静态部分*这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  \n  greeting: string\n\n  constructor(message?: string) {\n    this.greeting = message\n  }\n\n  greet() {\n    if (this.greeting) {\n      return 'Hello, ' + this.greeting\n    } else {\n      return Greeter.standardGreeting\n    }\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter()\nconsole.log(greeter.greet())\n\nlet greeterMaker: typeof Greeter = Greeter\ngreeterMaker.standardGreeting = 'Hey there'\n\nlet greeter2: Greeter = new greeterMaker()\nconsole.log(greeter2.greet())\n```\n\n这个例子里， `greeter1` 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做 `greeterMaker` 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 `typeof Greeter`，意思是取 `Greeter` 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 `Greeter` 标识符的类型\"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 `greeterMaker` 上使用 `new`，创建 `Greeter` 的实例。\n\n### 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\n```typescript\nclass Point {\n  x: number\n  y: number\n}\n\ninterface Point3d extends Point {\n  z: number\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3}\n```\n\n\n","source":"_posts/TypeScript 学习第六章 TypeScript类.md","raw":"---\ntitle: TypeScript 学习第六章 TypeScript 类Class\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-19 17:39:02\nsubtitle:\nheader-img: \"http://img-download.pchome.net/download/1k1/8w/2j/oixa3f-13nt.jpg@0e_0o_960w_600h_90q.src\"\n---\n\n# 类\n\n对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。\n\n## 基本示例\n\n下面看一个使用类的例子：\n\n```typescript\nclass Greeter {\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter = new Greeter('world')\n```\n\n如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 `Greeter` 类。这个类有 3 个成员：一个叫做 `greeting` 的属性，一个构造函数和一个 `greet` 方法。\n\n你会注意到，我们在引用任何一个类成员的时候都用了 `this`。 它表示我们访问的是类的成员。\n\n最后一行，我们使用 `new` 构造了 `Greeter` 类的一个实例。它会调用之前定义的构造函数，创建一个 `Greeter` 类型的新对象，并执行构造函数初始化它。\n\n## 继承\n\n在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。\n\n看下面的例子：\n\n```typescript\nclass Animal {\n  move(distance: number = 0) {\n    console.log(`Animal moved ${distance}m.`)\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log('Woof! Woof!')\n  }\n}\n\nconst dog = new Dog()\ndog.bark()\ndog.move(10)\n```\n\n这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，`Dog` 是一个 派生类，它派生自 `Animal` 基类，通过 `extends` 关键字。 派生类通常被称作*子类*，基类通常被称作*超类*。\n\n因为 `Dog` 继承了 `Animal` 的功能，因此我们可以创建一个 `Dog` 的实例，它能够 `bark()` 和 `move()`。\n\n下面我们来看个更加复杂的例子。\n\n```typescript\nclass Animal {\n  name: string\n  constructor(name: string) { \n    this.name = name\n  }\n  move(distance: number = 0) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) { \n    super(name)\n  }\n  move(distance: number = 5) {\n    console.log('Slithering...')\n    super.move(distance)\n  }\n}\n\nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  move(distance: number = 45) {\n    console.log('Galloping...')\n    super.move(distance)\n  }\n}\n\nlet sam = new Snake('Sammy')\nlet tom: Animal = new Horse('Tommy')\n\nsam.move()\ntom.move(34)\n```\n\n这个例子展示了一些上面没有提到的特性。 这一次，我们使用 `extends` 关键字创建了 Animal的两个子类：`Horse` 和 `Snake`。\n\n与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 `super()`，它会执行基类的构造函数。 而且，在构造函数里访问 `this` 的属性之前，我们 一定要调用 `super()`。 这个是 TypeScript 强制执行的一条重要规则。\n\n这个例子演示了如何在子类里可以重写父类的方法。`Snake`类和 `Horse` 类都创建了 `move` 方法，它们重写了从 `Animal` 继承来的 `move` 方法，使得 `move` 方法根据不同的类而具有不同的功能。注意，即使 `tom` 被声明为 `Animal` 类型，但因为它的值是 `Horse`，调用 `tom.move(34)` 时，它会调用 `Horse` 里重写的方法。\n\n```\nSlithering...\nSammy moved 5m.\nGalloping...\nTommy moved 34m.\n```\n\n## 公共，私有与受保护的修饰符\n\n### 默认为 public\n\n在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 `public` 来做修饰；例如，C# 要求必须明确地使用 `public` 指定成员是可见的。 在 TypeScript 里，成员都默认为 `public`。\n\n你也可以明确的将一个成员标记成 `public`。 我们可以用下面的方式来重写上面的 `Animal` 类：\n\n```typescript\nclass Animal {\n  public name: string\n  public constructor(name: string) {\n    this.name = name\n  }\n  public move(distance: number) {\n    console.log(`${this.name} moved ${distance}m.`)\n  }\n}\n```\n\n### 理解 private\n\n当成员被标记成 `private` 时，它就不能在声明它的类的外部访问。比如：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nnew Animal('Cat').name // 错误: 'name' 是私有的.\n```\n\nTypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。\n\n然而，当我们比较带有 `private` 或 `protected` 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 `private` 成员，那么只有当另外一个类型中也存在这样一个 `private` 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 `protected` 成员也使用这个规则。\n\n下面来看一个例子，更好地说明了这一点：\n\n```typescript\nclass Animal {\n  private name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Rhino extends Animal {\n  constructor() { \n    super('Rhino')\n  }\n}\n\nclass Employee {\n  private name: string\n  constructor(name: string) { \n    this.name = name\n  }\n}\n\nlet animal = new Animal('Goat')\nlet rhino = new Rhino()\nlet employee = new Employee('Bob')\n\nanimal = rhino\nanimal = employee // 错误: Animal 与 Employee 不兼容.\n```\n\n这个例子中有 `Animal` 和 `Rhino` 两个类， `Rhino` 是 `Animal` 类的子类。 还有一个 `Employee` 类，其类型看上去与 `Animal` 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 `Animal` 和 `Rhino` 共享了来自 `Animal` 里的私有成员定义 `private name: string`，因此它们是兼容的。然而 `Employee` 却不是这样。当把 `Employee` 赋值给 `Animal` 的时候，得到一个错误，说它们的类型不兼容。尽管 `Employee` 里也有一个私有成员 `name`，但它明显不是 `Animal` 里面定义的那个。\n\n### 理解 protected\n\n`protected` 修饰符与 `private` 修饰符的行为很相似，但有一点不同，`protected`成员在派生类中仍然可以访问。例如：\n\n```typescript\nclass Person {\n  protected name: string\n  constructor(name: string) { \n    this.name = name \n  }\n}\n\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n  \n  getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nconsole.log(howard.getElevatorPitch())\nconsole.log(howard.name) // error\n```\n\n注意，我们不能在 `Person` 类外使用 `name`，但是我们仍然可以通过 `Employee` 类的实例方法访问，因为 `Employee` 是由 `Person`  派生而来的。\n\n构造函数也可以被标记成 `protected`。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：\n\n```typescript\nclass Person {\n  protected name: string\n  protected constructor(name: string) {\n    this.name = name\n  }\n}\n\n// Employee 能够继承 Person\nclass Employee extends Person {\n  private department: string\n\n  constructor(name: string, department: string) {\n    super(name)\n    this.department = department\n  }\n\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`\n  }\n}\n\nlet howard = new Employee('Howard', 'Sales')\nlet john = new Person('John') // 错误: 'Person' 的构造函数是被保护的.\n```\n\n## readonly 修饰符\n\n你可以使用 `readonly` 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。\n\n```typescript\nclass Person {\n  readonly name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nlet john = new Person('John')\njohn.name = 'peter'\n```\n\n### 参数属性\n\n在上面的例子中，我们必须在 `Person` 类里定义一个只读成员 `name` 和一个参数为 `name` 的构造函数，并且立刻将 `name` 的值赋给 `this.name`，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 `Person` 类的修改版，使用了参数属性：\n\n```typescript\nclass Person {\n  constructor(readonly name: string) {\n  }\n}\n```\n\n注意看我们是如何舍弃参数 `name`，仅在构造函数里使用 `readonly name: string` 参数来创建和初始化 `name` 成员。 我们把声明和赋值合并至一处。\n\n参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 `private` 限定一个参数属性会声明并初始化一个私有成员；对于 `public` 和 `protected` 来说也是一样。\n\n## 存取器\n\n`TypeScript` 支持通过 `getters/setters` 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。\n\n下面来看如何把一个简单的类改写成使用 `get` 和 `set`。 首先，我们从一个没有使用存取器的例子开始。\n\n```typescript\nclass Employee {\n  fullName: string\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以设置 `fullName`，因为它是 `public` 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。\n\n下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 `fullName` 的直接访问改成了可以检查密码的 `set` 方法。 我们也加了一个 `get` 方法，让上面的例子仍然可以工作。\n\n```typescript\nlet passcode = 'secret passcode'\n\nclass Employee {\n  private _fullName: string\n\n  get fullName(): string {\n    return this._fullName\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == 'secret passcode') {\n      this._fullName = newName\n    }\n    else {\n      console.log('Error: Unauthorized update of employee!')\n    }\n  }\n}\n\nlet employee = new Employee()\nemployee.fullName = 'Bob Smith'\nif (employee.fullName) {\n  console.log(employee.fullName)\n}\n```\n\n我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n\n对于存取器有下面几点需要注意的：\n\n首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`。这在从代码生成 `.d.ts` 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n## 静态属性\n\n到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 `static` 定义 `origin`，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 `origin` 前面加上类名。 如同在实例属性上使用 `this.xxx` 来访问属性一样，这里我们使用 `Grid.xxx` 来访问静态属性。\n\n```typescript\nclass Grid {\n  static origin = {x: 0, y: 0}\n\n  scale: number\n\n  constructor (scale: number) {\n    this.scale = scale\n  }\n\n  calculateDistanceFromOrigin(point: {x: number; y: number}) {\n    let xDist = point.x - Grid.origin.x\n    let yDist = point.y - Grid.origin.y\n    return Math.sqrt(xDist * xDist + yDist * yDist) * this.scale\n  }\n}\n\nlet grid1 = new Grid(1.0)  // 1x scale\nlet grid2 = new Grid(5.0)  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 3, y: 4}))\nconsole.log(grid2.calculateDistanceFromOrigin({x: 3, y: 4}))\n```\n\n## 抽象类\n\n抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 `abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法。\n\n```typescript\nabstract class Animal {\n  abstract makeSound(): void\n  move(): void {\n    console.log('roaming the earth...')\n  }\n}\n```\n\n抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 `abstract` 关键字并且可以包含访问修饰符。\n\n```typescript\nabstract class Department {\n  name: string\n\n  constructor(name: string) {\n     this.name = name\n  }\n\n  printName(): void {\n    console.log('Department name: ' + this.name)\n  }\n\n  abstract printMeeting(): void // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n  constructor() {\n    super('Accounting and Auditing') // 在派生类的构造函数中必须调用 super()\n  }\n\n  printMeeting(): void {\n    console.log('The Accounting Department meets each Monday at 10am.')\n  }\n\n  generateReports(): void {\n    console.log('Generating accounting reports...')\n  }\n}\n\nlet department: Department // 允许创建一个对抽象类型的引用\ndepartment = new Department() // 错误: 不能创建一个抽象类的实例\ndepartment = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName()\ndepartment.printMeeting()\ndepartment.generateReports() // 错误: 方法在声明的抽象类中不存在\n```\n\n## 高级技巧\n\n### 构造函数\n\n当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的*实例*的类型。\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  greeting: string\n  constructor(message: string) {\n    this.greeting = message\n  }\n  greet() {\n    return 'Hello, ' + this.greeting\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter('world')\nconsole.log(greeter.greet())\n```\n\n这里，我们写了 `let greeter: Greeter`，意思是 `Greeter` 类的实例的类型是 `Greeter`。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。\n\n我们也创建了一个叫做*构造函数的值*。 这个函数会在我们使用 `new` 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：\n\n```javascript\nvar Greeter = /** @class */ (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n  Greeter.prototype.greet = function () {\n    return 'Hello, ' + this.greeting;\n  };\n  Greeter.standardGreeting = 'Hello, there';\n  return Greeter;\n}());\nvar greeter;\ngreeter = new Greeter('world');\nconsole.log(greeter.greet());\n```\n\n上面的代码里，`var Greeter` 将被构造函数赋值。 当我们调用 `new` 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有*实例部分*与*静态部分*这两个部分。\n\n让我们稍微改写一下这个例子，看看它们之间的区别：\n\n```typescript\nclass Greeter {\n  static standardGreeting = 'Hello, there'\n  \n  greeting: string\n\n  constructor(message?: string) {\n    this.greeting = message\n  }\n\n  greet() {\n    if (this.greeting) {\n      return 'Hello, ' + this.greeting\n    } else {\n      return Greeter.standardGreeting\n    }\n  }\n}\n\nlet greeter: Greeter\ngreeter = new Greeter()\nconsole.log(greeter.greet())\n\nlet greeterMaker: typeof Greeter = Greeter\ngreeterMaker.standardGreeting = 'Hey there'\n\nlet greeter2: Greeter = new greeterMaker()\nconsole.log(greeter2.greet())\n```\n\n这个例子里， `greeter1` 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。\n\n再之后，我们直接使用类。 我们创建了一个叫做 `greeterMaker` 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 `typeof Greeter`，意思是取 `Greeter` 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 `Greeter` 标识符的类型\"，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 `greeterMaker` 上使用 `new`，创建 `Greeter` 的实例。\n\n### 把类当做接口使用\n\n如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。\n\n```typescript\nclass Point {\n  x: number\n  y: number\n}\n\ninterface Point3d extends Point {\n  z: number\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3}\n```\n\n\n","slug":"TypeScript 学习第六章 TypeScript类","published":1,"updated":"2019-12-31T03:00:25.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj8y008izws6nvf8z3xv","content":"<h1><span id=\"类\">类</span></h1>\n<p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p>\n<h2><span id=\"基本示例\">基本示例</span></h2>\n<p>下面看一个使用类的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 <code>Greeter</code> 类。这个类有 3 个成员：一个叫做 <code>greeting</code> 的属性，一个构造函数和一个 <code>greet</code> 方法。</p>\n<p>你会注意到，我们在引用任何一个类成员的时候都用了 <code>this</code>。 它表示我们访问的是类的成员。</p>\n<p>最后一行，我们使用 <code>new</code> 构造了 <code>Greeter</code> 类的一个实例。它会调用之前定义的构造函数，创建一个 <code>Greeter</code> 类型的新对象，并执行构造函数初始化它。</p>\n<h2><span id=\"继承\">继承</span></h2>\n<p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Animal moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  bark() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Woof! Woof!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog = <span class=\"keyword\">new</span> Dog()</span><br><span class=\"line\">dog.bark()</span><br><span class=\"line\">dog.move(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p>\n<p>因为 <code>Dog</code> 继承了 <code>Animal</code> 的功能，因此我们可以创建一个 <code>Dog</code> 的实例，它能够 <code>bark()</code> 和 <code>move()</code>。</p>\n<p>下面我们来看个更加复杂的例子。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Snake <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Slithering...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Horse <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Galloping...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">'Sammy'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">'Tommy'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move()</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 <code>extends</code> 关键字创建了 Animal的两个子类：<code>Horse</code> 和 <code>Snake</code>。</p>\n<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code> 的属性之前，我们 一定要调用 <code>super()</code>。 这个是 TypeScript 强制执行的一条重要规则。</p>\n<p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和 <code>Horse</code> 类都创建了 <code>move</code> 方法，它们重写了从 <code>Animal</code> 继承来的 <code>move</code> 方法，使得 <code>move</code> 方法根据不同的类而具有不同的功能。注意，即使 <code>tom</code> 被声明为 <code>Animal</code> 类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code> 时，它会调用 <code>Horse</code> 里重写的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slithering...</span><br><span class=\"line\">Sammy moved 5m.</span><br><span class=\"line\">Galloping...</span><br><span class=\"line\">Tommy moved 34m.</span><br></pre></td></tr></table></figure>\n<h2><span id=\"公共私有与受保护的修饰符\">公共，私有与受保护的修饰符</span></h2>\n<h3><span id=\"默认为-public\">默认为 public</span></h3>\n<p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p>\n<p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> move(distance: <span class=\"built_in\">number</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"理解-private\">理解 private</span></h3>\n<p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal(<span class=\"string\">'Cat'</span>).name <span class=\"comment\">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>\n<p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code> 成员也使用这个规则。</p>\n<p>下面来看一个例子，更好地说明了这一点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Rhino <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Rhino'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'Goat'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino()</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Bob'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino</span><br><span class=\"line\">animal = employee <span class=\"comment\">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure>\n<p>这个例子中有 <code>Animal</code> 和 <code>Rhino</code> 两个类， <code>Rhino</code> 是 <code>Animal</code> 类的子类。 还有一个 <code>Employee</code> 类，其类型看上去与 <code>Animal</code> 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code> 和 <code>Rhino</code> 共享了来自 <code>Animal</code> 里的私有成员定义 <code>private name: string</code>，因此它们是兼容的。然而 <code>Employee</code> 却不是这样。当把 <code>Employee</code> 赋值给 <code>Animal</code> 的时候，得到一个错误，说它们的类型不兼容。尽管 <code>Employee</code> 里也有一个私有成员 <code>name</code>，但它明显不是 <code>Animal</code> 里面定义的那个。</p>\n<h3><span id=\"理解-protected\">理解 protected</span></h3>\n<p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch())</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.name) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>注意，我们不能在 <code>Person</code> 类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code> 类的实例方法访问，因为 <code>Employee</code> 是由 <code>Person</code>  派生而来的。</p>\n<p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Employee 能够继承 Person</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>) <span class=\"comment\">// 错误: 'Person' 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"readonly-修饰符\">readonly 修饰符</span></h2>\n<p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  readonly name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>)</span><br><span class=\"line\">john.name = <span class=\"string\">'peter'</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"参数属性\">参数属性</span></h3>\n<p>在上面的例子中，我们必须在 <code>Person</code> 类里定义一个只读成员 <code>name</code> 和一个参数为 <code>name</code> 的构造函数，并且立刻将 <code>name</code> 的值赋给 <code>this.name</code>，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Person</code> 类的修改版，使用了参数属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">readonly name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意看我们是如何舍弃参数 <code>name</code>，仅在构造函数里使用 <code>readonly name: string</code> 参数来创建和初始化 <code>name</code> 成员。 我们把声明和赋值合并至一处。</p>\n<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</p>\n<h2><span id=\"存取器\">存取器</span></h2>\n<p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>\n<p>下面来看如何把一个简单的类改写成使用 <code>get</code> 和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以设置 <code>fullName</code>，因为它是 <code>public</code> 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。</p>\n<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 <code>fullName</code> 的直接访问改成了可以检查密码的 <code>set</code> 方法。 我们也加了一个 <code>get</code> 方法，让上面的例子仍然可以工作。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">'secret passcode'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> fullName(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._fullName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> fullName(newName: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode == <span class=\"string\">'secret passcode'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._fullName = newName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Error: Unauthorized update of employee!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>\n<p>对于存取器有下面几点需要注意的：</p>\n<p>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>\n<h2><span id=\"静态属性\">静态属性</span></h2>\n<p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code> 定义 <code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code> 前面加上类名。 如同在实例属性上使用 <code>this.xxx</code> 来访问属性一样，这里我们使用 <code>Grid.xxx</code> 来访问静态属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Grid &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> origin = &#123;x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  scale: <span class=\"built_in\">number</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">scale: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scale = scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  calculateDistanceFromOrigin(point: &#123;x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xDist = point.x - Grid.origin.x</span><br><span class=\"line\">    <span class=\"keyword\">let</span> yDist = point.y - Grid.origin.y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) * <span class=\"keyword\">this</span>.scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">1.0</span>)  <span class=\"comment\">// 1x scale</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid2 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">5.0</span>)  <span class=\"comment\">// 5x scale</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"抽象类\">抽象类</span></h2>\n<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> makeSound(): <span class=\"built_in\">void</span></span><br><span class=\"line\">  move(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'roaming the earth...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Department &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printName(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Department name: '</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> printMeeting(): <span class=\"built_in\">void</span> <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> AccountingDepartment <span class=\"keyword\">extends</span> Department &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Accounting and Auditing'</span>) <span class=\"comment\">// 在派生类的构造函数中必须调用 super()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printMeeting(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The Accounting Department meets each Monday at 10am.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  generateReports(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Generating accounting reports...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department <span class=\"comment\">// 允许创建一个对抽象类型的引用</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> Department() <span class=\"comment\">// 错误: 不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment() <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName()</span><br><span class=\"line\">department.printMeeting()</span><br><span class=\"line\">department.generateReports() <span class=\"comment\">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"高级技巧\">高级技巧</span></h2>\n<h3><span id=\"构造函数\">构造函数</span></h3>\n<p>当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的<em>实例</em>的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure>\n<p>这里，我们写了 <code>let greeter: Greeter</code>，意思是 <code>Greeter</code> 类的实例的类型是 <code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>\n<p>我们也创建了一个叫做<em>构造函数的值</em>。 这个函数会在我们使用 <code>new</code> 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Greeter = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeter</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Greeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Greeter.standardGreeting = <span class=\"string\">'Hello, there'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Greeter;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n<p>上面的代码里，<code>var Greeter</code> 将被构造函数赋值。 当我们调用 <code>new</code> 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p>\n<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.greeting) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Greeter.standardGreeting</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeterMaker: <span class=\"keyword\">typeof</span> Greeter = Greeter</span><br><span class=\"line\">greeterMaker.standardGreeting = <span class=\"string\">'Hey there'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter2: Greeter = <span class=\"keyword\">new</span> greeterMaker()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter2.greet())</span><br></pre></td></tr></table></figure>\n<p>这个例子里， <code>greeter1</code> 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p>\n<p>再之后，我们直接使用类。 我们创建了一个叫做 <code>greeterMaker</code> 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 <code>typeof Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，“告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 <code>greeterMaker</code> 上使用 <code>new</code>，创建 <code>Greeter</code> 的实例。</p>\n<h3><span id=\"把类当做接口使用\">把类当做接口使用</span></h3>\n<p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Point &#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Point3d <span class=\"keyword\">extends</span> Point &#123;</span><br><span class=\"line\">  z: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123;x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>, z: <span class=\"number\">3</span>&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>类</h1>\n<p>对于传统的 JavaScript 程序我们会使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p>\n<h2>基本示例</h2>\n<p>下面看一个使用类的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 <code>Greeter</code> 类。这个类有 3 个成员：一个叫做 <code>greeting</code> 的属性，一个构造函数和一个 <code>greet</code> 方法。</p>\n<p>你会注意到，我们在引用任何一个类成员的时候都用了 <code>this</code>。 它表示我们访问的是类的成员。</p>\n<p>最后一行，我们使用 <code>new</code> 构造了 <code>Greeter</code> 类的一个实例。它会调用之前定义的构造函数，创建一个 <code>Greeter</code> 类型的新对象，并执行构造函数初始化它。</p>\n<h2>继承</h2>\n<p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>\n<p>看下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Animal moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  bark() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Woof! Woof!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> dog = <span class=\"keyword\">new</span> Dog()</span><br><span class=\"line\">dog.bark()</span><br><span class=\"line\">dog.move(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<code>Dog</code> 是一个 派生类，它派生自 <code>Animal</code> 基类，通过 <code>extends</code> 关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。</p>\n<p>因为 <code>Dog</code> 继承了 <code>Animal</code> 的功能，因此我们可以创建一个 <code>Dog</code> 的实例，它能够 <code>bark()</code> 和 <code>move()</code>。</p>\n<p>下面我们来看个更加复杂的例子。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Snake <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Slithering...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Horse <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  move(distance: <span class=\"built_in\">number</span> = <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Galloping...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.move(distance)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">'Sammy'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">'Tommy'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move()</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>)</span><br></pre></td></tr></table></figure>\n<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 <code>extends</code> 关键字创建了 Animal的两个子类：<code>Horse</code> 和 <code>Snake</code>。</p>\n<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 <code>super()</code>，它会执行基类的构造函数。 而且，在构造函数里访问 <code>this</code> 的属性之前，我们 一定要调用 <code>super()</code>。 这个是 TypeScript 强制执行的一条重要规则。</p>\n<p>这个例子演示了如何在子类里可以重写父类的方法。<code>Snake</code>类和 <code>Horse</code> 类都创建了 <code>move</code> 方法，它们重写了从 <code>Animal</code> 继承来的 <code>move</code> 方法，使得 <code>move</code> 方法根据不同的类而具有不同的功能。注意，即使 <code>tom</code> 被声明为 <code>Animal</code> 类型，但因为它的值是 <code>Horse</code>，调用 <code>tom.move(34)</code> 时，它会调用 <code>Horse</code> 里重写的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slithering...</span><br><span class=\"line\">Sammy moved 5m.</span><br><span class=\"line\">Galloping...</span><br><span class=\"line\">Tommy moved 34m.</span><br></pre></td></tr></table></figure>\n<h2>公共，私有与受保护的修饰符</h2>\n<h3>默认为 public</h3>\n<p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p>\n<p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> move(distance: <span class=\"built_in\">number</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> moved <span class=\"subst\">$&#123;distance&#125;</span>m.`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>理解 private</h3>\n<p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Animal(<span class=\"string\">'Cat'</span>).name <span class=\"comment\">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>\n<p>然而，当我们比较带有 <code>private</code> 或 <code>protected</code> 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code> 成员也使用这个规则。</p>\n<p>下面来看一个例子，更好地说明了这一点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Rhino <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Rhino'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal(<span class=\"string\">'Goat'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino()</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Bob'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino</span><br><span class=\"line\">animal = employee <span class=\"comment\">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure>\n<p>这个例子中有 <code>Animal</code> 和 <code>Rhino</code> 两个类， <code>Rhino</code> 是 <code>Animal</code> 类的子类。 还有一个 <code>Employee</code> 类，其类型看上去与 <code>Animal</code> 是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 <code>Animal</code> 和 <code>Rhino</code> 共享了来自 <code>Animal</code> 里的私有成员定义 <code>private name: string</code>，因此它们是兼容的。然而 <code>Employee</code> 却不是这样。当把 <code>Employee</code> 赋值给 <code>Animal</code> 的时候，得到一个错误，说它们的类型不兼容。尽管 <code>Employee</code> 里也有一个私有成员 <code>name</code>，但它明显不是 <code>Animal</code> 里面定义的那个。</p>\n<h3>理解 protected</h3>\n<p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch())</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.name) <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>注意，我们不能在 <code>Person</code> 类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code> 类的实例方法访问，因为 <code>Employee</code> 是由 <code>Person</code>  派生而来的。</p>\n<p>构造函数也可以被标记成 <code>protected</code>。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Employee 能够继承 Person</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.department = department</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> getElevatorPitch() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;this.name&#125;</span> and I work in <span class=\"subst\">$&#123;this.department&#125;</span>.`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> Employee(<span class=\"string\">'Howard'</span>, <span class=\"string\">'Sales'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>) <span class=\"comment\">// 错误: 'Person' 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure>\n<h2>readonly 修饰符</h2>\n<p>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  readonly name: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"keyword\">new</span> Person(<span class=\"string\">'John'</span>)</span><br><span class=\"line\">john.name = <span class=\"string\">'peter'</span></span><br></pre></td></tr></table></figure>\n<h3>参数属性</h3>\n<p>在上面的例子中，我们必须在 <code>Person</code> 类里定义一个只读成员 <code>name</code> 和一个参数为 <code>name</code> 的构造函数，并且立刻将 <code>name</code> 的值赋给 <code>this.name</code>，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 <code>Person</code> 类的修改版，使用了参数属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">readonly name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意看我们是如何舍弃参数 <code>name</code>，仅在构造函数里使用 <code>readonly name: string</code> 参数来创建和初始化 <code>name</code> 成员。 我们把声明和赋值合并至一处。</p>\n<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</p>\n<h2>存取器</h2>\n<p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>\n<p>下面来看如何把一个简单的类改写成使用 <code>get</code> 和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以设置 <code>fullName</code>，因为它是 <code>public</code> 的，有时候当我们去修改它的时候触发一些额外逻辑，存取器就派上用场了。</p>\n<p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。我们把对 <code>fullName</code> 的直接访问改成了可以检查密码的 <code>set</code> 方法。 我们也加了一个 <code>get</code> 方法，让上面的例子仍然可以工作。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">'secret passcode'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Employee &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> fullName(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._fullName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> fullName(newName: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode == <span class=\"string\">'secret passcode'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._fullName = newName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Error: Unauthorized update of employee!'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee()</span><br><span class=\"line\">employee.fullName = <span class=\"string\">'Bob Smith'</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</p>\n<p>对于存取器有下面几点需要注意的：</p>\n<p>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。其次，只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>\n<h2>静态属性</h2>\n<p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 <code>static</code> 定义 <code>origin</code>，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 <code>origin</code> 前面加上类名。 如同在实例属性上使用 <code>this.xxx</code> 来访问属性一样，这里我们使用 <code>Grid.xxx</code> 来访问静态属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Grid &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> origin = &#123;x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  scale: <span class=\"built_in\">number</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">scale: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.scale = scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  calculateDistanceFromOrigin(point: &#123;x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xDist = point.x - Grid.origin.x</span><br><span class=\"line\">    <span class=\"keyword\">let</span> yDist = point.y - Grid.origin.y</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) * <span class=\"keyword\">this</span>.scale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">1.0</span>)  <span class=\"comment\">// 1x scale</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> grid2 = <span class=\"keyword\">new</span> Grid(<span class=\"number\">5.0</span>)  <span class=\"comment\">// 5x scale</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>&#125;))</span><br></pre></td></tr></table></figure>\n<h2>抽象类</h2>\n<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> makeSound(): <span class=\"built_in\">void</span></span><br><span class=\"line\">  move(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'roaming the earth...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> Department &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printName(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Department name: '</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> printMeeting(): <span class=\"built_in\">void</span> <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> AccountingDepartment <span class=\"keyword\">extends</span> Department &#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(<span class=\"string\">'Accounting and Auditing'</span>) <span class=\"comment\">// 在派生类的构造函数中必须调用 super()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  printMeeting(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'The Accounting Department meets each Monday at 10am.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  generateReports(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Generating accounting reports...'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department <span class=\"comment\">// 允许创建一个对抽象类型的引用</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> Department() <span class=\"comment\">// 错误: 不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment() <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName()</span><br><span class=\"line\">department.printMeeting()</span><br><span class=\"line\">department.generateReports() <span class=\"comment\">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n<h2>高级技巧</h2>\n<h3>构造函数</h3>\n<p>当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的<em>实例</em>的类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure>\n<p>这里，我们写了 <code>let greeter: Greeter</code>，意思是 <code>Greeter</code> 类的实例的类型是 <code>Greeter</code>。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。</p>\n<p>我们也创建了一个叫做<em>构造函数的值</em>。 这个函数会在我们使用 <code>new</code> 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Greeter = <span class=\"comment\">/** @class */</span> (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Greeter</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Greeter.prototype.greet = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Greeter.standardGreeting = <span class=\"string\">'Hello, there'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Greeter;</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeter;</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">'world'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n<p>上面的代码里，<code>var Greeter</code> 将被构造函数赋值。 当我们调用 <code>new</code> 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有<em>实例部分</em>与<em>静态部分</em>这两个部分。</p>\n<p>让我们稍微改写一下这个例子，看看它们之间的区别：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Greeter &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">'Hello, there'</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\">message?: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.greeting = message</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.greeting) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + <span class=\"keyword\">this</span>.greeting</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Greeter.standardGreeting</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter</span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeterMaker: <span class=\"keyword\">typeof</span> Greeter = Greeter</span><br><span class=\"line\">greeterMaker.standardGreeting = <span class=\"string\">'Hey there'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter2: Greeter = <span class=\"keyword\">new</span> greeterMaker()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter2.greet())</span><br></pre></td></tr></table></figure>\n<p>这个例子里， <code>greeter1</code> 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。</p>\n<p>再之后，我们直接使用类。 我们创建了一个叫做 <code>greeterMaker</code> 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 <code>typeof Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，“告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 <code>greeterMaker</code> 上使用 <code>new</code>，创建 <code>Greeter</code> 的实例。</p>\n<h3>把类当做接口使用</h3>\n<p>如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Point &#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span></span><br><span class=\"line\">  y: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Point3d <span class=\"keyword\">extends</span> Point &#123;</span><br><span class=\"line\">  z: <span class=\"built_in\">number</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123;x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>, z: <span class=\"number\">3</span>&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Vue 源码阅读 深入响应式原理(三)","catalog":true,"date":"2019-10-18T17:22:10.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n上一篇文章中我们介绍了`Object`数据的变化侦测方式，本篇文章我们来看一下对`Array`型数据的变化`Vue`是如何进行侦测的。\n\n为什么`Object`数据和`Array`型数据会有两种不同的变化侦测方式？\n\n这是因为对于`Object`数据我们使用的是`JS`提供的对象原型上的方法`Object.defineProperty`，而这个方法是对象原型上的，所以`Array`无法使用这个方法，所以我们需要对`Array`型数据设计一套另外的变化侦测机制。\n\n万变不离其宗，虽然对`Array`型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。\n\n下面我们就通过源码来看看`Vue`对`Array`型数据到底是如何进行变化侦测的。\n\n## 2. 在哪里收集依赖\n\n首先还是老规矩，我们得先把用到`Array`型数据的地方作为依赖收集起来，那么第一问题就是该在哪里收集呢？\n\n其实`Array`型数据的依赖收集方式和`Object`数据的依赖收集方式相同，都是在`getter`中收集。那么问题就来了，不是说`Array`无法使用`Object.defineProperty`方法吗？无法使用怎么还在`getter`中收集依赖呢？\n\n其实不然，我们回想一下平常在开发的时候，在组件的`data`中是不是都这么写的：\n\n```javascript\ndata(){\n    return {\n        arr:[1,2,3]\n    }\n}\n```\n\n想想看，`arr`这个数据始终都存在于一个`object`数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到`arr`这个数据，是不是得先从`object`数据对象中获取一下`arr`数据，而从`object`数据对象中获取`arr`数据自然就会触发`arr`的`getter`，所以我们就可以在`getter`中收集依赖。\n\n总结一句话就是：**Array型数据还是在getter中收集依赖。**\n\n## 3. 使Array型数据可观测\n\n上一章节中我们知道了`Array`型数据还是在`getter`中收集依赖，换句话说就是我们已经知道了`Array`型数据何时被读取了。\n\n回想上一篇文章中介绍`Object`数据变化侦测的时候，我们先让`Object`数据变的可观测，即我们能够知道数据什么时候被读取了、什么时候发生变化了。同理，对于`Array`型数据我们也得让它变的可观测，目前我们已经完成了一半可观测，即我们只知道了`Array`型数据何时被读取了，而何时发生变化我们无法知道，那么接下来我们就来解决这一问题：当`Array`型数据发生变化时我们如何得知？\n\n### 3.1 思路分析\n\n`Object`的变化时通过`setter`来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的`setter`。但是`Array`型数据没有`setter`，怎么办？\n\n我们试想一下，要想让`Array`型数据发生变化，那必然是操作了`Array`，而`JS`中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：\n\n```javascript\nlet arr = [1,2,3]\narr.push(4)\nArray.prototype.newPush = function(val){\n    console.log('arr被修改了')\n    this.push(val)\n}\narr.newPush(4)\n```\n\n在上面这个例子中，我们针对数组的原生`push`方法定义个一个新的`newPush`方法，这个`newPush`方法内部调用了原生`push`方法，这样就保证了新的`newPush`方法跟原生`push`方法具有相同的功能，而且我们还可以在新的`newPush`方法内部干一些别的事情，比如通知变化。\n\n是不是很巧妙？`Vue`内部就是这么干的。\n\n### 3.2 数组方法拦截器\n\n基于上一小节的思想，在`Vue`中创建了一个数组方法拦截器，它拦截在数组实例与`Array.prototype`之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用`Array.prototype`上的原生方法。如下图所示：\n\n![](/img/reactive/2.png)\n\n\n\n经过整理，`Array`原型中可以改变数组自身内容的方法有7个，分别是：`push`,`pop`,`shift`,`unshift`,`splice`,`sort`,`reverse`。那么源码中的拦截器代码如下：\n\n```javascript\n// 源码位置：/src/core/observer/array.js\n\nconst arrayProto = Array.prototype\n// 创建一个对象作为拦截器\nexport const arrayMethods = Object.create(arrayProto)\n\n// 改变数组自身内容的7个方法\nconst methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  const original = arrayProto[method]      // 缓存原生方法\n  Object.defineProperty(arrayMethods, method, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value:function mutator(...args){\n          const result = original.apply(this, args)\n          return result\n      }\n  })\n})\n\n```\n\n在上面的代码中，首先创建了继承自`Array`原型的空对象`arrayMethods`，接着在`arrayMethods`上使用`object.defineProperty`方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用`push`方法的时候，其实用的是`arrayMethods.push`，而`arrayMethods.push`就是封装的新函数`mutator`，也就后说，实标上执行的是函数`mutator`，而`mutator`函数内部执行了`original`函数，这个`original`函数就是`Array.prototype`上对应的原生方法。\n那么，接下来我们就可以在`mutato`r函数中做一些其他的事，比如说发送变化通知。\n\n### 3.3 使用拦截器\n\n在上一小节的图中，我们把拦截器做好还不够，还要把它挂载到数组实例与`Array.prototype`之间，这样拦截器才能够生效。\n\n其实挂载不难，我们只需把数据的`__proto__`属性设置为拦截器`arrayMethods`即可，源码实现如下：\n\n```javascript\n// 源码位置：/src/core/observer/index.js\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性\nexport const hasProto = '__proto__' in {}\n\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src: Object, keys: any) {\n  target.__proto__ = src\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target: Object, src: Object, keys: Array<string>) {\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\n\n```\n\n上面代码中首先判断了浏览器是否支持`__proto__`，如果支持，则调用`protoAugment`函数把`value.__proto__ = arrayMethods`；如果不支持，则调用`copyAugment`函数把拦截器中重写的7个方法循环加入到`value`上。\n\n拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对`Array`型数据的可观测。\n\n## 4. 再谈依赖收集\n\n### 4.1 把依赖收集到哪里\n\n在第二章中我们说了，数组的依赖也在`getter`中收集，而给数据添加`getter/setter`都是在`Observer`类中完成的，所以我们也应该把依赖收集到`Observer`类中，源码如下：\n\n```javascript\n// 源码位置：/src/core/observer/index.js\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    this.dep = new Dep()    // 实例化一个依赖管理器，用来收集数组依赖  \n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n```\n\n上面代码中，在`Observer`类中实例化了一个依赖管理器，用来收集数组依赖。\n\n### 4.2 如何收集依赖\n\n在第二章中我们说了，数组的依赖也在`getter`中收集，那么在`getter`中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在`Observer`类中，而我们需要在`getter`中收集依赖，也就是说我们必须在`getter`中能够访问到`Observer`类中的依赖管理器，才能把依赖存进去。源码是这么做的：\n\n```javascript\nfunction defineReactive (obj,key,val) {\n    let childOb = observe(val)\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get(){\n            if (childOb) {\n              childOb.dep.depend()\n            }\n            return val;\n        },\n        set(newVal){\n            if(val === newVal){\n                return\n            }\n            val = newVal;\n            dep.notify()   // 在setter中通知依赖更新\n        }\n    })\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。\n * 如果 Value 已经存在一个Observer实例，则直接返回它\n */\nexport function observe (value, asRootData){\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else {\n    ob = new Observer(value)\n  }\n  return ob\n}\n```\n\n在上面代码中，我们首先通过`observe`函数为被获取的数据`arr`尝试创建一个`Observer`实例，在`observe`实函数内部，先判断当前传入的数据上是否有`__ob__`属性，因为在上篇文章中说了，如果数据有`__ob__`属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用`new Observer(value)`将其转化成响应式的，并把数据对应的`Observer`实例返回。\n\n而在`defineReactive`函数中，首先获取数据对应的`Observer`实例，然后在`getter`中调用`Observer`实例上依赖管理器，从而将依赖收集起来。\n\n### 4.3 如何通知依赖\n\n到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？\n\n其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据`value`即可，因为`vaule`上的`__ob__`就是其对应的`Observer`类实例，有了`Observer`类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的`dep.notify()`方法，让它去通知依赖更新即可。源码如下：\n\n```javascript\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的`this`就是数据`value`，拿到`value`上的`Observer`类实例，从而你就可以调用`Observer`类实例上面依赖管理器的`dep.notify()`方法，以达到通知依赖的目的。\n\nOK，以上就基本完成了`Array`数据的变化侦测。\n\n## 5. 深度侦测\n\n在前文所有讲的`Array`型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在`Vue`中，不论是`Object`型数据还是`Array`型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：\n\n```javascript\nlet arr = [\n    {\n        name:'NLRX'，\n        age:'18'\n    }\n]\n```\n\n数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。\n\n这个实现起来比较简单，源码如下：\n\n```javascript\nexport class Observer {\n  value: any;\n  dep: Dep;\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)   // 将数组中的所有元素都转化为可被侦测的响应式\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n\nexport function observe (value, asRootData){\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else {\n    ob = new Observer(value)\n  }\n  return ob\n}\n```\n\n在上面代码中，对于`Array`型数据，调用了`observeArray()`方法，该方法内部会遍历数组中的每一个元素，然后通过调用`observe`函数将每一个元素都转化成可侦测的响应式数据。\n\n而对应`object`数据，在上一篇文章中我们已经在`defineReactive`函数中进行了递归操作。\n\n## 6. 数组新增元素的侦测\n\n对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。\n\n这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用`observe`函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：`push`、`unshift`、`splice`。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：\n\n```javascript\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args   // 如果是push或unshift方法，那么传入参数就是新增的元素\n        break\n      case 'splice':\n        inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素\n        break\n    }\n    if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n在上面拦截器定义代码中，如果是`push`或`unshift`方法，那么传入参数就是新增的元素;如果是`splice`方法，那么传入参数列表中下标为2的就是新增的元素，拿到新增的元素后，就可以调用`observe`函数将新增的元素转化成响应式的了。\n\n## 7. 不足之处\n\n前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：\n\n```javascript\nlet arr = [1,2,3]\narr[0] = 5;       // 通过数组下标修改数组中的数据\narr.length = 0    // 通过修改数组长度清空数组\n```\n\n而使用上述例子中的操作方式来修改数组是无法侦测到的。\n同样，`Vue`也注意到了这个问题， 为了解决这一问题，`Vue`增加了两个全局API:`Vue.set`和`Vue.delete`，这两个API的实现原理将会在后面学习全局API的时候说到。 \n## 8. 总结\n\n在本篇文章中，首先我们分析了对于`Array`型数据也在`getter`中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现`Vue`不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。\n\n以上就是对`Array`型数据的变化侦测分析。\n\n\n","source":"_posts/Vue 源码阅读 深入响应式原理(三).md","raw":"---\ntitle: Vue 源码阅读 深入响应式原理(三) \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-19 01:22:10\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n上一篇文章中我们介绍了`Object`数据的变化侦测方式，本篇文章我们来看一下对`Array`型数据的变化`Vue`是如何进行侦测的。\n\n为什么`Object`数据和`Array`型数据会有两种不同的变化侦测方式？\n\n这是因为对于`Object`数据我们使用的是`JS`提供的对象原型上的方法`Object.defineProperty`，而这个方法是对象原型上的，所以`Array`无法使用这个方法，所以我们需要对`Array`型数据设计一套另外的变化侦测机制。\n\n万变不离其宗，虽然对`Array`型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。\n\n下面我们就通过源码来看看`Vue`对`Array`型数据到底是如何进行变化侦测的。\n\n## 2. 在哪里收集依赖\n\n首先还是老规矩，我们得先把用到`Array`型数据的地方作为依赖收集起来，那么第一问题就是该在哪里收集呢？\n\n其实`Array`型数据的依赖收集方式和`Object`数据的依赖收集方式相同，都是在`getter`中收集。那么问题就来了，不是说`Array`无法使用`Object.defineProperty`方法吗？无法使用怎么还在`getter`中收集依赖呢？\n\n其实不然，我们回想一下平常在开发的时候，在组件的`data`中是不是都这么写的：\n\n```javascript\ndata(){\n    return {\n        arr:[1,2,3]\n    }\n}\n```\n\n想想看，`arr`这个数据始终都存在于一个`object`数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到`arr`这个数据，是不是得先从`object`数据对象中获取一下`arr`数据，而从`object`数据对象中获取`arr`数据自然就会触发`arr`的`getter`，所以我们就可以在`getter`中收集依赖。\n\n总结一句话就是：**Array型数据还是在getter中收集依赖。**\n\n## 3. 使Array型数据可观测\n\n上一章节中我们知道了`Array`型数据还是在`getter`中收集依赖，换句话说就是我们已经知道了`Array`型数据何时被读取了。\n\n回想上一篇文章中介绍`Object`数据变化侦测的时候，我们先让`Object`数据变的可观测，即我们能够知道数据什么时候被读取了、什么时候发生变化了。同理，对于`Array`型数据我们也得让它变的可观测，目前我们已经完成了一半可观测，即我们只知道了`Array`型数据何时被读取了，而何时发生变化我们无法知道，那么接下来我们就来解决这一问题：当`Array`型数据发生变化时我们如何得知？\n\n### 3.1 思路分析\n\n`Object`的变化时通过`setter`来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的`setter`。但是`Array`型数据没有`setter`，怎么办？\n\n我们试想一下，要想让`Array`型数据发生变化，那必然是操作了`Array`，而`JS`中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：\n\n```javascript\nlet arr = [1,2,3]\narr.push(4)\nArray.prototype.newPush = function(val){\n    console.log('arr被修改了')\n    this.push(val)\n}\narr.newPush(4)\n```\n\n在上面这个例子中，我们针对数组的原生`push`方法定义个一个新的`newPush`方法，这个`newPush`方法内部调用了原生`push`方法，这样就保证了新的`newPush`方法跟原生`push`方法具有相同的功能，而且我们还可以在新的`newPush`方法内部干一些别的事情，比如通知变化。\n\n是不是很巧妙？`Vue`内部就是这么干的。\n\n### 3.2 数组方法拦截器\n\n基于上一小节的思想，在`Vue`中创建了一个数组方法拦截器，它拦截在数组实例与`Array.prototype`之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用`Array.prototype`上的原生方法。如下图所示：\n\n![](/img/reactive/2.png)\n\n\n\n经过整理，`Array`原型中可以改变数组自身内容的方法有7个，分别是：`push`,`pop`,`shift`,`unshift`,`splice`,`sort`,`reverse`。那么源码中的拦截器代码如下：\n\n```javascript\n// 源码位置：/src/core/observer/array.js\n\nconst arrayProto = Array.prototype\n// 创建一个对象作为拦截器\nexport const arrayMethods = Object.create(arrayProto)\n\n// 改变数组自身内容的7个方法\nconst methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  const original = arrayProto[method]      // 缓存原生方法\n  Object.defineProperty(arrayMethods, method, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value:function mutator(...args){\n          const result = original.apply(this, args)\n          return result\n      }\n  })\n})\n\n```\n\n在上面的代码中，首先创建了继承自`Array`原型的空对象`arrayMethods`，接着在`arrayMethods`上使用`object.defineProperty`方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用`push`方法的时候，其实用的是`arrayMethods.push`，而`arrayMethods.push`就是封装的新函数`mutator`，也就后说，实标上执行的是函数`mutator`，而`mutator`函数内部执行了`original`函数，这个`original`函数就是`Array.prototype`上对应的原生方法。\n那么，接下来我们就可以在`mutato`r函数中做一些其他的事，比如说发送变化通知。\n\n### 3.3 使用拦截器\n\n在上一小节的图中，我们把拦截器做好还不够，还要把它挂载到数组实例与`Array.prototype`之间，这样拦截器才能够生效。\n\n其实挂载不难，我们只需把数据的`__proto__`属性设置为拦截器`arrayMethods`即可，源码实现如下：\n\n```javascript\n// 源码位置：/src/core/observer/index.js\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性\nexport const hasProto = '__proto__' in {}\n\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src: Object, keys: any) {\n  target.__proto__ = src\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target: Object, src: Object, keys: Array<string>) {\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i]\n    def(target, key, src[key])\n  }\n}\n\n```\n\n上面代码中首先判断了浏览器是否支持`__proto__`，如果支持，则调用`protoAugment`函数把`value.__proto__ = arrayMethods`；如果不支持，则调用`copyAugment`函数把拦截器中重写的7个方法循环加入到`value`上。\n\n拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对`Array`型数据的可观测。\n\n## 4. 再谈依赖收集\n\n### 4.1 把依赖收集到哪里\n\n在第二章中我们说了，数组的依赖也在`getter`中收集，而给数据添加`getter/setter`都是在`Observer`类中完成的，所以我们也应该把依赖收集到`Observer`类中，源码如下：\n\n```javascript\n// 源码位置：/src/core/observer/index.js\nexport class Observer {\n  constructor (value) {\n    this.value = value\n    this.dep = new Dep()    // 实例化一个依赖管理器，用来收集数组依赖  \n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n    } else {\n      this.walk(value)\n    }\n  }\n}\n```\n\n上面代码中，在`Observer`类中实例化了一个依赖管理器，用来收集数组依赖。\n\n### 4.2 如何收集依赖\n\n在第二章中我们说了，数组的依赖也在`getter`中收集，那么在`getter`中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在`Observer`类中，而我们需要在`getter`中收集依赖，也就是说我们必须在`getter`中能够访问到`Observer`类中的依赖管理器，才能把依赖存进去。源码是这么做的：\n\n```javascript\nfunction defineReactive (obj,key,val) {\n    let childOb = observe(val)\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get(){\n            if (childOb) {\n              childOb.dep.depend()\n            }\n            return val;\n        },\n        set(newVal){\n            if(val === newVal){\n                return\n            }\n            val = newVal;\n            dep.notify()   // 在setter中通知依赖更新\n        }\n    })\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。\n * 如果 Value 已经存在一个Observer实例，则直接返回它\n */\nexport function observe (value, asRootData){\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else {\n    ob = new Observer(value)\n  }\n  return ob\n}\n```\n\n在上面代码中，我们首先通过`observe`函数为被获取的数据`arr`尝试创建一个`Observer`实例，在`observe`实函数内部，先判断当前传入的数据上是否有`__ob__`属性，因为在上篇文章中说了，如果数据有`__ob__`属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用`new Observer(value)`将其转化成响应式的，并把数据对应的`Observer`实例返回。\n\n而在`defineReactive`函数中，首先获取数据对应的`Observer`实例，然后在`getter`中调用`Observer`实例上依赖管理器，从而将依赖收集起来。\n\n### 4.3 如何通知依赖\n\n到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？\n\n其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据`value`即可，因为`vaule`上的`__ob__`就是其对应的`Observer`类实例，有了`Observer`类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的`dep.notify()`方法，让它去通知依赖更新即可。源码如下：\n\n```javascript\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的`this`就是数据`value`，拿到`value`上的`Observer`类实例，从而你就可以调用`Observer`类实例上面依赖管理器的`dep.notify()`方法，以达到通知依赖的目的。\n\nOK，以上就基本完成了`Array`数据的变化侦测。\n\n## 5. 深度侦测\n\n在前文所有讲的`Array`型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在`Vue`中，不论是`Object`型数据还是`Array`型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：\n\n```javascript\nlet arr = [\n    {\n        name:'NLRX'，\n        age:'18'\n    }\n]\n```\n\n数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。\n\n这个实现起来比较简单，源码如下：\n\n```javascript\nexport class Observer {\n  value: any;\n  dep: Dep;\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)   // 将数组中的所有元素都转化为可被侦测的响应式\n    } else {\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n\nexport function observe (value, asRootData){\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else {\n    ob = new Observer(value)\n  }\n  return ob\n}\n```\n\n在上面代码中，对于`Array`型数据，调用了`observeArray()`方法，该方法内部会遍历数组中的每一个元素，然后通过调用`observe`函数将每一个元素都转化成可侦测的响应式数据。\n\n而对应`object`数据，在上一篇文章中我们已经在`defineReactive`函数中进行了递归操作。\n\n## 6. 数组新增元素的侦测\n\n对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。\n\n这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用`observe`函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：`push`、`unshift`、`splice`。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：\n\n```javascript\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args   // 如果是push或unshift方法，那么传入参数就是新增的元素\n        break\n      case 'splice':\n        inserted = args.slice(2) // 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素\n        break\n    }\n    if (inserted) ob.observeArray(inserted) // 调用observe函数将新增的元素转化成响应式\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n在上面拦截器定义代码中，如果是`push`或`unshift`方法，那么传入参数就是新增的元素;如果是`splice`方法，那么传入参数列表中下标为2的就是新增的元素，拿到新增的元素后，就可以调用`observe`函数将新增的元素转化成响应式的了。\n\n## 7. 不足之处\n\n前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：\n\n```javascript\nlet arr = [1,2,3]\narr[0] = 5;       // 通过数组下标修改数组中的数据\narr.length = 0    // 通过修改数组长度清空数组\n```\n\n而使用上述例子中的操作方式来修改数组是无法侦测到的。\n同样，`Vue`也注意到了这个问题， 为了解决这一问题，`Vue`增加了两个全局API:`Vue.set`和`Vue.delete`，这两个API的实现原理将会在后面学习全局API的时候说到。 \n## 8. 总结\n\n在本篇文章中，首先我们分析了对于`Array`型数据也在`getter`中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现`Vue`不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。\n\n以上就是对`Array`型数据的变化侦测分析。\n\n\n","slug":"Vue 源码阅读 深入响应式原理(三)","published":1,"updated":"2019-12-31T03:26:22.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj8z008kzws6wst133f1","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>上一篇文章中我们介绍了<code>Object</code>数据的变化侦测方式，本篇文章我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p>\n<p>为什么<code>Object</code>数据和<code>Array</code>型数据会有两种不同的变化侦测方式？</p>\n<p>这是因为对于<code>Object</code>数据我们使用的是<code>JS</code>提供的对象原型上的方法<code>Object.defineProperty</code>，而这个方法是对象原型上的，所以<code>Array</code>无法使用这个方法，所以我们需要对<code>Array</code>型数据设计一套另外的变化侦测机制。</p>\n<p>万变不离其宗，虽然对<code>Array</code>型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。</p>\n<p>下面我们就通过源码来看看<code>Vue</code>对<code>Array</code>型数据到底是如何进行变化侦测的。</p>\n<h2><span id=\"2-在哪里收集依赖\">2. 在哪里收集依赖</span></h2>\n<p>首先还是老规矩，我们得先把用到<code>Array</code>型数据的地方作为依赖收集起来，那么第一问题就是该在哪里收集呢？</p>\n<p>其实<code>Array</code>型数据的依赖收集方式和<code>Object</code>数据的依赖收集方式相同，都是在<code>getter</code>中收集。那么问题就来了，不是说<code>Array</code>无法使用<code>Object.defineProperty</code>方法吗？无法使用怎么还在<code>getter</code>中收集依赖呢？</p>\n<p>其实不然，我们回想一下平常在开发的时候，在组件的<code>data</code>中是不是都这么写的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        arr:[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>想想看，<code>arr</code>这个数据始终都存在于一个<code>object</code>数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到<code>arr</code>这个数据，是不是得先从<code>object</code>数据对象中获取一下<code>arr</code>数据，而从<code>object</code>数据对象中获取<code>arr</code>数据自然就会触发<code>arr</code>的<code>getter</code>，所以我们就可以在<code>getter</code>中收集依赖。</p>\n<p>总结一句话就是：<strong>Array型数据还是在getter中收集依赖。</strong></p>\n<h2><span id=\"3-使array型数据可观测\">3. 使Array型数据可观测</span></h2>\n<p>上一章节中我们知道了<code>Array</code>型数据还是在<code>getter</code>中收集依赖，换句话说就是我们已经知道了<code>Array</code>型数据何时被读取了。</p>\n<p>回想上一篇文章中介绍<code>Object</code>数据变化侦测的时候，我们先让<code>Object</code>数据变的可观测，即我们能够知道数据什么时候被读取了、什么时候发生变化了。同理，对于<code>Array</code>型数据我们也得让它变的可观测，目前我们已经完成了一半可观测，即我们只知道了<code>Array</code>型数据何时被读取了，而何时发生变化我们无法知道，那么接下来我们就来解决这一问题：当<code>Array</code>型数据发生变化时我们如何得知？</p>\n<h3><span id=\"31-思路分析\">3.1 思路分析</span></h3>\n<p><code>Object</code>的变化时通过<code>setter</code>来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的<code>setter</code>。但是<code>Array</code>型数据没有<code>setter</code>，怎么办？</p>\n<p>我们试想一下，要想让<code>Array</code>型数据发生变化，那必然是操作了<code>Array</code>，而<code>JS</code>中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">arr.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.newPush = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'arr被修改了'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.push(val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.newPush(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>在上面这个例子中，我们针对数组的原生<code>push</code>方法定义个一个新的<code>newPush</code>方法，这个<code>newPush</code>方法内部调用了原生<code>push</code>方法，这样就保证了新的<code>newPush</code>方法跟原生<code>push</code>方法具有相同的功能，而且我们还可以在新的<code>newPush</code>方法内部干一些别的事情，比如通知变化。</p>\n<p>是不是很巧妙？<code>Vue</code>内部就是这么干的。</p>\n<h3><span id=\"32-数组方法拦截器\">3.2 数组方法拦截器</span></h3>\n<p>基于上一小节的思想，在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。如下图所示：</p>\n<p><img src=\"/img/reactive/2.png\" alt></p>\n<p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有7个，分别是：<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>。那么源码中的拦截器代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：/src/core/observer/array.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayProto = <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"><span class=\"comment\">// 创建一个对象作为拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> arrayMethods = <span class=\"built_in\">Object</span>.create(arrayProto)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变数组自身内容的7个方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> methodsToPatch = [</span><br><span class=\"line\">  <span class=\"string\">'push'</span>,</span><br><span class=\"line\">  <span class=\"string\">'pop'</span>,</span><br><span class=\"line\">  <span class=\"string\">'shift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'unshift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'splice'</span>,</span><br><span class=\"line\">  <span class=\"string\">'sort'</span>,</span><br><span class=\"line\">  <span class=\"string\">'reverse'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercept mutating methods and emit events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]      <span class=\"comment\">// 缓存原生方法</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value:<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span>(<span class=\"params\">...args</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> result</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就后说，实标上执行的是函数<code>mutator</code>，而<code>mutator</code>函数内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。<br>\n那么，接下来我们就可以在<code>mutato</code>r函数中做一些其他的事，比如说发送变化通知。</p>\n<h3><span id=\"33-使用拦截器\">3.3 使用拦截器</span></h3>\n<p>在上一小节的图中，我们把拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p>\n<p>其实挂载不难，我们只需把数据的<code>__proto__</code>属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：/src/core/observer/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">        ? protoAugment</span><br><span class=\"line\">        : copyAugment</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> hasProto = <span class=\"string\">'__proto__'</span> <span class=\"keyword\">in</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayKeys = <span class=\"built_in\">Object</span>.getOwnPropertyNames(arrayMethods)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Augment an target Object or Array by intercepting</span></span><br><span class=\"line\"><span class=\"comment\"> * the prototype chain using __proto__</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">protoAugment</span> (<span class=\"params\">target, src: Object, keys: any</span>) </span>&#123;</span><br><span class=\"line\">  target.__proto__ = src</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Augment an target Object or Array by defining</span></span><br><span class=\"line\"><span class=\"comment\"> * hidden properties.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/* istanbul ignore next */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyAugment</span> (<span class=\"params\">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = keys[i]</span><br><span class=\"line\">    def(target, key, src[key])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value.__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的7个方法循环加入到<code>value</code>上。</p>\n<p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对<code>Array</code>型数据的可观测。</p>\n<h2><span id=\"4-再谈依赖收集\">4. 再谈依赖收集</span></h2>\n<h3><span id=\"41-把依赖收集到哪里\">4.1 把依赖收集到哪里</span></h3>\n<p>在第二章中我们说了，数组的依赖也在<code>getter</code>中收集，而给数据添加<code>getter/setter</code>都是在<code>Observer</code>类中完成的，所以我们也应该把依赖收集到<code>Observer</code>类中，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：/src/core/observer/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep()    <span class=\"comment\">// 实例化一个依赖管理器，用来收集数组依赖  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">        ? protoAugment</span><br><span class=\"line\">        : copyAugment</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，在<code>Observer</code>类中实例化了一个依赖管理器，用来收集数组依赖。</p>\n<h3><span id=\"42-如何收集依赖\">4.2 如何收集依赖</span></h3>\n<p>在第二章中我们说了，数组的依赖也在<code>getter</code>中收集，那么在<code>getter</code>中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在<code>Observer</code>类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。源码是这么做的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\">obj,key,val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> childOb = observe(val)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">              childOb.dep.depend()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(val === newVal)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            val = newVal;</span><br><span class=\"line\">            dep.notify()   <span class=\"comment\">// 在setter中通知依赖更新</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"comment\"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span> (<span class=\"params\">value, asRootData</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(value) || value <span class=\"keyword\">instanceof</span> VNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ob</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasOwn(value, <span class=\"string\">'__ob__'</span>) &amp;&amp; value.__ob__ <span class=\"keyword\">instanceof</span> Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ob = <span class=\"keyword\">new</span> Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，我们首先通过<code>observe</code>函数为被获取的数据<code>arr</code>尝试创建一个<code>Observer</code>实例，在<code>observe</code>实函数内部，先判断当前传入的数据上是否有<code>__ob__</code>属性，因为在上篇文章中说了，如果数据有<code>__ob__</code>属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用<code>new Observer(value)</code>将其转化成响应式的，并把数据对应的<code>Observer</code>实例返回。</p>\n<p>而在<code>defineReactive</code>函数中，首先获取数据对应的<code>Observer</code>实例，然后在<code>getter</code>中调用<code>Observer</code>实例上依赖管理器，从而将依赖收集起来。</p>\n<h3><span id=\"43-如何通知依赖\">4.3 如何通知依赖</span></h3>\n<p>到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？</p>\n<p>其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据<code>value</code>即可，因为<code>vaule</code>上的<code>__ob__</code>就是其对应的<code>Observer</code>类实例，有了<code>Observer</code>类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的<code>dep.notify()</code>方法，让它去通知依赖更新即可。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercept mutating methods and emit events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ob = <span class=\"keyword\">this</span>.__ob__</span><br><span class=\"line\">    <span class=\"comment\">// notify change</span></span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的<code>this</code>就是数据<code>value</code>，拿到<code>value</code>上的<code>Observer</code>类实例，从而你就可以调用<code>Observer</code>类实例上面依赖管理器的<code>dep.notify()</code>方法，以达到通知依赖的目的。</p>\n<p>OK，以上就基本完成了<code>Array</code>数据的变化侦测。</p>\n<h2><span id=\"5-深度侦测\">5. 深度侦测</span></h2>\n<p>在前文所有讲的<code>Array</code>型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在<code>Vue</code>中，不论是<code>Object</code>型数据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name:<span class=\"string\">'NLRX'</span>，</span><br><span class=\"line\">        age:<span class=\"string\">'18'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p>\n<p>这个实现起来比较简单，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value: any) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep()</span><br><span class=\"line\">    def(value, <span class=\"string\">'__ob__'</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">        ? protoAugment</span><br><span class=\"line\">        : copyAugment</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.observeArray(value)   <span class=\"comment\">// 将数组中的所有元素都转化为可被侦测的响应式</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Observe a list of Array items.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  observeArray (items: <span class=\"built_in\">Array</span>&lt;any&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span> (<span class=\"params\">value, asRootData</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(value) || value <span class=\"keyword\">instanceof</span> VNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ob</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasOwn(value, <span class=\"string\">'__ob__'</span>) &amp;&amp; value.__ob__ <span class=\"keyword\">instanceof</span> Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ob = <span class=\"keyword\">new</span> Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p>\n<p>而对应<code>object</code>数据，在上一篇文章中我们已经在<code>defineReactive</code>函数中进行了递归操作。</p>\n<h2><span id=\"6-数组新增元素的侦测\">6. 数组新增元素的侦测</span></h2>\n<p>对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。</p>\n<p>这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercept mutating methods and emit events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// cache original method</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ob = <span class=\"keyword\">this</span>.__ob__</span><br><span class=\"line\">    <span class=\"keyword\">let</span> inserted</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'push'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'unshift'</span>:</span><br><span class=\"line\">        inserted = args   <span class=\"comment\">// 如果是push或unshift方法，那么传入参数就是新增的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'splice'</span>:</span><br><span class=\"line\">        inserted = args.slice(<span class=\"number\">2</span>) <span class=\"comment\">// 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inserted) ob.observeArray(inserted) <span class=\"comment\">// 调用observe函数将新增的元素转化成响应式</span></span><br><span class=\"line\">    <span class=\"comment\">// notify change</span></span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在上面拦截器定义代码中，如果是<code>push</code>或<code>unshift</code>方法，那么传入参数就是新增的元素;如果是<code>splice</code>方法，那么传入参数列表中下标为2的就是新增的元素，拿到新增的元素后，就可以调用<code>observe</code>函数将新增的元素转化成响应式的了。</p>\n<h2><span id=\"7-不足之处\">7. 不足之处</span></h2>\n<p>前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;       <span class=\"comment\">// 通过数组下标修改数组中的数据</span></span><br><span class=\"line\">arr.length = <span class=\"number\">0</span>    <span class=\"comment\">// 通过修改数组长度清空数组</span></span><br></pre></td></tr></table></figure>\n<p>而使用上述例子中的操作方式来修改数组是无法侦测到的。<br>\n同样，<code>Vue</code>也注意到了这个问题， 为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到。</p>\n<h2><span id=\"8-总结\">8. 总结</span></h2>\n<p>在本篇文章中，首先我们分析了对于<code>Array</code>型数据也在<code>getter</code>中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现<code>Vue</code>不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。</p>\n<p>以上就是对<code>Array</code>型数据的变化侦测分析。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>上一篇文章中我们介绍了<code>Object</code>数据的变化侦测方式，本篇文章我们来看一下对<code>Array</code>型数据的变化<code>Vue</code>是如何进行侦测的。</p>\n<p>为什么<code>Object</code>数据和<code>Array</code>型数据会有两种不同的变化侦测方式？</p>\n<p>这是因为对于<code>Object</code>数据我们使用的是<code>JS</code>提供的对象原型上的方法<code>Object.defineProperty</code>，而这个方法是对象原型上的，所以<code>Array</code>无法使用这个方法，所以我们需要对<code>Array</code>型数据设计一套另外的变化侦测机制。</p>\n<p>万变不离其宗，虽然对<code>Array</code>型数据设计了新的变化侦测机制，但是其根本思路还是不变的。那就是：还是在获取数据时收集依赖，数据变化时通知依赖更新。</p>\n<p>下面我们就通过源码来看看<code>Vue</code>对<code>Array</code>型数据到底是如何进行变化侦测的。</p>\n<h2>2. 在哪里收集依赖</h2>\n<p>首先还是老规矩，我们得先把用到<code>Array</code>型数据的地方作为依赖收集起来，那么第一问题就是该在哪里收集呢？</p>\n<p>其实<code>Array</code>型数据的依赖收集方式和<code>Object</code>数据的依赖收集方式相同，都是在<code>getter</code>中收集。那么问题就来了，不是说<code>Array</code>无法使用<code>Object.defineProperty</code>方法吗？无法使用怎么还在<code>getter</code>中收集依赖呢？</p>\n<p>其实不然，我们回想一下平常在开发的时候，在组件的<code>data</code>中是不是都这么写的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        arr:[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>想想看，<code>arr</code>这个数据始终都存在于一个<code>object</code>数据对象中，而且我们也说了，谁用到了数据谁就是依赖，那么要用到<code>arr</code>这个数据，是不是得先从<code>object</code>数据对象中获取一下<code>arr</code>数据，而从<code>object</code>数据对象中获取<code>arr</code>数据自然就会触发<code>arr</code>的<code>getter</code>，所以我们就可以在<code>getter</code>中收集依赖。</p>\n<p>总结一句话就是：<strong>Array型数据还是在getter中收集依赖。</strong></p>\n<h2>3. 使Array型数据可观测</h2>\n<p>上一章节中我们知道了<code>Array</code>型数据还是在<code>getter</code>中收集依赖，换句话说就是我们已经知道了<code>Array</code>型数据何时被读取了。</p>\n<p>回想上一篇文章中介绍<code>Object</code>数据变化侦测的时候，我们先让<code>Object</code>数据变的可观测，即我们能够知道数据什么时候被读取了、什么时候发生变化了。同理，对于<code>Array</code>型数据我们也得让它变的可观测，目前我们已经完成了一半可观测，即我们只知道了<code>Array</code>型数据何时被读取了，而何时发生变化我们无法知道，那么接下来我们就来解决这一问题：当<code>Array</code>型数据发生变化时我们如何得知？</p>\n<h3>3.1 思路分析</h3>\n<p><code>Object</code>的变化时通过<code>setter</code>来追踪的，只有某个数据发生了变化，就一定会触发这个数据上的<code>setter</code>。但是<code>Array</code>型数据没有<code>setter</code>，怎么办？</p>\n<p>我们试想一下，要想让<code>Array</code>型数据发生变化，那必然是操作了<code>Array</code>，而<code>JS</code>中提供的操作数组的方法就那么几种，我们可以把这些方法都重写一遍，在不改变原有功能的前提下，我们为其新增一些其他功能，例如下面这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">arr.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.newPush = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'arr被修改了'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.push(val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr.newPush(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>在上面这个例子中，我们针对数组的原生<code>push</code>方法定义个一个新的<code>newPush</code>方法，这个<code>newPush</code>方法内部调用了原生<code>push</code>方法，这样就保证了新的<code>newPush</code>方法跟原生<code>push</code>方法具有相同的功能，而且我们还可以在新的<code>newPush</code>方法内部干一些别的事情，比如通知变化。</p>\n<p>是不是很巧妙？<code>Vue</code>内部就是这么干的。</p>\n<h3>3.2 数组方法拦截器</h3>\n<p>基于上一小节的思想，在<code>Vue</code>中创建了一个数组方法拦截器，它拦截在数组实例与<code>Array.prototype</code>之间，在拦截器内重写了操作数组的一些方法，当数组实例使用操作数组方法时，其实使用的是拦截器中重写的方法，而不再使用<code>Array.prototype</code>上的原生方法。如下图所示：</p>\n<p><img src=\"/img/reactive/2.png\" alt></p>\n<p>经过整理，<code>Array</code>原型中可以改变数组自身内容的方法有7个，分别是：<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>。那么源码中的拦截器代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：/src/core/observer/array.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayProto = <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"><span class=\"comment\">// 创建一个对象作为拦截器</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> arrayMethods = <span class=\"built_in\">Object</span>.create(arrayProto)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变数组自身内容的7个方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> methodsToPatch = [</span><br><span class=\"line\">  <span class=\"string\">'push'</span>,</span><br><span class=\"line\">  <span class=\"string\">'pop'</span>,</span><br><span class=\"line\">  <span class=\"string\">'shift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'unshift'</span>,</span><br><span class=\"line\">  <span class=\"string\">'splice'</span>,</span><br><span class=\"line\">  <span class=\"string\">'sort'</span>,</span><br><span class=\"line\">  <span class=\"string\">'reverse'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercept mutating methods and emit events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]      <span class=\"comment\">// 缓存原生方法</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class=\"line\">      enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      value:<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span>(<span class=\"params\">...args</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> result</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，首先创建了继承自<code>Array</code>原型的空对象<code>arrayMethods</code>，接着在<code>arrayMethods</code>上使用<code>object.defineProperty</code>方法将那些可以改变数组自身的7个方法遍历逐个进行封装。最后，当我们使用<code>push</code>方法的时候，其实用的是<code>arrayMethods.push</code>，而<code>arrayMethods.push</code>就是封装的新函数<code>mutator</code>，也就后说，实标上执行的是函数<code>mutator</code>，而<code>mutator</code>函数内部执行了<code>original</code>函数，这个<code>original</code>函数就是<code>Array.prototype</code>上对应的原生方法。<br>\n那么，接下来我们就可以在<code>mutato</code>r函数中做一些其他的事，比如说发送变化通知。</p>\n<h3>3.3 使用拦截器</h3>\n<p>在上一小节的图中，我们把拦截器做好还不够，还要把它挂载到数组实例与<code>Array.prototype</code>之间，这样拦截器才能够生效。</p>\n<p>其实挂载不难，我们只需把数据的<code>__proto__</code>属性设置为拦截器<code>arrayMethods</code>即可，源码实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：/src/core/observer/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">        ? protoAugment</span><br><span class=\"line\">        : copyAugment</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 能力检测：判断__proto__是否可用，因为有的浏览器不支持该属性</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> hasProto = <span class=\"string\">'__proto__'</span> <span class=\"keyword\">in</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayKeys = <span class=\"built_in\">Object</span>.getOwnPropertyNames(arrayMethods)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Augment an target Object or Array by intercepting</span></span><br><span class=\"line\"><span class=\"comment\"> * the prototype chain using __proto__</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">protoAugment</span> (<span class=\"params\">target, src: Object, keys: any</span>) </span>&#123;</span><br><span class=\"line\">  target.__proto__ = src</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Augment an target Object or Array by defining</span></span><br><span class=\"line\"><span class=\"comment\"> * hidden properties.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/* istanbul ignore next */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyAugment</span> (<span class=\"params\">target: Object, src: Object, keys: Array&lt;string&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = keys[i]</span><br><span class=\"line\">    def(target, key, src[key])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中首先判断了浏览器是否支持<code>__proto__</code>，如果支持，则调用<code>protoAugment</code>函数把<code>value.__proto__ = arrayMethods</code>；如果不支持，则调用<code>copyAugment</code>函数把拦截器中重写的7个方法循环加入到<code>value</code>上。</p>\n<p>拦截器生效以后，当数组数据再发生变化时，我们就可以在拦截器中通知变化了，也就是说现在我们就可以知道数组数据何时发生变化了，OK，以上我们就完成了对<code>Array</code>型数据的可观测。</p>\n<h2>4. 再谈依赖收集</h2>\n<h3>4.1 把依赖收集到哪里</h3>\n<p>在第二章中我们说了，数组的依赖也在<code>getter</code>中收集，而给数据添加<code>getter/setter</code>都是在<code>Observer</code>类中完成的，所以我们也应该把依赖收集到<code>Observer</code>类中，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源码位置：/src/core/observer/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep()    <span class=\"comment\">// 实例化一个依赖管理器，用来收集数组依赖  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">        ? protoAugment</span><br><span class=\"line\">        : copyAugment</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，在<code>Observer</code>类中实例化了一个依赖管理器，用来收集数组依赖。</p>\n<h3>4.2 如何收集依赖</h3>\n<p>在第二章中我们说了，数组的依赖也在<code>getter</code>中收集，那么在<code>getter</code>中到底该如何收集呢？这里有一个需要注意的点，那就是依赖管理器定义在<code>Observer</code>类中，而我们需要在<code>getter</code>中收集依赖，也就是说我们必须在<code>getter</code>中能够访问到<code>Observer</code>类中的依赖管理器，才能把依赖存进去。源码是这么做的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span> (<span class=\"params\">obj,key,val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> childOb = observe(val)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">        enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"keyword\">get</span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childOb) &#123;</span><br><span class=\"line\">              childOb.dep.depend()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">set</span>(newVal)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(val === newVal)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            val = newVal;</span><br><span class=\"line\">            dep.notify()   <span class=\"comment\">// 在setter中通知依赖更新</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Attempt to create an observer instance for a value,</span></span><br><span class=\"line\"><span class=\"comment\"> * returns the new observer if successfully observed,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the existing observer if the value already has one.</span></span><br><span class=\"line\"><span class=\"comment\"> * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果 Value 已经存在一个Observer实例，则直接返回它</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span> (<span class=\"params\">value, asRootData</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(value) || value <span class=\"keyword\">instanceof</span> VNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ob</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasOwn(value, <span class=\"string\">'__ob__'</span>) &amp;&amp; value.__ob__ <span class=\"keyword\">instanceof</span> Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ob = <span class=\"keyword\">new</span> Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，我们首先通过<code>observe</code>函数为被获取的数据<code>arr</code>尝试创建一个<code>Observer</code>实例，在<code>observe</code>实函数内部，先判断当前传入的数据上是否有<code>__ob__</code>属性，因为在上篇文章中说了，如果数据有<code>__ob__</code>属性，表示它已经被转化成响应式的了，如果没有则表示该数据还不是响应式的，那么就调用<code>new Observer(value)</code>将其转化成响应式的，并把数据对应的<code>Observer</code>实例返回。</p>\n<p>而在<code>defineReactive</code>函数中，首先获取数据对应的<code>Observer</code>实例，然后在<code>getter</code>中调用<code>Observer</code>实例上依赖管理器，从而将依赖收集起来。</p>\n<h3>4.3 如何通知依赖</h3>\n<p>到现在为止，依赖已经收集好了，并且也已经存放好了，那么我们该如何通知依赖呢？</p>\n<p>其实不难，在前文说过，我们应该在拦截器里通知依赖，要想通知依赖，首先要能访问到依赖。要访问到依赖也不难，因为我们只要能访问到被转化成响应式的数据<code>value</code>即可，因为<code>vaule</code>上的<code>__ob__</code>就是其对应的<code>Observer</code>类实例，有了<code>Observer</code>类实例我们就能访问到它上面的依赖管理器，然后只需调用依赖管理器的<code>dep.notify()</code>方法，让它去通知依赖更新即可。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercept mutating methods and emit events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ob = <span class=\"keyword\">this</span>.__ob__</span><br><span class=\"line\">    <span class=\"comment\">// notify change</span></span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于我们的拦截器是挂载到数组数据的原型上的，所以拦截器中的<code>this</code>就是数据<code>value</code>，拿到<code>value</code>上的<code>Observer</code>类实例，从而你就可以调用<code>Observer</code>类实例上面依赖管理器的<code>dep.notify()</code>方法，以达到通知依赖的目的。</p>\n<p>OK，以上就基本完成了<code>Array</code>数据的变化侦测。</p>\n<h2>5. 深度侦测</h2>\n<p>在前文所有讲的<code>Array</code>型数据的变化侦测都仅仅说的是数组自身变化的侦测，比如给数组新增一个元素或删除数组中一个元素，而在<code>Vue</code>中，不论是<code>Object</code>型数据还是<code>Array</code>型数据所实现的数据变化侦测都是深度侦测，所谓深度侦测就是不但要侦测数据自身的变化，还要侦测数据中所有子数据的变化。举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name:<span class=\"string\">'NLRX'</span>，</span><br><span class=\"line\">        age:<span class=\"string\">'18'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>数组中包含了一个对象，如果该对象的某个属性发生了变化也应该被侦测到，这就是深度侦测。</p>\n<p>这个实现起来比较简单，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (value: any) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dep = <span class=\"keyword\">new</span> Dep()</span><br><span class=\"line\">    def(value, <span class=\"string\">'__ob__'</span>, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> augment = hasProto</span><br><span class=\"line\">        ? protoAugment</span><br><span class=\"line\">        : copyAugment</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.observeArray(value)   <span class=\"comment\">// 将数组中的所有元素都转化为可被侦测的响应式</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Observe a list of Array items.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  observeArray (items: <span class=\"built_in\">Array</span>&lt;any&gt;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span> (<span class=\"params\">value, asRootData</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isObject(value) || value <span class=\"keyword\">instanceof</span> VNode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ob</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasOwn(value, <span class=\"string\">'__ob__'</span>) &amp;&amp; value.__ob__ <span class=\"keyword\">instanceof</span> Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ob = <span class=\"keyword\">new</span> Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，对于<code>Array</code>型数据，调用了<code>observeArray()</code>方法，该方法内部会遍历数组中的每一个元素，然后通过调用<code>observe</code>函数将每一个元素都转化成可侦测的响应式数据。</p>\n<p>而对应<code>object</code>数据，在上一篇文章中我们已经在<code>defineReactive</code>函数中进行了递归操作。</p>\n<h2>6. 数组新增元素的侦测</h2>\n<p>对于数组中已有的元素我们已经可以将其全部转化成可侦测的响应式数据了，但是如果向数组里新增一个元素的话，我们也需要将新增的这个元素转化成可侦测的响应式数据。</p>\n<p>这个实现起来也很容易，我们只需拿到新增的这个元素，然后调用<code>observe</code>函数将其转化即可。我们知道，可以向数组内新增元素的方法有3个，分别是：<code>push</code>、<code>unshift</code>、<code>splice</code>。我们只需对这3中方法分别处理，拿到新增的元素，再将其转化即可。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Intercept mutating methods and emit events</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">methodsToPatch.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">method</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// cache original method</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mutator</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = original.apply(<span class=\"keyword\">this</span>, args)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ob = <span class=\"keyword\">this</span>.__ob__</span><br><span class=\"line\">    <span class=\"keyword\">let</span> inserted</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'push'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'unshift'</span>:</span><br><span class=\"line\">        inserted = args   <span class=\"comment\">// 如果是push或unshift方法，那么传入参数就是新增的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'splice'</span>:</span><br><span class=\"line\">        inserted = args.slice(<span class=\"number\">2</span>) <span class=\"comment\">// 如果是splice方法，那么传入参数列表中下标为2的就是新增的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inserted) ob.observeArray(inserted) <span class=\"comment\">// 调用observe函数将新增的元素转化成响应式</span></span><br><span class=\"line\">    <span class=\"comment\">// notify change</span></span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在上面拦截器定义代码中，如果是<code>push</code>或<code>unshift</code>方法，那么传入参数就是新增的元素;如果是<code>splice</code>方法，那么传入参数列表中下标为2的就是新增的元素，拿到新增的元素后，就可以调用<code>observe</code>函数将新增的元素转化成响应式的了。</p>\n<h2>7. 不足之处</h2>\n<p>前文中我们说过，对于数组变化侦测是通过拦截器实现的，也就是说只要是通过数组原型上的方法对数组进行操作就都可以侦测到，但是别忘了，我们在日常开发中，还可以通过数组的下标来操作数据，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;       <span class=\"comment\">// 通过数组下标修改数组中的数据</span></span><br><span class=\"line\">arr.length = <span class=\"number\">0</span>    <span class=\"comment\">// 通过修改数组长度清空数组</span></span><br></pre></td></tr></table></figure>\n<p>而使用上述例子中的操作方式来修改数组是无法侦测到的。<br>\n同样，<code>Vue</code>也注意到了这个问题， 为了解决这一问题，<code>Vue</code>增加了两个全局API:<code>Vue.set</code>和<code>Vue.delete</code>，这两个API的实现原理将会在后面学习全局API的时候说到。</p>\n<h2>8. 总结</h2>\n<p>在本篇文章中，首先我们分析了对于<code>Array</code>型数据也在<code>getter</code>中进行依赖收集；其次我们发现，当数组数据被访问时我们轻而易举可以知道，但是被修改时我们却很难知道，为了解决这一问题，我们创建了数组方法拦截器，从而成功的将数组数据变的可观测。接着我们对数组的依赖收集及数据变化如何通知依赖进行了深入分析；最后我们发现<code>Vue</code>不但对数组自身进行了变化侦测，还对数组中的每一个元素以及新增的元素都进行了变化侦测，我们也分析了其实现原理。</p>\n<p>以上就是对<code>Array</code>型数据的变化侦测分析。</p>\n"},{"title":"Vue 源码阅读 虚拟DOM （四）","catalog":true,"date":"2019-10-29T15:21:32.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n## 1. 前言\n\n在上一篇文章中，我们介绍了当新的`VNode`与旧的`oldVNode`都是元素节点并且都包含子节点时，`Vue`对子节点是\n\n先外层循环`newChildren`数组，再内层循环`oldChildren`数组，每循环外层`newChildren`数组里的一个子节点，就去内层`oldChildren`数组里找看有没有与之相同的子节点，最后根据不同的情况作出不同的操作。\n\n在上一篇文章的结尾我们也说了，这种方法虽然能够解决问题，但是还存在可优化的地方。比如当包含的子节点数量很多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。当然，`Vue`也意识到了这点，并对此也进行了优化，那么本篇文章，就来学习一下关于子节点更新的优化问题`Vue`是如何做的。\n\n## 2. 优化策略介绍\n\n假如我们现有一份新的`newChildren`数组和旧的`oldChildren`数组，如下所示：\n\n```javascript\nnewChildren = ['新子节点1','新子节点2','新子节点3','新子节点4']\noldChildren = ['旧子节点1','旧子节点2','旧子节点3','旧子节点4']\n```\n\n如果按照优化之前的解决方案，那么我们接下来的操作应该是这样的：先循环`newChildren`数组，拿到第一个新子节点1，然后用第一个新子节点1去跟`oldChildren`数组里的旧子节点逐一对比，如果运气好一点，刚好`oldChildren`数组里的第一个旧子节点1与第一个新子节点1相同，那就皆大欢喜，直接处理，不用再往下循环了。那如果运气坏一点，直到循环到`oldChildren`数组里的第四个旧子节点4才与第一个新子节点1相同，那此时就会多循环了4次。我们不妨把情况再设想的极端一点，如果`newChildren`数组和`oldChildren`数组里前三个节点都没有变化，只是第四个节点发生了变化，那么我们就会循环16次，只有在第16次循环的时候才发现新节点4与旧节点4相同，进行更新，如下图所示：\n![](/img/virtualDOM/7.jpg)\n\n上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。\n\n那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环`newChildren`和`oldChildren`这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：\n\n- 先把`newChildren`数组里的所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；\n- 如果不同，再把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；\n- 如果不同，再把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n- 如果不同，再把`newChildren`数组里所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n- 最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。\n\n其过程如下图所示：\n![](/img/virtualDOM/8.png)\n\n在上图中，我们把：\n\n- `newChildren`数组里的所有未处理子节点的第一个子节点称为：新前；\n- `newChildren`数组里的所有未处理子节点的最后一个子节点称为：新后；\n- `oldChildren`数组里的所有未处理子节点的第一个子节点称为：旧前；\n- `oldChildren`数组里的所有未处理子节点的最后一个子节点称为：旧后；\n\n\n\nOK，有了以上概念以后，下面我们就来看看其具体是如何实施的。\n\n## 3. 新前与旧前\n\n把`newChildren`数组里的所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那好极了，直接进入之前文章中说的更新节点的操作并且由于新前与旧前两个节点的位置也相同，无需进行节点移动操作；如果不同，没关系，再尝试后面三种情况。\n![](/img/virtualDOM/9.png)\n\n## 4. 新后与旧后\n\n把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。\n![](/img/virtualDOM/10.png)\n\n## 5. 新后与旧前\n\n把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n![](/img/virtualDOM/11.png)\n\n此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，**更新节点要以新`VNode`为基准，然后操作旧的`oldVNode`，使之最后旧的`oldVNode`与新的`VNode`相同**。那么现在的情况是：`newChildren`数组里的最后一个子节点与`oldChildren`数组里的第一个子节点相同，那么我们就应该在`oldChildren`数组里把第一个子节点移动到最后一个子节点的位置，如下图：\n\n![](/img/virtualDOM/12.png)\n\n\n从图中不难看出，我们要把`oldChildren`数组里把第一个子节点移动到数组中**所有未处理节点之后**。\n\n如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。\n\n## 6. 新前与旧后\n\n把`newChildren`数组里所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n\n![](/img/virtualDOM/13.png)\n\n同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是`newChildren`数组里的第一个子节点与`oldChildren`数组里的最后一个子节点相同，那么我们就应该在`oldChildren`数组里把最后一个子节点移动到第一个子节点的位置，如下图：\n\n![](/img/virtualDOM/14.png)\n\n\n从图中不难看出，我们要把`oldChildren`数组里把最后一个子节点移动到数组中**所有未处理节点之前**。\n\n\n\nOK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。\n\n## 7. 回到源码\n\n\n\n思路分析完，逻辑理清之后，我们再回到源码里看看，验证一下源码实现的逻辑是否跟我们分析的一样。源码如下：\n\n```javascript\n// 循环更新子节点\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0               // oldChildren开始索引\n    let oldEndIdx = oldCh.length - 1   // oldChildren结束索引\n    let oldStartVnode = oldCh[0]        // oldChildren中所有未处理节点中的第一个\n    let oldEndVnode = oldCh[oldEndIdx]   // oldChildren中所有未处理节点中的最后一个\n    \n    let newStartIdx = 0               // newChildren开始索引\n    let newEndIdx = newCh.length - 1   // newChildren结束索引\n    let newStartVnode = newCh[0]        // newChildren中所有未处理节点中的第一个\n    let newEndVnode = newCh[newEndIdx]  // newChildren中所有未处理节点中的最后一个\n    \n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh)\n    }\n\n    // 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // 如果oldStartVnode不存在，则直接跳过，比对下一个\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        // 如果新前与旧前节点相同，就把两个节点进行patch更新\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        // 如果新后与旧后节点相同，就把两个节点进行patch更新\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        // 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        // 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        // 如果不属于以上四种情况，就进行常规的循环比对patch\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        // 如果在oldChildren里找不到当前循环的newChildren里的子节点\n        if (isUndef(idxInOld)) { // New element\n          // 新增节点并插入到合适位置\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          // 如果在oldChildren里找到了当前循环的newChildren里的子节点\n          vnodeToMove = oldCh[idxInOld]\n          // 如果两个节点相同\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            // 调用patchVnode更新节点\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n            oldCh[idxInOld] = undefined\n            // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      /**\n       * 如果oldChildren比newChildren先循环完毕，\n       * 那么newChildren里面剩余的节点都是需要新增的节点，\n       * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中\n       */\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx > newEndIdx) {\n      /**\n       * 如果newChildren比oldChildren先循环完毕，\n       * 那么oldChildren里面剩余的节点都是需要删除的节点，\n       * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除\n       */\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n\n```\n\n读源码之前，我们先有这样一个概念：那就是在我们前面所说的优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环。\n\n那么该如何从两边向中间循环呢？请看下图：\n![](~@/virtualDOM/15.png)\n\n首先，我们先准备4个变量：\n\n- **newStartIdx:**`newChildren`数组里开始位置的下标；\n- **newEndIdx:**`newChildren`数组里结束位置的下标；\n- **oldStartIdx:**`oldChildren`数组里开始位置的下标；\n- **oldEndIdx:**`oldChildren`数组里结束位置的下标；\n\n在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：`newStartIdx`和`oldStartIdx`只能往后移动（只会加），`newEndIdx`和`oldEndIdx`只能往前移动（只会减）。\n\n当开始位置大于结束位置时，表示所有节点都已经遍历过了。\n\nOK，有了这个概念后，我们开始读源码：\n\n1. 如果`oldStartVnode`不存在，则直接跳过，将`oldStartIdx`加1，比对下一个\n\n   ```javascript\n   // 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点\n   while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n   \tif (isUndef(oldStartVnode)) {\n           oldStartVnode = oldCh[++oldStartIdx] \n         }\n   }\n   ```\n\n2. 如果`oldEndVnode`不存在，则直接跳过，将`oldEndIdx`减1，比对前一个\n\n   ```javascript\n   else if (isUndef(oldEndVnode)) {\n       oldEndVnode = oldCh[--oldEndIdx]\n   } \n   ```\n\n3. 如果新前与旧前节点相同，就把两个节点进行`patch`更新，同时`oldStartIdx`和`newStartIdx`都加1，后移一个位置\n\n   ```javascript\n   else if (sameVnode(oldStartVnode, newStartVnode)) {\n       patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n       oldStartVnode = oldCh[++oldStartIdx]\n       newStartVnode = newCh[++newStartIdx]\n   }\n   ```\n\n4. 如果新后与旧后节点相同，就把两个节点进行`patch`更新，同时`oldEndIdx`和`newEndIdx`都减1，前移一个位置\n\n   ```javascript\n   else if (sameVnode(oldEndVnode, newEndVnode)) {\n       patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n       oldEndVnode = oldCh[--oldEndIdx]\n       newEndVnode = newCh[--newEndIdx]\n   } \n   ```\n\n5. 如果新后与旧前节点相同，先把两个节点进行`patch`更新，然后把旧前节点移动到`oldChilren`中所有未处理节点之后，最后把`oldStartIdx`加1，后移一个位置，`newEndIdx`减1，前移一个位置\n\n   ```javascript\n   else if (sameVnode(oldStartVnode, newEndVnode)) { \n       patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n       canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n       oldStartVnode = oldCh[++oldStartIdx]\n       newEndVnode = newCh[--newEndIdx]\n   } \n   ```\n\n6. 如果新前与旧后节点相同，先把两个节点进行`patch`更新，然后把旧后节点移动到`oldChilren`中所有未处理节点之前，最后把`newStartIdx`加1，后移一个位置，`oldEndIdx`减1，前移一个位置\n\n   ```javascript\n   else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n       patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n       canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n       oldEndVnode = oldCh[--oldEndIdx]\n       newStartVnode = newCh[++newStartIdx]\n   } \n   ```\n\n7. 如果不属于以上四种情况，就进行常规的循环比对`patch`\n\n8. 如果在循环中，`oldStartIdx`大于`oldEndIdx`了，那就表示`oldChildren`比`newChildren`先循环完毕，那么`newChildren`里面剩余的节点都是需要新增的节点，把`[newStartIdx, newEndIdx]`之间的所有节点都插入到`DOM`中\n\n   ```javascript\n   if (oldStartIdx > oldEndIdx) {\n       refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n       addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n   } \n   ```\n\n9. 如果在循环中，`newStartIdx`大于`newEndIdx`了，那就表示`newChildren`比`oldChildren`先循环完毕，那么`oldChildren`里面剩余的节点都是需要删除的节点，把`[oldStartIdx, oldEndIdx]`之间的所有节点都删除\n\n   ```javascript\n   else if (newStartIdx > newEndIdx) {\n       removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n   }\n   ```\n\n   \n\nOK,处理完毕，可见源码中的处理逻辑跟我们之前分析的逻辑是一样的。\n\n## 8. 总结\n\n本篇文章中，我们介绍了`Vue`中子节点更新的优化策略，发现`Vue`为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。对于每一种情况我们都通过图文的形式对其逻辑进行了分析。最后我们回到源码，通过阅读源码来验证我们分析的是否正确。幸运的是我们之前每一步的分析都在源码中找到了相应的实现，得以验证我们的分析没有错。以上就是`Vue`中的`patch`过程，即`DOM-Diff`算法所有内容了，到这里相信你再读这部分源码的时候就有比较清晰的思路了。\n\n\n","source":"_posts/Vue 源码阅读 虚拟DOM （四）.md","raw":"---\ntitle: Vue 源码阅读 虚拟DOM （四） \ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-29 23:21:32\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n## 1. 前言\n\n在上一篇文章中，我们介绍了当新的`VNode`与旧的`oldVNode`都是元素节点并且都包含子节点时，`Vue`对子节点是\n\n先外层循环`newChildren`数组，再内层循环`oldChildren`数组，每循环外层`newChildren`数组里的一个子节点，就去内层`oldChildren`数组里找看有没有与之相同的子节点，最后根据不同的情况作出不同的操作。\n\n在上一篇文章的结尾我们也说了，这种方法虽然能够解决问题，但是还存在可优化的地方。比如当包含的子节点数量很多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。当然，`Vue`也意识到了这点，并对此也进行了优化，那么本篇文章，就来学习一下关于子节点更新的优化问题`Vue`是如何做的。\n\n## 2. 优化策略介绍\n\n假如我们现有一份新的`newChildren`数组和旧的`oldChildren`数组，如下所示：\n\n```javascript\nnewChildren = ['新子节点1','新子节点2','新子节点3','新子节点4']\noldChildren = ['旧子节点1','旧子节点2','旧子节点3','旧子节点4']\n```\n\n如果按照优化之前的解决方案，那么我们接下来的操作应该是这样的：先循环`newChildren`数组，拿到第一个新子节点1，然后用第一个新子节点1去跟`oldChildren`数组里的旧子节点逐一对比，如果运气好一点，刚好`oldChildren`数组里的第一个旧子节点1与第一个新子节点1相同，那就皆大欢喜，直接处理，不用再往下循环了。那如果运气坏一点，直到循环到`oldChildren`数组里的第四个旧子节点4才与第一个新子节点1相同，那此时就会多循环了4次。我们不妨把情况再设想的极端一点，如果`newChildren`数组和`oldChildren`数组里前三个节点都没有变化，只是第四个节点发生了变化，那么我们就会循环16次，只有在第16次循环的时候才发现新节点4与旧节点4相同，进行更新，如下图所示：\n![](/img/virtualDOM/7.jpg)\n\n上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。\n\n那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环`newChildren`和`oldChildren`这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：\n\n- 先把`newChildren`数组里的所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；\n- 如果不同，再把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；\n- 如果不同，再把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n- 如果不同，再把`newChildren`数组里所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n- 最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。\n\n其过程如下图所示：\n![](/img/virtualDOM/8.png)\n\n在上图中，我们把：\n\n- `newChildren`数组里的所有未处理子节点的第一个子节点称为：新前；\n- `newChildren`数组里的所有未处理子节点的最后一个子节点称为：新后；\n- `oldChildren`数组里的所有未处理子节点的第一个子节点称为：旧前；\n- `oldChildren`数组里的所有未处理子节点的最后一个子节点称为：旧后；\n\n\n\nOK，有了以上概念以后，下面我们就来看看其具体是如何实施的。\n\n## 3. 新前与旧前\n\n把`newChildren`数组里的所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那好极了，直接进入之前文章中说的更新节点的操作并且由于新前与旧前两个节点的位置也相同，无需进行节点移动操作；如果不同，没关系，再尝试后面三种情况。\n![](/img/virtualDOM/9.png)\n\n## 4. 新后与旧后\n\n把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。\n![](/img/virtualDOM/10.png)\n\n## 5. 新后与旧前\n\n把`newChildren`数组里所有未处理子节点的最后一个子节点和`oldChildren`数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n![](/img/virtualDOM/11.png)\n\n此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，**更新节点要以新`VNode`为基准，然后操作旧的`oldVNode`，使之最后旧的`oldVNode`与新的`VNode`相同**。那么现在的情况是：`newChildren`数组里的最后一个子节点与`oldChildren`数组里的第一个子节点相同，那么我们就应该在`oldChildren`数组里把第一个子节点移动到最后一个子节点的位置，如下图：\n\n![](/img/virtualDOM/12.png)\n\n\n从图中不难看出，我们要把`oldChildren`数组里把第一个子节点移动到数组中**所有未处理节点之后**。\n\n如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。\n\n## 6. 新前与旧后\n\n把`newChildren`数组里所有未处理子节点的第一个子节点和`oldChildren`数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将`oldChildren`数组里的该节点移动到与`newChildren`数组里节点相同的位置；\n\n![](/img/virtualDOM/13.png)\n\n同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是`newChildren`数组里的第一个子节点与`oldChildren`数组里的最后一个子节点相同，那么我们就应该在`oldChildren`数组里把最后一个子节点移动到第一个子节点的位置，如下图：\n\n![](/img/virtualDOM/14.png)\n\n\n从图中不难看出，我们要把`oldChildren`数组里把最后一个子节点移动到数组中**所有未处理节点之前**。\n\n\n\nOK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。\n\n## 7. 回到源码\n\n\n\n思路分析完，逻辑理清之后，我们再回到源码里看看，验证一下源码实现的逻辑是否跟我们分析的一样。源码如下：\n\n```javascript\n// 循环更新子节点\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0               // oldChildren开始索引\n    let oldEndIdx = oldCh.length - 1   // oldChildren结束索引\n    let oldStartVnode = oldCh[0]        // oldChildren中所有未处理节点中的第一个\n    let oldEndVnode = oldCh[oldEndIdx]   // oldChildren中所有未处理节点中的最后一个\n    \n    let newStartIdx = 0               // newChildren开始索引\n    let newEndIdx = newCh.length - 1   // newChildren结束索引\n    let newStartVnode = newCh[0]        // newChildren中所有未处理节点中的第一个\n    let newEndVnode = newCh[newEndIdx]  // newChildren中所有未处理节点中的最后一个\n    \n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh)\n    }\n\n    // 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // 如果oldStartVnode不存在，则直接跳过，比对下一个\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        // 如果新前与旧前节点相同，就把两个节点进行patch更新\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        // 如果新后与旧后节点相同，就把两个节点进行patch更新\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        // 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        // 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        // 如果不属于以上四种情况，就进行常规的循环比对patch\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        // 如果在oldChildren里找不到当前循环的newChildren里的子节点\n        if (isUndef(idxInOld)) { // New element\n          // 新增节点并插入到合适位置\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          // 如果在oldChildren里找到了当前循环的newChildren里的子节点\n          vnodeToMove = oldCh[idxInOld]\n          // 如果两个节点相同\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            // 调用patchVnode更新节点\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)\n            oldCh[idxInOld] = undefined\n            // canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      /**\n       * 如果oldChildren比newChildren先循环完毕，\n       * 那么newChildren里面剩余的节点都是需要新增的节点，\n       * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中\n       */\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx > newEndIdx) {\n      /**\n       * 如果newChildren比oldChildren先循环完毕，\n       * 那么oldChildren里面剩余的节点都是需要删除的节点，\n       * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除\n       */\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n  }\n\n```\n\n读源码之前，我们先有这样一个概念：那就是在我们前面所说的优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环。\n\n那么该如何从两边向中间循环呢？请看下图：\n![](~@/virtualDOM/15.png)\n\n首先，我们先准备4个变量：\n\n- **newStartIdx:**`newChildren`数组里开始位置的下标；\n- **newEndIdx:**`newChildren`数组里结束位置的下标；\n- **oldStartIdx:**`oldChildren`数组里开始位置的下标；\n- **oldEndIdx:**`oldChildren`数组里结束位置的下标；\n\n在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：`newStartIdx`和`oldStartIdx`只能往后移动（只会加），`newEndIdx`和`oldEndIdx`只能往前移动（只会减）。\n\n当开始位置大于结束位置时，表示所有节点都已经遍历过了。\n\nOK，有了这个概念后，我们开始读源码：\n\n1. 如果`oldStartVnode`不存在，则直接跳过，将`oldStartIdx`加1，比对下一个\n\n   ```javascript\n   // 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点\n   while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n   \tif (isUndef(oldStartVnode)) {\n           oldStartVnode = oldCh[++oldStartIdx] \n         }\n   }\n   ```\n\n2. 如果`oldEndVnode`不存在，则直接跳过，将`oldEndIdx`减1，比对前一个\n\n   ```javascript\n   else if (isUndef(oldEndVnode)) {\n       oldEndVnode = oldCh[--oldEndIdx]\n   } \n   ```\n\n3. 如果新前与旧前节点相同，就把两个节点进行`patch`更新，同时`oldStartIdx`和`newStartIdx`都加1，后移一个位置\n\n   ```javascript\n   else if (sameVnode(oldStartVnode, newStartVnode)) {\n       patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n       oldStartVnode = oldCh[++oldStartIdx]\n       newStartVnode = newCh[++newStartIdx]\n   }\n   ```\n\n4. 如果新后与旧后节点相同，就把两个节点进行`patch`更新，同时`oldEndIdx`和`newEndIdx`都减1，前移一个位置\n\n   ```javascript\n   else if (sameVnode(oldEndVnode, newEndVnode)) {\n       patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n       oldEndVnode = oldCh[--oldEndIdx]\n       newEndVnode = newCh[--newEndIdx]\n   } \n   ```\n\n5. 如果新后与旧前节点相同，先把两个节点进行`patch`更新，然后把旧前节点移动到`oldChilren`中所有未处理节点之后，最后把`oldStartIdx`加1，后移一个位置，`newEndIdx`减1，前移一个位置\n\n   ```javascript\n   else if (sameVnode(oldStartVnode, newEndVnode)) { \n       patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n       canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n       oldStartVnode = oldCh[++oldStartIdx]\n       newEndVnode = newCh[--newEndIdx]\n   } \n   ```\n\n6. 如果新前与旧后节点相同，先把两个节点进行`patch`更新，然后把旧后节点移动到`oldChilren`中所有未处理节点之前，最后把`newStartIdx`加1，后移一个位置，`oldEndIdx`减1，前移一个位置\n\n   ```javascript\n   else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n       patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n       canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n       oldEndVnode = oldCh[--oldEndIdx]\n       newStartVnode = newCh[++newStartIdx]\n   } \n   ```\n\n7. 如果不属于以上四种情况，就进行常规的循环比对`patch`\n\n8. 如果在循环中，`oldStartIdx`大于`oldEndIdx`了，那就表示`oldChildren`比`newChildren`先循环完毕，那么`newChildren`里面剩余的节点都是需要新增的节点，把`[newStartIdx, newEndIdx]`之间的所有节点都插入到`DOM`中\n\n   ```javascript\n   if (oldStartIdx > oldEndIdx) {\n       refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n       addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n   } \n   ```\n\n9. 如果在循环中，`newStartIdx`大于`newEndIdx`了，那就表示`newChildren`比`oldChildren`先循环完毕，那么`oldChildren`里面剩余的节点都是需要删除的节点，把`[oldStartIdx, oldEndIdx]`之间的所有节点都删除\n\n   ```javascript\n   else if (newStartIdx > newEndIdx) {\n       removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n   }\n   ```\n\n   \n\nOK,处理完毕，可见源码中的处理逻辑跟我们之前分析的逻辑是一样的。\n\n## 8. 总结\n\n本篇文章中，我们介绍了`Vue`中子节点更新的优化策略，发现`Vue`为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。对于每一种情况我们都通过图文的形式对其逻辑进行了分析。最后我们回到源码，通过阅读源码来验证我们分析的是否正确。幸运的是我们之前每一步的分析都在源码中找到了相应的实现，得以验证我们的分析没有错。以上就是`Vue`中的`patch`过程，即`DOM-Diff`算法所有内容了，到这里相信你再读这部分源码的时候就有比较清晰的思路了。\n\n\n","slug":"Vue 源码阅读 虚拟DOM （四）","published":1,"updated":"2019-12-31T03:27:19.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj91008mzws6a23dhuue","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>在上一篇文章中，我们介绍了当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，<code>Vue</code>对子节点是</p>\n<p>先外层循环<code>newChildren</code>数组，再内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，最后根据不同的情况作出不同的操作。</p>\n<p>在上一篇文章的结尾我们也说了，这种方法虽然能够解决问题，但是还存在可优化的地方。比如当包含的子节点数量很多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。当然，<code>Vue</code>也意识到了这点，并对此也进行了优化，那么本篇文章，就来学习一下关于子节点更新的优化问题<code>Vue</code>是如何做的。</p>\n<h2><span id=\"2-优化策略介绍\">2. 优化策略介绍</span></h2>\n<p>假如我们现有一份新的<code>newChildren</code>数组和旧的<code>oldChildren</code>数组，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newChildren = [<span class=\"string\">'新子节点1'</span>,<span class=\"string\">'新子节点2'</span>,<span class=\"string\">'新子节点3'</span>,<span class=\"string\">'新子节点4'</span>]</span><br><span class=\"line\">oldChildren = [<span class=\"string\">'旧子节点1'</span>,<span class=\"string\">'旧子节点2'</span>,<span class=\"string\">'旧子节点3'</span>,<span class=\"string\">'旧子节点4'</span>]</span><br></pre></td></tr></table></figure>\n<p>如果按照优化之前的解决方案，那么我们接下来的操作应该是这样的：先循环<code>newChildren</code>数组，拿到第一个新子节点1，然后用第一个新子节点1去跟<code>oldChildren</code>数组里的旧子节点逐一对比，如果运气好一点，刚好<code>oldChildren</code>数组里的第一个旧子节点1与第一个新子节点1相同，那就皆大欢喜，直接处理，不用再往下循环了。那如果运气坏一点，直到循环到<code>oldChildren</code>数组里的第四个旧子节点4才与第一个新子节点1相同，那此时就会多循环了4次。我们不妨把情况再设想的极端一点，如果<code>newChildren</code>数组和<code>oldChildren</code>数组里前三个节点都没有变化，只是第四个节点发生了变化，那么我们就会循环16次，只有在第16次循环的时候才发现新节点4与旧节点4相同，进行更新，如下图所示：<br>\n<img src=\"/img/virtualDOM/7.jpg\" alt></p>\n<p>上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。</p>\n<p>那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环<code>newChildren</code>和<code>oldChildren</code>这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：</p>\n<ul>\n<li>先把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>\n<li>最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。</li>\n</ul>\n<p>其过程如下图所示：<br>\n<img src=\"/img/virtualDOM/8.png\" alt></p>\n<p>在上图中，我们把：</p>\n<ul>\n<li><code>newChildren</code>数组里的所有未处理子节点的第一个子节点称为：新前；</li>\n<li><code>newChildren</code>数组里的所有未处理子节点的最后一个子节点称为：新后；</li>\n<li><code>oldChildren</code>数组里的所有未处理子节点的第一个子节点称为：旧前；</li>\n<li><code>oldChildren</code>数组里的所有未处理子节点的最后一个子节点称为：旧后；</li>\n</ul>\n<p>OK，有了以上概念以后，下面我们就来看看其具体是如何实施的。</p>\n<h2><span id=\"3-新前与旧前\">3. 新前与旧前</span></h2>\n<p>把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那好极了，直接进入之前文章中说的更新节点的操作并且由于新前与旧前两个节点的位置也相同，无需进行节点移动操作；如果不同，没关系，再尝试后面三种情况。<br>\n<img src=\"/img/virtualDOM/9.png\" alt></p>\n<h2><span id=\"4-新后与旧后\">4. 新后与旧后</span></h2>\n<p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。<br>\n<img src=\"/img/virtualDOM/10.png\" alt></p>\n<h2><span id=\"5-新后与旧前\">5. 新后与旧前</span></h2>\n<p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；<br>\n<img src=\"/img/virtualDOM/11.png\" alt></p>\n<p>此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，<strong>更新节点要以新<code>VNode</code>为基准，然后操作旧的<code>oldVNode</code>，使之最后旧的<code>oldVNode</code>与新的<code>VNode</code>相同</strong>。那么现在的情况是：<code>newChildren</code>数组里的最后一个子节点与<code>oldChildren</code>数组里的第一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把第一个子节点移动到最后一个子节点的位置，如下图：</p>\n<p><img src=\"/img/virtualDOM/12.png\" alt></p>\n<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把第一个子节点移动到数组中<strong>所有未处理节点之后</strong>。</p>\n<p>如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。</p>\n<h2><span id=\"6-新前与旧后\">6. 新前与旧后</span></h2>\n<p>把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>\n<p><img src=\"/img/virtualDOM/13.png\" alt></p>\n<p>同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是<code>newChildren</code>数组里的第一个子节点与<code>oldChildren</code>数组里的最后一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把最后一个子节点移动到第一个子节点的位置，如下图：</p>\n<p><img src=\"/img/virtualDOM/14.png\" alt></p>\n<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把最后一个子节点移动到数组中<strong>所有未处理节点之前</strong>。</p>\n<p>OK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。</p>\n<h2><span id=\"7-回到源码\">7. 回到源码</span></h2>\n<p>思路分析完，逻辑理清之后，我们再回到源码里看看，验证一下源码实现的逻辑是否跟我们分析的一样。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 循环更新子节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildren</span> (<span class=\"params\">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldStartIdx = <span class=\"number\">0</span>               <span class=\"comment\">// oldChildren开始索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldEndIdx = oldCh.length - <span class=\"number\">1</span>   <span class=\"comment\">// oldChildren结束索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldStartVnode = oldCh[<span class=\"number\">0</span>]        <span class=\"comment\">// oldChildren中所有未处理节点中的第一个</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldEndVnode = oldCh[oldEndIdx]   <span class=\"comment\">// oldChildren中所有未处理节点中的最后一个</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> newStartIdx = <span class=\"number\">0</span>               <span class=\"comment\">// newChildren开始索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newEndIdx = newCh.length - <span class=\"number\">1</span>   <span class=\"comment\">// newChildren结束索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newStartVnode = newCh[<span class=\"number\">0</span>]        <span class=\"comment\">// newChildren中所有未处理节点中的第一个</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newEndVnode = newCh[newEndIdx]  <span class=\"comment\">// newChildren中所有未处理节点中的最后一个</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// to ensure removed elements stay in correct relative positions</span></span><br><span class=\"line\">    <span class=\"comment\">// during leaving transitions</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      checkDuplicateKeys(newCh)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] <span class=\"comment\">// 如果oldStartVnode不存在，则直接跳过，比对下一个</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果新前与旧前节点相同，就把两个节点进行patch更新</span></span><br><span class=\"line\">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果新后与旧后节点相同，就把两个节点进行patch更新</span></span><br><span class=\"line\">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class=\"comment\">// Vnode moved right</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后</span></span><br><span class=\"line\">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前</span></span><br><span class=\"line\">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不属于以上四种情况，就进行常规的循环比对patch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        <span class=\"comment\">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; <span class=\"comment\">// New element</span></span><br><span class=\"line\">          <span class=\"comment\">// 新增节点并插入到合适位置</span></span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span></span><br><span class=\"line\">          vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">          <span class=\"comment\">// 如果两个节点相同</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用patchVnode更新节点</span></span><br><span class=\"line\">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">            oldCh[idxInOld] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">            <span class=\"comment\">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span></span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// same key but different element. treat as new element</span></span><br><span class=\"line\">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 如果oldChildren比newChildren先循环完毕，</span></span><br><span class=\"line\"><span class=\"comment\">       * 那么newChildren里面剩余的节点都是需要新增的节点，</span></span><br><span class=\"line\"><span class=\"comment\">       * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm</span><br><span class=\"line\">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 如果newChildren比oldChildren先循环完毕，</span></span><br><span class=\"line\"><span class=\"comment\">       * 那么oldChildren里面剩余的节点都是需要删除的节点，</span></span><br><span class=\"line\"><span class=\"comment\">       * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>读源码之前，我们先有这样一个概念：那就是在我们前面所说的优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环。</p>\n<p>那么该如何从两边向中间循环呢？请看下图：<br>\n<img src=\"~@/virtualDOM/15.png\" alt></p>\n<p>首先，我们先准备4个变量：</p>\n<ul>\n<li><strong>newStartIdx:</strong><code>newChildren</code>数组里开始位置的下标；</li>\n<li><strong>newEndIdx:</strong><code>newChildren</code>数组里结束位置的下标；</li>\n<li><strong>oldStartIdx:</strong><code>oldChildren</code>数组里开始位置的下标；</li>\n<li><strong>oldEndIdx:</strong><code>oldChildren</code>数组里结束位置的下标；</li>\n</ul>\n<p>在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：<code>newStartIdx</code>和<code>oldStartIdx</code>只能往后移动（只会加），<code>newEndIdx</code>和<code>oldEndIdx</code>只能往前移动（只会减）。</p>\n<p>当开始位置大于结束位置时，表示所有节点都已经遍历过了。</p>\n<p>OK，有了这个概念后，我们开始读源码：</p>\n<ol>\n<li>\n<p>如果<code>oldStartVnode</code>不存在，则直接跳过，将<code>oldStartIdx</code>加1，比对下一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果<code>oldEndVnode</code>不存在，则直接跳过，将<code>oldEndIdx</code>减1，比对前一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新前与旧前节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldStartIdx</code>和<code>newStartIdx</code>都加1，后移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">    newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新后与旧后节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldEndIdx</code>和<code>newEndIdx</code>都减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">    newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新后与旧前节点相同，先把两个节点进行<code>patch</code>更新，然后把旧前节点移动到<code>oldChilren</code>中所有未处理节点之后，最后把<code>oldStartIdx</code>加1，后移一个位置，<code>newEndIdx</code>减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; </span><br><span class=\"line\">    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">    newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新前与旧后节点相同，先把两个节点进行<code>patch</code>更新，然后把旧后节点移动到<code>oldChilren</code>中所有未处理节点之前，最后把<code>newStartIdx</code>加1，后移一个位置，<code>oldEndIdx</code>减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">    newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果不属于以上四种情况，就进行常规的循环比对<code>patch</code></p>\n</li>\n<li>\n<p>如果在循环中，<code>oldStartIdx</code>大于<code>oldEndIdx</code>了，那就表示<code>oldChildren</code>比<code>newChildren</code>先循环完毕，那么<code>newChildren</code>里面剩余的节点都是需要新增的节点，把<code>[newStartIdx, newEndIdx]</code>之间的所有节点都插入到<code>DOM</code>中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">    refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm</span><br><span class=\"line\">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果在循环中，<code>newStartIdx</code>大于<code>newEndIdx</code>了，那就表示<code>newChildren</code>比<code>oldChildren</code>先循环完毕，那么<code>oldChildren</code>里面剩余的节点都是需要删除的节点，把<code>[oldStartIdx, oldEndIdx]</code>之间的所有节点都删除</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>OK,处理完毕，可见源码中的处理逻辑跟我们之前分析的逻辑是一样的。</p>\n<h2><span id=\"8-总结\">8. 总结</span></h2>\n<p>本篇文章中，我们介绍了<code>Vue</code>中子节点更新的优化策略，发现<code>Vue</code>为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。对于每一种情况我们都通过图文的形式对其逻辑进行了分析。最后我们回到源码，通过阅读源码来验证我们分析的是否正确。幸运的是我们之前每一步的分析都在源码中找到了相应的实现，得以验证我们的分析没有错。以上就是<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法所有内容了，到这里相信你再读这部分源码的时候就有比较清晰的思路了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>在上一篇文章中，我们介绍了当新的<code>VNode</code>与旧的<code>oldVNode</code>都是元素节点并且都包含子节点时，<code>Vue</code>对子节点是</p>\n<p>先外层循环<code>newChildren</code>数组，再内层循环<code>oldChildren</code>数组，每循环外层<code>newChildren</code>数组里的一个子节点，就去内层<code>oldChildren</code>数组里找看有没有与之相同的子节点，最后根据不同的情况作出不同的操作。</p>\n<p>在上一篇文章的结尾我们也说了，这种方法虽然能够解决问题，但是还存在可优化的地方。比如当包含的子节点数量很多时，这样循环算法的时间复杂度就会变的很大，不利于性能提升。当然，<code>Vue</code>也意识到了这点，并对此也进行了优化，那么本篇文章，就来学习一下关于子节点更新的优化问题<code>Vue</code>是如何做的。</p>\n<h2>2. 优化策略介绍</h2>\n<p>假如我们现有一份新的<code>newChildren</code>数组和旧的<code>oldChildren</code>数组，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newChildren = [<span class=\"string\">'新子节点1'</span>,<span class=\"string\">'新子节点2'</span>,<span class=\"string\">'新子节点3'</span>,<span class=\"string\">'新子节点4'</span>]</span><br><span class=\"line\">oldChildren = [<span class=\"string\">'旧子节点1'</span>,<span class=\"string\">'旧子节点2'</span>,<span class=\"string\">'旧子节点3'</span>,<span class=\"string\">'旧子节点4'</span>]</span><br></pre></td></tr></table></figure>\n<p>如果按照优化之前的解决方案，那么我们接下来的操作应该是这样的：先循环<code>newChildren</code>数组，拿到第一个新子节点1，然后用第一个新子节点1去跟<code>oldChildren</code>数组里的旧子节点逐一对比，如果运气好一点，刚好<code>oldChildren</code>数组里的第一个旧子节点1与第一个新子节点1相同，那就皆大欢喜，直接处理，不用再往下循环了。那如果运气坏一点，直到循环到<code>oldChildren</code>数组里的第四个旧子节点4才与第一个新子节点1相同，那此时就会多循环了4次。我们不妨把情况再设想的极端一点，如果<code>newChildren</code>数组和<code>oldChildren</code>数组里前三个节点都没有变化，只是第四个节点发生了变化，那么我们就会循环16次，只有在第16次循环的时候才发现新节点4与旧节点4相同，进行更新，如下图所示：<br>\n<img src=\"/img/virtualDOM/7.jpg\" alt></p>\n<p>上面例子中只有四个子节点，好像还看不出来有什么缺陷，但是当子节点数量很多的时候，算法的时间复杂度就会非常高，很不利于性能提升。</p>\n<p>那么我们该怎么优化呢？其实我们可以这样想，我们不要按顺序去循环<code>newChildren</code>和<code>oldChildren</code>这两个数组，可以先比较这两个数组里特殊位置的子节点，比如：</p>\n<ul>\n<li>先把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>\n<li>如果不同，再把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</li>\n<li>最后四种情况都试完如果还不同，那就按照之前循环的方式来查找节点。</li>\n</ul>\n<p>其过程如下图所示：<br>\n<img src=\"/img/virtualDOM/8.png\" alt></p>\n<p>在上图中，我们把：</p>\n<ul>\n<li><code>newChildren</code>数组里的所有未处理子节点的第一个子节点称为：新前；</li>\n<li><code>newChildren</code>数组里的所有未处理子节点的最后一个子节点称为：新后；</li>\n<li><code>oldChildren</code>数组里的所有未处理子节点的第一个子节点称为：旧前；</li>\n<li><code>oldChildren</code>数组里的所有未处理子节点的最后一个子节点称为：旧后；</li>\n</ul>\n<p>OK，有了以上概念以后，下面我们就来看看其具体是如何实施的。</p>\n<h2>3. 新前与旧前</h2>\n<p>把<code>newChildren</code>数组里的所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那好极了，直接进入之前文章中说的更新节点的操作并且由于新前与旧前两个节点的位置也相同，无需进行节点移动操作；如果不同，没关系，再尝试后面三种情况。<br>\n<img src=\"/img/virtualDOM/9.png\" alt></p>\n<h2>4. 新后与旧后</h2>\n<p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。<br>\n<img src=\"/img/virtualDOM/10.png\" alt></p>\n<h2>5. 新后与旧前</h2>\n<p>把<code>newChildren</code>数组里所有未处理子节点的最后一个子节点和<code>oldChildren</code>数组里所有未处理子节点的第一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；<br>\n<img src=\"/img/virtualDOM/11.png\" alt></p>\n<p>此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，<strong>更新节点要以新<code>VNode</code>为基准，然后操作旧的<code>oldVNode</code>，使之最后旧的<code>oldVNode</code>与新的<code>VNode</code>相同</strong>。那么现在的情况是：<code>newChildren</code>数组里的最后一个子节点与<code>oldChildren</code>数组里的第一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把第一个子节点移动到最后一个子节点的位置，如下图：</p>\n<p><img src=\"/img/virtualDOM/12.png\" alt></p>\n<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把第一个子节点移动到数组中<strong>所有未处理节点之后</strong>。</p>\n<p>如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。</p>\n<h2>6. 新前与旧后</h2>\n<p>把<code>newChildren</code>数组里所有未处理子节点的第一个子节点和<code>oldChildren</code>数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将<code>oldChildren</code>数组里的该节点移动到与<code>newChildren</code>数组里节点相同的位置；</p>\n<p><img src=\"/img/virtualDOM/13.png\" alt></p>\n<p>同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是<code>newChildren</code>数组里的第一个子节点与<code>oldChildren</code>数组里的最后一个子节点相同，那么我们就应该在<code>oldChildren</code>数组里把最后一个子节点移动到第一个子节点的位置，如下图：</p>\n<p><img src=\"/img/virtualDOM/14.png\" alt></p>\n<p>从图中不难看出，我们要把<code>oldChildren</code>数组里把最后一个子节点移动到数组中<strong>所有未处理节点之前</strong>。</p>\n<p>OK，以上就是子节点对比更新优化策略种的4种情况，如果以上4种情况逐个试遍之后要是还没找到相同的节点，那就再通过之前的循环方式查找。</p>\n<h2>7. 回到源码</h2>\n<p>思路分析完，逻辑理清之后，我们再回到源码里看看，验证一下源码实现的逻辑是否跟我们分析的一样。源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 循环更新子节点</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateChildren</span> (<span class=\"params\">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldStartIdx = <span class=\"number\">0</span>               <span class=\"comment\">// oldChildren开始索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldEndIdx = oldCh.length - <span class=\"number\">1</span>   <span class=\"comment\">// oldChildren结束索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldStartVnode = oldCh[<span class=\"number\">0</span>]        <span class=\"comment\">// oldChildren中所有未处理节点中的第一个</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldEndVnode = oldCh[oldEndIdx]   <span class=\"comment\">// oldChildren中所有未处理节点中的最后一个</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> newStartIdx = <span class=\"number\">0</span>               <span class=\"comment\">// newChildren开始索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newEndIdx = newCh.length - <span class=\"number\">1</span>   <span class=\"comment\">// newChildren结束索引</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newStartVnode = newCh[<span class=\"number\">0</span>]        <span class=\"comment\">// newChildren中所有未处理节点中的第一个</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newEndVnode = newCh[newEndIdx]  <span class=\"comment\">// newChildren中所有未处理节点中的最后一个</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">// to ensure removed elements stay in correct relative positions</span></span><br><span class=\"line\">    <span class=\"comment\">// during leaving transitions</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> canMove = !removeOnly</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      checkDuplicateKeys(newCh)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] <span class=\"comment\">// 如果oldStartVnode不存在，则直接跳过，比对下一个</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果新前与旧前节点相同，就把两个节点进行patch更新</span></span><br><span class=\"line\">        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果新后与旧后节点相同，就把两个节点进行patch更新</span></span><br><span class=\"line\">        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class=\"comment\">// Vnode moved right</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果新后与旧前节点相同，先把两个节点进行patch更新，然后把旧前节点移动到oldChilren中所有未处理节点之后</span></span><br><span class=\"line\">        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">        newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果新前与旧后节点相同，先把两个节点进行patch更新，然后把旧后节点移动到oldChilren中所有未处理节点之前</span></span><br><span class=\"line\">        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">        oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果不属于以上四种情况，就进行常规的循环比对patch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        idxInOld = isDef(newStartVnode.key)</span><br><span class=\"line\">          ? oldKeyToIdx[newStartVnode.key]</span><br><span class=\"line\">          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">        <span class=\"comment\">// 如果在oldChildren里找不到当前循环的newChildren里的子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isUndef(idxInOld)) &#123; <span class=\"comment\">// New element</span></span><br><span class=\"line\">          <span class=\"comment\">// 新增节点并插入到合适位置</span></span><br><span class=\"line\">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 如果在oldChildren里找到了当前循环的newChildren里的子节点</span></span><br><span class=\"line\">          vnodeToMove = oldCh[idxInOld]</span><br><span class=\"line\">          <span class=\"comment\">// 如果两个节点相同</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用patchVnode更新节点</span></span><br><span class=\"line\">            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">            oldCh[idxInOld] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">            <span class=\"comment\">// canmove表示是否需要移动节点，如果为true表示需要移动，则移动节点，如果为false则不用移动</span></span><br><span class=\"line\">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// same key but different element. treat as new element</span></span><br><span class=\"line\">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class=\"literal\">false</span>, newCh, newStartIdx)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 如果oldChildren比newChildren先循环完毕，</span></span><br><span class=\"line\"><span class=\"comment\">       * 那么newChildren里面剩余的节点都是需要新增的节点，</span></span><br><span class=\"line\"><span class=\"comment\">       * 把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm</span><br><span class=\"line\">      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 如果newChildren比oldChildren先循环完毕，</span></span><br><span class=\"line\"><span class=\"comment\">       * 那么oldChildren里面剩余的节点都是需要删除的节点，</span></span><br><span class=\"line\"><span class=\"comment\">       * 把[oldStartIdx, oldEndIdx]之间的所有节点都删除</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>读源码之前，我们先有这样一个概念：那就是在我们前面所说的优化策略中，节点有可能是从前面对比，也有可能是从后面对比，对比成功就会进行更新处理，也就是说我们有可能处理第一个，也有可能处理最后一个，那么我们在循环的时候就不能简单从前往后或从后往前循环，而是要从两边向中间循环。</p>\n<p>那么该如何从两边向中间循环呢？请看下图：<br>\n<img src=\"~@/virtualDOM/15.png\" alt></p>\n<p>首先，我们先准备4个变量：</p>\n<ul>\n<li><strong>newStartIdx:</strong><code>newChildren</code>数组里开始位置的下标；</li>\n<li><strong>newEndIdx:</strong><code>newChildren</code>数组里结束位置的下标；</li>\n<li><strong>oldStartIdx:</strong><code>oldChildren</code>数组里开始位置的下标；</li>\n<li><strong>oldEndIdx:</strong><code>oldChildren</code>数组里结束位置的下标；</li>\n</ul>\n<p>在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：<code>newStartIdx</code>和<code>oldStartIdx</code>只能往后移动（只会加），<code>newEndIdx</code>和<code>oldEndIdx</code>只能往前移动（只会减）。</p>\n<p>当开始位置大于结束位置时，表示所有节点都已经遍历过了。</p>\n<p>OK，有了这个概念后，我们开始读源码：</p>\n<ol>\n<li>\n<p>如果<code>oldStartVnode</code>不存在，则直接跳过，将<code>oldStartIdx</code>加1，比对下一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以\"新前\"、\"新后\"、\"旧前\"、\"旧后\"的方式开始比对节点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class=\"line\">        oldStartVnode = oldCh[++oldStartIdx] </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果<code>oldEndVnode</code>不存在，则直接跳过，将<code>oldEndIdx</code>减1，比对前一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class=\"line\">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新前与旧前节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldStartIdx</code>和<code>newStartIdx</code>都加1，后移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class=\"line\">    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">    newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新后与旧后节点相同，就把两个节点进行<code>patch</code>更新，同时<code>oldEndIdx</code>和<code>newEndIdx</code>都减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class=\"line\">    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">    newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新后与旧前节点相同，先把两个节点进行<code>patch</code>更新，然后把旧前节点移动到<code>oldChilren</code>中所有未处理节点之后，最后把<code>oldStartIdx</code>加1，后移一个位置，<code>newEndIdx</code>减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; </span><br><span class=\"line\">    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class=\"line\">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class=\"line\">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class=\"line\">    newEndVnode = newCh[--newEndIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果新前与旧后节点相同，先把两个节点进行<code>patch</code>更新，然后把旧后节点移动到<code>oldChilren</code>中所有未处理节点之前，最后把<code>newStartIdx</code>加1，后移一个位置，<code>oldEndIdx</code>减1，前移一个位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class=\"comment\">// Vnode moved left</span></span><br><span class=\"line\">    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class=\"line\">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class=\"line\">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class=\"line\">    newStartVnode = newCh[++newStartIdx]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果不属于以上四种情况，就进行常规的循环比对<code>patch</code></p>\n</li>\n<li>\n<p>如果在循环中，<code>oldStartIdx</code>大于<code>oldEndIdx</code>了，那就表示<code>oldChildren</code>比<code>newChildren</code>先循环完毕，那么<code>newChildren</code>里面剩余的节点都是需要新增的节点，把<code>[newStartIdx, newEndIdx]</code>之间的所有节点都插入到<code>DOM</code>中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class=\"line\">    refElm = isUndef(newCh[newEndIdx + <span class=\"number\">1</span>]) ? <span class=\"literal\">null</span> : newCh[newEndIdx + <span class=\"number\">1</span>].elm</span><br><span class=\"line\">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果在循环中，<code>newStartIdx</code>大于<code>newEndIdx</code>了，那就表示<code>newChildren</code>比<code>oldChildren</code>先循环完毕，那么<code>oldChildren</code>里面剩余的节点都是需要删除的节点，把<code>[oldStartIdx, oldEndIdx]</code>之间的所有节点都删除</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class=\"line\">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>OK,处理完毕，可见源码中的处理逻辑跟我们之前分析的逻辑是一样的。</p>\n<h2>8. 总结</h2>\n<p>本篇文章中，我们介绍了<code>Vue</code>中子节点更新的优化策略，发现<code>Vue</code>为了避免双重循环数据量大时间复杂度升高带来的性能问题，而选择了从子节点数组中的4个特殊位置互相比对，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。对于每一种情况我们都通过图文的形式对其逻辑进行了分析。最后我们回到源码，通过阅读源码来验证我们分析的是否正确。幸运的是我们之前每一步的分析都在源码中找到了相应的实现，得以验证我们的分析没有错。以上就是<code>Vue</code>中的<code>patch</code>过程，即<code>DOM-Diff</code>算法所有内容了，到这里相信你再读这部分源码的时候就有比较清晰的思路了。</p>\n"},{"title":"Vue 源码阅读 模板编译（三）","catalog":true,"date":"2019-10-19T13:39:42.000Z","subtitle":null,"header-img":"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg","_content":"\n\n## 1. 前言\n\n上篇文章中我们说到，在模板解析阶段主线函数`parse`中，根据要解析的内容不同会调用不同的解析器，\n\n而在三个不同的解析器中最主要的当属`HTML`解析器，为什么这么说呢？因为`HTML`解析器主要负责解析出模板字符串中有哪些内容，然后根据不同的内容才能调用其他的解析器以及做相应的处理。那么本篇文章就来介绍一下`HTML`解析器是如何解析出模板字符串中包含的不同的内容的。\n\n## 2. HTML解析器内部运行流程\n\n在源码中，`HTML`解析器就是`parseHTML`函数，在模板解析主线函数`parse`中调用了该函数，并传入两个参数，代码如下：\n\n```javascript\n// 代码位置：/src/complier/parser/index.js\n\n/**\n * Convert HTML string to AST.\n * 将HTML模板字符串转化为AST\n */\nexport function parse(template, options) {\n   // ...\n  parseHTML(template, {\n    warn,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    // 当解析到开始标签时，调用该函数  \n    start (tag, attrs, unary) {\n\n    },\n    // 当解析到结束标签时，调用该函数\n    end () {\n\n    },\n    // 当解析到文本时，调用该函数  \n    chars (text) {\n\n    },\n    // 当解析到注释时，调用该函数  \n    comment (text) {\n\n    }\n  })\n  return root\n}\n```\n\n从代码中我们可以看到，调用`parseHTML`函数时为其传入的两个参数分别是：\n\n- template:待转换的模板字符串；\n- options:转换时所需的选项；\n\n第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析`HTML`模板时的一些参数，同时还定义了4个钩子函数。这4个钩子函数有什么作用呢？我们说了模板编译阶段主线函数`parse`会将`HTML`模板字符串转化成`AST`，而`parseHTML`是用来解析模板字符串的，把模板字符串中不同的内容出来之后，那么谁来把提取出来的内容生成对应的`AST`呢？答案就是这4个钩子函数。\n\n把这4个钩子函数作为参数传给解析器`parseHTML`，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的`AST`。\n\n- 当解析到开始标签时调用`start`函数生成元素类型的`AST`节点，代码如下；\n\n  ```javascript\n  // 当解析到标签的开始位置时，触发start\n  start (tag, attrs, unary) {\n  \tlet element = createASTElement(tag, attrs, currentParent)\n  }\n  \n  export function createASTElement (tag,attrs,parent) {\n    return {\n      type: 1,\n      tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      parent,\n      children: []\n    }\n  }\n  ```\n\n  从上面代码中我们可以看到，`start`函数接收三个参数，分别是标签名`tag`、标签属性`attrs`、标签是否自闭合`unary`。当调用该钩子函数时，内部会调用`createASTElement`函数来创建元素类型的`AST`节点\n\n- 当解析到结束标签时调用`end`函数；\n\n- 当解析到文本时调用`chars`函数生成文本类型的`AST`节点；\n\n  ```javascript\n  // 当解析到标签的文本时，触发chars\n  chars (text) {\n  \tif(text是带变量的动态文本){\n         let element = {\n             type: 2,\n             expression: res.expression,\n             tokens: res.tokens,\n             text\n         }\n      } else {\n         let element = {\n             type: 3,\n             text\n         } \n      }\n  }\n  ```\n\n  当解析到标签的文本时，触发`chars`钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello {{name}}”。如果是动态文本，则创建动态文本类型的`AST`节点；如果不是动态文本，则创建纯静态文本类型的`AST`节点。\n\n- 当解析到注释时调用`comment`函数生成注释类型的`AST`节点；\n\n  ```javascript\n  // 当解析到标签的注释时，触发comment\n  comment (text: string) {\n      let element = {\n          type: 3,\n          text,\n          isComment: true\n      }\n  }\n  ```\n\n  当解析到标签的注释时，触发`comment`钩子函数，该钩子函数会创建一个注释类型的`AST`节点。\n\n一边解析不同的内容一边调用对应的钩子函数生成对应的`AST`节点，最终完成将整个模板字符串转化成`AST`,这就是`HTML`解析器所要做的工作。\n\n## 3. 如何解析不同的内容\n\n要从模板字符串中解析出不同的内容，那首先要知道模板字符串中都会包含哪些内容。那么通常我们所写的模板字符串中都会包含哪些内容呢？经过整理，通常模板内会包含如下内容：\n\n- 文本，例如“难凉热血”\n- HTML注释，例如\\<!-- 我是注释 -->\n- 条件注释，例如\\<!-- [if !IE]> -->我是注释\\<!--< ![endif]  -->\n- DOCTYPE，例如\\<!DOCTYPE html>\n- 开始标签，例如\\<div>\n- 结束标签，例如\\</div>\n\n这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。\n\n下面，我们就来分别看一下`HTML`解析器是如何从模板字符串中将以上不同种类的内容进行解析出来。\n\n### 3.1 解析HTML注释\n\n解析注释比较简单，我们知道`HTML`注释是以`<!--`开头，以`-->`结尾，这两者中间的内容就是注释内容，那么我们只需用正则判断待解析的模板字符串`html`是否以`<!--`开头，若是，那就继续向后寻找`-->`，如果找到了，OK，注释就被解析出来了。代码如下：\n\n```javascript\nconst comment = /^<!\\--/\nif (comment.test(html)) {\n    // 若为注释，则继续查找是否存在'-->'\n    const commentEnd = html.indexOf('-->')\n\n    if (commentEnd >= 0) {\n        // 若存在 '-->',继续判断options中是否保留注释\n        if (options.shouldKeepComment) {\n            // 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点\n            options.comment(html.substring(4, commentEnd))\n        }\n        // 若不保留注释，则将游标移动到'-->'之后，继续向后解析\n        advance(commentEnd + 3)\n        continue\n    }\n}\n```\n\n在上面代码中，如果模板字符串`html`符合注释开始的正则，那么就继续向后查找是否存在`-->`，若存在，则把`html`从第4位（\"\\<!--\"长度为4）开始截取，直到`-->`处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的`comment`函数，将真实的注释内容传进去，创建注释类型的`AST`节点。\n\n上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在`<template></template>`标签上配置`comments`选项来决定在渲染模板时是否保留注释，对应到上面代码中就是`options.shouldKeepComment`,如果用户配置了`comments`选项为`true`，则`shouldKeepComment`为`true`，则创建注释类型的`AST`节点，如不保留注释，则将游标移动到'-->'之后，继续向后解析。\n\n`advance`函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：\n\n```javascript\nfunction advance (n) {\n    index += n   // index为解析游标\n    html = html.substring(n)\n}\n```\n为了更加直观地说明 `advance` 的作用，请看下图： \n![](/img/complie/5.png)\n\n调用 `advance` 函数：\n\n```js\nadvance(3)\n```\n\n得到结果：\n![](/img/complie/6.png)\n\n从图中可以看到，解析游标`index`最开始在模板字符串的位置0处，当调用了`advance(3)`之后，解析游标到了位置3处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。\n\n### 3.2 解析条件注释\n\n解析条件注释也比较简单，其原理跟解析注释相同，都是先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的`DOM`树中，所以不需要调用钩子函数创建`AST`节点。代码如下：\n\n```javascript\n// 解析是否是条件注释\nconst conditionalComment = /^<!\\[/\nif (conditionalComment.test(html)) {\n    // 若为条件注释，则继续查找是否存在']>'\n    const conditionalEnd = html.indexOf(']>')\n\n    if (conditionalEnd >= 0) {\n        // 若存在 ']>',则从原本的html字符串中把条件注释截掉，把剩下的内容重新赋给html，继续向后匹配\n        advance(conditionalEnd + 2)\n        continue\n    }\n}\n```\n\n### 3.3 解析DOCTYPE\n\n解析`DOCTYPE`的原理同解析条件注释完全相同，此处不再赘述，代码如下：\n\n```javascript\nconst doctype = /^<!DOCTYPE [^>]+>/i\n// 解析是否是DOCTYPE\nconst doctypeMatch = html.match(doctype)\nif (doctypeMatch) {\n    advance(doctypeMatch[0].length)\n    continue\n}\n```\n\n### 3.4 解析开始标签\n\n相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是相通的，都是使用正则去匹配提取。\n\n首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下：\n\n```javascript\n/**\n * 匹配开始标签的正则\n */\nconst ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\n\nconst start = html.match(startTagOpen)\nif (start) {\n    const match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n    }\n}\n\n// 以开始标签开始的模板：\n'<div></div>'.match(startTagOpen)  => ['<div','div',index:0,input:'<div></div>']\n// 以结束标签开始的模板：\n'</div><div></div>'.match(startTagOpen) => null\n// 以文本开始的模板：\n'我是文本</p>'.match(startTagOpen) => null\n```\n\n在上面代码中，我们用不同类型的内容去匹配开始标签的正则，发现只有`<div></div>`的字符串可以正确匹配，并且返回一个数组。\n\n在前文中我们说到，当解析到开始标签时，会调用4个钩子函数中的`start`函数，而`start`函数需要传递3个参数，分别是标签名`tag`、标签属性`attrs`、标签是否自闭合`unary`。标签名通过正则匹配的结果就可以拿到，即上面代码中的`start[1]`，而标签属性`attrs`以及标签是否自闭合`unary`需要进一步解析。\n\n1. 解析标签属性\n\n   我们知道，标签属性一般是写在开始标签的标签名之后的，如下：\n\n   ```html\n   <div class=\"a\" id=\"b\"></div>\n   ```\n\n   另外，我们在上面匹配是否是开始标签的正则中已经可以拿到开始标签的标签名，即上面代码中的`start[0]`，那么我们可以将这一部分先从模板字符串中截掉，则剩下的部分如下：\n\n   ```html\n    class=\"a\" id=\"b\"></div>\n   ```\n\n   那么我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：\n\n   ```javascript\n   const attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\n   let html = 'class=\"a\" id=\"b\"></div>'\n   let attr = html.match(attribute)\n   console.log(attr)\n   // [\"class=\"a\"\", \"class\", \"=\", \"a\", undefined, undefined, index: 0, input: \"class=\"a\" id=\"b\"></div>\", groups: undefined]\n   ```\n\n   可以看到，第一个标签属性`class=\"a\"`已经被拿到了。另外，标签属性有可能有多个也有可能没有，如果没有的话那好办，匹配标签属性的正则就会匹配失败，标签属性就为空数组；而如果标签属性有多个的话，那就需要循环匹配了，匹配出第一个标签属性后，就把该属性截掉，用剩下的字符串继续匹配，直到不再满足正则为止，代码如下：\n\n   ```javascript\n   const attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\n   const startTagClose = /^\\s*(\\/?)>/\n   const match = {\n       tagName: start[1],\n       attrs: [],\n       start: index\n   }\n   while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n       advance(attr[0].length)\n       match.attrs.push(attr)\n   }\n   ```\n\n   在上面代码的`while`循环中，如果剩下的字符串不符合开始标签的结束特征（startTagClose）并且符合标签属性的特征的话，那就说明还有未提取出的标签属性，那就进入循环，继续提取，直到把所有标签属性都提取完毕。\n\n   所谓不符合开始标签的结束特征是指当前剩下的字符串不是以开始标签结束符开头的，我们知道一个开始标签的结束符有可能是一个`>`（非自闭合标签），也有可能是`/>`（自闭合标签），如果剩下的字符串（如`></div>`）以开始标签的结束符开头，那么就表示标签属性已经被提取完毕了。\n\n   \n\n2. 解析标签是否是自闭合\n\n   在`HTML`中，有自闭合标签（如`<img src=\"\"/>`）也有非自闭合标签（如`<div></div>`），这两种类型的标签在创建`AST`节点是处理方式是有区别的，所以我们需要解析出当前标签是否是自闭合标签。\n\n   解析的方式很简单，我们知道，经过标签属性提取之后，那么剩下的字符串无非就两种，如下：\n\n   ```html\n   <!--非自闭合标签-->\n   ></div>\n   ```\n\n   或\n\n   ```html\n   <!--自闭合标签-->\n   />\n   ```\n\n   所以我们可以用剩下的字符串去匹配开始标签结束符正则，如下：\n\n   ```javascript\n   const startTagClose = /^\\s*(\\/?)>/\n   let end = html.match(startTagClose)\n   '></div>'.match(startTagClose) // [\">\", \"\", index: 0, input: \"></div>\", groups: undefined]\n   '/>'.match(startTagClose) // [\"/>\", \"/\", index: 0, input: \"/><div></div>\", groups: undefined]\n   ```\n\n   可以看到，非自闭合标签匹配结果中的`end[1]`为`\"\"`，而自闭合标签匹配结果中的`end[1]`为`\"/\"`。所以根据匹配结果的`end[1]`是否是`\"\"`我们即可判断出当前标签是否为自闭合标签，源码如下：\n\n   ```javascript\n   const startTagClose = /^\\s*(\\/?)>/\n   let end = html.match(startTagClose)\n   if (end) {\n       match.unarySlash = end[1]\n       advance(end[0].length)\n       match.end = index\n       return match\n   }\n   ```\n\n经过以上两步，开始标签就已经解析完毕了，完整源码如下：\n\n```javascript\nconst ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\nconst startTagClose = /^\\s*(\\/?)>/\n\n\nfunction parseStartTag () {\n    const start = html.match(startTagOpen)\n    // '<div></div>'.match(startTagOpen)  => ['<div','div',index:0,input:'<div></div>']\n    if (start) {\n      const match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      }\n      advance(start[0].length)\n      let end, attr\n      /**\n       * <div a=1 b=2 c=3></div>\n       * 从<div之后到开始标签的结束符号'>'之前，一直匹配属性attrs\n       * 所有属性匹配完之后，html字符串还剩下 \n       * 自闭合标签剩下：'/>'\n       * 非自闭合标签剩下：'></div>'\n       */\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length)\n        match.attrs.push(attr)\n      }\n\n      /**\n       * 这里判断了该标签是否为自闭合标签\n       * 自闭合标签如:<input type='text' />\n       * 非自闭合标签如:<div></div>\n       * '></div>'.match(startTagClose) => [\">\", \"\", index: 0, input: \"></div>\", groups: undefined]\n       * '/><div></div>'.match(startTagClose) => [\"/>\", \"/\", index: 0, input: \"/><div></div>\", groups: undefined]\n       * 因此，我们可以通过end[1]是否是\"/\"来判断该标签是否是自闭合标签\n       */\n      if (end) {\n        match.unarySlash = end[1]\n        advance(end[0].length)\n        match.end = index\n        return match\n      }\n    }\n  }\n```\n\n通过源码可以看到，调用`parseStartTag`函数，如果模板字符串符合开始标签的特征，则解析开始标签，并将解析结果返回，如果不符合开始标签的特征，则返回`undefined`。\n\n解析完毕后，就可以用解析得到的结果去调用`start`钩子函数去创建元素型的`AST`节点了。\n\n在源码中，`Vue`并没有直接去调`start`钩子函数去创建`AST`节点，而是调用了`handleStartTag`函数，在该函数内部才去调的`start`钩子函数，为什么要这样做呢？这是因为虽然经过`parseStartTag`函数已经把创建`AST`节点必要信息提取出来了，但是提取出来的标签属性数组还是需要处理一下，下面我们就来看一下`handleStartTag`函数都做了些什么事。`handleStartTag`函数源码如下：\n\n```javascript\nfunction handleStartTag (match) {\n    const tagName = match.tagName\n    const unarySlash = match.unarySlash\n\n    if (expectHTML) {\n      // ...\n    }\n\n    const unary = isUnaryTag(tagName) || !!unarySlash\n\n    const l = match.attrs.length\n    const attrs = new Array(l)\n    for (let i = 0; i < l; i++) {\n      const args = match.attrs[i]\n      const value = args[3] || args[4] || args[5] || ''\n      const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })\n      lastTag = tagName\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end)\n    }\n  }\n\n```\n\n `handleStartTag`函数用来对`parseStartTag`函数的解析结果进行进一步处理，它接收`parseStartTag`函数的返回值作为参数。\n\n`handleStartTag`函数的开始定义几个常量：\n\n```javascript\nconst tagName = match.tagName       // 开始标签的标签名\nconst unarySlash = match.unarySlash  // 是否为自闭合标签的标志，自闭合为\"\",非自闭合为\"/\"\nconst unary = isUnaryTag(tagName) || !!unarySlash  // 布尔值，标志是否为自闭合标签\nconst l = match.attrs.length    // match.attrs 数组的长度\nconst attrs = new Array(l)  // 一个与match.attrs数组长度相等的数组\n```\n\n接下来是循环处理提取出来的标签属性数组`match.attrs`，如下：\n\n```javascript\nfor (let i = 0; i < l; i++) {\n    const args = match.attrs[i]\n    const value = args[3] || args[4] || args[5] || ''\n    const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n    ? options.shouldDecodeNewlinesForHref\n    : options.shouldDecodeNewlines\n    attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n    }\n}\n```\n\n 上面代码中，首先定义了 `args `常量，它是解析出来的标签属性数组中的每一个属性对象，即`match.attrs` 数组中每个元素对象。 它长这样：\n\n```javascript\nconst args = [\"class=\"a\"\", \"class\", \"=\", \"a\", undefined, undefined, index: 0, input: \"class=\"a\" id=\"b\"></div>\", groups: undefined]\n```\n\n接着定义了`value`，用于存储标签属性的属性值，我们可以看到，在代码中尝试取`args`的`args[3]`、`args[4]`、`args[5]`，如果都取不到，则给`value`复制为空\n\n```javascript\nconst value = args[3] || args[4] || args[5] || ''\n```\n\n\n\n接着定义了`shouldDecodeNewlines`，这个常量主要是做一些兼容性处理， 如果 `shouldDecodeNewlines` 为 `true`，意味着 `Vue` 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。而`shouldDecodeNewlinesForHref`为`true` 意味着`Vue`在编译模板的时候，要对`a`标签的 `href `属性值中的换行符或制表符做兼容处理。\n\n```javascript\nconst shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n    ? options.shouldDecodeNewlinesForHref\n    : options.shouldDecodeNewlinesconst value = args[3] || args[4] || args[5] || ''\n```\n\n最后将处理好的结果存入之前定义好的与`match.attrs`数组长度相等的`attrs`数组中，如下：\n\n```javascript\nattrs[i] = {\n    name: args[1],    // 标签属性的属性名，如class\n    value: decodeAttr(value, shouldDecodeNewlines) // 标签属性的属性值，如class对应的a\n}\n```\n\n最后，如果该标签是非自闭合标签，则将标签推入栈中（关于栈这个概念后面会说到），如下：\n\n```javascript\nif (!unary) {\n    stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })\n    lastTag = tagName\n}\n```\n\n如果该标签是自闭合标签，现在就可以调用`start`钩子函数并传入处理好的参数来创建`AST`节点了，如下：\n\n```javascript\nif (options.start) {\n    options.start(tagName, attrs, unary, match.start, match.end)\n}\n```\n\n以上就是开始标签的解析以及调用`start`钩子函数创建元素型的`AST`节点的所有过程。\n\n### 3.5 解析结束标签\n\n结束标签的解析要比解析开始标签容易多了，因为它不需要解析什么属性，只需要判断剩下的模板字符串是否符合结束标签的特征，如果是，就将结束标签名提取出来，再调用4个钩子函数中的`end`函数就好了。\n\n首先判断剩余的模板字符串是否符合结束标签的特征，如下：\n\n```javascript\nconst ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)\nconst endTagMatch = html.match(endTag)\n\n'</div>'.match(endTag)  // [\"</div>\", \"div\", index: 0, input: \"</div>\", groups: undefined]\n'<div>'.match(endTag)  // null\n```\n\n上面代码中，如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到null。\n\n接着再调用`end`钩子函数，如下：\n\n```javascript\nif (endTagMatch) {\n    const curIndex = index\n    advance(endTagMatch[0].length)\n    parseEndTag(endTagMatch[1], curIndex, index)\n    continue\n}\n```\n\n在上面代码中，没有直接去调用`end`函数，而是调用了`parseEndTag`函数，关于`parseEndTag`函数内部的作用我们后面会介绍到，在这里你暂时可以理解为该函数内部就是去调用了`end`钩子函数。\n\n### 3.6 解析文本\n\n```\n终于到了解析最后一种文本类型的内容了，为什么要把解析文本类型放在最后一个介绍呢？我们仔细想一下，前面五种类型都是以`<`开头的，只有文本类型的内容不是以`<`开头的，所以我们在解析模板字符串的时候可以先判断一下字符串是不是以`<`开头的，如果是则继续判断是以上五种类型的具体哪一种，而如果不是的话，那它肯定就是文本了。\n```\n\n解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个`<`出现在什么位置，如果第一个`<`在第一个位置，那么说明模板字符串是以其它5种类型开始的；如果第一个`<`不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个`<`出现的位置就都是文本内容了；如果在整个模板字符串里没有找到`<`，那说明整个模板字符串都是文本。这就是解析思路，接下来我们对照源码来了解一下实际的解析过程，源码如下：\n\n```javascript\nlet textEnd = html.indexOf('<')\n// '<' 在第一个位置，为其余5种类型\nif (textEnd === 0) {\n    // ... \n}\n// '<' 不在第一个位置，文本开头\nif (textEnd >= 0) {\n    // 如果html字符串不是以'<'开头,说明'<'前面的都是纯文本，无需处理\n    // 那就把'<'以后的内容拿出来赋给rest\n    rest = html.slice(textEnd)\n    while (\n        !endTag.test(rest) &&\n        !startTagOpen.test(rest) &&\n        !comment.test(rest) &&\n        !conditionalComment.test(rest)\n    ) {\n        // < in plain text, be forgiving and treat it as text\n        /**\n           * 用'<'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment\n           * 如果都匹配不上，表示'<'是属于文本本身的内容\n           */\n        // 在'<'之后查找是否还有'<'\n        next = rest.indexOf('<', 1)\n        // 如果没有了，表示'<'后面也是文本\n        if (next < 0) break\n        // 如果还有，表示'<'是文本中的一个字符\n        textEnd += next\n        // 那就把next之后的内容截出来继续下一轮循环匹配\n        rest = html.slice(textEnd)\n    }\n    // '<'是结束标签的开始 ,说明从开始到'<'都是文本，截取出来\n    text = html.substring(0, textEnd)\n    advance(textEnd)\n}\n// 整个模板字符串里没有找到`<`,说明整个模板字符串都是文本\nif (textEnd < 0) {\n    text = html\n    html = ''\n}\n// 把截取出来的text转化成textAST\nif (options.chars && text) {\n    options.chars(text)\n}\n```\n\n源码的逻辑很清晰，根据`<`在不在第一个位置以及整个模板字符串里没有`<`都分别进行了处理。\n\n值得深究的是如果`<`不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个`<`出现的位置就都是文本内容了，接着我们还要从第一个`<`的位置继续向后判断，因为还存在这样一种情况，那就是如果文本里面本来就包含一个`<`，例如`1<2</div>`。为了处理这种情况，我们把从第一个`<`的位置直到模板字符串结束都截取出来记作`rest`，如下：\n\n```javascript\n let rest = html.slice(textEnd)\n```\n\n接着用`rest`去匹配以上5种类型的正则，如果都匹配不上，则表明这个`<`是属于文本本身的内容，如下：\n\n```javascript\nwhile (\n    !endTag.test(rest) &&\n    !startTagOpen.test(rest) &&\n    !comment.test(rest) &&\n    !conditionalComment.test(rest)\n) {\n    \n}\n```\n\n如果都匹配不上，则表明这个`<`是属于文本本身的内容，接着以这个`<`的位置继续向后查找，看是否还有`<`，如果没有了，则表示后面的都是文本；如果后面还有下一个`<`，那表明至少在这个`<`到下一个`<`中间的内容都是文本，至于下一个`<`以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：\n\n```javascript\nwhile (\n    !endTag.test(rest) &&\n    !startTagOpen.test(rest) &&\n    !comment.test(rest) &&\n    !conditionalComment.test(rest)\n) {\n    // < in plain text, be forgiving and treat it as text\n    /**\n    * 用'<'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment\n    * 如果都匹配不上，表示'<'是属于文本本身的内容\n    */\n    // 在'<'之后查找是否还有'<'\n    next = rest.indexOf('<', 1)\n    // 如果没有了，表示'<'后面也是文本\n    if (next < 0) break\n    // 如果还有，表示'<'是文本中的一个字符\n    textEnd += next\n    // 那就把next之后的内容截出来继续下一轮循环匹配\n    rest = html.slice(textEnd)\n}\n```\n\n最后截取文本内容`text`并调用4个钩子函数中的`chars`函数创建文本型的`AST`节点。\n\n## 4. 如何保证AST节点层级关系\n\n上一章节我们介绍了`HTML`解析器是如何解析各种不同类型的内容并且调用钩子函数创建不同类型的`AST`节点。此时你可能会有个疑问，我们上面创建的`AST`节点都是单独创建且分散的，而真正的`DOM`节点都是有层级关系的，那如何来保证`AST`节点的层级关系与真正的`DOM`节点相同呢？ \n\n关于这个问题，`Vue`也注意到了。`Vue`在`HTML`解析器的开头定义了一个栈`stack`，这个栈的作用就是用来维护`AST`节点层级的，那么它是怎么维护的呢？通过前文我们知道，`HTML`解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用`start`钩子函数，那么在`start`钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用`end`钩子函数，那么我们也可以在`end`钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。请看如下例子：\n\n加入有如下模板字符串：\n\n```html\n<div><p><span></span></p></div>\n```\n\n当解析到开始标签`<div>`时，就把`div`推入栈中，然后继续解析，当解析到`<p>`时，再把`p`推入栈中，同理，再把`span`推入栈中，当解析到结束标签`</span>`时，此时栈顶的标签刚好是`span`的开始标签，那么就用`span`的开始标签和结束标签构建`AST`节点，并且从栈中把`span`的开始标签弹出，那么此时栈中的栈顶标签`p`就是构建好的`span`的`AST`节点的父节点，如下图：\n\n![](/img/complie/7.png)\n\n\n这样我们就找到了当前被构建节点的父节点。这只是栈的一个用途，它还有另外一个用途，我们再看如下模板字符串：\n\n```html\n<div><p><span></p></div>\n```\n\n按照上面的流程解析这个模板字符串时，当解析到结束标签`</p>`时，此时栈顶的标签应该是`p`才对，而现在是`span`，那么就说明`span`标签没有被正确闭合，此时控制台就会抛出警告：‘tag  has no matching end tag.’相信这个警告你一定不会陌生。这就是栈的第二个用途： 检测模板字符串中是否有未正确闭合的标签。 \n\nOK，有了这个栈的概念之后，我们再回看上一章`HTML`解析器解析不同内容的代码。\n\n## 5. 回归源码\n\n### 5.1 HTML解析器源码\n\n以上内容都了解了之后，我们回归源码，逐句分析`HTML`解析器`parseHTML`函数，函数定义如下：\n\n```javascript\nfunction parseHTML(html, options) {\n\tvar stack = [];\n\tvar expectHTML = options.expectHTML;\n\tvar isUnaryTag$$1 = options.isUnaryTag || no;\n\tvar canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n\tvar index = 0;\n\tvar last, lastTag;\n\n\t// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕\n\twhile (html) {\n\t\tlast = html;\n\t\t// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)\n\t\tif (!lastTag || !isPlainTextElement(lastTag)) {\n\t\t   let textEnd = html.indexOf('<')\n              /**\n               * 如果html字符串是以'<'开头,则有以下几种可能\n               * 开始标签:<div>\n               * 结束标签:</div>\n               * 注释:<!-- 我是注释 -->\n               * 条件注释:<!-- [if !IE] --> <!-- [endif] -->\n               * DOCTYPE:<!DOCTYPE html>\n               * 需要一一去匹配尝试\n               */\n            if (textEnd === 0) {\n                // 解析是否是注释\n        \t\tif (comment.test(html)) {\n                    \n                }\n                // 解析是否是条件注释\n                if (conditionalComment.test(html)) {\n                    \n                }\n                // 解析是否是DOCTYPE\n                const doctypeMatch = html.match(doctype)\n                if (doctypeMatch) {\n                    \n                }\n                // 解析是否是结束标签\n                const endTagMatch = html.match(endTag)\n                if (endTagMatch) {\n                    \n                }\n                // 匹配是否是开始标签\n                const startTagMatch = parseStartTag()\n                if (startTagMatch) {\n                    \n                }\n            } \n            // 如果html字符串不是以'<'开头,则解析文本类型\n            let text, rest, next\n            if (textEnd >= 0) {\n\n            }\n            // 如果在html字符串中没有找到'<'，表示这一段html字符串都是纯文本\n            if (textEnd < 0) {\n                text = html\n                html = ''\n            }\n            // 把截取出来的text转化成textAST\n            if (options.chars && text) {\n                options.chars(text)\n            }\n\t\t} else {\n\t\t\t// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理\n\t\t}\n\n\t\t//将整个字符串作为文本对待\n\t\tif (html === last) {\n\t\t\toptions.chars && options.chars(html);\n\t\t\tif (!stack.length && options.warn) {\n\t\t\t\toptions.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Clean up any remaining tags\n\tparseEndTag();\n\t//parse 开始标签\n\tfunction parseStartTag() {\n\t\t\n\t}\n\t//处理 parseStartTag 的结果\n\tfunction handleStartTag(match) {\n\t\t\n\t}\n\t//parse 结束标签\n\tfunction parseEndTag(tagName, start, end) {\n\t\t\n\t}\n}\n```\n\n上述代码中大致可分为三部分：\n\n- 定义的一些常量和变量\n- while 循环\n- 解析过程中用到的辅助函数\n\n我们一一来分析：\n\n首先定义了几个常量，如下\n\n```javascript\nconst stack = []       // 维护AST节点层级的栈\nconst expectHTML = options.expectHTML\nconst isUnaryTag = options.isUnaryTag || no\nconst canBeLeftOpenTag = options.canBeLeftOpenTag || no   //用来检测一个标签是否是可以省略闭合标签的非自闭合标签\nlet index = 0   //解析游标，标识当前从何处开始解析模板字符串\nlet last,   // 存储剩余还未解析的模板字符串\n    lastTag  // 存储着位于 stack 栈顶的元素\n```\n\n 接着开启` while` 循环，循环的终止条件是 模板字符串`html `为空，即模板字符串被全部编译完毕。在每次`while`循环中， 先把 ` html `的值赋给变量 `last  `，如下：\n\n```javascript\nlast = html\n```\n\n这样做的目的是，如果经过上述所有处理逻辑处理过后，`html`字符串没有任何变化，即表示`html`字符串没有匹配上任何一条规则，那么就把`html`字符串当作纯文本对待，创建文本类型的`AST`节点并且如果抛出异常：模板字符串中标签格式有误。如下：\n\n```javascript\n//将整个字符串作为文本对待\nif (html === last) {\n    options.chars && options.chars(html);\n    if (!stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n    }\n    break\n}\n```\n\n接着，我们继续看`while`循环体内的代码：\n\n```javascript\nwhile (html) {\n  // 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)\n  if (!lastTag || !isPlainTextElement(lastTag)) {\n      \n  } else {\n    // parse 的内容是在纯文本标签里 (script,style,textarea)\n  }\n}\n```\n\n在循环体内，首先判断了待解析的`html`字符串是否在纯文本标签里，如`script`,`style`,`textarea`，因为在这三个标签里的内容肯定不会有`HTML`标签，所以我们可直接当作文本处理，判断条件如下：\n\n```javascript\n!lastTag || !isPlainTextElement(lastTag)\n```\n\n 前面我们说了，`lastTag`为栈顶元素，`!lastTag`即表示当前`html`字符串没有父节点，而`isPlainTextElement(lastTag)` 是检测 `lastTag` 是否为是那三个纯文本标签之一，是的话返回`true`，不是返回`fasle`。\n\n也就是说当前`html`字符串要么没有父节点要么父节点不是纯文本标签，则接下来就可以依次解析那6种类型的内容了，关于6种类型内容的处理方式前文已经逐个介绍过，此处不再重复。\n\n### 5.2 parseEndTag函数源码\n\n接下来我们看一下之前在解析结束标签时遗留的`parseEndTag`函数，该函数定义如下：\n\n```javascript\nfunction parseEndTag (tagName, start, end) {\n    let pos, lowerCasedTagName\n    if (start == null) start = index\n    if (end == null) end = index\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase()\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (let i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            `tag <${stack[i].tag}> has no matching end tag.`\n          )\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end)\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos\n      lastTag = pos && stack[pos - 1].tag\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end)\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end)\n      }\n      if (options.end) {\n        options.end(tagName, start, end)\n      }\n    }\n  }\n}\n```\n\n该函数接收三个参数，分别是结束标签名`tagName`、结束标签在`html`字符串中的起始和结束位置`start`和`end`。\n\n这三个参数其实都是可选的，根据传参的不同其功能也不同。\n\n- 第一种是三个参数都传递，用于处理普通的结束标签\n- 第二种是只传递`tagName`\n- 第三种是三个参数都不传递，用于处理栈中剩余未处理的标签\n\n如果`tagName`存在，那么就从后往前遍历栈，在栈中寻找与`tagName`相同的标签并记录其所在的位置`pos`，如果`tagName`不存在，则将`pos`置为0。如下：\n\n```javascript\nif (tagName) {\n    for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break\n        }\n    }\n} else {\n    // If no tag name is provided, clean shop\n    pos = 0\n}\n```\n\n接着当`pos>=0`时，开启一个`for`循环，从栈顶位置从后向前遍历直到`pos`处，如果发现`stack`栈中存在索引大于` pos `的元素，那么该元素一定是缺少闭合标签的。这是因为在正常情况下，`stack`栈的栈顶元素应该和当前的结束标签`tagName` 匹配，也就是说正常的`pos`应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签 那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用 `options.end(stack[i].tag, start, end) `立即将其闭合，这是为了保证解析结果的正确性。\n\n```javascript\nif (pos >= 0) {\n\t// Close all the open elements, up the stack\n\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\tif (i > pos || !tagName ) {\n\t\t\toptions.warn(\n\t\t\t\t(\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n\t\t\t);\n\t\t}\n\t\tif (options.end) {\n\t\t\toptions.end(stack[i].tag, start, end);\n\t\t}\n\t}\n\n\t// Remove the open elements from the stack\n\tstack.length = pos;\n\tlastTag = pos && stack[pos - 1].tag;\n} \n```\n\n最后把`pos`位置以后的元素都从`stack`栈中弹出，以及把` lastTag`更新为栈顶元素:\n\n```js\nstack.length = pos;\nlastTag = pos && stack[pos - 1].tag;\n```\n\n接着，如果`pos`没有大于等于0，即当 `tagName` 没有在 `stack` 栈中找到对应的开始标签时，`pos` 为 -1 。那么此时再判断 `tagName` 是否为`br` 或`p`标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下`HTML`：\n\n```html\n<div>\n    </br>\n    </p>\n</div>\n```\n\n浏览器会自动把`</br>`标签解析为正常的 \\<br>标签，而对于`</p>`浏览器则自动将其补全为`<p></p>`，所以`Vue`为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：\n\n```javascript\nif (lowerCasedTagName === 'br') {\n    if (options.start) {   \n        options.start(tagName, [], true, start, end)  // 创建<br>AST节点\n    }\n} \n// 补全p标签并创建AST节点\nif (lowerCasedTagName === 'p') {\n    if (options.start) {\n        options.start(tagName, [], false, start, end)\n    }\n    if (options.end) {\n        options.end(tagName, start, end)\n    }\n}\n```\n\n以上就是对结束标签的解析与处理。\n\n另外，在`while`循环后面还有一行代码：\n\n```javascript\nparseEndTag()\n```\n\n这行代码执行的时机是`html === last`，即`html`字符串中的标签格式有误时会跳出`while`循环，此时就会执行这行代码，这行代码是调用`parseEndTag`函数并不传递任何参数，前面我们说过如果`parseEndTag`函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时`parseEndTag`函数里的`pos`就为0，那么`pos>=0`就会恒成立，那么就会逐个警告缺少闭合标签，并调用 `options.end `将其闭合。\n\n## 6. 总结\n\n本篇文章主要介绍了`HTML`解析器的工作流程以及工作原理，文章比较长，但是逻辑并不复杂。\n\n首先介绍了`HTML`解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子函数生成对应的`AST`节点，最终完成将整个模板字符串转化成`AST`。\n\n接着介绍了`HTML`解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。\n\n其次，介绍了在解析器内维护了一个栈，用来保证构建的`AST`节点层级与真正`DOM`层级一致。\n\n了解了思想之后，最后回归源码，学习了源码中一些处理细节的地方。","source":"_posts/Vue 源码阅读 模板编译（三）.md","raw":"---\ntitle: Vue 源码阅读 模板编译（三）\ncatalog: true\ntags:\n  - JavaScript\n  - Vue源码\n  - Vue\ncategories:\n  - Vue\ndate: 2019-10-19 21:39:42\nsubtitle:\nheader-img: \"https://img.zcool.cn/community/0144ed58660585a8012060c810d41f.jpg@2o.jpg\"\n---\n\n\n## 1. 前言\n\n上篇文章中我们说到，在模板解析阶段主线函数`parse`中，根据要解析的内容不同会调用不同的解析器，\n\n而在三个不同的解析器中最主要的当属`HTML`解析器，为什么这么说呢？因为`HTML`解析器主要负责解析出模板字符串中有哪些内容，然后根据不同的内容才能调用其他的解析器以及做相应的处理。那么本篇文章就来介绍一下`HTML`解析器是如何解析出模板字符串中包含的不同的内容的。\n\n## 2. HTML解析器内部运行流程\n\n在源码中，`HTML`解析器就是`parseHTML`函数，在模板解析主线函数`parse`中调用了该函数，并传入两个参数，代码如下：\n\n```javascript\n// 代码位置：/src/complier/parser/index.js\n\n/**\n * Convert HTML string to AST.\n * 将HTML模板字符串转化为AST\n */\nexport function parse(template, options) {\n   // ...\n  parseHTML(template, {\n    warn,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    // 当解析到开始标签时，调用该函数  \n    start (tag, attrs, unary) {\n\n    },\n    // 当解析到结束标签时，调用该函数\n    end () {\n\n    },\n    // 当解析到文本时，调用该函数  \n    chars (text) {\n\n    },\n    // 当解析到注释时，调用该函数  \n    comment (text) {\n\n    }\n  })\n  return root\n}\n```\n\n从代码中我们可以看到，调用`parseHTML`函数时为其传入的两个参数分别是：\n\n- template:待转换的模板字符串；\n- options:转换时所需的选项；\n\n第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析`HTML`模板时的一些参数，同时还定义了4个钩子函数。这4个钩子函数有什么作用呢？我们说了模板编译阶段主线函数`parse`会将`HTML`模板字符串转化成`AST`，而`parseHTML`是用来解析模板字符串的，把模板字符串中不同的内容出来之后，那么谁来把提取出来的内容生成对应的`AST`呢？答案就是这4个钩子函数。\n\n把这4个钩子函数作为参数传给解析器`parseHTML`，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的`AST`。\n\n- 当解析到开始标签时调用`start`函数生成元素类型的`AST`节点，代码如下；\n\n  ```javascript\n  // 当解析到标签的开始位置时，触发start\n  start (tag, attrs, unary) {\n  \tlet element = createASTElement(tag, attrs, currentParent)\n  }\n  \n  export function createASTElement (tag,attrs,parent) {\n    return {\n      type: 1,\n      tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      parent,\n      children: []\n    }\n  }\n  ```\n\n  从上面代码中我们可以看到，`start`函数接收三个参数，分别是标签名`tag`、标签属性`attrs`、标签是否自闭合`unary`。当调用该钩子函数时，内部会调用`createASTElement`函数来创建元素类型的`AST`节点\n\n- 当解析到结束标签时调用`end`函数；\n\n- 当解析到文本时调用`chars`函数生成文本类型的`AST`节点；\n\n  ```javascript\n  // 当解析到标签的文本时，触发chars\n  chars (text) {\n  \tif(text是带变量的动态文本){\n         let element = {\n             type: 2,\n             expression: res.expression,\n             tokens: res.tokens,\n             text\n         }\n      } else {\n         let element = {\n             type: 3,\n             text\n         } \n      }\n  }\n  ```\n\n  当解析到标签的文本时，触发`chars`钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello {{name}}”。如果是动态文本，则创建动态文本类型的`AST`节点；如果不是动态文本，则创建纯静态文本类型的`AST`节点。\n\n- 当解析到注释时调用`comment`函数生成注释类型的`AST`节点；\n\n  ```javascript\n  // 当解析到标签的注释时，触发comment\n  comment (text: string) {\n      let element = {\n          type: 3,\n          text,\n          isComment: true\n      }\n  }\n  ```\n\n  当解析到标签的注释时，触发`comment`钩子函数，该钩子函数会创建一个注释类型的`AST`节点。\n\n一边解析不同的内容一边调用对应的钩子函数生成对应的`AST`节点，最终完成将整个模板字符串转化成`AST`,这就是`HTML`解析器所要做的工作。\n\n## 3. 如何解析不同的内容\n\n要从模板字符串中解析出不同的内容，那首先要知道模板字符串中都会包含哪些内容。那么通常我们所写的模板字符串中都会包含哪些内容呢？经过整理，通常模板内会包含如下内容：\n\n- 文本，例如“难凉热血”\n- HTML注释，例如\\<!-- 我是注释 -->\n- 条件注释，例如\\<!-- [if !IE]> -->我是注释\\<!--< ![endif]  -->\n- DOCTYPE，例如\\<!DOCTYPE html>\n- 开始标签，例如\\<div>\n- 结束标签，例如\\</div>\n\n这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。\n\n下面，我们就来分别看一下`HTML`解析器是如何从模板字符串中将以上不同种类的内容进行解析出来。\n\n### 3.1 解析HTML注释\n\n解析注释比较简单，我们知道`HTML`注释是以`<!--`开头，以`-->`结尾，这两者中间的内容就是注释内容，那么我们只需用正则判断待解析的模板字符串`html`是否以`<!--`开头，若是，那就继续向后寻找`-->`，如果找到了，OK，注释就被解析出来了。代码如下：\n\n```javascript\nconst comment = /^<!\\--/\nif (comment.test(html)) {\n    // 若为注释，则继续查找是否存在'-->'\n    const commentEnd = html.indexOf('-->')\n\n    if (commentEnd >= 0) {\n        // 若存在 '-->',继续判断options中是否保留注释\n        if (options.shouldKeepComment) {\n            // 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点\n            options.comment(html.substring(4, commentEnd))\n        }\n        // 若不保留注释，则将游标移动到'-->'之后，继续向后解析\n        advance(commentEnd + 3)\n        continue\n    }\n}\n```\n\n在上面代码中，如果模板字符串`html`符合注释开始的正则，那么就继续向后查找是否存在`-->`，若存在，则把`html`从第4位（\"\\<!--\"长度为4）开始截取，直到`-->`处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的`comment`函数，将真实的注释内容传进去，创建注释类型的`AST`节点。\n\n上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在`<template></template>`标签上配置`comments`选项来决定在渲染模板时是否保留注释，对应到上面代码中就是`options.shouldKeepComment`,如果用户配置了`comments`选项为`true`，则`shouldKeepComment`为`true`，则创建注释类型的`AST`节点，如不保留注释，则将游标移动到'-->'之后，继续向后解析。\n\n`advance`函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：\n\n```javascript\nfunction advance (n) {\n    index += n   // index为解析游标\n    html = html.substring(n)\n}\n```\n为了更加直观地说明 `advance` 的作用，请看下图： \n![](/img/complie/5.png)\n\n调用 `advance` 函数：\n\n```js\nadvance(3)\n```\n\n得到结果：\n![](/img/complie/6.png)\n\n从图中可以看到，解析游标`index`最开始在模板字符串的位置0处，当调用了`advance(3)`之后，解析游标到了位置3处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。\n\n### 3.2 解析条件注释\n\n解析条件注释也比较简单，其原理跟解析注释相同，都是先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的`DOM`树中，所以不需要调用钩子函数创建`AST`节点。代码如下：\n\n```javascript\n// 解析是否是条件注释\nconst conditionalComment = /^<!\\[/\nif (conditionalComment.test(html)) {\n    // 若为条件注释，则继续查找是否存在']>'\n    const conditionalEnd = html.indexOf(']>')\n\n    if (conditionalEnd >= 0) {\n        // 若存在 ']>',则从原本的html字符串中把条件注释截掉，把剩下的内容重新赋给html，继续向后匹配\n        advance(conditionalEnd + 2)\n        continue\n    }\n}\n```\n\n### 3.3 解析DOCTYPE\n\n解析`DOCTYPE`的原理同解析条件注释完全相同，此处不再赘述，代码如下：\n\n```javascript\nconst doctype = /^<!DOCTYPE [^>]+>/i\n// 解析是否是DOCTYPE\nconst doctypeMatch = html.match(doctype)\nif (doctypeMatch) {\n    advance(doctypeMatch[0].length)\n    continue\n}\n```\n\n### 3.4 解析开始标签\n\n相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是相通的，都是使用正则去匹配提取。\n\n首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下：\n\n```javascript\n/**\n * 匹配开始标签的正则\n */\nconst ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\n\nconst start = html.match(startTagOpen)\nif (start) {\n    const match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n    }\n}\n\n// 以开始标签开始的模板：\n'<div></div>'.match(startTagOpen)  => ['<div','div',index:0,input:'<div></div>']\n// 以结束标签开始的模板：\n'</div><div></div>'.match(startTagOpen) => null\n// 以文本开始的模板：\n'我是文本</p>'.match(startTagOpen) => null\n```\n\n在上面代码中，我们用不同类型的内容去匹配开始标签的正则，发现只有`<div></div>`的字符串可以正确匹配，并且返回一个数组。\n\n在前文中我们说到，当解析到开始标签时，会调用4个钩子函数中的`start`函数，而`start`函数需要传递3个参数，分别是标签名`tag`、标签属性`attrs`、标签是否自闭合`unary`。标签名通过正则匹配的结果就可以拿到，即上面代码中的`start[1]`，而标签属性`attrs`以及标签是否自闭合`unary`需要进一步解析。\n\n1. 解析标签属性\n\n   我们知道，标签属性一般是写在开始标签的标签名之后的，如下：\n\n   ```html\n   <div class=\"a\" id=\"b\"></div>\n   ```\n\n   另外，我们在上面匹配是否是开始标签的正则中已经可以拿到开始标签的标签名，即上面代码中的`start[0]`，那么我们可以将这一部分先从模板字符串中截掉，则剩下的部分如下：\n\n   ```html\n    class=\"a\" id=\"b\"></div>\n   ```\n\n   那么我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：\n\n   ```javascript\n   const attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\n   let html = 'class=\"a\" id=\"b\"></div>'\n   let attr = html.match(attribute)\n   console.log(attr)\n   // [\"class=\"a\"\", \"class\", \"=\", \"a\", undefined, undefined, index: 0, input: \"class=\"a\" id=\"b\"></div>\", groups: undefined]\n   ```\n\n   可以看到，第一个标签属性`class=\"a\"`已经被拿到了。另外，标签属性有可能有多个也有可能没有，如果没有的话那好办，匹配标签属性的正则就会匹配失败，标签属性就为空数组；而如果标签属性有多个的话，那就需要循环匹配了，匹配出第一个标签属性后，就把该属性截掉，用剩下的字符串继续匹配，直到不再满足正则为止，代码如下：\n\n   ```javascript\n   const attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\n   const startTagClose = /^\\s*(\\/?)>/\n   const match = {\n       tagName: start[1],\n       attrs: [],\n       start: index\n   }\n   while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n       advance(attr[0].length)\n       match.attrs.push(attr)\n   }\n   ```\n\n   在上面代码的`while`循环中，如果剩下的字符串不符合开始标签的结束特征（startTagClose）并且符合标签属性的特征的话，那就说明还有未提取出的标签属性，那就进入循环，继续提取，直到把所有标签属性都提取完毕。\n\n   所谓不符合开始标签的结束特征是指当前剩下的字符串不是以开始标签结束符开头的，我们知道一个开始标签的结束符有可能是一个`>`（非自闭合标签），也有可能是`/>`（自闭合标签），如果剩下的字符串（如`></div>`）以开始标签的结束符开头，那么就表示标签属性已经被提取完毕了。\n\n   \n\n2. 解析标签是否是自闭合\n\n   在`HTML`中，有自闭合标签（如`<img src=\"\"/>`）也有非自闭合标签（如`<div></div>`），这两种类型的标签在创建`AST`节点是处理方式是有区别的，所以我们需要解析出当前标签是否是自闭合标签。\n\n   解析的方式很简单，我们知道，经过标签属性提取之后，那么剩下的字符串无非就两种，如下：\n\n   ```html\n   <!--非自闭合标签-->\n   ></div>\n   ```\n\n   或\n\n   ```html\n   <!--自闭合标签-->\n   />\n   ```\n\n   所以我们可以用剩下的字符串去匹配开始标签结束符正则，如下：\n\n   ```javascript\n   const startTagClose = /^\\s*(\\/?)>/\n   let end = html.match(startTagClose)\n   '></div>'.match(startTagClose) // [\">\", \"\", index: 0, input: \"></div>\", groups: undefined]\n   '/>'.match(startTagClose) // [\"/>\", \"/\", index: 0, input: \"/><div></div>\", groups: undefined]\n   ```\n\n   可以看到，非自闭合标签匹配结果中的`end[1]`为`\"\"`，而自闭合标签匹配结果中的`end[1]`为`\"/\"`。所以根据匹配结果的`end[1]`是否是`\"\"`我们即可判断出当前标签是否为自闭合标签，源码如下：\n\n   ```javascript\n   const startTagClose = /^\\s*(\\/?)>/\n   let end = html.match(startTagClose)\n   if (end) {\n       match.unarySlash = end[1]\n       advance(end[0].length)\n       match.end = index\n       return match\n   }\n   ```\n\n经过以上两步，开始标签就已经解析完毕了，完整源码如下：\n\n```javascript\nconst ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`)\nconst startTagClose = /^\\s*(\\/?)>/\n\n\nfunction parseStartTag () {\n    const start = html.match(startTagOpen)\n    // '<div></div>'.match(startTagOpen)  => ['<div','div',index:0,input:'<div></div>']\n    if (start) {\n      const match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      }\n      advance(start[0].length)\n      let end, attr\n      /**\n       * <div a=1 b=2 c=3></div>\n       * 从<div之后到开始标签的结束符号'>'之前，一直匹配属性attrs\n       * 所有属性匹配完之后，html字符串还剩下 \n       * 自闭合标签剩下：'/>'\n       * 非自闭合标签剩下：'></div>'\n       */\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length)\n        match.attrs.push(attr)\n      }\n\n      /**\n       * 这里判断了该标签是否为自闭合标签\n       * 自闭合标签如:<input type='text' />\n       * 非自闭合标签如:<div></div>\n       * '></div>'.match(startTagClose) => [\">\", \"\", index: 0, input: \"></div>\", groups: undefined]\n       * '/><div></div>'.match(startTagClose) => [\"/>\", \"/\", index: 0, input: \"/><div></div>\", groups: undefined]\n       * 因此，我们可以通过end[1]是否是\"/\"来判断该标签是否是自闭合标签\n       */\n      if (end) {\n        match.unarySlash = end[1]\n        advance(end[0].length)\n        match.end = index\n        return match\n      }\n    }\n  }\n```\n\n通过源码可以看到，调用`parseStartTag`函数，如果模板字符串符合开始标签的特征，则解析开始标签，并将解析结果返回，如果不符合开始标签的特征，则返回`undefined`。\n\n解析完毕后，就可以用解析得到的结果去调用`start`钩子函数去创建元素型的`AST`节点了。\n\n在源码中，`Vue`并没有直接去调`start`钩子函数去创建`AST`节点，而是调用了`handleStartTag`函数，在该函数内部才去调的`start`钩子函数，为什么要这样做呢？这是因为虽然经过`parseStartTag`函数已经把创建`AST`节点必要信息提取出来了，但是提取出来的标签属性数组还是需要处理一下，下面我们就来看一下`handleStartTag`函数都做了些什么事。`handleStartTag`函数源码如下：\n\n```javascript\nfunction handleStartTag (match) {\n    const tagName = match.tagName\n    const unarySlash = match.unarySlash\n\n    if (expectHTML) {\n      // ...\n    }\n\n    const unary = isUnaryTag(tagName) || !!unarySlash\n\n    const l = match.attrs.length\n    const attrs = new Array(l)\n    for (let i = 0; i < l; i++) {\n      const args = match.attrs[i]\n      const value = args[3] || args[4] || args[5] || ''\n      const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })\n      lastTag = tagName\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end)\n    }\n  }\n\n```\n\n `handleStartTag`函数用来对`parseStartTag`函数的解析结果进行进一步处理，它接收`parseStartTag`函数的返回值作为参数。\n\n`handleStartTag`函数的开始定义几个常量：\n\n```javascript\nconst tagName = match.tagName       // 开始标签的标签名\nconst unarySlash = match.unarySlash  // 是否为自闭合标签的标志，自闭合为\"\",非自闭合为\"/\"\nconst unary = isUnaryTag(tagName) || !!unarySlash  // 布尔值，标志是否为自闭合标签\nconst l = match.attrs.length    // match.attrs 数组的长度\nconst attrs = new Array(l)  // 一个与match.attrs数组长度相等的数组\n```\n\n接下来是循环处理提取出来的标签属性数组`match.attrs`，如下：\n\n```javascript\nfor (let i = 0; i < l; i++) {\n    const args = match.attrs[i]\n    const value = args[3] || args[4] || args[5] || ''\n    const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n    ? options.shouldDecodeNewlinesForHref\n    : options.shouldDecodeNewlines\n    attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n    }\n}\n```\n\n 上面代码中，首先定义了 `args `常量，它是解析出来的标签属性数组中的每一个属性对象，即`match.attrs` 数组中每个元素对象。 它长这样：\n\n```javascript\nconst args = [\"class=\"a\"\", \"class\", \"=\", \"a\", undefined, undefined, index: 0, input: \"class=\"a\" id=\"b\"></div>\", groups: undefined]\n```\n\n接着定义了`value`，用于存储标签属性的属性值，我们可以看到，在代码中尝试取`args`的`args[3]`、`args[4]`、`args[5]`，如果都取不到，则给`value`复制为空\n\n```javascript\nconst value = args[3] || args[4] || args[5] || ''\n```\n\n\n\n接着定义了`shouldDecodeNewlines`，这个常量主要是做一些兼容性处理， 如果 `shouldDecodeNewlines` 为 `true`，意味着 `Vue` 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。而`shouldDecodeNewlinesForHref`为`true` 意味着`Vue`在编译模板的时候，要对`a`标签的 `href `属性值中的换行符或制表符做兼容处理。\n\n```javascript\nconst shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n    ? options.shouldDecodeNewlinesForHref\n    : options.shouldDecodeNewlinesconst value = args[3] || args[4] || args[5] || ''\n```\n\n最后将处理好的结果存入之前定义好的与`match.attrs`数组长度相等的`attrs`数组中，如下：\n\n```javascript\nattrs[i] = {\n    name: args[1],    // 标签属性的属性名，如class\n    value: decodeAttr(value, shouldDecodeNewlines) // 标签属性的属性值，如class对应的a\n}\n```\n\n最后，如果该标签是非自闭合标签，则将标签推入栈中（关于栈这个概念后面会说到），如下：\n\n```javascript\nif (!unary) {\n    stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })\n    lastTag = tagName\n}\n```\n\n如果该标签是自闭合标签，现在就可以调用`start`钩子函数并传入处理好的参数来创建`AST`节点了，如下：\n\n```javascript\nif (options.start) {\n    options.start(tagName, attrs, unary, match.start, match.end)\n}\n```\n\n以上就是开始标签的解析以及调用`start`钩子函数创建元素型的`AST`节点的所有过程。\n\n### 3.5 解析结束标签\n\n结束标签的解析要比解析开始标签容易多了，因为它不需要解析什么属性，只需要判断剩下的模板字符串是否符合结束标签的特征，如果是，就将结束标签名提取出来，再调用4个钩子函数中的`end`函数就好了。\n\n首先判断剩余的模板字符串是否符合结束标签的特征，如下：\n\n```javascript\nconst ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*'\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)\nconst endTagMatch = html.match(endTag)\n\n'</div>'.match(endTag)  // [\"</div>\", \"div\", index: 0, input: \"</div>\", groups: undefined]\n'<div>'.match(endTag)  // null\n```\n\n上面代码中，如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到null。\n\n接着再调用`end`钩子函数，如下：\n\n```javascript\nif (endTagMatch) {\n    const curIndex = index\n    advance(endTagMatch[0].length)\n    parseEndTag(endTagMatch[1], curIndex, index)\n    continue\n}\n```\n\n在上面代码中，没有直接去调用`end`函数，而是调用了`parseEndTag`函数，关于`parseEndTag`函数内部的作用我们后面会介绍到，在这里你暂时可以理解为该函数内部就是去调用了`end`钩子函数。\n\n### 3.6 解析文本\n\n```\n终于到了解析最后一种文本类型的内容了，为什么要把解析文本类型放在最后一个介绍呢？我们仔细想一下，前面五种类型都是以`<`开头的，只有文本类型的内容不是以`<`开头的，所以我们在解析模板字符串的时候可以先判断一下字符串是不是以`<`开头的，如果是则继续判断是以上五种类型的具体哪一种，而如果不是的话，那它肯定就是文本了。\n```\n\n解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个`<`出现在什么位置，如果第一个`<`在第一个位置，那么说明模板字符串是以其它5种类型开始的；如果第一个`<`不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个`<`出现的位置就都是文本内容了；如果在整个模板字符串里没有找到`<`，那说明整个模板字符串都是文本。这就是解析思路，接下来我们对照源码来了解一下实际的解析过程，源码如下：\n\n```javascript\nlet textEnd = html.indexOf('<')\n// '<' 在第一个位置，为其余5种类型\nif (textEnd === 0) {\n    // ... \n}\n// '<' 不在第一个位置，文本开头\nif (textEnd >= 0) {\n    // 如果html字符串不是以'<'开头,说明'<'前面的都是纯文本，无需处理\n    // 那就把'<'以后的内容拿出来赋给rest\n    rest = html.slice(textEnd)\n    while (\n        !endTag.test(rest) &&\n        !startTagOpen.test(rest) &&\n        !comment.test(rest) &&\n        !conditionalComment.test(rest)\n    ) {\n        // < in plain text, be forgiving and treat it as text\n        /**\n           * 用'<'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment\n           * 如果都匹配不上，表示'<'是属于文本本身的内容\n           */\n        // 在'<'之后查找是否还有'<'\n        next = rest.indexOf('<', 1)\n        // 如果没有了，表示'<'后面也是文本\n        if (next < 0) break\n        // 如果还有，表示'<'是文本中的一个字符\n        textEnd += next\n        // 那就把next之后的内容截出来继续下一轮循环匹配\n        rest = html.slice(textEnd)\n    }\n    // '<'是结束标签的开始 ,说明从开始到'<'都是文本，截取出来\n    text = html.substring(0, textEnd)\n    advance(textEnd)\n}\n// 整个模板字符串里没有找到`<`,说明整个模板字符串都是文本\nif (textEnd < 0) {\n    text = html\n    html = ''\n}\n// 把截取出来的text转化成textAST\nif (options.chars && text) {\n    options.chars(text)\n}\n```\n\n源码的逻辑很清晰，根据`<`在不在第一个位置以及整个模板字符串里没有`<`都分别进行了处理。\n\n值得深究的是如果`<`不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个`<`出现的位置就都是文本内容了，接着我们还要从第一个`<`的位置继续向后判断，因为还存在这样一种情况，那就是如果文本里面本来就包含一个`<`，例如`1<2</div>`。为了处理这种情况，我们把从第一个`<`的位置直到模板字符串结束都截取出来记作`rest`，如下：\n\n```javascript\n let rest = html.slice(textEnd)\n```\n\n接着用`rest`去匹配以上5种类型的正则，如果都匹配不上，则表明这个`<`是属于文本本身的内容，如下：\n\n```javascript\nwhile (\n    !endTag.test(rest) &&\n    !startTagOpen.test(rest) &&\n    !comment.test(rest) &&\n    !conditionalComment.test(rest)\n) {\n    \n}\n```\n\n如果都匹配不上，则表明这个`<`是属于文本本身的内容，接着以这个`<`的位置继续向后查找，看是否还有`<`，如果没有了，则表示后面的都是文本；如果后面还有下一个`<`，那表明至少在这个`<`到下一个`<`中间的内容都是文本，至于下一个`<`以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：\n\n```javascript\nwhile (\n    !endTag.test(rest) &&\n    !startTagOpen.test(rest) &&\n    !comment.test(rest) &&\n    !conditionalComment.test(rest)\n) {\n    // < in plain text, be forgiving and treat it as text\n    /**\n    * 用'<'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment\n    * 如果都匹配不上，表示'<'是属于文本本身的内容\n    */\n    // 在'<'之后查找是否还有'<'\n    next = rest.indexOf('<', 1)\n    // 如果没有了，表示'<'后面也是文本\n    if (next < 0) break\n    // 如果还有，表示'<'是文本中的一个字符\n    textEnd += next\n    // 那就把next之后的内容截出来继续下一轮循环匹配\n    rest = html.slice(textEnd)\n}\n```\n\n最后截取文本内容`text`并调用4个钩子函数中的`chars`函数创建文本型的`AST`节点。\n\n## 4. 如何保证AST节点层级关系\n\n上一章节我们介绍了`HTML`解析器是如何解析各种不同类型的内容并且调用钩子函数创建不同类型的`AST`节点。此时你可能会有个疑问，我们上面创建的`AST`节点都是单独创建且分散的，而真正的`DOM`节点都是有层级关系的，那如何来保证`AST`节点的层级关系与真正的`DOM`节点相同呢？ \n\n关于这个问题，`Vue`也注意到了。`Vue`在`HTML`解析器的开头定义了一个栈`stack`，这个栈的作用就是用来维护`AST`节点层级的，那么它是怎么维护的呢？通过前文我们知道，`HTML`解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用`start`钩子函数，那么在`start`钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用`end`钩子函数，那么我们也可以在`end`钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。请看如下例子：\n\n加入有如下模板字符串：\n\n```html\n<div><p><span></span></p></div>\n```\n\n当解析到开始标签`<div>`时，就把`div`推入栈中，然后继续解析，当解析到`<p>`时，再把`p`推入栈中，同理，再把`span`推入栈中，当解析到结束标签`</span>`时，此时栈顶的标签刚好是`span`的开始标签，那么就用`span`的开始标签和结束标签构建`AST`节点，并且从栈中把`span`的开始标签弹出，那么此时栈中的栈顶标签`p`就是构建好的`span`的`AST`节点的父节点，如下图：\n\n![](/img/complie/7.png)\n\n\n这样我们就找到了当前被构建节点的父节点。这只是栈的一个用途，它还有另外一个用途，我们再看如下模板字符串：\n\n```html\n<div><p><span></p></div>\n```\n\n按照上面的流程解析这个模板字符串时，当解析到结束标签`</p>`时，此时栈顶的标签应该是`p`才对，而现在是`span`，那么就说明`span`标签没有被正确闭合，此时控制台就会抛出警告：‘tag  has no matching end tag.’相信这个警告你一定不会陌生。这就是栈的第二个用途： 检测模板字符串中是否有未正确闭合的标签。 \n\nOK，有了这个栈的概念之后，我们再回看上一章`HTML`解析器解析不同内容的代码。\n\n## 5. 回归源码\n\n### 5.1 HTML解析器源码\n\n以上内容都了解了之后，我们回归源码，逐句分析`HTML`解析器`parseHTML`函数，函数定义如下：\n\n```javascript\nfunction parseHTML(html, options) {\n\tvar stack = [];\n\tvar expectHTML = options.expectHTML;\n\tvar isUnaryTag$$1 = options.isUnaryTag || no;\n\tvar canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n\tvar index = 0;\n\tvar last, lastTag;\n\n\t// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕\n\twhile (html) {\n\t\tlast = html;\n\t\t// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)\n\t\tif (!lastTag || !isPlainTextElement(lastTag)) {\n\t\t   let textEnd = html.indexOf('<')\n              /**\n               * 如果html字符串是以'<'开头,则有以下几种可能\n               * 开始标签:<div>\n               * 结束标签:</div>\n               * 注释:<!-- 我是注释 -->\n               * 条件注释:<!-- [if !IE] --> <!-- [endif] -->\n               * DOCTYPE:<!DOCTYPE html>\n               * 需要一一去匹配尝试\n               */\n            if (textEnd === 0) {\n                // 解析是否是注释\n        \t\tif (comment.test(html)) {\n                    \n                }\n                // 解析是否是条件注释\n                if (conditionalComment.test(html)) {\n                    \n                }\n                // 解析是否是DOCTYPE\n                const doctypeMatch = html.match(doctype)\n                if (doctypeMatch) {\n                    \n                }\n                // 解析是否是结束标签\n                const endTagMatch = html.match(endTag)\n                if (endTagMatch) {\n                    \n                }\n                // 匹配是否是开始标签\n                const startTagMatch = parseStartTag()\n                if (startTagMatch) {\n                    \n                }\n            } \n            // 如果html字符串不是以'<'开头,则解析文本类型\n            let text, rest, next\n            if (textEnd >= 0) {\n\n            }\n            // 如果在html字符串中没有找到'<'，表示这一段html字符串都是纯文本\n            if (textEnd < 0) {\n                text = html\n                html = ''\n            }\n            // 把截取出来的text转化成textAST\n            if (options.chars && text) {\n                options.chars(text)\n            }\n\t\t} else {\n\t\t\t// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理\n\t\t}\n\n\t\t//将整个字符串作为文本对待\n\t\tif (html === last) {\n\t\t\toptions.chars && options.chars(html);\n\t\t\tif (!stack.length && options.warn) {\n\t\t\t\toptions.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Clean up any remaining tags\n\tparseEndTag();\n\t//parse 开始标签\n\tfunction parseStartTag() {\n\t\t\n\t}\n\t//处理 parseStartTag 的结果\n\tfunction handleStartTag(match) {\n\t\t\n\t}\n\t//parse 结束标签\n\tfunction parseEndTag(tagName, start, end) {\n\t\t\n\t}\n}\n```\n\n上述代码中大致可分为三部分：\n\n- 定义的一些常量和变量\n- while 循环\n- 解析过程中用到的辅助函数\n\n我们一一来分析：\n\n首先定义了几个常量，如下\n\n```javascript\nconst stack = []       // 维护AST节点层级的栈\nconst expectHTML = options.expectHTML\nconst isUnaryTag = options.isUnaryTag || no\nconst canBeLeftOpenTag = options.canBeLeftOpenTag || no   //用来检测一个标签是否是可以省略闭合标签的非自闭合标签\nlet index = 0   //解析游标，标识当前从何处开始解析模板字符串\nlet last,   // 存储剩余还未解析的模板字符串\n    lastTag  // 存储着位于 stack 栈顶的元素\n```\n\n 接着开启` while` 循环，循环的终止条件是 模板字符串`html `为空，即模板字符串被全部编译完毕。在每次`while`循环中， 先把 ` html `的值赋给变量 `last  `，如下：\n\n```javascript\nlast = html\n```\n\n这样做的目的是，如果经过上述所有处理逻辑处理过后，`html`字符串没有任何变化，即表示`html`字符串没有匹配上任何一条规则，那么就把`html`字符串当作纯文本对待，创建文本类型的`AST`节点并且如果抛出异常：模板字符串中标签格式有误。如下：\n\n```javascript\n//将整个字符串作为文本对待\nif (html === last) {\n    options.chars && options.chars(html);\n    if (!stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n    }\n    break\n}\n```\n\n接着，我们继续看`while`循环体内的代码：\n\n```javascript\nwhile (html) {\n  // 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)\n  if (!lastTag || !isPlainTextElement(lastTag)) {\n      \n  } else {\n    // parse 的内容是在纯文本标签里 (script,style,textarea)\n  }\n}\n```\n\n在循环体内，首先判断了待解析的`html`字符串是否在纯文本标签里，如`script`,`style`,`textarea`，因为在这三个标签里的内容肯定不会有`HTML`标签，所以我们可直接当作文本处理，判断条件如下：\n\n```javascript\n!lastTag || !isPlainTextElement(lastTag)\n```\n\n 前面我们说了，`lastTag`为栈顶元素，`!lastTag`即表示当前`html`字符串没有父节点，而`isPlainTextElement(lastTag)` 是检测 `lastTag` 是否为是那三个纯文本标签之一，是的话返回`true`，不是返回`fasle`。\n\n也就是说当前`html`字符串要么没有父节点要么父节点不是纯文本标签，则接下来就可以依次解析那6种类型的内容了，关于6种类型内容的处理方式前文已经逐个介绍过，此处不再重复。\n\n### 5.2 parseEndTag函数源码\n\n接下来我们看一下之前在解析结束标签时遗留的`parseEndTag`函数，该函数定义如下：\n\n```javascript\nfunction parseEndTag (tagName, start, end) {\n    let pos, lowerCasedTagName\n    if (start == null) start = index\n    if (end == null) end = index\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase()\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (let i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            `tag <${stack[i].tag}> has no matching end tag.`\n          )\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end)\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos\n      lastTag = pos && stack[pos - 1].tag\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end)\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end)\n      }\n      if (options.end) {\n        options.end(tagName, start, end)\n      }\n    }\n  }\n}\n```\n\n该函数接收三个参数，分别是结束标签名`tagName`、结束标签在`html`字符串中的起始和结束位置`start`和`end`。\n\n这三个参数其实都是可选的，根据传参的不同其功能也不同。\n\n- 第一种是三个参数都传递，用于处理普通的结束标签\n- 第二种是只传递`tagName`\n- 第三种是三个参数都不传递，用于处理栈中剩余未处理的标签\n\n如果`tagName`存在，那么就从后往前遍历栈，在栈中寻找与`tagName`相同的标签并记录其所在的位置`pos`，如果`tagName`不存在，则将`pos`置为0。如下：\n\n```javascript\nif (tagName) {\n    for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break\n        }\n    }\n} else {\n    // If no tag name is provided, clean shop\n    pos = 0\n}\n```\n\n接着当`pos>=0`时，开启一个`for`循环，从栈顶位置从后向前遍历直到`pos`处，如果发现`stack`栈中存在索引大于` pos `的元素，那么该元素一定是缺少闭合标签的。这是因为在正常情况下，`stack`栈的栈顶元素应该和当前的结束标签`tagName` 匹配，也就是说正常的`pos`应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签 那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用 `options.end(stack[i].tag, start, end) `立即将其闭合，这是为了保证解析结果的正确性。\n\n```javascript\nif (pos >= 0) {\n\t// Close all the open elements, up the stack\n\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\tif (i > pos || !tagName ) {\n\t\t\toptions.warn(\n\t\t\t\t(\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n\t\t\t);\n\t\t}\n\t\tif (options.end) {\n\t\t\toptions.end(stack[i].tag, start, end);\n\t\t}\n\t}\n\n\t// Remove the open elements from the stack\n\tstack.length = pos;\n\tlastTag = pos && stack[pos - 1].tag;\n} \n```\n\n最后把`pos`位置以后的元素都从`stack`栈中弹出，以及把` lastTag`更新为栈顶元素:\n\n```js\nstack.length = pos;\nlastTag = pos && stack[pos - 1].tag;\n```\n\n接着，如果`pos`没有大于等于0，即当 `tagName` 没有在 `stack` 栈中找到对应的开始标签时，`pos` 为 -1 。那么此时再判断 `tagName` 是否为`br` 或`p`标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下`HTML`：\n\n```html\n<div>\n    </br>\n    </p>\n</div>\n```\n\n浏览器会自动把`</br>`标签解析为正常的 \\<br>标签，而对于`</p>`浏览器则自动将其补全为`<p></p>`，所以`Vue`为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：\n\n```javascript\nif (lowerCasedTagName === 'br') {\n    if (options.start) {   \n        options.start(tagName, [], true, start, end)  // 创建<br>AST节点\n    }\n} \n// 补全p标签并创建AST节点\nif (lowerCasedTagName === 'p') {\n    if (options.start) {\n        options.start(tagName, [], false, start, end)\n    }\n    if (options.end) {\n        options.end(tagName, start, end)\n    }\n}\n```\n\n以上就是对结束标签的解析与处理。\n\n另外，在`while`循环后面还有一行代码：\n\n```javascript\nparseEndTag()\n```\n\n这行代码执行的时机是`html === last`，即`html`字符串中的标签格式有误时会跳出`while`循环，此时就会执行这行代码，这行代码是调用`parseEndTag`函数并不传递任何参数，前面我们说过如果`parseEndTag`函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时`parseEndTag`函数里的`pos`就为0，那么`pos>=0`就会恒成立，那么就会逐个警告缺少闭合标签，并调用 `options.end `将其闭合。\n\n## 6. 总结\n\n本篇文章主要介绍了`HTML`解析器的工作流程以及工作原理，文章比较长，但是逻辑并不复杂。\n\n首先介绍了`HTML`解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子函数生成对应的`AST`节点，最终完成将整个模板字符串转化成`AST`。\n\n接着介绍了`HTML`解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。\n\n其次，介绍了在解析器内维护了一个栈，用来保证构建的`AST`节点层级与真正`DOM`层级一致。\n\n了解了思想之后，最后回归源码，学习了源码中一些处理细节的地方。","slug":"Vue 源码阅读 模板编译（三）","published":1,"updated":"2019-12-31T03:25:01.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4wltj97008zzws6l7o9cqlb","content":"<h2><span id=\"1-前言\">1. 前言</span></h2>\n<p>上篇文章中我们说到，在模板解析阶段主线函数<code>parse</code>中，根据要解析的内容不同会调用不同的解析器，</p>\n<p>而在三个不同的解析器中最主要的当属<code>HTML</code>解析器，为什么这么说呢？因为<code>HTML</code>解析器主要负责解析出模板字符串中有哪些内容，然后根据不同的内容才能调用其他的解析器以及做相应的处理。那么本篇文章就来介绍一下<code>HTML</code>解析器是如何解析出模板字符串中包含的不同的内容的。</p>\n<h2><span id=\"2-html解析器内部运行流程\">2. HTML解析器内部运行流程</span></h2>\n<p>在源码中，<code>HTML</code>解析器就是<code>parseHTML</code>函数，在模板解析主线函数<code>parse</code>中调用了该函数，并传入两个参数，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码位置：/src/complier/parser/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Convert HTML string to AST.</span></span><br><span class=\"line\"><span class=\"comment\"> * 将HTML模板字符串转化为AST</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parse</span>(<span class=\"params\">template, options</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">  parseHTML(template, &#123;</span><br><span class=\"line\">    warn,</span><br><span class=\"line\">    expectHTML: options.expectHTML,</span><br><span class=\"line\">    isUnaryTag: options.isUnaryTag,</span><br><span class=\"line\">    canBeLeftOpenTag: options.canBeLeftOpenTag,</span><br><span class=\"line\">    shouldDecodeNewlines: options.shouldDecodeNewlines,</span><br><span class=\"line\">    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,</span><br><span class=\"line\">    shouldKeepComment: options.comments,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到开始标签时，调用该函数  </span></span><br><span class=\"line\">    start (tag, attrs, unary) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到结束标签时，调用该函数</span></span><br><span class=\"line\">    end () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到文本时，调用该函数  </span></span><br><span class=\"line\">    chars (text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到注释时，调用该函数  </span></span><br><span class=\"line\">    comment (text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p>\n<ul>\n<li>template:待转换的模板字符串；</li>\n<li>options:转换时所需的选项；</li>\n</ul>\n<p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析<code>HTML</code>模板时的一些参数，同时还定义了4个钩子函数。这4个钩子函数有什么作用呢？我们说了模板编译阶段主线函数<code>parse</code>会将<code>HTML</code>模板字符串转化成<code>AST</code>，而<code>parseHTML</code>是用来解析模板字符串的，把模板字符串中不同的内容出来之后，那么谁来把提取出来的内容生成对应的<code>AST</code>呢？答案就是这4个钩子函数。</p>\n<p>把这4个钩子函数作为参数传给解析器<code>parseHTML</code>，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的<code>AST</code>。</p>\n<ul>\n<li>\n<p>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当解析到标签的开始位置时，触发start</span></span><br><span class=\"line\">start (tag, attrs, unary) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> element = createASTElement(tag, attrs, currentParent)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createASTElement</span> (<span class=\"params\">tag,attrs,parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"number\">1</span>,</span><br><span class=\"line\">    tag,</span><br><span class=\"line\">    attrsList: attrs,</span><br><span class=\"line\">    attrsMap: makeAttrsMap(attrs),</span><br><span class=\"line\">    parent,</span><br><span class=\"line\">    children: []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中我们可以看到，<code>start</code>函数接收三个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</p>\n</li>\n<li>\n<p>当解析到结束标签时调用<code>end</code>函数；</p>\n</li>\n<li>\n<p>当解析到文本时调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当解析到标签的文本时，触发chars</span></span><br><span class=\"line\">chars (text) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(text是带变量的动态文本)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> element = &#123;</span><br><span class=\"line\">           type: <span class=\"number\">2</span>,</span><br><span class=\"line\">           expression: res.expression,</span><br><span class=\"line\">           tokens: res.tokens,</span><br><span class=\"line\">           text</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> element = &#123;</span><br><span class=\"line\">           type: <span class=\"number\">3</span>,</span><br><span class=\"line\">           text</span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当解析到标签的文本时，触发<code>chars</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello ”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</p>\n</li>\n<li>\n<p>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当解析到标签的注释时，触发comment</span></span><br><span class=\"line\">comment (text: string) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &#123;</span><br><span class=\"line\">        type: <span class=\"number\">3</span>,</span><br><span class=\"line\">        text,</span><br><span class=\"line\">        isComment: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</p>\n</li>\n</ul>\n<p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>,这就是<code>HTML</code>解析器所要做的工作。</p>\n<h2><span id=\"3-如何解析不同的内容\">3. 如何解析不同的内容</span></h2>\n<p>要从模板字符串中解析出不同的内容，那首先要知道模板字符串中都会包含哪些内容。那么通常我们所写的模板字符串中都会包含哪些内容呢？经过整理，通常模板内会包含如下内容：</p>\n<ul>\n<li>文本，例如“难凉热血”</li>\n<li>HTML注释，例如&lt;!-- 我是注释 --&gt;</li>\n<li>条件注释，例如&lt;!-- [if !IE]&gt; --&gt;我是注释&lt;!–&lt; ![endif]  --&gt;</li>\n<li>DOCTYPE，例如&lt;!DOCTYPE html&gt;</li>\n<li>开始标签，例如&lt;div&gt;</li>\n<li>结束标签，例如&lt;/div&gt;</li>\n</ul>\n<p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p>\n<p>下面，我们就来分别看一下<code>HTML</code>解析器是如何从模板字符串中将以上不同种类的内容进行解析出来。</p>\n<h3><span id=\"31-解析html注释\">3.1 解析HTML注释</span></h3>\n<p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容就是注释内容，那么我们只需用正则判断待解析的模板字符串<code>html</code>是否以<code>&lt;!--</code>开头，若是，那就继续向后寻找<code>--&gt;</code>，如果找到了，OK，注释就被解析出来了。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> comment = <span class=\"regexp\">/^&lt;!\\--/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (comment.test(html)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若为注释，则继续查找是否存在'--&gt;'</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> commentEnd = html.indexOf(<span class=\"string\">'--&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (commentEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若存在 '--&gt;',继续判断options中是否保留注释</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.shouldKeepComment) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点</span></span><br><span class=\"line\">            options.comment(html.substring(<span class=\"number\">4</span>, commentEnd))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 若不保留注释，则将游标移动到'--&gt;'之后，继续向后解析</span></span><br><span class=\"line\">        advance(commentEnd + <span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第4位（&quot;&lt;!–&quot;长度为4）开始截取，直到<code>--&gt;</code>处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的<code>comment</code>函数，将真实的注释内容传进去，创建注释类型的<code>AST</code>节点。</p>\n<p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code>选项来决定在渲染模板时是否保留注释，对应到上面代码中就是<code>options.shouldKeepComment</code>,如果用户配置了<code>comments</code>选项为<code>true</code>，则<code>shouldKeepComment</code>为<code>true</code>，则创建注释类型的<code>AST</code>节点，如不保留注释，则将游标移动到’–&gt;'之后，继续向后解析。</p>\n<p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">advance</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    index += n   <span class=\"comment\">// index为解析游标</span></span><br><span class=\"line\">    html = html.substring(n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了更加直观地说明 <code>advance</code> 的作用，请看下图：<br>\n<img src=\"/img/complie/5.png\" alt></p>\n<p>调用 <code>advance</code> 函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">advance(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>得到结果：<br>\n<img src=\"/img/complie/6.png\" alt></p>\n<p>从图中可以看到，解析游标<code>index</code>最开始在模板字符串的位置0处，当调用了<code>advance(3)</code>之后，解析游标到了位置3处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。</p>\n<h3><span id=\"32-解析条件注释\">3.2 解析条件注释</span></h3>\n<p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的<code>DOM</code>树中，所以不需要调用钩子函数创建<code>AST</code>节点。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析是否是条件注释</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> conditionalComment = <span class=\"regexp\">/^&lt;!\\[/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (conditionalComment.test(html)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若为条件注释，则继续查找是否存在']&gt;'</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> conditionalEnd = html.indexOf(<span class=\"string\">']&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (conditionalEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若存在 ']&gt;',则从原本的html字符串中把条件注释截掉，把剩下的内容重新赋给html，继续向后匹配</span></span><br><span class=\"line\">        advance(conditionalEnd + <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"33-解析doctype\">3.3 解析DOCTYPE</span></h3>\n<p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doctype = <span class=\"regexp\">/^&lt;!DOCTYPE [^&gt;]+&gt;/i</span></span><br><span class=\"line\"><span class=\"comment\">// 解析是否是DOCTYPE</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doctypeMatch = html.match(doctype)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (doctypeMatch) &#123;</span><br><span class=\"line\">    advance(doctypeMatch[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"34-解析开始标签\">3.4 解析开始标签</span></h3>\n<p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是相通的，都是使用正则去匹配提取。</p>\n<p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 匹配开始标签的正则</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ncname = <span class=\"string\">'[a-zA-Z_][\\\\w\\\\-\\\\.]*'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> qnameCapture = <span class=\"string\">`((?:<span class=\"subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"subst\">$&#123;ncname&#125;</span>)`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagOpen = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^&lt;<span class=\"subst\">$&#123;qnameCapture&#125;</span>`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> start = html.match(startTagOpen)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (start) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> match = &#123;</span><br><span class=\"line\">        tagName: start[<span class=\"number\">1</span>],</span><br><span class=\"line\">        attrs: [],</span><br><span class=\"line\">        start: index</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以开始标签开始的模板：</span></span><br><span class=\"line\"><span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>.match(startTagOpen)  =&gt; [<span class=\"string\">'&lt;div'</span>,<span class=\"string\">'div'</span>,<span class=\"attr\">index</span>:<span class=\"number\">0</span>,<span class=\"attr\">input</span>:<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>]</span><br><span class=\"line\"><span class=\"comment\">// 以结束标签开始的模板：</span></span><br><span class=\"line\"><span class=\"string\">'&lt;/div&gt;&lt;div&gt;&lt;/div&gt;'</span>.match(startTagOpen) =&gt; <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// 以文本开始的模板：</span></span><br><span class=\"line\"><span class=\"string\">'我是文本&lt;/p&gt;'</span>.match(startTagOpen) =&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>在上面代码中，我们用不同类型的内容去匹配开始标签的正则，发现只有<code>&lt;div&gt;&lt;/div&gt;</code>的字符串可以正确匹配，并且返回一个数组。</p>\n<p>在前文中我们说到，当解析到开始标签时，会调用4个钩子函数中的<code>start</code>函数，而<code>start</code>函数需要传递3个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。标签名通过正则匹配的结果就可以拿到，即上面代码中的<code>start[1]</code>，而标签属性<code>attrs</code>以及标签是否自闭合<code>unary</code>需要进一步解析。</p>\n<ol>\n<li>\n<p>解析标签属性</p>\n<p>我们知道，标签属性一般是写在开始标签的标签名之后的，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>另外，我们在上面匹配是否是开始标签的正则中已经可以拿到开始标签的标签名，即上面代码中的<code>start[0]</code>，那么我们可以将这一部分先从模板字符串中截掉，则剩下的部分如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class=\"a\" id=\"b\"&gt;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>那么我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> attribute = <span class=\"regexp\">/^\\s*([^\\s\"'&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=&lt;&gt;`]+)))?/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> html = <span class=\"string\">'class=\"a\" id=\"b\"&gt;&lt;/div&gt;'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> attr = html.match(attribute)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(attr)</span><br><span class=\"line\"><span class=\"comment\">// [\"class=\"a\"\", \"class\", \"=\", \"a\", undefined, undefined, index: 0, input: \"class=\"a\" id=\"b\"&gt;&lt;/div&gt;\", groups: undefined]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，第一个标签属性<code>class=&quot;a&quot;</code>已经被拿到了。另外，标签属性有可能有多个也有可能没有，如果没有的话那好办，匹配标签属性的正则就会匹配失败，标签属性就为空数组；而如果标签属性有多个的话，那就需要循环匹配了，匹配出第一个标签属性后，就把该属性截掉，用剩下的字符串继续匹配，直到不再满足正则为止，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> attribute = <span class=\"regexp\">/^\\s*([^\\s\"'&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=&lt;&gt;`]+)))?/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> match = &#123;</span><br><span class=\"line\">    tagName: start[<span class=\"number\">1</span>],</span><br><span class=\"line\">    attrs: [],</span><br><span class=\"line\">    start: index</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class=\"line\">    advance(attr[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    match.attrs.push(attr)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码的<code>while</code>循环中，如果剩下的字符串不符合开始标签的结束特征（startTagClose）并且符合标签属性的特征的话，那就说明还有未提取出的标签属性，那就进入循环，继续提取，直到把所有标签属性都提取完毕。</p>\n<p>所谓不符合开始标签的结束特征是指当前剩下的字符串不是以开始标签结束符开头的，我们知道一个开始标签的结束符有可能是一个<code>&gt;</code>（非自闭合标签），也有可能是<code>/&gt;</code>（自闭合标签），如果剩下的字符串（如<code>&gt;&lt;/div&gt;</code>）以开始标签的结束符开头，那么就表示标签属性已经被提取完毕了。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>解析标签是否是自闭合</p>\n<p>在<code>HTML</code>中，有自闭合标签（如<code>&lt;img src=&quot;&quot;/&gt;</code>）也有非自闭合标签（如<code>&lt;div&gt;&lt;/div&gt;</code>），这两种类型的标签在创建<code>AST</code>节点是处理方式是有区别的，所以我们需要解析出当前标签是否是自闭合标签。</p>\n<p>解析的方式很简单，我们知道，经过标签属性提取之后，那么剩下的字符串无非就两种，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--非自闭合标签--&gt;</span></span><br><span class=\"line\">&gt;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--自闭合标签--&gt;</span></span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n<p>所以我们可以用剩下的字符串去匹配开始标签结束符正则，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> end = html.match(startTagClose)</span><br><span class=\"line\"><span class=\"string\">'&gt;&lt;/div&gt;'</span>.match(startTagClose) <span class=\"comment\">// [\"&gt;\", \"\", index: 0, input: \"&gt;&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"string\">'/&gt;'</span>.match(startTagClose) <span class=\"comment\">// [\"/&gt;\", \"/\", index: 0, input: \"/&gt;&lt;div&gt;&lt;/div&gt;\", groups: undefined]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，非自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;&quot;</code>，而自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;/&quot;</code>。所以根据匹配结果的<code>end[1]</code>是否是<code>&quot;&quot;</code>我们即可判断出当前标签是否为自闭合标签，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> end = html.match(startTagClose)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">    match.unarySlash = end[<span class=\"number\">1</span>]</span><br><span class=\"line\">    advance(end[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    match.end = index</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>经过以上两步，开始标签就已经解析完毕了，完整源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ncname = <span class=\"string\">'[a-zA-Z_][\\\\w\\\\-\\\\.]*'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> qnameCapture = <span class=\"string\">`((?:<span class=\"subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"subst\">$&#123;ncname&#125;</span>)`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagOpen = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^&lt;<span class=\"subst\">$&#123;qnameCapture&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseStartTag</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> start = html.match(startTagOpen)</span><br><span class=\"line\">    <span class=\"comment\">// '&lt;div&gt;&lt;/div&gt;'.match(startTagOpen)  =&gt; ['&lt;div','div',index:0,input:'&lt;div&gt;&lt;/div&gt;']</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> match = &#123;</span><br><span class=\"line\">        tagName: start[<span class=\"number\">1</span>],</span><br><span class=\"line\">        attrs: [],</span><br><span class=\"line\">        start: index</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      advance(start[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> end, attr</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;div a=1 b=2 c=3&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">       * 从&lt;div之后到开始标签的结束符号'&gt;'之前，一直匹配属性attrs</span></span><br><span class=\"line\"><span class=\"comment\">       * 所有属性匹配完之后，html字符串还剩下 </span></span><br><span class=\"line\"><span class=\"comment\">       * 自闭合标签剩下：'/&gt;'</span></span><br><span class=\"line\"><span class=\"comment\">       * 非自闭合标签剩下：'&gt;&lt;/div&gt;'</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class=\"line\">        advance(attr[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">        match.attrs.push(attr)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 这里判断了该标签是否为自闭合标签</span></span><br><span class=\"line\"><span class=\"comment\">       * 自闭合标签如:&lt;input type='text' /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">       * 非自闭合标签如:&lt;div&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">       * '&gt;&lt;/div&gt;'.match(startTagClose) =&gt; [\"&gt;\", \"\", index: 0, input: \"&gt;&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"comment\">       * '/&gt;&lt;div&gt;&lt;/div&gt;'.match(startTagClose) =&gt; [\"/&gt;\", \"/\", index: 0, input: \"/&gt;&lt;div&gt;&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"comment\">       * 因此，我们可以通过end[1]是否是\"/\"来判断该标签是否是自闭合标签</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">        match.unarySlash = end[<span class=\"number\">1</span>]</span><br><span class=\"line\">        advance(end[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">        match.end = index</span><br><span class=\"line\">        <span class=\"keyword\">return</span> match</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过源码可以看到，调用<code>parseStartTag</code>函数，如果模板字符串符合开始标签的特征，则解析开始标签，并将解析结果返回，如果不符合开始标签的特征，则返回<code>undefined</code>。</p>\n<p>解析完毕后，就可以用解析得到的结果去调用<code>start</code>钩子函数去创建元素型的<code>AST</code>节点了。</p>\n<p>在源码中，<code>Vue</code>并没有直接去调<code>start</code>钩子函数去创建<code>AST</code>节点，而是调用了<code>handleStartTag</code>函数，在该函数内部才去调的<code>start</code>钩子函数，为什么要这样做呢？这是因为虽然经过<code>parseStartTag</code>函数已经把创建<code>AST</code>节点必要信息提取出来了，但是提取出来的标签属性数组还是需要处理一下，下面我们就来看一下<code>handleStartTag</code>函数都做了些什么事。<code>handleStartTag</code>函数源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStartTag</span> (<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tagName = match.tagName</span><br><span class=\"line\">    <span class=\"keyword\">const</span> unarySlash = match.unarySlash</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expectHTML) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> unary = isUnaryTag(tagName) || !!unarySlash</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = match.attrs.length</span><br><span class=\"line\">    <span class=\"keyword\">const</span> attrs = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(l)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> args = match.attrs[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> shouldDecodeNewlines = tagName === <span class=\"string\">'a'</span> &amp;&amp; args[<span class=\"number\">1</span>] === <span class=\"string\">'href'</span></span><br><span class=\"line\">        ? options.shouldDecodeNewlinesForHref</span><br><span class=\"line\">        : options.shouldDecodeNewlines</span><br><span class=\"line\">      attrs[i] = &#123;</span><br><span class=\"line\">        name: args[<span class=\"number\">1</span>],</span><br><span class=\"line\">        value: decodeAttr(value, shouldDecodeNewlines)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!unary) &#123;</span><br><span class=\"line\">      stack.push(&#123; <span class=\"attr\">tag</span>: tagName, <span class=\"attr\">lowerCasedTag</span>: tagName.toLowerCase(), <span class=\"attr\">attrs</span>: attrs &#125;)</span><br><span class=\"line\">      lastTag = tagName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">      options.start(tagName, attrs, unary, match.start, match.end)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><code>handleStartTag</code>函数用来对<code>parseStartTag</code>函数的解析结果进行进一步处理，它接收<code>parseStartTag</code>函数的返回值作为参数。</p>\n<p><code>handleStartTag</code>函数的开始定义几个常量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tagName = match.tagName       <span class=\"comment\">// 开始标签的标签名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unarySlash = match.unarySlash  <span class=\"comment\">// 是否为自闭合标签的标志，自闭合为\"\",非自闭合为\"/\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unary = isUnaryTag(tagName) || !!unarySlash  <span class=\"comment\">// 布尔值，标志是否为自闭合标签</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> l = match.attrs.length    <span class=\"comment\">// match.attrs 数组的长度</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> attrs = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(l)  <span class=\"comment\">// 一个与match.attrs数组长度相等的数组</span></span><br></pre></td></tr></table></figure>\n<p>接下来是循环处理提取出来的标签属性数组<code>match.attrs</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args = match.attrs[i]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> shouldDecodeNewlines = tagName === <span class=\"string\">'a'</span> &amp;&amp; args[<span class=\"number\">1</span>] === <span class=\"string\">'href'</span></span><br><span class=\"line\">    ? options.shouldDecodeNewlinesForHref</span><br><span class=\"line\">    : options.shouldDecodeNewlines</span><br><span class=\"line\">    attrs[i] = &#123;</span><br><span class=\"line\">        name: args[<span class=\"number\">1</span>],</span><br><span class=\"line\">        value: decodeAttr(value, shouldDecodeNewlines)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，首先定义了 <code>args</code>常量，它是解析出来的标签属性数组中的每一个属性对象，即<code>match.attrs</code> 数组中每个元素对象。 它长这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> args = [<span class=\"string\">\"class=\"</span>a<span class=\"string\">\"\"</span>, <span class=\"string\">\"class\"</span>, <span class=\"string\">\"=\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>, <span class=\"attr\">input</span>: <span class=\"string\">\"class=\"</span>a<span class=\"string\">\" id=\"</span>b<span class=\"string\">\"&gt;&lt;/div&gt;\"</span>, <span class=\"attr\">groups</span>: <span class=\"literal\">undefined</span>]</span><br></pre></td></tr></table></figure>\n<p>接着定义了<code>value</code>，用于存储标签属性的属性值，我们可以看到，在代码中尝试取<code>args</code>的<code>args[3]</code>、<code>args[4]</code>、<code>args[5]</code>，如果都取不到，则给<code>value</code>复制为空</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<p>接着定义了<code>shouldDecodeNewlines</code>，这个常量主要是做一些兼容性处理， 如果 <code>shouldDecodeNewlines</code> 为 <code>true</code>，意味着 <code>Vue</code> 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。而<code>shouldDecodeNewlinesForHref</code>为<code>true</code> 意味着<code>Vue</code>在编译模板的时候，要对<code>a</code>标签的 <code>href</code>属性值中的换行符或制表符做兼容处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shouldDecodeNewlines = tagName === <span class=\"string\">'a'</span> &amp;&amp; args[<span class=\"number\">1</span>] === <span class=\"string\">'href'</span></span><br><span class=\"line\">    ? options.shouldDecodeNewlinesForHref</span><br><span class=\"line\">    : options.shouldDecodeNewlinesconst value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<p>最后将处理好的结果存入之前定义好的与<code>match.attrs</code>数组长度相等的<code>attrs</code>数组中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attrs[i] = &#123;</span><br><span class=\"line\">    name: args[<span class=\"number\">1</span>],    <span class=\"comment\">// 标签属性的属性名，如class</span></span><br><span class=\"line\">    value: decodeAttr(value, shouldDecodeNewlines) <span class=\"comment\">// 标签属性的属性值，如class对应的a</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，如果该标签是非自闭合标签，则将标签推入栈中（关于栈这个概念后面会说到），如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!unary) &#123;</span><br><span class=\"line\">    stack.push(&#123; <span class=\"attr\">tag</span>: tagName, <span class=\"attr\">lowerCasedTag</span>: tagName.toLowerCase(), <span class=\"attr\">attrs</span>: attrs &#125;)</span><br><span class=\"line\">    lastTag = tagName</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果该标签是自闭合标签，现在就可以调用<code>start</code>钩子函数并传入处理好的参数来创建<code>AST</code>节点了，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">    options.start(tagName, attrs, unary, match.start, match.end)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是开始标签的解析以及调用<code>start</code>钩子函数创建元素型的<code>AST</code>节点的所有过程。</p>\n<h3><span id=\"35-解析结束标签\">3.5 解析结束标签</span></h3>\n<p>结束标签的解析要比解析开始标签容易多了，因为它不需要解析什么属性，只需要判断剩下的模板字符串是否符合结束标签的特征，如果是，就将结束标签名提取出来，再调用4个钩子函数中的<code>end</code>函数就好了。</p>\n<p>首先判断剩余的模板字符串是否符合结束标签的特征，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ncname = <span class=\"string\">'[a-zA-Z_][\\\\w\\\\-\\\\.]*'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> qnameCapture = <span class=\"string\">`((?:<span class=\"subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"subst\">$&#123;ncname&#125;</span>)`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> endTag = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^&lt;\\\\/<span class=\"subst\">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> endTagMatch = html.match(endTag)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'&lt;/div&gt;'</span>.match(endTag)  <span class=\"comment\">// [\"&lt;/div&gt;\", \"div\", index: 0, input: \"&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"string\">'&lt;div&gt;'</span>.match(endTag)  <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到null。</p>\n<p>接着再调用<code>end</code>钩子函数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (endTagMatch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> curIndex = index</span><br><span class=\"line\">    advance(endTagMatch[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    parseEndTag(endTagMatch[<span class=\"number\">1</span>], curIndex, index)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，没有直接去调用<code>end</code>函数，而是调用了<code>parseEndTag</code>函数，关于<code>parseEndTag</code>函数内部的作用我们后面会介绍到，在这里你暂时可以理解为该函数内部就是去调用了<code>end</code>钩子函数。</p>\n<h3><span id=\"36-解析文本\">3.6 解析文本</span></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">终于到了解析最后一种文本类型的内容了，为什么要把解析文本类型放在最后一个介绍呢？我们仔细想一下，前面五种类型都是以`&lt;`开头的，只有文本类型的内容不是以`&lt;`开头的，所以我们在解析模板字符串的时候可以先判断一下字符串是不是以`&lt;`开头的，如果是则继续判断是以上五种类型的具体哪一种，而如果不是的话，那它肯定就是文本了。</span><br></pre></td></tr></table></figure>\n<p>解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置，那么说明模板字符串是以其它5种类型开始的；如果第一个<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了；如果在整个模板字符串里没有找到<code>&lt;</code>，那说明整个模板字符串都是文本。这就是解析思路，接下来我们对照源码来了解一下实际的解析过程，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> textEnd = html.indexOf(<span class=\"string\">'&lt;'</span>)</span><br><span class=\"line\"><span class=\"comment\">// '&lt;' 在第一个位置，为其余5种类型</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (textEnd === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// '&lt;' 不在第一个位置，文本开头</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (textEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果html字符串不是以'&lt;'开头,说明'&lt;'前面的都是纯文本，无需处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 那就把'&lt;'以后的内容拿出来赋给rest</span></span><br><span class=\"line\">    rest = html.slice(textEnd)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">        !endTag.test(rest) &amp;&amp;</span><br><span class=\"line\">        !startTagOpen.test(rest) &amp;&amp;</span><br><span class=\"line\">        !comment.test(rest) &amp;&amp;</span><br><span class=\"line\">        !conditionalComment.test(rest)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &lt; in plain text, be forgiving and treat it as text</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">           * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span></span><br><span class=\"line\"><span class=\"comment\">           * 如果都匹配不上，表示'&lt;'是属于文本本身的内容</span></span><br><span class=\"line\"><span class=\"comment\">           */</span></span><br><span class=\"line\">        <span class=\"comment\">// 在'&lt;'之后查找是否还有'&lt;'</span></span><br><span class=\"line\">        next = rest.indexOf(<span class=\"string\">'&lt;'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有了，表示'&lt;'后面也是文本</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &lt; <span class=\"number\">0</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果还有，表示'&lt;'是文本中的一个字符</span></span><br><span class=\"line\">        textEnd += next</span><br><span class=\"line\">        <span class=\"comment\">// 那就把next之后的内容截出来继续下一轮循环匹配</span></span><br><span class=\"line\">        rest = html.slice(textEnd)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// '&lt;'是结束标签的开始 ,说明从开始到'&lt;'都是文本，截取出来</span></span><br><span class=\"line\">    text = html.substring(<span class=\"number\">0</span>, textEnd)</span><br><span class=\"line\">    advance(textEnd)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (textEnd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    text = html</span><br><span class=\"line\">    html = <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 把截取出来的text转化成textAST</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class=\"line\">    options.chars(text)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>源码的逻辑很清晰，根据<code>&lt;</code>在不在第一个位置以及整个模板字符串里没有<code>&lt;</code>都分别进行了处理。</p>\n<p>值得深究的是如果<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了，接着我们还要从第一个<code>&lt;</code>的位置继续向后判断，因为还存在这样一种情况，那就是如果文本里面本来就包含一个<code>&lt;</code>，例如<code>1&lt;2&lt;/div&gt;</code>。为了处理这种情况，我们把从第一个<code>&lt;</code>的位置直到模板字符串结束都截取出来记作<code>rest</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rest = html.slice(textEnd)</span><br></pre></td></tr></table></figure>\n<p>接着用<code>rest</code>去匹配以上5种类型的正则，如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (</span><br><span class=\"line\">    !endTag.test(rest) &amp;&amp;</span><br><span class=\"line\">    !startTagOpen.test(rest) &amp;&amp;</span><br><span class=\"line\">    !comment.test(rest) &amp;&amp;</span><br><span class=\"line\">    !conditionalComment.test(rest)</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，接着以这个<code>&lt;</code>的位置继续向后查找，看是否还有<code>&lt;</code>，如果没有了，则表示后面的都是文本；如果后面还有下一个<code>&lt;</code>，那表明至少在这个<code>&lt;</code>到下一个<code>&lt;</code>中间的内容都是文本，至于下一个<code>&lt;</code>以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (</span><br><span class=\"line\">    !endTag.test(rest) &amp;&amp;</span><br><span class=\"line\">    !startTagOpen.test(rest) &amp;&amp;</span><br><span class=\"line\">    !comment.test(rest) &amp;&amp;</span><br><span class=\"line\">    !conditionalComment.test(rest)</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &lt; in plain text, be forgiving and treat it as text</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果都匹配不上，表示'&lt;'是属于文本本身的内容</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 在'&lt;'之后查找是否还有'&lt;'</span></span><br><span class=\"line\">    next = rest.indexOf(<span class=\"string\">'&lt;'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有了，表示'&lt;'后面也是文本</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next &lt; <span class=\"number\">0</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果还有，表示'&lt;'是文本中的一个字符</span></span><br><span class=\"line\">    textEnd += next</span><br><span class=\"line\">    <span class=\"comment\">// 那就把next之后的内容截出来继续下一轮循环匹配</span></span><br><span class=\"line\">    rest = html.slice(textEnd)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后截取文本内容<code>text</code>并调用4个钩子函数中的<code>chars</code>函数创建文本型的<code>AST</code>节点。</p>\n<h2><span id=\"4-如何保证ast节点层级关系\">4. 如何保证AST节点层级关系</span></h2>\n<p>上一章节我们介绍了<code>HTML</code>解析器是如何解析各种不同类型的内容并且调用钩子函数创建不同类型的<code>AST</code>节点。此时你可能会有个疑问，我们上面创建的<code>AST</code>节点都是单独创建且分散的，而真正的<code>DOM</code>节点都是有层级关系的，那如何来保证<code>AST</code>节点的层级关系与真正的<code>DOM</code>节点相同呢？</p>\n<p>关于这个问题，<code>Vue</code>也注意到了。<code>Vue</code>在<code>HTML</code>解析器的开头定义了一个栈<code>stack</code>，这个栈的作用就是用来维护<code>AST</code>节点层级的，那么它是怎么维护的呢？通过前文我们知道，<code>HTML</code>解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用<code>start</code>钩子函数，那么在<code>start</code>钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用<code>end</code>钩子函数，那么我们也可以在<code>end</code>钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。请看如下例子：</p>\n<p>加入有如下模板字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当解析到开始标签<code>&lt;div&gt;</code>时，就把<code>div</code>推入栈中，然后继续解析，当解析到<code>&lt;p&gt;</code>时，再把<code>p</code>推入栈中，同理，再把<code>span</code>推入栈中，当解析到结束标签<code>&lt;/span&gt;</code>时，此时栈顶的标签刚好是<code>span</code>的开始标签，那么就用<code>span</code>的开始标签和结束标签构建<code>AST</code>节点，并且从栈中把<code>span</code>的开始标签弹出，那么此时栈中的栈顶标签<code>p</code>就是构建好的<code>span</code>的<code>AST</code>节点的父节点，如下图：</p>\n<p><img src=\"/img/complie/7.png\" alt></p>\n<p>这样我们就找到了当前被构建节点的父节点。这只是栈的一个用途，它还有另外一个用途，我们再看如下模板字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>按照上面的流程解析这个模板字符串时，当解析到结束标签<code>&lt;/p&gt;</code>时，此时栈顶的标签应该是<code>p</code>才对，而现在是<code>span</code>，那么就说明<code>span</code>标签没有被正确闭合，此时控制台就会抛出警告：‘tag  has no matching end tag.’相信这个警告你一定不会陌生。这就是栈的第二个用途： 检测模板字符串中是否有未正确闭合的标签。</p>\n<p>OK，有了这个栈的概念之后，我们再回看上一章<code>HTML</code>解析器解析不同内容的代码。</p>\n<h2><span id=\"5-回归源码\">5. 回归源码</span></h2>\n<h3><span id=\"51-html解析器源码\">5.1 HTML解析器源码</span></h3>\n<p>以上内容都了解了之后，我们回归源码，逐句分析<code>HTML</code>解析器<code>parseHTML</code>函数，函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseHTML</span>(<span class=\"params\">html, options</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> expectHTML = options.expectHTML;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> isUnaryTag$$<span class=\"number\">1</span> = options.isUnaryTag || no;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> canBeLeftOpenTag$$<span class=\"number\">1</span> = options.canBeLeftOpenTag || no;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> last, lastTag;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (html) &#123;</span><br><span class=\"line\">\t\tlast = html;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">let</span> textEnd = html.indexOf(<span class=\"string\">'&lt;'</span>)</span><br><span class=\"line\">              <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">               * 如果html字符串是以'&lt;'开头,则有以下几种可能</span></span><br><span class=\"line\"><span class=\"comment\">               * 开始标签:&lt;div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 结束标签:&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 注释:&lt;!-- 我是注释 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * DOCTYPE:&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 需要一一去匹配尝试</span></span><br><span class=\"line\"><span class=\"comment\">               */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (textEnd === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是注释</span></span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> (comment.test(html)) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是条件注释</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (conditionalComment.test(html)) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是DOCTYPE</span></span><br><span class=\"line\">                <span class=\"keyword\">const</span> doctypeMatch = html.match(doctype)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (doctypeMatch) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是结束标签</span></span><br><span class=\"line\">                <span class=\"keyword\">const</span> endTagMatch = html.match(endTag)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (endTagMatch) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 匹配是否是开始标签</span></span><br><span class=\"line\">                <span class=\"keyword\">const</span> startTagMatch = parseStartTag()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (startTagMatch) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"comment\">// 如果html字符串不是以'&lt;'开头,则解析文本类型</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> text, rest, next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (textEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果在html字符串中没有找到'&lt;'，表示这一段html字符串都是纯文本</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (textEnd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                text = html</span><br><span class=\"line\">                html = <span class=\"string\">''</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 把截取出来的text转化成textAST</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class=\"line\">                options.chars(text)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将整个字符串作为文本对待</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (html === last) &#123;</span><br><span class=\"line\">\t\t\toptions.chars &amp;&amp; options.chars(html);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!stack.length &amp;&amp; options.warn) &#123;</span><br><span class=\"line\">\t\t\t\toptions.warn((<span class=\"string\">\"Mal-formatted tag at end of template: \\\"\"</span> + html + <span class=\"string\">\"\\\"\"</span>));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Clean up any remaining tags</span></span><br><span class=\"line\">\tparseEndTag();</span><br><span class=\"line\">\t<span class=\"comment\">//parse 开始标签</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseStartTag</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//处理 parseStartTag 的结果</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStartTag</span>(<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//parse 结束标签</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseEndTag</span>(<span class=\"params\">tagName, start, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中大致可分为三部分：</p>\n<ul>\n<li>定义的一些常量和变量</li>\n<li>while 循环</li>\n<li>解析过程中用到的辅助函数</li>\n</ul>\n<p>我们一一来分析：</p>\n<p>首先定义了几个常量，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stack = []       <span class=\"comment\">// 维护AST节点层级的栈</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> expectHTML = options.expectHTML</span><br><span class=\"line\"><span class=\"keyword\">const</span> isUnaryTag = options.isUnaryTag || no</span><br><span class=\"line\"><span class=\"keyword\">const</span> canBeLeftOpenTag = options.canBeLeftOpenTag || no   <span class=\"comment\">//用来检测一个标签是否是可以省略闭合标签的非自闭合标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> index = <span class=\"number\">0</span>   <span class=\"comment\">//解析游标，标识当前从何处开始解析模板字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> last,   <span class=\"comment\">// 存储剩余还未解析的模板字符串</span></span><br><span class=\"line\">    lastTag  <span class=\"comment\">// 存储着位于 stack 栈顶的元素</span></span><br></pre></td></tr></table></figure>\n<p>接着开启<code>while</code> 循环，循环的终止条件是 模板字符串<code>html</code>为空，即模板字符串被全部编译完毕。在每次<code>while</code>循环中， 先把 <code>html</code>的值赋给变量 <code>last</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">last = html</span><br></pre></td></tr></table></figure>\n<p>这样做的目的是，如果经过上述所有处理逻辑处理过后，<code>html</code>字符串没有任何变化，即表示<code>html</code>字符串没有匹配上任何一条规则，那么就把<code>html</code>字符串当作纯文本对待，创建文本类型的<code>AST</code>节点并且如果抛出异常：模板字符串中标签格式有误。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将整个字符串作为文本对待</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (html === last) &#123;</span><br><span class=\"line\">    options.chars &amp;&amp; options.chars(html);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stack.length &amp;&amp; options.warn) &#123;</span><br><span class=\"line\">        options.warn((<span class=\"string\">\"Mal-formatted tag at end of template: \\\"\"</span> + html + <span class=\"string\">\"\\\"\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着，我们继续看<code>while</code>循环体内的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (html) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// parse 的内容是在纯文本标签里 (script,style,textarea)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在循环体内，首先判断了待解析的<code>html</code>字符串是否在纯文本标签里，如<code>script</code>,<code>style</code>,<code>textarea</code>，因为在这三个标签里的内容肯定不会有<code>HTML</code>标签，所以我们可直接当作文本处理，判断条件如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!lastTag || !isPlainTextElement(lastTag)</span><br></pre></td></tr></table></figure>\n<p>前面我们说了，<code>lastTag</code>为栈顶元素，<code>!lastTag</code>即表示当前<code>html</code>字符串没有父节点，而<code>isPlainTextElement(lastTag)</code> 是检测 <code>lastTag</code> 是否为是那三个纯文本标签之一，是的话返回<code>true</code>，不是返回<code>fasle</code>。</p>\n<p>也就是说当前<code>html</code>字符串要么没有父节点要么父节点不是纯文本标签，则接下来就可以依次解析那6种类型的内容了，关于6种类型内容的处理方式前文已经逐个介绍过，此处不再重复。</p>\n<h3><span id=\"52-parseendtag函数源码\">5.2 parseEndTag函数源码</span></h3>\n<p>接下来我们看一下之前在解析结束标签时遗留的<code>parseEndTag</code>函数，该函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseEndTag</span> (<span class=\"params\">tagName, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pos, lowerCasedTagName</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == <span class=\"literal\">null</span>) start = index</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end == <span class=\"literal\">null</span>) end = index</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tagName) &#123;</span><br><span class=\"line\">      lowerCasedTagName = tagName.toLowerCase()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find the closest opened tag of the same type</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tagName) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (pos = stack.length - <span class=\"number\">1</span>; pos &gt;= <span class=\"number\">0</span>; pos--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If no tag name is provided, clean shop</span></span><br><span class=\"line\">      pos = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pos &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Close all the open elements, up the stack</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = stack.length - <span class=\"number\">1</span>; i &gt;= pos; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">          (i &gt; pos || !tagName) &amp;&amp;</span><br><span class=\"line\">          options.warn</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          options.warn(</span><br><span class=\"line\">            <span class=\"string\">`tag &lt;<span class=\"subst\">$&#123;stack[i].tag&#125;</span>&gt; has no matching end tag.`</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">          options.end(stack[i].tag, start, end)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Remove the open elements from the stack</span></span><br><span class=\"line\">      stack.length = pos</span><br><span class=\"line\">      lastTag = pos &amp;&amp; stack[pos - <span class=\"number\">1</span>].tag</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'br'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">true</span>, start, end)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'p'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">false</span>, start, end)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">        options.end(tagName, start, end)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数接收三个参数，分别是结束标签名<code>tagName</code>、结束标签在<code>html</code>字符串中的起始和结束位置<code>start</code>和<code>end</code>。</p>\n<p>这三个参数其实都是可选的，根据传参的不同其功能也不同。</p>\n<ul>\n<li>第一种是三个参数都传递，用于处理普通的结束标签</li>\n<li>第二种是只传递<code>tagName</code></li>\n<li>第三种是三个参数都不传递，用于处理栈中剩余未处理的标签</li>\n</ul>\n<p>如果<code>tagName</code>存在，那么就从后往前遍历栈，在栈中寻找与<code>tagName</code>相同的标签并记录其所在的位置<code>pos</code>，如果<code>tagName</code>不存在，则将<code>pos</code>置为0。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (tagName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pos = stack.length - <span class=\"number\">1</span>; pos &gt;= <span class=\"number\">0</span>; pos--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If no tag name is provided, clean shop</span></span><br><span class=\"line\">    pos = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着当<code>pos&gt;=0</code>时，开启一个<code>for</code>循环，从栈顶位置从后向前遍历直到<code>pos</code>处，如果发现<code>stack</code>栈中存在索引大于<code>pos</code>的元素，那么该元素一定是缺少闭合标签的。这是因为在正常情况下，<code>stack</code>栈的栈顶元素应该和当前的结束标签<code>tagName</code> 匹配，也就是说正常的<code>pos</code>应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签 那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用 <code>options.end(stack[i].tag, start, end)</code>立即将其闭合，这是为了保证解析结果的正确性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (pos &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Close all the open elements, up the stack</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = stack.length - <span class=\"number\">1</span>; i &gt;= pos; i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &gt; pos || !tagName ) &#123;</span><br><span class=\"line\">\t\t\toptions.warn(</span><br><span class=\"line\">\t\t\t\t(<span class=\"string\">\"tag &lt;\"</span> + (stack[i].tag) + <span class=\"string\">\"&gt; has no matching end tag.\"</span>)</span><br><span class=\"line\">\t\t\t);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">\t\t\toptions.end(stack[i].tag, start, end);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Remove the open elements from the stack</span></span><br><span class=\"line\">\tstack.length = pos;</span><br><span class=\"line\">\tlastTag = pos &amp;&amp; stack[pos - <span class=\"number\">1</span>].tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后把<code>pos</code>位置以后的元素都从<code>stack</code>栈中弹出，以及把<code>lastTag</code>更新为栈顶元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack.length = pos;</span><br><span class=\"line\">lastTag = pos &amp;&amp; stack[pos - <span class=\"number\">1</span>].tag;</span><br></pre></td></tr></table></figure>\n<p>接着，如果<code>pos</code>没有大于等于0，即当 <code>tagName</code> 没有在 <code>stack</code> 栈中找到对应的开始标签时，<code>pos</code> 为 -1 。那么此时再判断 <code>tagName</code> 是否为<code>br</code> 或<code>p</code>标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下<code>HTML</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>浏览器会自动把<code>&lt;/br&gt;</code>标签解析为正常的 &lt;br&gt;标签，而对于<code>&lt;/p&gt;</code>浏览器则自动将其补全为<code>&lt;p&gt;&lt;/p&gt;</code>，所以<code>Vue</code>为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'br'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.start) &#123;   </span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">true</span>, start, end)  <span class=\"comment\">// 创建&lt;br&gt;AST节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// 补全p标签并创建AST节点</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'p'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">false</span>, start, end)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">        options.end(tagName, start, end)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是对结束标签的解析与处理。</p>\n<p>另外，在<code>while</code>循环后面还有一行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseEndTag()</span><br></pre></td></tr></table></figure>\n<p>这行代码执行的时机是<code>html === last</code>，即<code>html</code>字符串中的标签格式有误时会跳出<code>while</code>循环，此时就会执行这行代码，这行代码是调用<code>parseEndTag</code>函数并不传递任何参数，前面我们说过如果<code>parseEndTag</code>函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时<code>parseEndTag</code>函数里的<code>pos</code>就为0，那么<code>pos&gt;=0</code>就会恒成立，那么就会逐个警告缺少闭合标签，并调用 <code>options.end</code>将其闭合。</p>\n<h2><span id=\"6-总结\">6. 总结</span></h2>\n<p>本篇文章主要介绍了<code>HTML</code>解析器的工作流程以及工作原理，文章比较长，但是逻辑并不复杂。</p>\n<p>首先介绍了<code>HTML</code>解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>。</p>\n<p>接着介绍了<code>HTML</code>解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。</p>\n<p>其次，介绍了在解析器内维护了一个栈，用来保证构建的<code>AST</code>节点层级与真正<code>DOM</code>层级一致。</p>\n<p>了解了思想之后，最后回归源码，学习了源码中一些处理细节的地方。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>1. 前言</h2>\n<p>上篇文章中我们说到，在模板解析阶段主线函数<code>parse</code>中，根据要解析的内容不同会调用不同的解析器，</p>\n<p>而在三个不同的解析器中最主要的当属<code>HTML</code>解析器，为什么这么说呢？因为<code>HTML</code>解析器主要负责解析出模板字符串中有哪些内容，然后根据不同的内容才能调用其他的解析器以及做相应的处理。那么本篇文章就来介绍一下<code>HTML</code>解析器是如何解析出模板字符串中包含的不同的内容的。</p>\n<h2>2. HTML解析器内部运行流程</h2>\n<p>在源码中，<code>HTML</code>解析器就是<code>parseHTML</code>函数，在模板解析主线函数<code>parse</code>中调用了该函数，并传入两个参数，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码位置：/src/complier/parser/index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Convert HTML string to AST.</span></span><br><span class=\"line\"><span class=\"comment\"> * 将HTML模板字符串转化为AST</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parse</span>(<span class=\"params\">template, options</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">  parseHTML(template, &#123;</span><br><span class=\"line\">    warn,</span><br><span class=\"line\">    expectHTML: options.expectHTML,</span><br><span class=\"line\">    isUnaryTag: options.isUnaryTag,</span><br><span class=\"line\">    canBeLeftOpenTag: options.canBeLeftOpenTag,</span><br><span class=\"line\">    shouldDecodeNewlines: options.shouldDecodeNewlines,</span><br><span class=\"line\">    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,</span><br><span class=\"line\">    shouldKeepComment: options.comments,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到开始标签时，调用该函数  </span></span><br><span class=\"line\">    start (tag, attrs, unary) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到结束标签时，调用该函数</span></span><br><span class=\"line\">    end () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到文本时，调用该函数  </span></span><br><span class=\"line\">    chars (text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 当解析到注释时，调用该函数  </span></span><br><span class=\"line\">    comment (text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码中我们可以看到，调用<code>parseHTML</code>函数时为其传入的两个参数分别是：</p>\n<ul>\n<li>template:待转换的模板字符串；</li>\n<li>options:转换时所需的选项；</li>\n</ul>\n<p>第一个参数是待转换的模板字符串，无需多言；重点看第二个参数，第二个参数提供了一些解析<code>HTML</code>模板时的一些参数，同时还定义了4个钩子函数。这4个钩子函数有什么作用呢？我们说了模板编译阶段主线函数<code>parse</code>会将<code>HTML</code>模板字符串转化成<code>AST</code>，而<code>parseHTML</code>是用来解析模板字符串的，把模板字符串中不同的内容出来之后，那么谁来把提取出来的内容生成对应的<code>AST</code>呢？答案就是这4个钩子函数。</p>\n<p>把这4个钩子函数作为参数传给解析器<code>parseHTML</code>，当解析器解析出不同的内容时调用不同的钩子函数从而生成不同的<code>AST</code>。</p>\n<ul>\n<li>\n<p>当解析到开始标签时调用<code>start</code>函数生成元素类型的<code>AST</code>节点，代码如下；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当解析到标签的开始位置时，触发start</span></span><br><span class=\"line\">start (tag, attrs, unary) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> element = createASTElement(tag, attrs, currentParent)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createASTElement</span> (<span class=\"params\">tag,attrs,parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"number\">1</span>,</span><br><span class=\"line\">    tag,</span><br><span class=\"line\">    attrsList: attrs,</span><br><span class=\"line\">    attrsMap: makeAttrsMap(attrs),</span><br><span class=\"line\">    parent,</span><br><span class=\"line\">    children: []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面代码中我们可以看到，<code>start</code>函数接收三个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。当调用该钩子函数时，内部会调用<code>createASTElement</code>函数来创建元素类型的<code>AST</code>节点</p>\n</li>\n<li>\n<p>当解析到结束标签时调用<code>end</code>函数；</p>\n</li>\n<li>\n<p>当解析到文本时调用<code>chars</code>函数生成文本类型的<code>AST</code>节点；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当解析到标签的文本时，触发chars</span></span><br><span class=\"line\">chars (text) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(text是带变量的动态文本)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> element = &#123;</span><br><span class=\"line\">           type: <span class=\"number\">2</span>,</span><br><span class=\"line\">           expression: res.expression,</span><br><span class=\"line\">           tokens: res.tokens,</span><br><span class=\"line\">           text</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">let</span> element = &#123;</span><br><span class=\"line\">           type: <span class=\"number\">3</span>,</span><br><span class=\"line\">           text</span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当解析到标签的文本时，触发<code>chars</code>钩子函数，在该钩子函数内部，首先会判断文本是不是一个带变量的动态文本，如“hello ”。如果是动态文本，则创建动态文本类型的<code>AST</code>节点；如果不是动态文本，则创建纯静态文本类型的<code>AST</code>节点。</p>\n</li>\n<li>\n<p>当解析到注释时调用<code>comment</code>函数生成注释类型的<code>AST</code>节点；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当解析到标签的注释时，触发comment</span></span><br><span class=\"line\">comment (text: string) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = &#123;</span><br><span class=\"line\">        type: <span class=\"number\">3</span>,</span><br><span class=\"line\">        text,</span><br><span class=\"line\">        isComment: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当解析到标签的注释时，触发<code>comment</code>钩子函数，该钩子函数会创建一个注释类型的<code>AST</code>节点。</p>\n</li>\n</ul>\n<p>一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>,这就是<code>HTML</code>解析器所要做的工作。</p>\n<h2>3. 如何解析不同的内容</h2>\n<p>要从模板字符串中解析出不同的内容，那首先要知道模板字符串中都会包含哪些内容。那么通常我们所写的模板字符串中都会包含哪些内容呢？经过整理，通常模板内会包含如下内容：</p>\n<ul>\n<li>文本，例如“难凉热血”</li>\n<li>HTML注释，例如&lt;!-- 我是注释 --&gt;</li>\n<li>条件注释，例如&lt;!-- [if !IE]&gt; --&gt;我是注释&lt;!–&lt; ![endif]  --&gt;</li>\n<li>DOCTYPE，例如&lt;!DOCTYPE html&gt;</li>\n<li>开始标签，例如&lt;div&gt;</li>\n<li>结束标签，例如&lt;/div&gt;</li>\n</ul>\n<p>这几种内容都有其各自独有的特点，也就是说我们要根据不同内容所具有的不同的的特点通过编写不同的正则表达式将这些内容从模板字符串中一一解析出来，然后再把不同的内容做不同的处理。</p>\n<p>下面，我们就来分别看一下<code>HTML</code>解析器是如何从模板字符串中将以上不同种类的内容进行解析出来。</p>\n<h3>3.1 解析HTML注释</h3>\n<p>解析注释比较简单，我们知道<code>HTML</code>注释是以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，这两者中间的内容就是注释内容，那么我们只需用正则判断待解析的模板字符串<code>html</code>是否以<code>&lt;!--</code>开头，若是，那就继续向后寻找<code>--&gt;</code>，如果找到了，OK，注释就被解析出来了。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> comment = <span class=\"regexp\">/^&lt;!\\--/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (comment.test(html)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若为注释，则继续查找是否存在'--&gt;'</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> commentEnd = html.indexOf(<span class=\"string\">'--&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (commentEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若存在 '--&gt;',继续判断options中是否保留注释</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.shouldKeepComment) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若保留注释，则把注释截取出来传给options.comment，创建注释类型的AST节点</span></span><br><span class=\"line\">            options.comment(html.substring(<span class=\"number\">4</span>, commentEnd))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 若不保留注释，则将游标移动到'--&gt;'之后，继续向后解析</span></span><br><span class=\"line\">        advance(commentEnd + <span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，如果模板字符串<code>html</code>符合注释开始的正则，那么就继续向后查找是否存在<code>--&gt;</code>，若存在，则把<code>html</code>从第4位（&quot;&lt;!–&quot;长度为4）开始截取，直到<code>--&gt;</code>处，截取得到的内容就是注释的真实内容，然后调用4个钩子函数中的<code>comment</code>函数，将真实的注释内容传进去，创建注释类型的<code>AST</code>节点。</p>\n<p>上面代码中有一处值得注意的地方，那就是我们平常在模板中可以在<code>&lt;template&gt;&lt;/template&gt;</code>标签上配置<code>comments</code>选项来决定在渲染模板时是否保留注释，对应到上面代码中就是<code>options.shouldKeepComment</code>,如果用户配置了<code>comments</code>选项为<code>true</code>，则<code>shouldKeepComment</code>为<code>true</code>，则创建注释类型的<code>AST</code>节点，如不保留注释，则将游标移动到’–&gt;'之后，继续向后解析。</p>\n<p><code>advance</code>函数是用来移动解析游标的，解析完一部分就把游标向后移动一部分，确保不会重复解析，其代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">advance</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    index += n   <span class=\"comment\">// index为解析游标</span></span><br><span class=\"line\">    html = html.substring(n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了更加直观地说明 <code>advance</code> 的作用，请看下图：<br>\n<img src=\"/img/complie/5.png\" alt></p>\n<p>调用 <code>advance</code> 函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">advance(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>得到结果：<br>\n<img src=\"/img/complie/6.png\" alt></p>\n<p>从图中可以看到，解析游标<code>index</code>最开始在模板字符串的位置0处，当调用了<code>advance(3)</code>之后，解析游标到了位置3处，每次解析完一段内容就将游标向后移动一段，接着再从解析游标往后解析，这样就保证了解析过的内容不会被重复解析。</p>\n<h3>3.2 解析条件注释</h3>\n<p>解析条件注释也比较简单，其原理跟解析注释相同，都是先用正则判断是否是以条件注释特有的开头标识开始，然后寻找其特有的结束标识，若找到，则说明是条件注释，将其截取出来即可，由于条件注释不存在于真正的<code>DOM</code>树中，所以不需要调用钩子函数创建<code>AST</code>节点。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析是否是条件注释</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> conditionalComment = <span class=\"regexp\">/^&lt;!\\[/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (conditionalComment.test(html)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若为条件注释，则继续查找是否存在']&gt;'</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> conditionalEnd = html.indexOf(<span class=\"string\">']&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (conditionalEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若存在 ']&gt;',则从原本的html字符串中把条件注释截掉，把剩下的内容重新赋给html，继续向后匹配</span></span><br><span class=\"line\">        advance(conditionalEnd + <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>3.3 解析DOCTYPE</h3>\n<p>解析<code>DOCTYPE</code>的原理同解析条件注释完全相同，此处不再赘述，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doctype = <span class=\"regexp\">/^&lt;!DOCTYPE [^&gt;]+&gt;/i</span></span><br><span class=\"line\"><span class=\"comment\">// 解析是否是DOCTYPE</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doctypeMatch = html.match(doctype)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (doctypeMatch) &#123;</span><br><span class=\"line\">    advance(doctypeMatch[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>3.4 解析开始标签</h3>\n<p>相较于前三种内容的解析，解析开始标签会稍微复杂一点，但是万变不离其宗，它的原理还是相通的，都是使用正则去匹配提取。</p>\n<p>首先使用开始标签的正则去匹配模板字符串，看模板字符串是否具有开始标签的特征，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 匹配开始标签的正则</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ncname = <span class=\"string\">'[a-zA-Z_][\\\\w\\\\-\\\\.]*'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> qnameCapture = <span class=\"string\">`((?:<span class=\"subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"subst\">$&#123;ncname&#125;</span>)`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagOpen = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^&lt;<span class=\"subst\">$&#123;qnameCapture&#125;</span>`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> start = html.match(startTagOpen)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (start) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> match = &#123;</span><br><span class=\"line\">        tagName: start[<span class=\"number\">1</span>],</span><br><span class=\"line\">        attrs: [],</span><br><span class=\"line\">        start: index</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以开始标签开始的模板：</span></span><br><span class=\"line\"><span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>.match(startTagOpen)  =&gt; [<span class=\"string\">'&lt;div'</span>,<span class=\"string\">'div'</span>,<span class=\"attr\">index</span>:<span class=\"number\">0</span>,<span class=\"attr\">input</span>:<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>]</span><br><span class=\"line\"><span class=\"comment\">// 以结束标签开始的模板：</span></span><br><span class=\"line\"><span class=\"string\">'&lt;/div&gt;&lt;div&gt;&lt;/div&gt;'</span>.match(startTagOpen) =&gt; <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// 以文本开始的模板：</span></span><br><span class=\"line\"><span class=\"string\">'我是文本&lt;/p&gt;'</span>.match(startTagOpen) =&gt; <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>在上面代码中，我们用不同类型的内容去匹配开始标签的正则，发现只有<code>&lt;div&gt;&lt;/div&gt;</code>的字符串可以正确匹配，并且返回一个数组。</p>\n<p>在前文中我们说到，当解析到开始标签时，会调用4个钩子函数中的<code>start</code>函数，而<code>start</code>函数需要传递3个参数，分别是标签名<code>tag</code>、标签属性<code>attrs</code>、标签是否自闭合<code>unary</code>。标签名通过正则匹配的结果就可以拿到，即上面代码中的<code>start[1]</code>，而标签属性<code>attrs</code>以及标签是否自闭合<code>unary</code>需要进一步解析。</p>\n<ol>\n<li>\n<p>解析标签属性</p>\n<p>我们知道，标签属性一般是写在开始标签的标签名之后的，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"a\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>另外，我们在上面匹配是否是开始标签的正则中已经可以拿到开始标签的标签名，即上面代码中的<code>start[0]</code>，那么我们可以将这一部分先从模板字符串中截掉，则剩下的部分如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class=\"a\" id=\"b\"&gt;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>那么我们只需用剩下的这部分去匹配标签属性的正则，就可以将标签属性提取出来了，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> attribute = <span class=\"regexp\">/^\\s*([^\\s\"'&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=&lt;&gt;`]+)))?/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> html = <span class=\"string\">'class=\"a\" id=\"b\"&gt;&lt;/div&gt;'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> attr = html.match(attribute)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(attr)</span><br><span class=\"line\"><span class=\"comment\">// [\"class=\"a\"\", \"class\", \"=\", \"a\", undefined, undefined, index: 0, input: \"class=\"a\" id=\"b\"&gt;&lt;/div&gt;\", groups: undefined]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，第一个标签属性<code>class=&quot;a&quot;</code>已经被拿到了。另外，标签属性有可能有多个也有可能没有，如果没有的话那好办，匹配标签属性的正则就会匹配失败，标签属性就为空数组；而如果标签属性有多个的话，那就需要循环匹配了，匹配出第一个标签属性后，就把该属性截掉，用剩下的字符串继续匹配，直到不再满足正则为止，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> attribute = <span class=\"regexp\">/^\\s*([^\\s\"'&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=&lt;&gt;`]+)))?/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> match = &#123;</span><br><span class=\"line\">    tagName: start[<span class=\"number\">1</span>],</span><br><span class=\"line\">    attrs: [],</span><br><span class=\"line\">    start: index</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class=\"line\">    advance(attr[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    match.attrs.push(attr)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码的<code>while</code>循环中，如果剩下的字符串不符合开始标签的结束特征（startTagClose）并且符合标签属性的特征的话，那就说明还有未提取出的标签属性，那就进入循环，继续提取，直到把所有标签属性都提取完毕。</p>\n<p>所谓不符合开始标签的结束特征是指当前剩下的字符串不是以开始标签结束符开头的，我们知道一个开始标签的结束符有可能是一个<code>&gt;</code>（非自闭合标签），也有可能是<code>/&gt;</code>（自闭合标签），如果剩下的字符串（如<code>&gt;&lt;/div&gt;</code>）以开始标签的结束符开头，那么就表示标签属性已经被提取完毕了。</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>解析标签是否是自闭合</p>\n<p>在<code>HTML</code>中，有自闭合标签（如<code>&lt;img src=&quot;&quot;/&gt;</code>）也有非自闭合标签（如<code>&lt;div&gt;&lt;/div&gt;</code>），这两种类型的标签在创建<code>AST</code>节点是处理方式是有区别的，所以我们需要解析出当前标签是否是自闭合标签。</p>\n<p>解析的方式很简单，我们知道，经过标签属性提取之后，那么剩下的字符串无非就两种，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--非自闭合标签--&gt;</span></span><br><span class=\"line\">&gt;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--自闭合标签--&gt;</span></span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n<p>所以我们可以用剩下的字符串去匹配开始标签结束符正则，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> end = html.match(startTagClose)</span><br><span class=\"line\"><span class=\"string\">'&gt;&lt;/div&gt;'</span>.match(startTagClose) <span class=\"comment\">// [\"&gt;\", \"\", index: 0, input: \"&gt;&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"string\">'/&gt;'</span>.match(startTagClose) <span class=\"comment\">// [\"/&gt;\", \"/\", index: 0, input: \"/&gt;&lt;div&gt;&lt;/div&gt;\", groups: undefined]</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，非自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;&quot;</code>，而自闭合标签匹配结果中的<code>end[1]</code>为<code>&quot;/&quot;</code>。所以根据匹配结果的<code>end[1]</code>是否是<code>&quot;&quot;</code>我们即可判断出当前标签是否为自闭合标签，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> end = html.match(startTagClose)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">    match.unarySlash = end[<span class=\"number\">1</span>]</span><br><span class=\"line\">    advance(end[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    match.end = index</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>经过以上两步，开始标签就已经解析完毕了，完整源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ncname = <span class=\"string\">'[a-zA-Z_][\\\\w\\\\-\\\\.]*'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> qnameCapture = <span class=\"string\">`((?:<span class=\"subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"subst\">$&#123;ncname&#125;</span>)`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagOpen = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^&lt;<span class=\"subst\">$&#123;qnameCapture&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> startTagClose = <span class=\"regexp\">/^\\s*(\\/?)&gt;/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseStartTag</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> start = html.match(startTagOpen)</span><br><span class=\"line\">    <span class=\"comment\">// '&lt;div&gt;&lt;/div&gt;'.match(startTagOpen)  =&gt; ['&lt;div','div',index:0,input:'&lt;div&gt;&lt;/div&gt;']</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> match = &#123;</span><br><span class=\"line\">        tagName: start[<span class=\"number\">1</span>],</span><br><span class=\"line\">        attrs: [],</span><br><span class=\"line\">        start: index</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      advance(start[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> end, attr</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;div a=1 b=2 c=3&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">       * 从&lt;div之后到开始标签的结束符号'&gt;'之前，一直匹配属性attrs</span></span><br><span class=\"line\"><span class=\"comment\">       * 所有属性匹配完之后，html字符串还剩下 </span></span><br><span class=\"line\"><span class=\"comment\">       * 自闭合标签剩下：'/&gt;'</span></span><br><span class=\"line\"><span class=\"comment\">       * 非自闭合标签剩下：'&gt;&lt;/div&gt;'</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class=\"line\">        advance(attr[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">        match.attrs.push(attr)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * 这里判断了该标签是否为自闭合标签</span></span><br><span class=\"line\"><span class=\"comment\">       * 自闭合标签如:&lt;input type='text' /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">       * 非自闭合标签如:&lt;div&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">       * '&gt;&lt;/div&gt;'.match(startTagClose) =&gt; [\"&gt;\", \"\", index: 0, input: \"&gt;&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"comment\">       * '/&gt;&lt;div&gt;&lt;/div&gt;'.match(startTagClose) =&gt; [\"/&gt;\", \"/\", index: 0, input: \"/&gt;&lt;div&gt;&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"comment\">       * 因此，我们可以通过end[1]是否是\"/\"来判断该标签是否是自闭合标签</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (end) &#123;</span><br><span class=\"line\">        match.unarySlash = end[<span class=\"number\">1</span>]</span><br><span class=\"line\">        advance(end[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">        match.end = index</span><br><span class=\"line\">        <span class=\"keyword\">return</span> match</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>通过源码可以看到，调用<code>parseStartTag</code>函数，如果模板字符串符合开始标签的特征，则解析开始标签，并将解析结果返回，如果不符合开始标签的特征，则返回<code>undefined</code>。</p>\n<p>解析完毕后，就可以用解析得到的结果去调用<code>start</code>钩子函数去创建元素型的<code>AST</code>节点了。</p>\n<p>在源码中，<code>Vue</code>并没有直接去调<code>start</code>钩子函数去创建<code>AST</code>节点，而是调用了<code>handleStartTag</code>函数，在该函数内部才去调的<code>start</code>钩子函数，为什么要这样做呢？这是因为虽然经过<code>parseStartTag</code>函数已经把创建<code>AST</code>节点必要信息提取出来了，但是提取出来的标签属性数组还是需要处理一下，下面我们就来看一下<code>handleStartTag</code>函数都做了些什么事。<code>handleStartTag</code>函数源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStartTag</span> (<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tagName = match.tagName</span><br><span class=\"line\">    <span class=\"keyword\">const</span> unarySlash = match.unarySlash</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expectHTML) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> unary = isUnaryTag(tagName) || !!unarySlash</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> l = match.attrs.length</span><br><span class=\"line\">    <span class=\"keyword\">const</span> attrs = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(l)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> args = match.attrs[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> shouldDecodeNewlines = tagName === <span class=\"string\">'a'</span> &amp;&amp; args[<span class=\"number\">1</span>] === <span class=\"string\">'href'</span></span><br><span class=\"line\">        ? options.shouldDecodeNewlinesForHref</span><br><span class=\"line\">        : options.shouldDecodeNewlines</span><br><span class=\"line\">      attrs[i] = &#123;</span><br><span class=\"line\">        name: args[<span class=\"number\">1</span>],</span><br><span class=\"line\">        value: decodeAttr(value, shouldDecodeNewlines)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!unary) &#123;</span><br><span class=\"line\">      stack.push(&#123; <span class=\"attr\">tag</span>: tagName, <span class=\"attr\">lowerCasedTag</span>: tagName.toLowerCase(), <span class=\"attr\">attrs</span>: attrs &#125;)</span><br><span class=\"line\">      lastTag = tagName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">      options.start(tagName, attrs, unary, match.start, match.end)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><code>handleStartTag</code>函数用来对<code>parseStartTag</code>函数的解析结果进行进一步处理，它接收<code>parseStartTag</code>函数的返回值作为参数。</p>\n<p><code>handleStartTag</code>函数的开始定义几个常量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tagName = match.tagName       <span class=\"comment\">// 开始标签的标签名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unarySlash = match.unarySlash  <span class=\"comment\">// 是否为自闭合标签的标志，自闭合为\"\",非自闭合为\"/\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unary = isUnaryTag(tagName) || !!unarySlash  <span class=\"comment\">// 布尔值，标志是否为自闭合标签</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> l = match.attrs.length    <span class=\"comment\">// match.attrs 数组的长度</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> attrs = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(l)  <span class=\"comment\">// 一个与match.attrs数组长度相等的数组</span></span><br></pre></td></tr></table></figure>\n<p>接下来是循环处理提取出来的标签属性数组<code>match.attrs</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args = match.attrs[i]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> shouldDecodeNewlines = tagName === <span class=\"string\">'a'</span> &amp;&amp; args[<span class=\"number\">1</span>] === <span class=\"string\">'href'</span></span><br><span class=\"line\">    ? options.shouldDecodeNewlinesForHref</span><br><span class=\"line\">    : options.shouldDecodeNewlines</span><br><span class=\"line\">    attrs[i] = &#123;</span><br><span class=\"line\">        name: args[<span class=\"number\">1</span>],</span><br><span class=\"line\">        value: decodeAttr(value, shouldDecodeNewlines)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，首先定义了 <code>args</code>常量，它是解析出来的标签属性数组中的每一个属性对象，即<code>match.attrs</code> 数组中每个元素对象。 它长这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> args = [<span class=\"string\">\"class=\"</span>a<span class=\"string\">\"\"</span>, <span class=\"string\">\"class\"</span>, <span class=\"string\">\"=\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"attr\">index</span>: <span class=\"number\">0</span>, <span class=\"attr\">input</span>: <span class=\"string\">\"class=\"</span>a<span class=\"string\">\" id=\"</span>b<span class=\"string\">\"&gt;&lt;/div&gt;\"</span>, <span class=\"attr\">groups</span>: <span class=\"literal\">undefined</span>]</span><br></pre></td></tr></table></figure>\n<p>接着定义了<code>value</code>，用于存储标签属性的属性值，我们可以看到，在代码中尝试取<code>args</code>的<code>args[3]</code>、<code>args[4]</code>、<code>args[5]</code>，如果都取不到，则给<code>value</code>复制为空</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<p>接着定义了<code>shouldDecodeNewlines</code>，这个常量主要是做一些兼容性处理， 如果 <code>shouldDecodeNewlines</code> 为 <code>true</code>，意味着 <code>Vue</code> 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。而<code>shouldDecodeNewlinesForHref</code>为<code>true</code> 意味着<code>Vue</code>在编译模板的时候，要对<code>a</code>标签的 <code>href</code>属性值中的换行符或制表符做兼容处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> shouldDecodeNewlines = tagName === <span class=\"string\">'a'</span> &amp;&amp; args[<span class=\"number\">1</span>] === <span class=\"string\">'href'</span></span><br><span class=\"line\">    ? options.shouldDecodeNewlinesForHref</span><br><span class=\"line\">    : options.shouldDecodeNewlinesconst value = args[<span class=\"number\">3</span>] || args[<span class=\"number\">4</span>] || args[<span class=\"number\">5</span>] || <span class=\"string\">''</span></span><br></pre></td></tr></table></figure>\n<p>最后将处理好的结果存入之前定义好的与<code>match.attrs</code>数组长度相等的<code>attrs</code>数组中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attrs[i] = &#123;</span><br><span class=\"line\">    name: args[<span class=\"number\">1</span>],    <span class=\"comment\">// 标签属性的属性名，如class</span></span><br><span class=\"line\">    value: decodeAttr(value, shouldDecodeNewlines) <span class=\"comment\">// 标签属性的属性值，如class对应的a</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，如果该标签是非自闭合标签，则将标签推入栈中（关于栈这个概念后面会说到），如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!unary) &#123;</span><br><span class=\"line\">    stack.push(&#123; <span class=\"attr\">tag</span>: tagName, <span class=\"attr\">lowerCasedTag</span>: tagName.toLowerCase(), <span class=\"attr\">attrs</span>: attrs &#125;)</span><br><span class=\"line\">    lastTag = tagName</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果该标签是自闭合标签，现在就可以调用<code>start</code>钩子函数并传入处理好的参数来创建<code>AST</code>节点了，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">    options.start(tagName, attrs, unary, match.start, match.end)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是开始标签的解析以及调用<code>start</code>钩子函数创建元素型的<code>AST</code>节点的所有过程。</p>\n<h3>3.5 解析结束标签</h3>\n<p>结束标签的解析要比解析开始标签容易多了，因为它不需要解析什么属性，只需要判断剩下的模板字符串是否符合结束标签的特征，如果是，就将结束标签名提取出来，再调用4个钩子函数中的<code>end</code>函数就好了。</p>\n<p>首先判断剩余的模板字符串是否符合结束标签的特征，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ncname = <span class=\"string\">'[a-zA-Z_][\\\\w\\\\-\\\\.]*'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> qnameCapture = <span class=\"string\">`((?:<span class=\"subst\">$&#123;ncname&#125;</span>\\\\:)?<span class=\"subst\">$&#123;ncname&#125;</span>)`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> endTag = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">`^&lt;\\\\/<span class=\"subst\">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> endTagMatch = html.match(endTag)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'&lt;/div&gt;'</span>.match(endTag)  <span class=\"comment\">// [\"&lt;/div&gt;\", \"div\", index: 0, input: \"&lt;/div&gt;\", groups: undefined]</span></span><br><span class=\"line\"><span class=\"string\">'&lt;div&gt;'</span>.match(endTag)  <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，如果模板字符串符合结束标签的特征，则会获得匹配结果数组；如果不合符，则得到null。</p>\n<p>接着再调用<code>end</code>钩子函数，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (endTagMatch) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> curIndex = index</span><br><span class=\"line\">    advance(endTagMatch[<span class=\"number\">0</span>].length)</span><br><span class=\"line\">    parseEndTag(endTagMatch[<span class=\"number\">1</span>], curIndex, index)</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，没有直接去调用<code>end</code>函数，而是调用了<code>parseEndTag</code>函数，关于<code>parseEndTag</code>函数内部的作用我们后面会介绍到，在这里你暂时可以理解为该函数内部就是去调用了<code>end</code>钩子函数。</p>\n<h3>3.6 解析文本</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">终于到了解析最后一种文本类型的内容了，为什么要把解析文本类型放在最后一个介绍呢？我们仔细想一下，前面五种类型都是以`&lt;`开头的，只有文本类型的内容不是以`&lt;`开头的，所以我们在解析模板字符串的时候可以先判断一下字符串是不是以`&lt;`开头的，如果是则继续判断是以上五种类型的具体哪一种，而如果不是的话，那它肯定就是文本了。</span><br></pre></td></tr></table></figure>\n<p>解析文本也比较容易，在解析模板字符串之前，我们先查找一下第一个<code>&lt;</code>出现在什么位置，如果第一个<code>&lt;</code>在第一个位置，那么说明模板字符串是以其它5种类型开始的；如果第一个<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了；如果在整个模板字符串里没有找到<code>&lt;</code>，那说明整个模板字符串都是文本。这就是解析思路，接下来我们对照源码来了解一下实际的解析过程，源码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> textEnd = html.indexOf(<span class=\"string\">'&lt;'</span>)</span><br><span class=\"line\"><span class=\"comment\">// '&lt;' 在第一个位置，为其余5种类型</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (textEnd === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// '&lt;' 不在第一个位置，文本开头</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (textEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果html字符串不是以'&lt;'开头,说明'&lt;'前面的都是纯文本，无需处理</span></span><br><span class=\"line\">    <span class=\"comment\">// 那就把'&lt;'以后的内容拿出来赋给rest</span></span><br><span class=\"line\">    rest = html.slice(textEnd)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (</span><br><span class=\"line\">        !endTag.test(rest) &amp;&amp;</span><br><span class=\"line\">        !startTagOpen.test(rest) &amp;&amp;</span><br><span class=\"line\">        !comment.test(rest) &amp;&amp;</span><br><span class=\"line\">        !conditionalComment.test(rest)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// &lt; in plain text, be forgiving and treat it as text</span></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">           * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span></span><br><span class=\"line\"><span class=\"comment\">           * 如果都匹配不上，表示'&lt;'是属于文本本身的内容</span></span><br><span class=\"line\"><span class=\"comment\">           */</span></span><br><span class=\"line\">        <span class=\"comment\">// 在'&lt;'之后查找是否还有'&lt;'</span></span><br><span class=\"line\">        next = rest.indexOf(<span class=\"string\">'&lt;'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有了，表示'&lt;'后面也是文本</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &lt; <span class=\"number\">0</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果还有，表示'&lt;'是文本中的一个字符</span></span><br><span class=\"line\">        textEnd += next</span><br><span class=\"line\">        <span class=\"comment\">// 那就把next之后的内容截出来继续下一轮循环匹配</span></span><br><span class=\"line\">        rest = html.slice(textEnd)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// '&lt;'是结束标签的开始 ,说明从开始到'&lt;'都是文本，截取出来</span></span><br><span class=\"line\">    text = html.substring(<span class=\"number\">0</span>, textEnd)</span><br><span class=\"line\">    advance(textEnd)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 整个模板字符串里没有找到`&lt;`,说明整个模板字符串都是文本</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (textEnd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    text = html</span><br><span class=\"line\">    html = <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 把截取出来的text转化成textAST</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class=\"line\">    options.chars(text)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>源码的逻辑很清晰，根据<code>&lt;</code>在不在第一个位置以及整个模板字符串里没有<code>&lt;</code>都分别进行了处理。</p>\n<p>值得深究的是如果<code>&lt;</code>不在第一个位置而在模板字符串中间某个位置，那么说明模板字符串是以文本开头的，那么从开头到第一个<code>&lt;</code>出现的位置就都是文本内容了，接着我们还要从第一个<code>&lt;</code>的位置继续向后判断，因为还存在这样一种情况，那就是如果文本里面本来就包含一个<code>&lt;</code>，例如<code>1&lt;2&lt;/div&gt;</code>。为了处理这种情况，我们把从第一个<code>&lt;</code>的位置直到模板字符串结束都截取出来记作<code>rest</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> rest = html.slice(textEnd)</span><br></pre></td></tr></table></figure>\n<p>接着用<code>rest</code>去匹配以上5种类型的正则，如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (</span><br><span class=\"line\">    !endTag.test(rest) &amp;&amp;</span><br><span class=\"line\">    !startTagOpen.test(rest) &amp;&amp;</span><br><span class=\"line\">    !comment.test(rest) &amp;&amp;</span><br><span class=\"line\">    !conditionalComment.test(rest)</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果都匹配不上，则表明这个<code>&lt;</code>是属于文本本身的内容，接着以这个<code>&lt;</code>的位置继续向后查找，看是否还有<code>&lt;</code>，如果没有了，则表示后面的都是文本；如果后面还有下一个<code>&lt;</code>，那表明至少在这个<code>&lt;</code>到下一个<code>&lt;</code>中间的内容都是文本，至于下一个<code>&lt;</code>以后的内容是什么，则还需要重复以上的逻辑继续判断。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (</span><br><span class=\"line\">    !endTag.test(rest) &amp;&amp;</span><br><span class=\"line\">    !startTagOpen.test(rest) &amp;&amp;</span><br><span class=\"line\">    !comment.test(rest) &amp;&amp;</span><br><span class=\"line\">    !conditionalComment.test(rest)</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &lt; in plain text, be forgiving and treat it as text</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 用'&lt;'以后的内容rest去匹配endTag、startTagOpen、comment、conditionalComment</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果都匹配不上，表示'&lt;'是属于文本本身的内容</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 在'&lt;'之后查找是否还有'&lt;'</span></span><br><span class=\"line\">    next = rest.indexOf(<span class=\"string\">'&lt;'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有了，表示'&lt;'后面也是文本</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (next &lt; <span class=\"number\">0</span>) <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果还有，表示'&lt;'是文本中的一个字符</span></span><br><span class=\"line\">    textEnd += next</span><br><span class=\"line\">    <span class=\"comment\">// 那就把next之后的内容截出来继续下一轮循环匹配</span></span><br><span class=\"line\">    rest = html.slice(textEnd)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后截取文本内容<code>text</code>并调用4个钩子函数中的<code>chars</code>函数创建文本型的<code>AST</code>节点。</p>\n<h2>4. 如何保证AST节点层级关系</h2>\n<p>上一章节我们介绍了<code>HTML</code>解析器是如何解析各种不同类型的内容并且调用钩子函数创建不同类型的<code>AST</code>节点。此时你可能会有个疑问，我们上面创建的<code>AST</code>节点都是单独创建且分散的，而真正的<code>DOM</code>节点都是有层级关系的，那如何来保证<code>AST</code>节点的层级关系与真正的<code>DOM</code>节点相同呢？</p>\n<p>关于这个问题，<code>Vue</code>也注意到了。<code>Vue</code>在<code>HTML</code>解析器的开头定义了一个栈<code>stack</code>，这个栈的作用就是用来维护<code>AST</code>节点层级的，那么它是怎么维护的呢？通过前文我们知道，<code>HTML</code>解析器在从前向后解析模板字符串时，每当遇到开始标签时就会调用<code>start</code>钩子函数，那么在<code>start</code>钩子函数内部我们可以将解析得到的开始标签推入栈中，而每当遇到结束标签时就会调用<code>end</code>钩子函数，那么我们也可以在<code>end</code>钩子函数内部将解析得到的结束标签所对应的开始标签从栈中弹出。请看如下例子：</p>\n<p>加入有如下模板字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当解析到开始标签<code>&lt;div&gt;</code>时，就把<code>div</code>推入栈中，然后继续解析，当解析到<code>&lt;p&gt;</code>时，再把<code>p</code>推入栈中，同理，再把<code>span</code>推入栈中，当解析到结束标签<code>&lt;/span&gt;</code>时，此时栈顶的标签刚好是<code>span</code>的开始标签，那么就用<code>span</code>的开始标签和结束标签构建<code>AST</code>节点，并且从栈中把<code>span</code>的开始标签弹出，那么此时栈中的栈顶标签<code>p</code>就是构建好的<code>span</code>的<code>AST</code>节点的父节点，如下图：</p>\n<p><img src=\"/img/complie/7.png\" alt></p>\n<p>这样我们就找到了当前被构建节点的父节点。这只是栈的一个用途，它还有另外一个用途，我们再看如下模板字符串：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>按照上面的流程解析这个模板字符串时，当解析到结束标签<code>&lt;/p&gt;</code>时，此时栈顶的标签应该是<code>p</code>才对，而现在是<code>span</code>，那么就说明<code>span</code>标签没有被正确闭合，此时控制台就会抛出警告：‘tag  has no matching end tag.’相信这个警告你一定不会陌生。这就是栈的第二个用途： 检测模板字符串中是否有未正确闭合的标签。</p>\n<p>OK，有了这个栈的概念之后，我们再回看上一章<code>HTML</code>解析器解析不同内容的代码。</p>\n<h2>5. 回归源码</h2>\n<h3>5.1 HTML解析器源码</h3>\n<p>以上内容都了解了之后，我们回归源码，逐句分析<code>HTML</code>解析器<code>parseHTML</code>函数，函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseHTML</span>(<span class=\"params\">html, options</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> expectHTML = options.expectHTML;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> isUnaryTag$$<span class=\"number\">1</span> = options.isUnaryTag || no;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> canBeLeftOpenTag$$<span class=\"number\">1</span> = options.canBeLeftOpenTag || no;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> last, lastTag;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 开启一个 while 循环，循环结束的条件是 html 为空，即 html 被 parse 完毕</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (html) &#123;</span><br><span class=\"line\">\t\tlast = html;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">let</span> textEnd = html.indexOf(<span class=\"string\">'&lt;'</span>)</span><br><span class=\"line\">              <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">               * 如果html字符串是以'&lt;'开头,则有以下几种可能</span></span><br><span class=\"line\"><span class=\"comment\">               * 开始标签:&lt;div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 结束标签:&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 注释:&lt;!-- 我是注释 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 条件注释:&lt;!-- [if !IE] --&gt; &lt;!-- [endif] --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * DOCTYPE:&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"comment\">               * 需要一一去匹配尝试</span></span><br><span class=\"line\"><span class=\"comment\">               */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (textEnd === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是注释</span></span><br><span class=\"line\">        \t\t<span class=\"keyword\">if</span> (comment.test(html)) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是条件注释</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (conditionalComment.test(html)) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是DOCTYPE</span></span><br><span class=\"line\">                <span class=\"keyword\">const</span> doctypeMatch = html.match(doctype)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (doctypeMatch) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 解析是否是结束标签</span></span><br><span class=\"line\">                <span class=\"keyword\">const</span> endTagMatch = html.match(endTag)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (endTagMatch) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 匹配是否是开始标签</span></span><br><span class=\"line\">                <span class=\"keyword\">const</span> startTagMatch = parseStartTag()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (startTagMatch) &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"comment\">// 如果html字符串不是以'&lt;'开头,则解析文本类型</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> text, rest, next</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (textEnd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果在html字符串中没有找到'&lt;'，表示这一段html字符串都是纯文本</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (textEnd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                text = html</span><br><span class=\"line\">                html = <span class=\"string\">''</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 把截取出来的text转化成textAST</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (options.chars &amp;&amp; text) &#123;</span><br><span class=\"line\">                options.chars(text)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 父元素为script、style、textarea时，其内部的内容全部当做纯文本处理</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//将整个字符串作为文本对待</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (html === last) &#123;</span><br><span class=\"line\">\t\t\toptions.chars &amp;&amp; options.chars(html);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!stack.length &amp;&amp; options.warn) &#123;</span><br><span class=\"line\">\t\t\t\toptions.warn((<span class=\"string\">\"Mal-formatted tag at end of template: \\\"\"</span> + html + <span class=\"string\">\"\\\"\"</span>));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Clean up any remaining tags</span></span><br><span class=\"line\">\tparseEndTag();</span><br><span class=\"line\">\t<span class=\"comment\">//parse 开始标签</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseStartTag</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//处理 parseStartTag 的结果</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStartTag</span>(<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//parse 结束标签</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseEndTag</span>(<span class=\"params\">tagName, start, end</span>) </span>&#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中大致可分为三部分：</p>\n<ul>\n<li>定义的一些常量和变量</li>\n<li>while 循环</li>\n<li>解析过程中用到的辅助函数</li>\n</ul>\n<p>我们一一来分析：</p>\n<p>首先定义了几个常量，如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stack = []       <span class=\"comment\">// 维护AST节点层级的栈</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> expectHTML = options.expectHTML</span><br><span class=\"line\"><span class=\"keyword\">const</span> isUnaryTag = options.isUnaryTag || no</span><br><span class=\"line\"><span class=\"keyword\">const</span> canBeLeftOpenTag = options.canBeLeftOpenTag || no   <span class=\"comment\">//用来检测一个标签是否是可以省略闭合标签的非自闭合标签</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> index = <span class=\"number\">0</span>   <span class=\"comment\">//解析游标，标识当前从何处开始解析模板字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> last,   <span class=\"comment\">// 存储剩余还未解析的模板字符串</span></span><br><span class=\"line\">    lastTag  <span class=\"comment\">// 存储着位于 stack 栈顶的元素</span></span><br></pre></td></tr></table></figure>\n<p>接着开启<code>while</code> 循环，循环的终止条件是 模板字符串<code>html</code>为空，即模板字符串被全部编译完毕。在每次<code>while</code>循环中， 先把 <code>html</code>的值赋给变量 <code>last</code>，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">last = html</span><br></pre></td></tr></table></figure>\n<p>这样做的目的是，如果经过上述所有处理逻辑处理过后，<code>html</code>字符串没有任何变化，即表示<code>html</code>字符串没有匹配上任何一条规则，那么就把<code>html</code>字符串当作纯文本对待，创建文本类型的<code>AST</code>节点并且如果抛出异常：模板字符串中标签格式有误。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将整个字符串作为文本对待</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (html === last) &#123;</span><br><span class=\"line\">    options.chars &amp;&amp; options.chars(html);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stack.length &amp;&amp; options.warn) &#123;</span><br><span class=\"line\">        options.warn((<span class=\"string\">\"Mal-formatted tag at end of template: \\\"\"</span> + html + <span class=\"string\">\"\\\"\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着，我们继续看<code>while</code>循环体内的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (html) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保即将 parse 的内容不是在纯文本标签里 (script,style,textarea)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!lastTag || !isPlainTextElement(lastTag)) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// parse 的内容是在纯文本标签里 (script,style,textarea)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在循环体内，首先判断了待解析的<code>html</code>字符串是否在纯文本标签里，如<code>script</code>,<code>style</code>,<code>textarea</code>，因为在这三个标签里的内容肯定不会有<code>HTML</code>标签，所以我们可直接当作文本处理，判断条件如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!lastTag || !isPlainTextElement(lastTag)</span><br></pre></td></tr></table></figure>\n<p>前面我们说了，<code>lastTag</code>为栈顶元素，<code>!lastTag</code>即表示当前<code>html</code>字符串没有父节点，而<code>isPlainTextElement(lastTag)</code> 是检测 <code>lastTag</code> 是否为是那三个纯文本标签之一，是的话返回<code>true</code>，不是返回<code>fasle</code>。</p>\n<p>也就是说当前<code>html</code>字符串要么没有父节点要么父节点不是纯文本标签，则接下来就可以依次解析那6种类型的内容了，关于6种类型内容的处理方式前文已经逐个介绍过，此处不再重复。</p>\n<h3>5.2 parseEndTag函数源码</h3>\n<p>接下来我们看一下之前在解析结束标签时遗留的<code>parseEndTag</code>函数，该函数定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseEndTag</span> (<span class=\"params\">tagName, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pos, lowerCasedTagName</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start == <span class=\"literal\">null</span>) start = index</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end == <span class=\"literal\">null</span>) end = index</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tagName) &#123;</span><br><span class=\"line\">      lowerCasedTagName = tagName.toLowerCase()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find the closest opened tag of the same type</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tagName) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (pos = stack.length - <span class=\"number\">1</span>; pos &gt;= <span class=\"number\">0</span>; pos--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If no tag name is provided, clean shop</span></span><br><span class=\"line\">      pos = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pos &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Close all the open elements, up the stack</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = stack.length - <span class=\"number\">1</span>; i &gt;= pos; i--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span> &amp;&amp;</span><br><span class=\"line\">          (i &gt; pos || !tagName) &amp;&amp;</span><br><span class=\"line\">          options.warn</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">          options.warn(</span><br><span class=\"line\">            <span class=\"string\">`tag &lt;<span class=\"subst\">$&#123;stack[i].tag&#125;</span>&gt; has no matching end tag.`</span></span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">          options.end(stack[i].tag, start, end)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Remove the open elements from the stack</span></span><br><span class=\"line\">      stack.length = pos</span><br><span class=\"line\">      lastTag = pos &amp;&amp; stack[pos - <span class=\"number\">1</span>].tag</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'br'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">true</span>, start, end)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'p'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">false</span>, start, end)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">        options.end(tagName, start, end)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数接收三个参数，分别是结束标签名<code>tagName</code>、结束标签在<code>html</code>字符串中的起始和结束位置<code>start</code>和<code>end</code>。</p>\n<p>这三个参数其实都是可选的，根据传参的不同其功能也不同。</p>\n<ul>\n<li>第一种是三个参数都传递，用于处理普通的结束标签</li>\n<li>第二种是只传递<code>tagName</code></li>\n<li>第三种是三个参数都不传递，用于处理栈中剩余未处理的标签</li>\n</ul>\n<p>如果<code>tagName</code>存在，那么就从后往前遍历栈，在栈中寻找与<code>tagName</code>相同的标签并记录其所在的位置<code>pos</code>，如果<code>tagName</code>不存在，则将<code>pos</code>置为0。如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (tagName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pos = stack.length - <span class=\"number\">1</span>; pos &gt;= <span class=\"number\">0</span>; pos--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If no tag name is provided, clean shop</span></span><br><span class=\"line\">    pos = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着当<code>pos&gt;=0</code>时，开启一个<code>for</code>循环，从栈顶位置从后向前遍历直到<code>pos</code>处，如果发现<code>stack</code>栈中存在索引大于<code>pos</code>的元素，那么该元素一定是缺少闭合标签的。这是因为在正常情况下，<code>stack</code>栈的栈顶元素应该和当前的结束标签<code>tagName</code> 匹配，也就是说正常的<code>pos</code>应该是栈顶位置，后面不应该再有元素，如果后面还有元素，那么后面的元素就都缺少闭合标签 那么这个时候如果是在非生产环境会抛出警告，告诉你缺少闭合标签。除此之外，还会调用 <code>options.end(stack[i].tag, start, end)</code>立即将其闭合，这是为了保证解析结果的正确性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (pos &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Close all the open elements, up the stack</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = stack.length - <span class=\"number\">1</span>; i &gt;= pos; i--) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &gt; pos || !tagName ) &#123;</span><br><span class=\"line\">\t\t\toptions.warn(</span><br><span class=\"line\">\t\t\t\t(<span class=\"string\">\"tag &lt;\"</span> + (stack[i].tag) + <span class=\"string\">\"&gt; has no matching end tag.\"</span>)</span><br><span class=\"line\">\t\t\t);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">\t\t\toptions.end(stack[i].tag, start, end);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Remove the open elements from the stack</span></span><br><span class=\"line\">\tstack.length = pos;</span><br><span class=\"line\">\tlastTag = pos &amp;&amp; stack[pos - <span class=\"number\">1</span>].tag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后把<code>pos</code>位置以后的元素都从<code>stack</code>栈中弹出，以及把<code>lastTag</code>更新为栈顶元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack.length = pos;</span><br><span class=\"line\">lastTag = pos &amp;&amp; stack[pos - <span class=\"number\">1</span>].tag;</span><br></pre></td></tr></table></figure>\n<p>接着，如果<code>pos</code>没有大于等于0，即当 <code>tagName</code> 没有在 <code>stack</code> 栈中找到对应的开始标签时，<code>pos</code> 为 -1 。那么此时再判断 <code>tagName</code> 是否为<code>br</code> 或<code>p</code>标签，为什么要单独判断这两个标签呢？这是因为在浏览器中如果我们写了如下<code>HTML</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>浏览器会自动把<code>&lt;/br&gt;</code>标签解析为正常的 &lt;br&gt;标签，而对于<code>&lt;/p&gt;</code>浏览器则自动将其补全为<code>&lt;p&gt;&lt;/p&gt;</code>，所以<code>Vue</code>为了与浏览器对这两个标签的行为保持一致，故对这两个便签单独判断处理，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'br'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.start) &#123;   </span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">true</span>, start, end)  <span class=\"comment\">// 创建&lt;br&gt;AST节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// 补全p标签并创建AST节点</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (lowerCasedTagName === <span class=\"string\">'p'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.start) &#123;</span><br><span class=\"line\">        options.start(tagName, [], <span class=\"literal\">false</span>, start, end)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.end) &#123;</span><br><span class=\"line\">        options.end(tagName, start, end)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上就是对结束标签的解析与处理。</p>\n<p>另外，在<code>while</code>循环后面还有一行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseEndTag()</span><br></pre></td></tr></table></figure>\n<p>这行代码执行的时机是<code>html === last</code>，即<code>html</code>字符串中的标签格式有误时会跳出<code>while</code>循环，此时就会执行这行代码，这行代码是调用<code>parseEndTag</code>函数并不传递任何参数，前面我们说过如果<code>parseEndTag</code>函数不传递任何参数是用于处理栈中剩余未处理的标签。这是因为如果不传递任何函数，此时<code>parseEndTag</code>函数里的<code>pos</code>就为0，那么<code>pos&gt;=0</code>就会恒成立，那么就会逐个警告缺少闭合标签，并调用 <code>options.end</code>将其闭合。</p>\n<h2>6. 总结</h2>\n<p>本篇文章主要介绍了<code>HTML</code>解析器的工作流程以及工作原理，文章比较长，但是逻辑并不复杂。</p>\n<p>首先介绍了<code>HTML</code>解析器的工作流程，一句话概括就是：一边解析不同的内容一边调用对应的钩子函数生成对应的<code>AST</code>节点，最终完成将整个模板字符串转化成<code>AST</code>。</p>\n<p>接着介绍了<code>HTML</code>解析器是如何解析用户所写的模板字符串中各种类型的内容的，把各种类型的解析方式都分别进行了介绍。</p>\n<p>其次，介绍了在解析器内维护了一个栈，用来保证构建的<code>AST</code>节点层级与真正<code>DOM</code>层级一致。</p>\n<p>了解了思想之后，最后回归源码，学习了源码中一些处理细节的地方。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4wltj490001zws61b3uyy4k","category_id":"ck4wltj4i0005zws69kuyche3","_id":"ck4wltj4x000gzws6t9lltwhn"},{"post_id":"ck4wltj4f0003zws6ympn3x71","category_id":"ck4wltj4i0005zws69kuyche3","_id":"ck4wltj52000lzws6yjmap0cw"},{"post_id":"ck4wltj4z000izws6qs3lu6m3","category_id":"ck4wltj4x000fzws6ofuocx1c","_id":"ck4wltj58000szws65jxpvxao"},{"post_id":"ck4wltj4k0007zws62oe50hqj","category_id":"ck4wltj4x000fzws6ofuocx1c","_id":"ck4wltj59000wzws6j86i0y6b"},{"post_id":"ck4wltj4m0009zws6y3710rj1","category_id":"ck4wltj4x000fzws6ofuocx1c","_id":"ck4wltj5a000yzws69gp39ut2"},{"post_id":"ck4wltj4q000azws639vp12y6","category_id":"ck4wltj58000tzws66hnf0tmf","_id":"ck4wltj5d0015zws6d92i1gvi"},{"post_id":"ck4wltj4u000dzws6o5obi102","category_id":"ck4wltj4x000fzws6ofuocx1c","_id":"ck4wltj5g001bzws607ziynqz"},{"post_id":"ck4wltj4w000ezws6mtw29cmu","category_id":"ck4wltj4x000fzws6ofuocx1c","_id":"ck4wltj5i001gzws6tz0lf55z"},{"post_id":"ck4wltj51000kzws6wqcgrf2z","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj5n001ozws6y0a3cgsi"},{"post_id":"ck4wltj5i001jzws6m69cwmr4","category_id":"ck4wltj4i0005zws69kuyche3","_id":"ck4wltj5q001szws6gik1fwhp"},{"post_id":"ck4wltj55000pzws6s1b2ua9h","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj5r001vzws6o6ex49rd"},{"post_id":"ck4wltj5m001mzws64dak4n89","category_id":"ck4wltj58000tzws66hnf0tmf","_id":"ck4wltj5s001zzws62xgy9zui"},{"post_id":"ck4wltj57000rzws609o3ty1m","category_id":"ck4wltj58000tzws66hnf0tmf","_id":"ck4wltj5u0023zws63tplyw7r"},{"post_id":"ck4wltj58000vzws62m3ru6ya","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj5v0026zws6223j8la5"},{"post_id":"ck4wltj59000xzws6hgdgt1f9","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj61002fzws604i63vrl"},{"post_id":"ck4wltj5b0011zws6rfbdqqz4","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj66002lzws6slh3ko4t"},{"post_id":"ck4wltj5c0013zws6vicg6wsu","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj69002rzws664xe8jkw"},{"post_id":"ck4wltj63002jzws66sq9t0z9","category_id":"ck4wltj58000tzws66hnf0tmf","_id":"ck4wltj69002tzws6y4att0c9"},{"post_id":"ck4wltj67002ozws6bi2hbgu0","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj6a002vzws6r0ujzyvs"},{"post_id":"ck4wltj5e0018zws6wnj9jsod","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj6a002xzws6bud4hjef"},{"post_id":"ck4wltj5f0019zws6oryk4wdt","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj6b0030zws6q6rfklhr"},{"post_id":"ck4wltj5g001dzws68s01j35a","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj6b0034zws6h0nn4pe1"},{"post_id":"ck4wltj5h001fzws6r54ibvto","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj6c0037zws6ug66zj3k"},{"post_id":"ck4wltj5n001pzws6a43v2o7h","category_id":"ck4wltj6b0033zws6yteh05jv","_id":"ck4wltj6d003czws6r3fw3r89"},{"post_id":"ck4wltj5p001rzws6o6cb2ioe","category_id":"ck4wltj6c0038zws6kfkjc16w","_id":"ck4wltj6e003fzws6o924bfa5"},{"post_id":"ck4wltj5q001uzws6a2rr9oia","category_id":"ck4wltj6d003dzws6t6jkft8s","_id":"ck4wltj6g003lzws6soyjv8ct"},{"post_id":"ck4wltj5s001yzws6mm94nfqk","category_id":"ck4wltj6f003hzws692q62mbo","_id":"ck4wltj6h003pzws67i4rjpx3"},{"post_id":"ck4wltj5t0022zws64x9m7sgx","category_id":"ck4wltj6d003dzws6t6jkft8s","_id":"ck4wltj6i003rzws6yy4jjn05"},{"post_id":"ck4wltj5u0025zws69cnbx8rc","category_id":"ck4wltj6d003dzws6t6jkft8s","_id":"ck4wltj6j003wzws6ivib2rf5"},{"post_id":"ck4wltj5v0027zws62e6b5ym1","category_id":"ck4wltj6d003dzws6t6jkft8s","_id":"ck4wltj6j003zzws6yueyehrl"},{"post_id":"ck4wltj5x002bzws6qy217p1h","category_id":"ck4wltj6i003vzws66n6bffpc","_id":"ck4wltj6k0043zws6s1uvsp2y"},{"post_id":"ck4wltj5z002dzws6ugwue7y9","category_id":"ck4wltj6d003dzws6t6jkft8s","_id":"ck4wltj6l0046zws64javkwm8"},{"post_id":"ck4wltj62002izws6ma3ddgkl","category_id":"ck4wltj6d003dzws6t6jkft8s","_id":"ck4wltj6l004azws6wtl3f6p4"},{"post_id":"ck4wltj7t0069zws6mlt8pub2","category_id":"ck4wltj4x000fzws6ofuocx1c","_id":"ck4wltj7x006fzws6wzbos7mx"},{"post_id":"ck4wltj7v006azws6c9u9y553","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj7z006izws6zo1s44lh"},{"post_id":"ck4wltj7w006czws6kp32hw7p","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj80006lzws6g0sn1stk"},{"post_id":"ck4wltj7x006ezws6in1fy04u","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj81006ozws6cb83q1rn"},{"post_id":"ck4wltj7y006hzws6onw5vjs9","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj82006rzws60qnklhwy"},{"post_id":"ck4wltj7z006kzws6ldrt5ldk","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj84006uzws6dug8652l"},{"post_id":"ck4wltj80006nzws6uras5da7","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj85006xzws6ndgb7hoc"},{"post_id":"ck4wltj81006qzws680vu3vpm","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj860070zws634h9l46b"},{"post_id":"ck4wltj83006tzws6w0q5v416","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj870073zws6fbryouyw"},{"post_id":"ck4wltj84006wzws6o9or81a4","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj880076zws6nsqqb3g2"},{"post_id":"ck4wltj85006zzws6kdmbojao","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj8a0079zws6jcizlmyz"},{"post_id":"ck4wltj860072zws6rsjh6jri","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj8b007czws69dcbdltj"},{"post_id":"ck4wltj870075zws6slwy1atb","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj8c007fzws6chmconmw"},{"post_id":"ck4wltj880078zws6imeum5wh","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj8d007jzws6yivtof8d"},{"post_id":"ck4wltj8d007izws66kypx68w","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj8h007pzws6f57xau8l"},{"post_id":"ck4wltj8a007bzws6b6e5zpjg","category_id":"ck4wltj8c007gzws61151k2se","_id":"ck4wltj8i007szws6b69x4z1x"},{"post_id":"ck4wltj8b007ezws6goawbuks","category_id":"ck4wltj8h007nzws6f0n6mywo","_id":"ck4wltj8i007vzws6aqkr55ng"},{"post_id":"ck4wltj8w008hzws6k0ct8qlj","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj91008nzws61v6pjoa5"},{"post_id":"ck4wltj8y008izws6nvf8z3xv","category_id":"ck4wltj5f001azws6f5zfzkj3","_id":"ck4wltj92008pzws65b1vfaqw"},{"post_id":"ck4wltj8z008kzws6wst133f1","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj92008rzws6o61jh2vi"},{"post_id":"ck4wltj91008mzws6a23dhuue","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj92008tzws6tdauvsid"},{"post_id":"ck4wltj97008zzws6l7o9cqlb","category_id":"ck4wltj5t0020zws6x93c07y0","_id":"ck4wltj980092zws6stq9tdge"}],"PostTag":[{"post_id":"ck4wltj490001zws61b3uyy4k","tag_id":"ck4wltj4k0006zws6mttr4e9u","_id":"ck4wltj51000jzws6w8rbllo6"},{"post_id":"ck4wltj490001zws61b3uyy4k","tag_id":"ck4wltj4s000czws606om7tbw","_id":"ck4wltj53000mzws6qieg33ej"},{"post_id":"ck4wltj4f0003zws6ympn3x71","tag_id":"ck4wltj4k0006zws6mttr4e9u","_id":"ck4wltj56000qzws60elypo48"},{"post_id":"ck4wltj4k0007zws62oe50hqj","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj5c0012zws621fiwzbn"},{"post_id":"ck4wltj4k0007zws62oe50hqj","tag_id":"ck4wltj58000uzws6fuq6u4ww","_id":"ck4wltj5d0016zws683ee9c1x"},{"post_id":"ck4wltj4m0009zws6y3710rj1","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj5h001ezws6p7ll340r"},{"post_id":"ck4wltj4m0009zws6y3710rj1","tag_id":"ck4wltj58000uzws6fuq6u4ww","_id":"ck4wltj5i001hzws6gktgtihx"},{"post_id":"ck4wltj4q000azws639vp12y6","tag_id":"ck4wltj5g001czws61fztus7m","_id":"ck4wltj5l001lzws6bdb3wac5"},{"post_id":"ck4wltj4u000dzws6o5obi102","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj5s001xzws6rpu0dixp"},{"post_id":"ck4wltj4u000dzws6o5obi102","tag_id":"ck4wltj58000uzws6fuq6u4ww","_id":"ck4wltj5t0021zws67l72579c"},{"post_id":"ck4wltj4w000ezws6mtw29cmu","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj5x002azws6d1e5fjh7"},{"post_id":"ck4wltj4w000ezws6mtw29cmu","tag_id":"ck4wltj58000uzws6fuq6u4ww","_id":"ck4wltj5y002czws635e3u5nl"},{"post_id":"ck4wltj5x002bzws6qy217p1h","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj62002hzws63cnxa96o"},{"post_id":"ck4wltj4z000izws6qs3lu6m3","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj67002nzws6kxqt17b1"},{"post_id":"ck4wltj4z000izws6qs3lu6m3","tag_id":"ck4wltj58000uzws6fuq6u4ww","_id":"ck4wltj68002pzws6qx1y1mnw"},{"post_id":"ck4wltj51000kzws6wqcgrf2z","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6a002yzws613vne9tz"},{"post_id":"ck4wltj51000kzws6wqcgrf2z","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj6b0031zws6f5oc9cs3"},{"post_id":"ck4wltj55000pzws6s1b2ua9h","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6c0036zws6eqiy5zs6"},{"post_id":"ck4wltj55000pzws6s1b2ua9h","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj6c0039zws6twpb6wjp"},{"post_id":"ck4wltj57000rzws609o3ty1m","tag_id":"ck4wltj5g001czws61fztus7m","_id":"ck4wltj6d003bzws6qcwofpd0"},{"post_id":"ck4wltj58000vzws62m3ru6ya","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6f003izws6dr8jzqqj"},{"post_id":"ck4wltj58000vzws62m3ru6ya","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj6f003jzws6baj6q8gx"},{"post_id":"ck4wltj59000xzws6hgdgt1f9","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6i003tzws6pt5ivq6l"},{"post_id":"ck4wltj59000xzws6hgdgt1f9","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj6i003uzws6oechnfck"},{"post_id":"ck4wltj59000xzws6hgdgt1f9","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj6j003yzws6wmfrgcjh"},{"post_id":"ck4wltj5b0011zws6rfbdqqz4","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj6l0045zws6apwa44fe"},{"post_id":"ck4wltj5b0011zws6rfbdqqz4","tag_id":"ck4wltj6j003xzws69278f214","_id":"ck4wltj6l0047zws696um6kvo"},{"post_id":"ck4wltj5b0011zws6rfbdqqz4","tag_id":"ck4wltj6j0041zws69520tbav","_id":"ck4wltj6l0049zws65gwjouvp"},{"post_id":"ck4wltj5c0013zws6vicg6wsu","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6m004dzws666qp3hbr"},{"post_id":"ck4wltj5c0013zws6vicg6wsu","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj6m004ezws6c59kiqki"},{"post_id":"ck4wltj5c0013zws6vicg6wsu","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj6n004gzws6j9nbjxph"},{"post_id":"ck4wltj5e0018zws6wnj9jsod","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6o004jzws6t5bek47s"},{"post_id":"ck4wltj5e0018zws6wnj9jsod","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj6o004kzws6c9il3blw"},{"post_id":"ck4wltj5e0018zws6wnj9jsod","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj6p004mzws6b06n395h"},{"post_id":"ck4wltj5f0019zws6oryk4wdt","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6p004pzws6d2ip3h1g"},{"post_id":"ck4wltj5f0019zws6oryk4wdt","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj6q004qzws6gwkylomi"},{"post_id":"ck4wltj5f0019zws6oryk4wdt","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj6r004szws6dbx7wnsf"},{"post_id":"ck4wltj5g001dzws68s01j35a","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6s004vzws646yao8io"},{"post_id":"ck4wltj5g001dzws68s01j35a","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj6s004wzws664ayer0o"},{"post_id":"ck4wltj5g001dzws68s01j35a","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj6t004yzws6cl56d59f"},{"post_id":"ck4wltj5h001fzws6r54ibvto","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj6t0051zws6b783n16y"},{"post_id":"ck4wltj5h001fzws6r54ibvto","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj6u0052zws6jik05wlu"},{"post_id":"ck4wltj5h001fzws6r54ibvto","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj6u0054zws67d2dthu5"},{"post_id":"ck4wltj5i001jzws6m69cwmr4","tag_id":"ck4wltj4k0006zws6mttr4e9u","_id":"ck4wltj6w0056zws6aorfc6q7"},{"post_id":"ck4wltj5i001jzws6m69cwmr4","tag_id":"ck4wltj6t0050zws6tddflsw7","_id":"ck4wltj6w0057zws67ma12wla"},{"post_id":"ck4wltj5i001jzws6m69cwmr4","tag_id":"ck4wltj6u0053zws6ekmspmzq","_id":"ck4wltj6x0059zws6p68665gs"},{"post_id":"ck4wltj5m001mzws64dak4n89","tag_id":"ck4wltj5g001czws61fztus7m","_id":"ck4wltj6x005azws6txp4emqp"},{"post_id":"ck4wltj5m001mzws64dak4n89","tag_id":"ck4wltj6u0055zws6uvxnowls","_id":"ck4wltj6x005czws6p6kerlcb"},{"post_id":"ck4wltj5q001uzws6a2rr9oia","tag_id":"ck4wltj6w0058zws6xmg8yg17","_id":"ck4wltj6y005fzws6gor9d60p"},{"post_id":"ck4wltj5q001uzws6a2rr9oia","tag_id":"ck4wltj6x005bzws6k330uzgz","_id":"ck4wltj6y005gzws6193yhjjl"},{"post_id":"ck4wltj5q001uzws6a2rr9oia","tag_id":"ck4wltj6x005dzws60zf0h2us","_id":"ck4wltj6y005izws6mu5d4p0e"},{"post_id":"ck4wltj5s001yzws6mm94nfqk","tag_id":"ck4wltj6y005ezws6eyoe1r43","_id":"ck4wltj6y005jzws61eqwv7nf"},{"post_id":"ck4wltj5t0022zws64x9m7sgx","tag_id":"ck4wltj6x005bzws6k330uzgz","_id":"ck4wltj6z005lzws64dc3ub1q"},{"post_id":"ck4wltj5u0025zws69cnbx8rc","tag_id":"ck4wltj6z005kzws6dgyptbjk","_id":"ck4wltj70005ozws65o1krpp8"},{"post_id":"ck4wltj5u0025zws69cnbx8rc","tag_id":"ck4wltj6x005bzws6k330uzgz","_id":"ck4wltj70005pzws6tsvue2wm"},{"post_id":"ck4wltj5u0025zws69cnbx8rc","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj70005rzws60pkpx4oy"},{"post_id":"ck4wltj5v0027zws62e6b5ym1","tag_id":"ck4wltj6x005bzws6k330uzgz","_id":"ck4wltj71005tzws68sv4d6w2"},{"post_id":"ck4wltj5v0027zws62e6b5ym1","tag_id":"ck4wltj6x005dzws60zf0h2us","_id":"ck4wltj71005uzws6ng8j92wq"},{"post_id":"ck4wltj5v0027zws62e6b5ym1","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj72005wzws6kiiql9u8"},{"post_id":"ck4wltj5z002dzws6ugwue7y9","tag_id":"ck4wltj6x005bzws6k330uzgz","_id":"ck4wltj72005xzws6f21bkqsl"},{"post_id":"ck4wltj62002izws6ma3ddgkl","tag_id":"ck4wltj6x005bzws6k330uzgz","_id":"ck4wltj73005zzws6z294964l"},{"post_id":"ck4wltj63002jzws66sq9t0z9","tag_id":"ck4wltj5g001czws61fztus7m","_id":"ck4wltj740062zws68w9hbv9p"},{"post_id":"ck4wltj63002jzws66sq9t0z9","tag_id":"ck4wltj6u0055zws6uvxnowls","_id":"ck4wltj740063zws66lduvmln"},{"post_id":"ck4wltj63002jzws66sq9t0z9","tag_id":"ck4wltj730060zws64r3etdtl","_id":"ck4wltj740065zws6jvnlbdiv"},{"post_id":"ck4wltj67002ozws6bi2hbgu0","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj750066zws6ggk8t8qk"},{"post_id":"ck4wltj67002ozws6bi2hbgu0","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj750067zws6q2z4j35v"},{"post_id":"ck4wltj67002ozws6bi2hbgu0","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj750068zws6j87uw42s"},{"post_id":"ck4wltj7t0069zws6mlt8pub2","tag_id":"ck4wltj54000ozws6tzs7q1dk","_id":"ck4wltj7w006bzws6qweblwid"},{"post_id":"ck4wltj7t0069zws6mlt8pub2","tag_id":"ck4wltj58000uzws6fuq6u4ww","_id":"ck4wltj7x006dzws63ouydfhj"},{"post_id":"ck4wltj7v006azws6c9u9y553","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj7y006gzws6vnwrvi8e"},{"post_id":"ck4wltj7v006azws6c9u9y553","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj7z006jzws61jj1tbvx"},{"post_id":"ck4wltj7w006czws6kp32hw7p","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj80006mzws61wrvec1z"},{"post_id":"ck4wltj7w006czws6kp32hw7p","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj81006pzws6mfwgit9m"},{"post_id":"ck4wltj7x006ezws6in1fy04u","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj83006szws63abwl456"},{"post_id":"ck4wltj7x006ezws6in1fy04u","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj84006vzws6boonjbnz"},{"post_id":"ck4wltj7y006hzws6onw5vjs9","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj85006yzws6cwr53qm6"},{"post_id":"ck4wltj7y006hzws6onw5vjs9","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj860071zws67ikut43o"},{"post_id":"ck4wltj7z006kzws6ldrt5ldk","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj870074zws6nb8fq7uz"},{"post_id":"ck4wltj7z006kzws6ldrt5ldk","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj880077zws6159q4rae"},{"post_id":"ck4wltj80006nzws6uras5da7","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8a007azws6bmgzsw38"},{"post_id":"ck4wltj80006nzws6uras5da7","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8b007dzws678vrc59n"},{"post_id":"ck4wltj80006nzws6uras5da7","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8d007hzws6dtfpc8qv"},{"post_id":"ck4wltj81006qzws680vu3vpm","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8e007lzws6tko0n7vn"},{"post_id":"ck4wltj81006qzws680vu3vpm","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8g007mzws6mr3i6vpo"},{"post_id":"ck4wltj81006qzws680vu3vpm","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8h007ozws6piyigrfq"},{"post_id":"ck4wltj83006tzws6w0q5v416","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8i007rzws6cwz8ij08"},{"post_id":"ck4wltj83006tzws6w0q5v416","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8i007tzws64b5qlpyj"},{"post_id":"ck4wltj83006tzws6w0q5v416","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8i007uzws6h4gonl3e"},{"post_id":"ck4wltj84006wzws6o9or81a4","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8i007wzws6x008li5y"},{"post_id":"ck4wltj84006wzws6o9or81a4","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8i007xzws6jj1fv4v2"},{"post_id":"ck4wltj84006wzws6o9or81a4","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8i007yzws6h634ns29"},{"post_id":"ck4wltj85006zzws6kdmbojao","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8i007zzws6tw9ycw7g"},{"post_id":"ck4wltj85006zzws6kdmbojao","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8i0080zws6oex6aqxl"},{"post_id":"ck4wltj85006zzws6kdmbojao","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8i0081zws6uwn6lyri"},{"post_id":"ck4wltj860072zws6rsjh6jri","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8i0082zws6tsby7bz2"},{"post_id":"ck4wltj860072zws6rsjh6jri","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8i0083zws62mx3n3hg"},{"post_id":"ck4wltj860072zws6rsjh6jri","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8i0084zws6s1cj76ip"},{"post_id":"ck4wltj870075zws6slwy1atb","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8j0085zws6qoj3cvsq"},{"post_id":"ck4wltj870075zws6slwy1atb","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8j0086zws64w83fi80"},{"post_id":"ck4wltj870075zws6slwy1atb","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8j0087zws62v33gxkw"},{"post_id":"ck4wltj880078zws6imeum5wh","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8j0088zws6v1cwz14d"},{"post_id":"ck4wltj880078zws6imeum5wh","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj8j0089zws6hl7eg3hw"},{"post_id":"ck4wltj880078zws6imeum5wh","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8j008azws6kbzooh9e"},{"post_id":"ck4wltj8d007izws66kypx68w","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8j008bzws6r52d8cat"},{"post_id":"ck4wltj8d007izws66kypx68w","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj8j008czws6rdcwnz7u"},{"post_id":"ck4wltj8d007izws66kypx68w","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj8j008dzws60lh3ljyc"},{"post_id":"ck4wltj8b007ezws6goawbuks","tag_id":"ck4wltj8e007kzws66a6vcd15","_id":"ck4wltj8j008ezws6qg2j2iky"},{"post_id":"ck4wltj8b007ezws6goawbuks","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8j008fzws62y0qpqgf"},{"post_id":"ck4wltj8b007ezws6goawbuks","tag_id":"ck4wltj8h007qzws6uziyl8un","_id":"ck4wltj8j008gzws6g8rjfl06"},{"post_id":"ck4wltj8w008hzws6k0ct8qlj","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj8z008jzws6yndi553t"},{"post_id":"ck4wltj8w008hzws6k0ct8qlj","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj90008lzws6nljkoctx"},{"post_id":"ck4wltj8y008izws6nvf8z3xv","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj92008ozws67e6a8t7x"},{"post_id":"ck4wltj8y008izws6nvf8z3xv","tag_id":"ck4wltj69002szws6i4lpxms7","_id":"ck4wltj92008qzws6n3v5ed2y"},{"post_id":"ck4wltj8z008kzws6wst133f1","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj92008szws6nny0jgh5"},{"post_id":"ck4wltj8z008kzws6wst133f1","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj92008uzws650ido7ng"},{"post_id":"ck4wltj8z008kzws6wst133f1","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj92008vzws68jtpgwh9"},{"post_id":"ck4wltj91008mzws6a23dhuue","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj93008wzws6vl885qeo"},{"post_id":"ck4wltj91008mzws6a23dhuue","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj93008xzws6r68x0bbn"},{"post_id":"ck4wltj91008mzws6a23dhuue","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj93008yzws64ha50lz6"},{"post_id":"ck4wltj97008zzws6l7o9cqlb","tag_id":"ck4wltj66002mzws6x0gl4ekp","_id":"ck4wltj980090zws6rsjs6pia"},{"post_id":"ck4wltj97008zzws6l7o9cqlb","tag_id":"ck4wltj6f003kzws6qxrklayb","_id":"ck4wltj980091zws6h0y5fian"},{"post_id":"ck4wltj97008zzws6l7o9cqlb","tag_id":"ck4wltj6g003nzws67l2rgath","_id":"ck4wltj980093zws66bkx4ilt"}],"Tag":[{"name":"Docker","_id":"ck4wltj4k0006zws6mttr4e9u"},{"name":"WordPress","_id":"ck4wltj4s000czws606om7tbw"},{"name":"javascript","_id":"ck4wltj54000ozws6tzs7q1dk"},{"name":"数据结构","_id":"ck4wltj58000uzws6fuq6u4ww"},{"name":"graphql","_id":"ck4wltj5g001czws61fztus7m"},{"name":"JavaScript","_id":"ck4wltj66002mzws6x0gl4ekp"},{"name":"TypeScript","_id":"ck4wltj69002szws6i4lpxms7"},{"name":"Vue源码","_id":"ck4wltj6f003kzws6qxrklayb"},{"name":"Vue","_id":"ck4wltj6g003nzws67l2rgath"},{"name":"Weex","_id":"ck4wltj6j003xzws69278f214"},{"name":"微信小程序","_id":"ck4wltj6j0041zws69520tbav"},{"name":"git","_id":"ck4wltj6t0050zws6tddflsw7"},{"name":"gitlab","_id":"ck4wltj6u0053zws6ekmspmzq"},{"name":"nodejs","_id":"ck4wltj6u0055zws6uvxnowls"},{"name":"CSS3","_id":"ck4wltj6w0058zws6xmg8yg17"},{"name":"Frontend Interview","_id":"ck4wltj6x005bzws6k330uzgz"},{"name":"html","_id":"ck4wltj6x005dzws60zf0h2us"},{"name":"http","_id":"ck4wltj6y005ezws6eyoe1r43"},{"name":"ES6","_id":"ck4wltj6z005kzws6dgyptbjk"},{"name":"vuejs","_id":"ck4wltj730060zws64r3etdtl"},{"name":"HTML","_id":"ck4wltj8e007kzws66a6vcd15"},{"name":"Threejs","_id":"ck4wltj8h007qzws6uziyl8un"}]}}