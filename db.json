{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":0,"renderable":0},{"_id":"source/img/avatar/alipay.jpg","path":"img/avatar/alipay.jpg","modified":0,"renderable":0},{"_id":"source/img/avatar/wechat.jpg","path":"img/avatar/wechat.jpg","modified":0,"renderable":0},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":0,"renderable":0},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":0,"renderable":0},{"_id":"themes/carlos/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/carlos/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/carlos/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":0,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":0,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"6d05053964eda7371ae3fdd373dae51cf5d3f413","modified":1564997520509},{"_id":"themes/carlos/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1564997520889},{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1564997520509},{"_id":"themes/carlos/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1564997520888},{"_id":"source/_posts/Docker 中如何安装WordPress.md","hash":"a5d0db018071fdeaf6384e44dd8dfbb1c7bbc207","modified":1564997520510},{"_id":"source/_posts/Docker 学习笔记 如何安装Docker.md","hash":"a30b02dbd6453c4f799c6373f14a1cf884f0d159","modified":1564997520510},{"_id":"source/_posts/GraphQL 简介.md","hash":"75bc3cc11f9a77afc2aeefef65258656924a1395","modified":1564997520510},{"_id":"source/_posts/GraphQL入门之GraphQL的查询.md","hash":"2896cdc6d10de79dadfbeaa415f798647b6a5773","modified":1564997520511},{"_id":"source/_posts/JavaScript数据结构与算法-字典和哈希表.md","hash":"cc8ab6a384939e4b732f3e2356851b5ada4bad1b","modified":1564997520511},{"_id":"source/_posts/JavaScript数据结构与算法-树.md","hash":"f9ed48d679f6878b3699e87161bb486e784d239b","modified":1564997520512},{"_id":"source/_posts/JavaScript数据结构与算法-栈（Stack）.md","hash":"be51b8102b8d27ed7699f981eb38db2bb29b1abf","modified":1564997520512},{"_id":"source/_posts/Uni-App 基于Vue技术栈方向跨端技术实践.md","hash":"811e5d515c36cbaf0ce806ade65613c07266271f","modified":1564997520513},{"_id":"source/_posts/JavaScript数据结构与算法-链表（LinkedList）.md","hash":"0ef74c71d3e559cba2d625e93ea88b92bfac3ee6","modified":1564997520512},{"_id":"source/_posts/JavaScript数据结构与算法队列（Queue）.md","hash":"c6bda3f42e3e46d2a1cf53a2c65dc6d0ad8060b9","modified":1564997520513},{"_id":"source/_posts/JavaScript数据结构与算法-集合.md","hash":"ca36cb3e02b16dd40735bed8eba458e7a576164e","modified":1564997520513},{"_id":"source/_posts/centOS中利用Docker安装gitlab.md","hash":"24da1cc9ebf0a36b429f1700c8da1e8459412133","modified":1564997520513},{"_id":"source/_posts/graphQL 如和在客户端调用.md","hash":"04ed731505e3ba9b9f580f0e331683afa59b58f0","modified":1564997520514},{"_id":"source/_posts/前端面试系列 — HMTL基础篇.md","hash":"3557fedafac5b51e7e2276f3e7fcab471a0d1792","modified":1564997520514},{"_id":"source/_posts/前端面试系列 — 布局篇.md","hash":"cde6b572e5f9a0de01f72f314a3411a968ce1440","modified":1564997520514},{"_id":"source/_posts/前端面试系列- CSS基础篇.md","hash":"d03034efbb1bee374236a7611efe0fe560cbf651","modified":1564997520515},{"_id":"source/_posts/前端面试系列-HTTP常考点.md","hash":"e72785bda53cc4b95b50d4e296472d6b8fa624ce","modified":1564997520515},{"_id":"source/_posts/前端面试系列-JS基础数据类型.md","hash":"117b966c2f8428d0ee3ed466b4ff56dfc86f3d27","modified":1564997520516},{"_id":"source/_posts/前端面试系列-JavaScript 数组.md","hash":"4ab0ba7506c3eb572de4e5c24e66a8b705d03216","modified":1564997520516},{"_id":"source/_posts/前端面试系列-JavaScript中的this指向问题.md","hash":"8efaadf5b1cc49d8840586d3f1d0367397fd8d8c","modified":1564997520517},{"_id":"source/_posts/前端面试系列-前端跨域常用的几种方式.md","hash":"42a3780bb357e5bc300c4c63bce0e80750fac06e","modified":1564997520518},{"_id":"source/_posts/前端面试系列-游览器中的事件.md","hash":"cd5a025a0e4ac8feb9efaff703ec3659731f0090","modified":1564997520518},{"_id":"source/_posts/如何在Vue SPA中集成GraphQL.md","hash":"730fd59babdf590ec1e2b240c3f989ae4d5da095","modified":1564997520518},{"_id":"source/_posts/微信小程序开发技术选型分享.md","hash":"c39a7378fd22753d6ed79f85a3fa61f02fc0735d","modified":1564997520519},{"_id":"source/_posts/前端面试系列-JavaScript继承.md","hash":"095911c2e083cb38e9c66420558aaffa16f0ba9c","modified":1564997520517},{"_id":"source/about/index.md","hash":"87b9f62b9fc93ea81bd20e698ff102203bcd2927","modified":1564997520519},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1564997520520},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1564997520884},{"_id":"source/_posts/第一章 TheeJS 创建场景.md","hash":"244e57ee56c7024c6f6c995c2b6662b56b2c3d20","modified":1564998169650},{"_id":"themes/carlos/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1564997520893},{"_id":"themes/carlos/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1564997520893},{"_id":"themes/carlos/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1564997520896},{"_id":"themes/carlos/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1564997520898},{"_id":"themes/carlos/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1564997520899},{"_id":"themes/carlos/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1564997520903},{"_id":"themes/carlos/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1564997520903},{"_id":"themes/carlos/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1564997520905},{"_id":"themes/carlos/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1564997520907},{"_id":"themes/carlos/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1564997520915},{"_id":"themes/carlos/layout/archive.ejs","hash":"a990910af3d5e402c27ffdc7e3f8831ffc3a88e2","modified":1564997520916},{"_id":"themes/carlos/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1564997520916},{"_id":"themes/carlos/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1564997520890},{"_id":"themes/carlos/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1564997520916},{"_id":"themes/carlos/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1564997520917},{"_id":"themes/carlos/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1564997520918},{"_id":"themes/carlos/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1564997520926},{"_id":"themes/carlos/layout/post.ejs","hash":"03107af08fec9a00f65d6692b01a419054dbf80e","modified":1564997520919},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1564997520532},{"_id":"source/img/avatar/alipay.jpg","hash":"1a748a29b0634999ee26512f696b7b7249eb5a1c","modified":1564997520561},{"_id":"source/img/avatar/wechat.jpg","hash":"3db1455b6616a182a7ef46773ef9750f1ec84831","modified":1564997520575},{"_id":"themes/carlos/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1564997520914},{"_id":"themes/carlos/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1564997520913},{"_id":"themes/carlos/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1564997520914},{"_id":"themes/carlos/layout/_partial/footer.ejs","hash":"f6197dccef7904fb7c2401e62d3219fab6f5ece0","modified":1564997520908},{"_id":"themes/carlos/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1564997520914},{"_id":"themes/carlos/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1564997520914},{"_id":"themes/carlos/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1564997520915},{"_id":"themes/carlos/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1564997520909},{"_id":"themes/carlos/layout/_partial/head.ejs","hash":"720349195a5ea7b610a82ce3ce74298fb2bc7347","modified":1564997520909},{"_id":"themes/carlos/layout/_partial/header.ejs","hash":"3bd09df76e0622d76d186b020393fcab361e6c97","modified":1564997520909},{"_id":"themes/carlos/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1564997520910},{"_id":"themes/carlos/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1564997520912},{"_id":"themes/carlos/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1564997520910},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1564997520942},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1564997520948},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1564997520949},{"_id":"themes/carlos/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1564997520927},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1564997520949},{"_id":"themes/carlos/source/css/beantech.css","hash":"f2aeda0e7bb732c0c16f77afb482f78b14dc42b7","modified":1564997520928},{"_id":"themes/carlos/source/css/beantech.min.css","hash":"b57004e24164568c938ad14d2c9f4df4b44a7e6c","modified":1564997520929},{"_id":"themes/carlos/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1564997520935},{"_id":"themes/carlos/source/css/hux-blog.min.css","hash":"eba8a9219b55d1f30c78927d6583ef03be5715f0","modified":1564997520936},{"_id":"themes/carlos/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1564997520935},{"_id":"themes/carlos/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1564997520939},{"_id":"themes/carlos/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1564997520939},{"_id":"themes/carlos/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1564997520939},{"_id":"themes/carlos/source/css/widget.styl","hash":"9940278d0b3cf92bdcf9cead877bb3a3338d1f23","modified":1564997520940},{"_id":"themes/carlos/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1564997520950},{"_id":"themes/carlos/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1564997520951},{"_id":"themes/carlos/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1564997520951},{"_id":"themes/carlos/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1564997520959},{"_id":"themes/carlos/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1564997520957},{"_id":"themes/carlos/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1564997520960},{"_id":"themes/carlos/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1564997520960},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1564997520690},{"_id":"themes/carlos/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1564997520947},{"_id":"themes/carlos/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1564997520933},{"_id":"themes/carlos/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1564997520950},{"_id":"themes/carlos/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1564997520957},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1564997520713},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1564997520741},{"_id":"themes/carlos/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1564997520932},{"_id":"themes/carlos/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1564997520938},{"_id":"themes/carlos/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1564997520938},{"_id":"themes/carlos/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1564997520954},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1564997520543},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1564997520531},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1564997520806},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1564997520884},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1564997520557},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1564997520761},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1564997520847},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1564997520684},{"_id":"public/post-sitemap.xml","hash":"881ee790784807038138d93c7baf05f229de759c","modified":1564998264650},{"_id":"public/page-sitemap.xml","hash":"535e66898dd86750b2111069e83e5bc98042026c","modified":1564998264650},{"_id":"public/tag-sitemap.xml","hash":"338e4b388d041f00ae3047c49167e6a848d0ce1e","modified":1564998265672},{"_id":"public/category-sitemap.xml","hash":"22f588e3753e43b98fa76914e2e0ef1ff851f3bf","modified":1564998265673},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1564998266023},{"_id":"public/sitemap.xml","hash":"5753d5e3218aed45e874583d8a383e9739c52f8a","modified":1564998266024},{"_id":"public/404.html","hash":"18d7e1ad9037cd7645ca666a02020c9697b5f20c","modified":1564998266054},{"_id":"public/tags/index.html","hash":"011fcb982041082cf378d526cefa44a80aaabbc3","modified":1564998266054},{"_id":"public/ThreeJS/第一章 TheeJS 创建场景/index.html","hash":"7b7eb3739613b5505bc1c25a89214a58af32c4eb","modified":1564998266054},{"_id":"public/Vue/Uni-App 基于Vue技术栈方向跨端技术实践/index.html","hash":"632eb6304cdcbb30a86cd6b6a7b96b854c3420f9","modified":1564998266054},{"_id":"public/数据结构/JavaScript数据结构与算法-树/index.html","hash":"d30251ad0e668bc7e01d06fbce2d9e2019cb7d7c","modified":1564998266054},{"_id":"public/数据结构/JavaScript数据结构与算法-字典和哈希表/index.html","hash":"636a07fd9b548e9646b80a5bd0161a7097f06784","modified":1564998266054},{"_id":"public/数据结构/JavaScript数据结构与算法-集合/index.html","hash":"3c0a447091275c8f5bd60ea6d3aa6f8e6d9591c6","modified":1564998266054},{"_id":"public/数据结构/JavaScript数据结构与算法-链表（LinkedList）/index.html","hash":"279b1f4505c3f47effe7b6893be0d240545e7b1a","modified":1564998266054},{"_id":"public/数据结构/JavaScript数据结构与算法队列（Queue）/index.html","hash":"106df30d63e58c91198cab8676ca83ee14028329","modified":1564998266054},{"_id":"public/数据结构/JavaScript数据结构与算法-栈（Stack）/index.html","hash":"9b269e9cfa141c212bf6e55cdda25a99cb3e66b7","modified":1564998266054},{"_id":"public/JavaScript/前端面试系列-JavaScript继承/index.html","hash":"8cb3df3d90e2f428c1ce94e2a6573cdd77891264","modified":1564998266054},{"_id":"public/HTTP/前端面试系列-HTTP常考点/index.html","hash":"3123b616462211c93b27ff19a00e52874dac56d8","modified":1564998266054},{"_id":"public/前端面试/前端面试系列-JavaScript 数组/index.html","hash":"af6f347a0f6429834e93d0732ade1436eb71e5f5","modified":1564998266055},{"_id":"public/前端面试/前端面试系列- CSS基础篇/index.html","hash":"db4ad340bfa1a9963127704c50d1489439a72ca5","modified":1564998266055},{"_id":"public/前端面试/前端面试系列-JavaScript中的this指向问题/index.html","hash":"a44412dcd64188037760c03e0b021f9dae83660e","modified":1564998266055},{"_id":"public/前端面试/前端面试系列-游览器中的事件/index.html","hash":"408a9e7691658d286db1c89cf5e87e4efd60fe9e","modified":1564998266055},{"_id":"public/前端面试/前端面试系列-前端跨域常用的几种方式/index.html","hash":"b2c2b985c66bc7bf01d4abc17fb521af33006ce8","modified":1564998266055},{"_id":"public/前端面试/前端面试系列-JS基础数据类型/index.html","hash":"d142142ea4a82987e80c09bbd5014e8934a1672b","modified":1564998266055},{"_id":"public/CSS3/前端面试系列 — 布局篇/index.html","hash":"c349594e83e10b9440c9568d0bc0cb487677ef0b","modified":1564998266055},{"_id":"public/HTML5/前端面试系列 — HMTL基础篇/index.html","hash":"3ad0ace5b0e9ca36eda479e89c46dabc4529aee9","modified":1564998266055},{"_id":"public/微信小程序/微信小程序开发技术选型分享/index.html","hash":"782503c1a65e97e3587497db8eecb08d9df65873","modified":1564998266055},{"_id":"public/docker/Docker 学习笔记 如何安装Docker/index.html","hash":"89354236f0951050b708470f60af0cbd7f4de320","modified":1564998266055},{"_id":"public/docker/centOS中利用Docker安装gitlab/index.html","hash":"c81b0c04ce1b43a7b9aae7f92282a6064dd16f4f","modified":1564998266055},{"_id":"public/GraphQL/如何在Vue SPA中集成GraphQL/index.html","hash":"4a8cdbf075a5cbcd5ac30c1c1e8833953362fbf9","modified":1564998266055},{"_id":"public/GraphQL/graphQL 如和在客户端调用/index.html","hash":"2bb7c3e726ba63970e08072e3a4af3014e6b1105","modified":1564998266056},{"_id":"public/GraphQL/GraphQL入门之GraphQL的查询/index.html","hash":"c541c57a2a276d19d35658c438d1e58bb4717a2c","modified":1564998266056},{"_id":"public/docker/Docker 中如何安装WordPress/index.html","hash":"7b1a8d4350f05191675ebe8d4cf70cb1294231ab","modified":1564998266056},{"_id":"public/GraphQL/GraphQL 简介/index.html","hash":"f85951af1ee583d6be37f97691349b695aa46289","modified":1564998266056},{"_id":"public/about/index.html","hash":"bacf857d825caf612e9101e00547a4a5355292e1","modified":1564998266056},{"_id":"public/archive/index.html","hash":"9596a35ace422d1e2b5f114031131e2d89fd7587","modified":1564998266056},{"_id":"public/categories/docker/index.html","hash":"d6bfdd9753f10ff3fd87470c45b06f7508fd42ba","modified":1564998266056},{"_id":"public/categories/GraphQL/index.html","hash":"886ba0bda56af18dd5b7391d8589f1302198346e","modified":1564998266056},{"_id":"public/categories/数据结构/index.html","hash":"cf09d817af3f8253986997655b1bf96cacfd8103","modified":1564998266056},{"_id":"public/categories/Vue/index.html","hash":"0767edb4430d915d1e1c110712bbf4518e15419a","modified":1564998266056},{"_id":"public/categories/HTML5/index.html","hash":"bfe34f0ec1c521889a40aee5a7ef1851f29440ff","modified":1564998266056},{"_id":"public/categories/CSS3/index.html","hash":"2c36a020f49316db84f20be29428ad4edeb449d3","modified":1564998266057},{"_id":"public/categories/前端面试/index.html","hash":"a340205851c62516db1269d0e5ddaa72a2431c6c","modified":1564998266057},{"_id":"public/categories/HTTP/index.html","hash":"2dee02f0aba76c13fa984f73c58c2ae721948f65","modified":1564998266057},{"_id":"public/categories/JavaScript/index.html","hash":"19d64ccb0ac3df8de77c9307b51184d8e0540c15","modified":1564998266057},{"_id":"public/categories/微信小程序/index.html","hash":"684a2cd9c1e4874d605d806b6b89fa74de2fba1a","modified":1564998266057},{"_id":"public/categories/ThreeJS/index.html","hash":"ac1b3fb6abfc12ff50824c917c1c9446a4a03f65","modified":1564998266057},{"_id":"public/archives/index.html","hash":"42e9df3eb0b76433ff4eb43e3922e0b218d62b76","modified":1564998266057},{"_id":"public/archives/archives/2/index.html","hash":"801f8ee70976638b13cae7de93fc216dfbf48fd4","modified":1564998266057},{"_id":"public/archives/archives/3/index.html","hash":"44f962730ca99af57cc8b935a04319827cc2b6f7","modified":1564998266057},{"_id":"public/archives/2019/index.html","hash":"1270ed235a0a06f403800b4e4c70ed75c370805c","modified":1564998266058},{"_id":"public/archives/2019/archives/2/index.html","hash":"507f7816d73364febb16a0b3589513bdc789461f","modified":1564998266058},{"_id":"public/archives/2019/archives/3/index.html","hash":"ff84b1b0b273e038cb242f11f9ec8d942a31af8b","modified":1564998266058},{"_id":"public/archives/2019/02/index.html","hash":"618b39a5f6bd399f75eecc4dab86f17a4bb1d615","modified":1564998266058},{"_id":"public/archives/2019/02/archives/2/index.html","hash":"92b6493686a519d42f4fad7d97a12b1db0cf33c6","modified":1564998266058},{"_id":"public/archives/2019/03/index.html","hash":"5bf1c70989950625ffb571177a447817c81e1f1e","modified":1564998266058},{"_id":"public/archives/2019/04/index.html","hash":"9e304fbc398b9738b0a56c002f0ed6e7ff6998b3","modified":1564998266058},{"_id":"public/archives/2019/08/index.html","hash":"be395c78779bc0ea4ca6318be92f6e565d7c15b3","modified":1564998266058},{"_id":"public/index.html","hash":"f4130fb900a4de138343ee6b3a00f0c9563e6c93","modified":1564998266058},{"_id":"public/archives/2/index.html","hash":"1b1ee465c4871073c959db70e7976efec46a9775","modified":1564998266059},{"_id":"public/archives/3/index.html","hash":"c58d59cbc6c62b7d3414fa7ed2f0af5934690650","modified":1564998266059},{"_id":"public/tags/Docker/index.html","hash":"ec96f345e8427524e19dc49df0116bcaf1f5b26f","modified":1564998266060},{"_id":"public/tags/WordPress/index.html","hash":"e685f1db2a87de8d7aa43532f3d7cbdfce3c0fc4","modified":1564998266060},{"_id":"public/tags/graphql/index.html","hash":"5096d44a1963ad24c56b6f55e963e56bc2a7c27f","modified":1564998266060},{"_id":"public/tags/javascript/index.html","hash":"74b3a4416208ff72331b1a9936f2cc8459525c37","modified":1564998266060},{"_id":"public/tags/数据结构/index.html","hash":"8d076ebd8dd5326ba37f2272f17a15aa87bafb76","modified":1564998266060},{"_id":"public/tags/Vue/index.html","hash":"31b9a1e92893e4d5642044b60f24e29ac8c3764d","modified":1564998266060},{"_id":"public/tags/Weex/index.html","hash":"f497b295e0b5a002e70127bd637fd6878f1206f1","modified":1564998266061},{"_id":"public/tags/微信小程序/index.html","hash":"2bc10af94c0b172ef63b2ce0cecbd06b44938c6b","modified":1564998266061},{"_id":"public/tags/git/index.html","hash":"8a77719693516227a360f2c79ff5bfb8958beecb","modified":1564998266061},{"_id":"public/tags/gitlab/index.html","hash":"47f52cf2d7c7b439b81e85af15968c5576172b25","modified":1564998266062},{"_id":"public/tags/nodejs/index.html","hash":"2dec5caf123af465574af289eac4d5f04f9fe990","modified":1564998266062},{"_id":"public/tags/CSS3/index.html","hash":"fae4c58ccffaf346a19461462749926b7f6d86f3","modified":1564998266063},{"_id":"public/tags/Frontend-Interview/index.html","hash":"f4627afcacd5a10700da1e4961e97aac8ba68cea","modified":1564998266063},{"_id":"public/tags/html/index.html","hash":"1f1f2f3ed990f037c984a52ee8cf6324e14a995f","modified":1564998266063},{"_id":"public/tags/http/index.html","hash":"04bd8111458408d8d1a8f88d221d19cf2e52e0bd","modified":1564998266063},{"_id":"public/tags/ES6/index.html","hash":"a59359d90788d271ec2075ced168b8b6d5cb6ab2","modified":1564998266063},{"_id":"public/tags/vuejs/index.html","hash":"213a08ff7b555903a0a72c7c1629055b067df2d5","modified":1564998266064},{"_id":"public/tags/HTML/index.html","hash":"54b2366962e600e5448dca95ae082a32410ca8be","modified":1564998266064},{"_id":"public/tags/JavaScript/index.html","hash":"681921cc945a5efa2b6e39ea6928b5e548e61d40","modified":1564998266064},{"_id":"public/tags/Threejs/index.html","hash":"cbc76e8f29dca32ccb28c4f2b138d552137d277e","modified":1564998266064},{"_id":"public/CNAME","hash":"6d05053964eda7371ae3fdd373dae51cf5d3f413","modified":1564998266099},{"_id":"public/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1564998266099},{"_id":"public/img/avatar/alipay.jpg","hash":"1a748a29b0634999ee26512f696b7b7249eb5a1c","modified":1564998266099},{"_id":"public/img/avatar/wechat.jpg","hash":"3db1455b6616a182a7ef46773ef9750f1ec84831","modified":1564998266099},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1564998266099},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1564998266099},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1564998266099},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1564998266100},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1564998266100},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1564998266100},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1564998266531},{"_id":"public/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1564998266533},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1564998266544},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1564998266544},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1564998266544},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1564998266544},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1564998266544},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1564998266544},{"_id":"public/css/widget.css","hash":"6ab0367504355a703f180f10343d2f5558f30fbd","modified":1564998266544},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1564998266544},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1564998266545},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1564998266545},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1564998266545},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1564998266545},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1564998266545},{"_id":"public/css/beantech.css","hash":"f2aeda0e7bb732c0c16f77afb482f78b14dc42b7","modified":1564998266545},{"_id":"public/css/beantech.min.css","hash":"b57004e24164568c938ad14d2c9f4df4b44a7e6c","modified":1564998266545},{"_id":"public/css/hux-blog.min.css","hash":"eba8a9219b55d1f30c78927d6583ef03be5715f0","modified":1564998266545},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1564998266545},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1564998266545},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1564998266545},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1564998266545},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1564998266545},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1564998266546},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1564998266546},{"_id":"public/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1564998266546},{"_id":"public/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1564998266566},{"_id":"public/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1564998266701},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1564998266788},{"_id":"public/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1564998266855},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1564998266863},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1564998266867},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1564998266872},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1564998266889}],"Category":[{"name":"Docker","_id":"cjyy7k4a00005a0s6sbv2r5kc"},{"name":"GraphQL","_id":"cjyy7k4a9000ba0s6gqx3po7p"},{"name":"数据结构","_id":"cjyy7k4aj000oa0s6ceam6nk2"},{"name":"Vue","_id":"cjyy7k4at0017a0s6yv8c9t3q"},{"name":"HTML5","_id":"cjyy7k4az001la0s6m9593mlm"},{"name":"CSS3","_id":"cjyy7k4b4001ua0s6ynwcur2f"},{"name":"前端面试","_id":"cjyy7k4b90020a0s6h2e36th5"},{"name":"HTTP","_id":"cjyy7k4bd002aa0s6lb9eqj7e"},{"name":"JavaScript","_id":"cjyy7k4bk002ua0s6d59qlya7"},{"name":"微信小程序","_id":"cjyy7k4bl0030a0s61vgnpu2z"},{"name":"ThreeJS","_id":"cjyy7k4bm0033a0s6y38jzgfy"},{"name":"TypeScript","_id":"cjzbdlz0u000c2v2szx1zjuxt"}],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-08-05T09:32:00.509Z","updated":"2019-08-05T09:32:00.509Z","path":"404.html","title":"","comments":1,"_id":"cjyy7k47t0000a0s6jf49tsxr","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About Me","date":"2019-05-01T02:48:33.000Z","description":"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。","header-img":"/img/header_img/about.jpg","aplayer":true,"fixed":false,"_content":"\n### 一句话\n\n> 吾生也有涯，而知也无涯。\n\n### 关于我\n\n>性格：外表冷淡 内心火热 雷厉风行 幽默\n\n### 兴趣方向\n\n> 前端（Vue、React等）相关生态技术研究。\n> 运维：GitLab,Jenkins等CI/CD 的构建。\n> 后端：Nodejs,Golang等。\n---\n> 一个不会运维的后端，不是一个好的前端。\n### 联系我\n>QQ: 1302151931\n>邮箱: lazykids520@gmail.com\n>微信: wxid_ooyfs990jdvs22\n\n### 我的音乐\n> 用户名：神秘的地下党\n> 数据来源于： 网易云音乐 --> 我喜欢的音乐\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About Me\"\ndate: 2019-05-01 10:48:33\ndescription: \"合抱之木，生于毫末。九层之台，起于累土。千里之行，始于足下。\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: true\nfixed: false\n---\n\n### 一句话\n\n> 吾生也有涯，而知也无涯。\n\n### 关于我\n\n>性格：外表冷淡 内心火热 雷厉风行 幽默\n\n### 兴趣方向\n\n> 前端（Vue、React等）相关生态技术研究。\n> 运维：GitLab,Jenkins等CI/CD 的构建。\n> 后端：Nodejs,Golang等。\n---\n> 一个不会运维的后端，不是一个好的前端。\n### 联系我\n>QQ: 1302151931\n>邮箱: lazykids520@gmail.com\n>微信: wxid_ooyfs990jdvs22\n\n### 我的音乐\n> 用户名：神秘的地下党\n> 数据来源于： 网易云音乐 --> 我喜欢的音乐\n\n","updated":"2019-08-05T09:32:00.519Z","path":"about/index.html","comments":1,"_id":"cjyy7k49v0002a0s63jll8g7f","content":"<h3><span id=\"一句话\">一句话</span></h3>\n<blockquote>\n<p>吾生也有涯，而知也无涯。</p>\n</blockquote>\n<h3><span id=\"关于我\">关于我</span></h3>\n<blockquote>\n<p>性格：外表冷淡 内心火热 雷厉风行 幽默</p>\n</blockquote>\n<h3><span id=\"兴趣方向\">兴趣方向</span></h3>\n<blockquote>\n<p>前端（Vue、React等）相关生态技术研究。<br>\n运维：GitLab,Jenkins等CI/CD 的构建。<br>\n后端：Nodejs,Golang等。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>一个不会运维的后端，不是一个好的前端。</p>\n</blockquote>\n<h3><span id=\"联系我\">联系我</span></h3>\n<blockquote>\n<p>QQ: 1302151931<br>\n邮箱: <a href=\"mailto:lazykids520@gmail.com\" target=\"_blank\" rel=\"noopener\">lazykids520@gmail.com</a><br>\n微信: wxid_ooyfs990jdvs22</p>\n</blockquote>\n<h3><span id=\"我的音乐\">我的音乐</span></h3>\n<blockquote>\n<p>用户名：神秘的地下党<br>\n数据来源于： 网易云音乐 --&gt; 我喜欢的音乐</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>吾生也有涯，而知也无涯。</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote>\n<p>性格：外表冷淡 内心火热 雷厉风行 幽默</p>\n</blockquote>\n<h3>兴趣方向</h3>\n<blockquote>\n<p>前端（Vue、React等）相关生态技术研究。<br>\n运维：GitLab,Jenkins等CI/CD 的构建。<br>\n后端：Nodejs,Golang等。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>一个不会运维的后端，不是一个好的前端。</p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>QQ: 1302151931<br>\n邮箱: <a href=\"mailto:lazykids520@gmail.com\" target=\"_blank\" rel=\"noopener\">lazykids520@gmail.com</a><br>\n微信: wxid_ooyfs990jdvs22</p>\n</blockquote>\n<h3>我的音乐</h3>\n<blockquote>\n<p>用户名：神秘的地下党<br>\n数据来源于： 网易云音乐 --&gt; 我喜欢的音乐</p>\n</blockquote>\n"},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-08-05T09:32:00.520Z","path":"archive/index.html","_id":"cjyy7k49y0004a0s6mjvmpqkw","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2019-08-05T09:32:00.884Z","updated":"2019-08-05T09:32:00.884Z","path":"tags/index.html","comments":1,"_id":"cjyy7k4a40008a0s6dbwiuxvn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Docker 中如何安装WordPress","catalog":true,"url":"39.html","id":"39","date":"2019-02-18T10:12:44.000Z","subtitle":null,"header-img":null,"_content":"\n### Docker 中如何安装WordPress\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> ##### 1\\. 从dockerHub 中拉取mysql镜像\n\n       docker pull mysql:5.6\n    \n\n当然你也可选用最新的mysql版本\n\n    docker pull mysql\n    \n\n![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&fm=58&bpow=1024&bpoh=1024)\n\n> ##### 2\\. 从dockerHub 中拉取 wordpress镜像\n\n    docker pull wordpress:latest\n    \n\n> ##### 3\\. 创建mysql容器 并且做一些设置\n\n    docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n    \n    \n\n> ##### 4\\. 创建WordPress 容器并且做一些基础配置\n\n    docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n    \n\n> ##### 5\\. 访问localhost:8080 端口进行配置wordpress站点","source":"_posts/Docker 中如何安装WordPress.md","raw":"---\ntitle: Docker 中如何安装WordPress\ncatalog: true\ntags:\n  - Docker\n  - WordPress\nurl: 39.html\nid: 39\ncategories:\n  - Docker\ndate: 2019-02-18 18:12:44\nsubtitle:\nheader-img:\n---\n\n### Docker 中如何安装WordPress\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> ##### 1\\. 从dockerHub 中拉取mysql镜像\n\n       docker pull mysql:5.6\n    \n\n当然你也可选用最新的mysql版本\n\n    docker pull mysql\n    \n\n![](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&fm=58&bpow=1024&bpoh=1024)\n\n> ##### 2\\. 从dockerHub 中拉取 wordpress镜像\n\n    docker pull wordpress:latest\n    \n\n> ##### 3\\. 创建mysql容器 并且做一些设置\n\n    docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n    \n    \n\n> ##### 4\\. 创建WordPress 容器并且做一些基础配置\n\n    docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n    \n\n> ##### 5\\. 访问localhost:8080 端口进行配置wordpress站点","slug":"Docker 中如何安装WordPress","published":1,"updated":"2019-08-05T09:32:00.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k49s0001a0s6xnqrgy8q","content":"<h3><span id=\"docker-中如何安装wordpress\">Docker 中如何安装WordPress</span></h3>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h5><span id=\"1-从dockerhub-中拉取mysql镜像\">1. 从dockerHub 中拉取mysql镜像</span></h5>\n</blockquote>\n<pre><code>   docker pull mysql:5.6\n</code></pre>\n<p>当然你也可选用最新的mysql版本</p>\n<pre><code>docker pull mysql\n</code></pre>\n<p><img src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&amp;fm=58&amp;bpow=1024&amp;bpoh=1024\" alt></p>\n<blockquote>\n<h5><span id=\"2-从dockerhub-中拉取-wordpress镜像\">2. 从dockerHub 中拉取 wordpress镜像</span></h5>\n</blockquote>\n<pre><code>docker pull wordpress:latest\n</code></pre>\n<blockquote>\n<h5><span id=\"3-创建mysql容器-并且做一些设置\">3. 创建mysql容器 并且做一些设置</span></h5>\n</blockquote>\n<pre><code>docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n</code></pre>\n<blockquote>\n<h5><span id=\"4-创建wordpress-容器并且做一些基础配置\">4. 创建WordPress 容器并且做一些基础配置</span></h5>\n</blockquote>\n<pre><code>docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n</code></pre>\n<blockquote>\n<h5><span id=\"5-访问localhost8080-端口进行配置wordpress站点\">5. 访问localhost:8080 端口进行配置wordpress站点</span></h5>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>Docker 中如何安装WordPress</h3>\n<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h5>1. 从dockerHub 中拉取mysql镜像</h5>\n</blockquote>\n<pre><code>   docker pull mysql:5.6\n</code></pre>\n<p>当然你也可选用最新的mysql版本</p>\n<pre><code>docker pull mysql\n</code></pre>\n<p><img src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2829320801,1933304096&amp;fm=58&amp;bpow=1024&amp;bpoh=1024\" alt></p>\n<blockquote>\n<h5>2. 从dockerHub 中拉取 wordpress镜像</h5>\n</blockquote>\n<pre><code>docker pull wordpress:latest\n</code></pre>\n<blockquote>\n<h5>3. 创建mysql容器 并且做一些设置</h5>\n</blockquote>\n<pre><code>docker run --name wordpress-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n</code></pre>\n<blockquote>\n<h5>4. 创建WordPress 容器并且做一些基础配置</h5>\n</blockquote>\n<pre><code>docker run --name blog-wordpress --link wordpress-mysql:mysql -p 8080:80 -d wordpress\n</code></pre>\n<blockquote>\n<h5>5. 访问localhost:8080 端口进行配置wordpress站点</h5>\n</blockquote>\n"},{"title":"GraphQL 简介","catalog":true,"url":"12.html","id":"12","date":"2019-02-18T08:12:40.000Z","subtitle":null,"header-img":null,"_content":"\n### GraphQL 简介\n\n![](http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png)\n\n#### 1\\. 什么是GraphQL ?\n\n1.  GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。\n    \n2.  GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。\n    \n3.  GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n    \n\n#### 2\\. GraphQL 有什么特点？\n\n1.  请求的数据，不多不少 \\> 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。\n2.  获取多个资源，只用一个请求。\n3.  描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。\n\n#### 3\\. GraphQL与Restful API 对比\n\n1.  restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。\n2.  restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。\n3.  restful用不同的url来区分资源，graphql用类型区分资源。\n\n#### 4\\. 构建一个GraphQL简单的服务端（Nodejs Express）\n\n1.  定义查询的Schema和类型\n\n       const Schema = buildSchema(\n       `\n        type Query {\n            hello: String\n        }\n       `);\n    \n\n2.  定义查询对应的处理器\n\n    const rootValue = {\n        hello: ()=>{\n            return \"hello graphql!\"\n        }\n    }\n    \n    \n\n3.  结合Schema和对应的处理器\n\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true // 打开graphql语言查询调试图形界面\n    }))\n    \n\n4.  打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句\n\n      nodemon app.js\n    \n\n    query {\n        hello\n    }\n    \n\n> 结果如图 [![](https://i.loli.net/2019/02/18/5c6a69c78a41b.png)](https://i.loli.net/2019/02/18/5c6a69c78a41b.png) 源码文件 app.js\n\n    // npm install express exprss-graphql graphql --save\n    const express = require('express');\n    const graphqlHTTP = require('express-graphql');\n    const { buildSchema } = require('graphql');\n    const app = express();\n    const schema = buildSchema(`\n        type Query {\n            hello: String\n        }\n       `);\n    const rootValue = {hello: () => \"hello graphql\"};\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    app.listen(3000, ()=>{\n        console.log(\"Now browser to localhost:3000/graphql!\");\n    })","source":"_posts/GraphQL 简介.md","raw":"---\ntitle: GraphQL 简介\ncatalog: true\ntags:\n  - graphql\nurl: 12.html\nid: 12\ncategories:\n  - GraphQL\ndate: 2019-02-18 16:12:40\nsubtitle:\nheader-img:\n---\n\n### GraphQL 简介\n\n![](http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png)\n\n#### 1\\. 什么是GraphQL ?\n\n1.  GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。\n    \n2.  GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。\n    \n3.  GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。\n    \n\n#### 2\\. GraphQL 有什么特点？\n\n1.  请求的数据，不多不少 \\> 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。\n2.  获取多个资源，只用一个请求。\n3.  描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。\n\n#### 3\\. GraphQL与Restful API 对比\n\n1.  restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。\n2.  restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。\n3.  restful用不同的url来区分资源，graphql用类型区分资源。\n\n#### 4\\. 构建一个GraphQL简单的服务端（Nodejs Express）\n\n1.  定义查询的Schema和类型\n\n       const Schema = buildSchema(\n       `\n        type Query {\n            hello: String\n        }\n       `);\n    \n\n2.  定义查询对应的处理器\n\n    const rootValue = {\n        hello: ()=>{\n            return \"hello graphql!\"\n        }\n    }\n    \n    \n\n3.  结合Schema和对应的处理器\n\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true // 打开graphql语言查询调试图形界面\n    }))\n    \n\n4.  打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句\n\n      nodemon app.js\n    \n\n    query {\n        hello\n    }\n    \n\n> 结果如图 [![](https://i.loli.net/2019/02/18/5c6a69c78a41b.png)](https://i.loli.net/2019/02/18/5c6a69c78a41b.png) 源码文件 app.js\n\n    // npm install express exprss-graphql graphql --save\n    const express = require('express');\n    const graphqlHTTP = require('express-graphql');\n    const { buildSchema } = require('graphql');\n    const app = express();\n    const schema = buildSchema(`\n        type Query {\n            hello: String\n        }\n       `);\n    const rootValue = {hello: () => \"hello graphql\"};\n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    app.listen(3000, ()=>{\n        console.log(\"Now browser to localhost:3000/graphql!\");\n    })","slug":"GraphQL 简介","published":1,"updated":"2019-08-05T09:32:00.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k49w0003a0s6brwdg8e5","content":"<h3><span id=\"graphql-简介\">GraphQL 简介</span></h3>\n<p><img src=\"http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png\" alt></p>\n<h4><span id=\"1-什么是graphql\">1. 什么是GraphQL ?</span></h4>\n<ol>\n<li>\n<p>GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。</p>\n</li>\n<li>\n<p>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</p>\n</li>\n<li>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>\n</li>\n</ol>\n<h4><span id=\"2-graphql-有什么特点\">2. GraphQL 有什么特点？</span></h4>\n<ol>\n<li>请求的数据，不多不少 &gt; 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。</li>\n<li>获取多个资源，只用一个请求。</li>\n<li>描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。</li>\n</ol>\n<h4><span id=\"3-graphql与restful-api-对比\">3. GraphQL与Restful API 对比</span></h4>\n<ol>\n<li>restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。</li>\n<li>restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。</li>\n<li>restful用不同的url来区分资源，graphql用类型区分资源。</li>\n</ol>\n<h4><span id=\"4-构建一个graphql简单的服务端nodejs-express\">4. 构建一个GraphQL简单的服务端（Nodejs Express）</span></h4>\n<ol>\n<li>\n<p>定义查询的Schema和类型</p>\n<p>const Schema = buildSchema(<br>\n<code>type Query { hello: String }</code>);</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>定义查询对应的处理器</p>\n<p>const rootValue = {<br>\nhello: ()=&gt;{<br>\nreturn “hello graphql!”<br>\n}<br>\n}</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>结合Schema和对应的处理器</p>\n<p>app.use(’/graphql’, graphqlHTTP({<br>\nschema,<br>\nrootValue,<br>\ngraphiql: true // 打开graphql语言查询调试图形界面<br>\n}))</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句</p>\n<p>nodemon app.js</p>\n</li>\n</ol>\n<pre><code>query {\n    hello\n}\n</code></pre>\n<blockquote>\n<p>结果如图 <a href=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" alt></a> 源码文件 app.js</p>\n</blockquote>\n<pre><code>// npm install express exprss-graphql graphql --save\nconst express = require('express');\nconst graphqlHTTP = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n    type Query {\n        hello: String\n    }\n   `);\nconst rootValue = {hello: () =&gt; &quot;hello graphql&quot;};\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\napp.listen(3000, ()=&gt;{\n    console.log(&quot;Now browser to localhost:3000/graphql!&quot;);\n})</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3>GraphQL 简介</h3>\n<p><img src=\"http://static.oschina.net/uploads/space/2018/0723/081132_6JEI_2720166.png\" alt></p>\n<h4>1. 什么是GraphQL ?</h4>\n<ol>\n<li>\n<p>GraphQL是一种新的API标准，它提供了一种更高效、强大和灵活的数据提供方式。它是由Facebook 2015年开发和开源，目前由来自世界各地的大公司和个人维护。是REST API的替代品。</p>\n</li>\n<li>\n<p>GraphQL本质上是一种基于api的查询语言，现在大多数应用程序都需要从服务器中获取数据，这些数据存储可能存储在数据库中，API的职责是提供与应用程序需求相匹配的存储数据的接口。</p>\n</li>\n<li>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>\n</li>\n</ol>\n<h4>2. GraphQL 有什么特点？</h4>\n<ol>\n<li>请求的数据，不多不少 &gt; 例如： User 中有name,age,gender,department等信息字段，我们可以只取得需要的字段。</li>\n<li>获取多个资源，只用一个请求。</li>\n<li>描述所有可能的类型系统。便于维护，根据需求平滑演进，添加或者隐藏字段。</li>\n</ol>\n<h4>3. GraphQL与Restful API 对比</h4>\n<ol>\n<li>restful: representational State Transfer 表属性状态转移。本质就是用定义uri,通过API接口来取得资源。通用系统架构，不受语言限制。</li>\n<li>restful一个接口只能返回一个资源，graphql 一次可以获取多个资源。</li>\n<li>restful用不同的url来区分资源，graphql用类型区分资源。</li>\n</ol>\n<h4>4. 构建一个GraphQL简单的服务端（Nodejs Express）</h4>\n<ol>\n<li>\n<p>定义查询的Schema和类型</p>\n<p>const Schema = buildSchema(<br>\n<code>type Query { hello: String }</code>);</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>定义查询对应的处理器</p>\n<p>const rootValue = {<br>\nhello: ()=&gt;{<br>\nreturn “hello graphql!”<br>\n}<br>\n}</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>\n<p>结合Schema和对应的处理器</p>\n<p>app.use(’/graphql’, graphqlHTTP({<br>\nschema,<br>\nrootValue,<br>\ngraphiql: true // 打开graphql语言查询调试图形界面<br>\n}))</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li>\n<p>打开游览器，输入localhost:3000/graphql,在graphiql 图形界面中输入查询语句</p>\n<p>nodemon app.js</p>\n</li>\n</ol>\n<pre><code>query {\n    hello\n}\n</code></pre>\n<blockquote>\n<p>结果如图 <a href=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2019/02/18/5c6a69c78a41b.png\" alt></a> 源码文件 app.js</p>\n</blockquote>\n<pre><code>// npm install express exprss-graphql graphql --save\nconst express = require('express');\nconst graphqlHTTP = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n    type Query {\n        hello: String\n    }\n   `);\nconst rootValue = {hello: () =&gt; &quot;hello graphql&quot;};\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\napp.listen(3000, ()=&gt;{\n    console.log(&quot;Now browser to localhost:3000/graphql!&quot;);\n})</code></pre>\n"},{"title":"GraphQL入门之GraphQL的查询","catalog":true,"url":"69.html","id":"69","date":"2019-02-19T05:18:01.000Z","subtitle":null,"header-img":null,"_content":"\n#### \n\nGraphQL入门之GraphQL的查询\n\n![](http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&fm=26&gp=0.jpg)\n\n#### 先附上源代码文件\n\n> app.js\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    \n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n\n> 然后运行\n\n     nodemon app.js\n    \n\n> 打开游览器访问 localhost:3000/graphql\n\n#### 一. 字段（Fields）\n\n> 1.  简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFields{\n     hello\n    }\n    \n\n> 在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/2.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFieldsObject {\n      randomUser {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 二. 参数（Arguments）\n\n> 即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/8.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n    \n\n#### 三. 别名（Aliases）\n\n> 你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/5.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail: userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 四. 片段（Fragments）\n\n> 假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/6.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail:userInfo(id: 10001) {\n        ...useItem\n      }\n    }\n    \n    fragment useItem on User {\n      name\n      age\n      id\n      gender\n    }\n    \n    \n\n#### 五. 变量（Variables）\n\n> 目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：\n\n1.  使用 $variableName 替代查询中的静态值。\n2.  声明 $variableName 为查询接受的变量之一。\n3.  将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/9.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n    }\n    \n\n#### 六. 操作名称（Operation name）\n\n> 这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。\n\n#### 七. 指令（Directives）\n\n> 我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/10.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001,$showId:Boolean=false){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n      userList: users{\n        name @include(if:$showId)\n        age\n        gender\n      }\n    }\n    \n\n> #### 更多学习请参考 [GraphQL官网](http://graphql.cn/)","source":"_posts/GraphQL入门之GraphQL的查询.md","raw":"---\ntitle: GraphQL入门之GraphQL的查询\ncatalog: true\ntags:\n  - graphql\nurl: 69.html\nid: 69\ncategories:\n  - GraphQL\ndate: 2019-02-19 13:18:01\nsubtitle:\nheader-img:\n---\n\n#### \n\nGraphQL入门之GraphQL的查询\n\n![](http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&fm=26&gp=0.jpg)\n\n#### 先附上源代码文件\n\n> app.js\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    \n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n\n> 然后运行\n\n     nodemon app.js\n    \n\n> 打开游览器访问 localhost:3000/graphql\n\n#### 一. 字段（Fields）\n\n> 1.  简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFields{\n     hello\n    }\n    \n\n> 在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/2.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLFieldsObject {\n      randomUser {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 二. 参数（Arguments）\n\n> 即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/8.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n    \n\n#### 三. 别名（Aliases）\n\n> 你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/5.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail: userInfo(id: 10001) {\n        name\n        age\n        gender\n        id\n      }\n    }\n    \n\n#### 四. 片段（Fragments）\n\n> 假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/6.png)\n\n> 查询语句如下：\n\n    query LearnGraphQLArguments {\n      userItemDetail:userInfo(id: 10001) {\n        ...useItem\n      }\n    }\n    \n    fragment useItem on User {\n      name\n      age\n      id\n      gender\n    }\n    \n    \n\n#### 五. 变量（Variables）\n\n> 目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：\n\n1.  使用 $variableName 替代查询中的静态值。\n2.  声明 $variableName 为查询接受的变量之一。\n3.  将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/9.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n    }\n    \n\n#### 六. 操作名称（Operation name）\n\n> 这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。\n\n#### 七. 指令（Directives）\n\n> 我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/10.png)\n\n> 查询语句如下：\n\n    query getUser($id:Int=10001,$showId:Boolean=false){\n      userDetailInfo:userInfo(id: $id){\n        name,\n        age,\n        gender\n      }\n      userList: users{\n        name @include(if:$showId)\n        age\n        gender\n      }\n    }\n    \n\n> #### 更多学习请参考 [GraphQL官网](http://graphql.cn/)","slug":"GraphQL入门之GraphQL的查询","published":1,"updated":"2019-08-05T09:32:00.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4a20007a0s6dm0lxnu5","content":"<h4><span id></span></h4>\n<p>GraphQL入门之GraphQL的查询</p>\n<p><img src=\"http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h4><span id=\"先附上源代码文件\">先附上源代码文件</span></h4>\n<blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\n\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<p>然后运行</p>\n</blockquote>\n<pre><code> nodemon app.js\n</code></pre>\n<blockquote>\n<p>打开游览器访问 localhost:3000/graphql</p>\n</blockquote>\n<h4><span id=\"一-字段fields\">一. 字段（Fields）</span></h4>\n<blockquote>\n<ol>\n<li>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFields{\n hello\n}\n</code></pre>\n<blockquote>\n<p>在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/2.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFieldsObject {\n  randomUser {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"二-参数arguments\">二. 参数（Arguments）</span></h4>\n<blockquote>\n<p>即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/8.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"三-别名aliases\">三. 别名（Aliases）</span></h4>\n<blockquote>\n<p>你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/5.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail: userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4><span id=\"四-片段fragments\">四. 片段（Fragments）</span></h4>\n<blockquote>\n<p>假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/6.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail:userInfo(id: 10001) {\n    ...useItem\n  }\n}\n\nfragment useItem on User {\n  name\n  age\n  id\n  gender\n}\n</code></pre>\n<h4><span id=\"五-变量variables\">五. 变量（Variables）</span></h4>\n<blockquote>\n<p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：</p>\n</blockquote>\n<ol>\n<li>使用 $variableName 替代查询中的静态值。</li>\n<li>声明 $variableName 为查询接受的变量之一。</li>\n<li>将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/9.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n}\n</code></pre>\n<h4><span id=\"六-操作名称operation-name\">六. 操作名称（Operation name）</span></h4>\n<blockquote>\n<p>这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。</p>\n</blockquote>\n<h4><span id=\"七-指令directives\">七. 指令（Directives）</span></h4>\n<blockquote>\n<p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/10.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001,$showId:Boolean=false){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n  userList: users{\n    name @include(if:$showId)\n    age\n    gender\n  }\n}\n</code></pre>\n<blockquote>\n<h4><span id=\"更多学习请参考-graphql官网\">更多学习请参考 </span></h4>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4></h4>\n<p>GraphQL入门之GraphQL的查询</p>\n<p><img src=\"http://img0.imgtn.bdimg.com/it/u=3309702283,977143577&amp;fm=26&amp;gp=0.jpg\" alt></p>\n<h4>先附上源代码文件</h4>\n<blockquote>\n<p>app.js</p>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\n\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<p>然后运行</p>\n</blockquote>\n<pre><code> nodemon app.js\n</code></pre>\n<blockquote>\n<p>打开游览器访问 localhost:3000/graphql</p>\n</blockquote>\n<h4>一. 字段（Fields）</h4>\n<blockquote>\n<ol>\n<li>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFields{\n hello\n}\n</code></pre>\n<blockquote>\n<p>在前一例子中，我们请求返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/2.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLFieldsObject {\n  randomUser {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>二. 参数（Arguments）</h4>\n<blockquote>\n<p>即使我们能做的仅仅是遍历对象及其字段，GraphQL就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/8.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>三. 别名（Aliases）</h4>\n<blockquote>\n<p>你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 ——这可以让你重命名结果中的字段为任意你想到的名字。</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/5.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail: userInfo(id: 10001) {\n    name\n    age\n    gender\n    id\n  }\n}\n</code></pre>\n<h4>四. 片段（Fragments）</h4>\n<blockquote>\n<p>假设我们的 app 有比较复杂的页面。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次。两方各一次以作比较。这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/6.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query LearnGraphQLArguments {\n  userItemDetail:userInfo(id: 10001) {\n    ...useItem\n  }\n}\n\nfragment useItem on User {\n  name\n  age\n  id\n  gender\n}\n</code></pre>\n<h4>五. 变量（Variables）</h4>\n<blockquote>\n<p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的。将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。使用变量之前，我们得做三件事：</p>\n</blockquote>\n<ol>\n<li>使用 $variableName 替代查询中的静态值。</li>\n<li>声明 $variableName 为查询接受的变量之一。</li>\n<li>将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/9.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n}\n</code></pre>\n<h4>六. 操作名称（Operation name）</h4>\n<blockquote>\n<p>这之前，我们都使用了简写句法，省略了 query 关键字和查询名称，但是生产中使用这些可以使我们代码减少歧义。操作类型可以是 query、mutation 或 subscription，描述你打算做什么类型的操作。操作类型是必需的，除非你使用查询简写语法，在这种情况下，你无法为操作提供名称或变量定义。操作名称是你的操作的有意义和明确的名称。它仅在有多个操作的文档中是必需的，但我们鼓励使用它，因为它对于调试和服务器端日志记录非常有用。 当在你的网络日志或是 GraphQL 服务器中出现问题时，通过名称来从你的代码库中找到一个查询比尝试去破译内容更加容易。 就把它想成你喜欢的程序语言中的函数名。例如，在 JavaScript 中，我们只用匿名函数就可以工作，但是当我们给了函数名之后，就更加容易追踪、调试我们的代码，并在其被调用的时候做日志。同理，GraphQL 的查询和变更名称，以及片段名称，都可以成为服务端侧用来识别不同 GraphQL 请求的有效调试工具。</p>\n</blockquote>\n<h4>七. 指令（Directives）</h4>\n<blockquote>\n<p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。我们来构建一个这种组件的查询：</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/10.png\" alt></p>\n<blockquote>\n<p>查询语句如下：</p>\n</blockquote>\n<pre><code>query getUser($id:Int=10001,$showId:Boolean=false){\n  userDetailInfo:userInfo(id: $id){\n    name,\n    age,\n    gender\n  }\n  userList: users{\n    name @include(if:$showId)\n    age\n    gender\n  }\n}\n</code></pre>\n<blockquote>\n<h4>更多学习请参考 <a href=\"http://graphql.cn/\" target=\"_blank\" rel=\"noopener\">GraphQL官网</a></h4>\n</blockquote>\n"},{"title":"JavaScript数据结构与算法-字典和哈希表","catalog":true,"url":"199.html","id":"199","date":"2019-03-10T07:56:49.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是字典？\n\n集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是\\[键，值\\] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以\\[值，值\\]的形式存储元素，字 典则是以\\[键，值\\]的形式来存储元素。字典也称作映射。\n\n#### 2\\. 手动实现Dirctionary\n\n    // 字典 Dirctionary\n    \n    class Dirctionary {\n        constructor(){\n            this.items = new Map();\n        }\n        set(key,value){\n            this.items.set(key,value);\n        }\n        get(key){\n            return this.items.get(key);\n        }\n        remove(key){\n            this.items.delete(key);\n        }\n        has(key){\n            return this.items.has(key);\n        }\n        size(){\n            return this.items.size();\n        }\n        clear(){\n            this.items = new Map();\n        }\n        values(){\n            const arr = []\n            for(let key of this.items.keys()){\n              arr.push(this.items.get(key));\n            }\n            return arr;\n        }\n    \n    }\n    \n    \n\n#### 3\\. 什么是散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。\n\n#### 4\\. 手动实现一个散列表\n\n    // 散列表\n    \n    var loseloseHashCode = function (key) {\n        var hash = 0;                          \n        for (var i = 0; i < key.length; i++) { \n            hash += key.charCodeAt(i);         \n        }\n        return hash % 37; \n    };\n    function HashTable() {\n        var table = [];\n    \n        this.put = function (key, value) {\n            var position = loseloseHashCode(key);\n            console.log(position + ' - ' + key);\n            table[position] = value; \n        };\n        this.get = function (key) {\n            return table[loseloseHashCode(key)];\n        };\n        this.remove = function (key) {\n            table[loseloseHashCode(key)] = undefined;\n        };\n    }\n    var hash = new HashTable();\n    hash.put('Gandalf', 'gandalf@email.com');\n    hash.put('John', 'johnsnow@email.com');\n    hash.put('Tyrion', 'tyrion@email.com');\n    // 19 - Gandalf\n    // 29 - John\n    // 16 - Tyrion","source":"_posts/JavaScript数据结构与算法-字典和哈希表.md","raw":"---\ntitle: JavaScript数据结构与算法-字典和哈希表\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 199.html\nid: 199\ncategories:\n  - 数据结构\ndate: 2019-03-10 15:56:49\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是字典？\n\n集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是\\[键，值\\] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以\\[值，值\\]的形式存储元素，字 典则是以\\[键，值\\]的形式来存储元素。字典也称作映射。\n\n#### 2\\. 手动实现Dirctionary\n\n    // 字典 Dirctionary\n    \n    class Dirctionary {\n        constructor(){\n            this.items = new Map();\n        }\n        set(key,value){\n            this.items.set(key,value);\n        }\n        get(key){\n            return this.items.get(key);\n        }\n        remove(key){\n            this.items.delete(key);\n        }\n        has(key){\n            return this.items.has(key);\n        }\n        size(){\n            return this.items.size();\n        }\n        clear(){\n            this.items = new Map();\n        }\n        values(){\n            const arr = []\n            for(let key of this.items.keys()){\n              arr.push(this.items.get(key));\n            }\n            return arr;\n        }\n    \n    }\n    \n    \n\n#### 3\\. 什么是散列表\n\n散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。\n\n#### 4\\. 手动实现一个散列表\n\n    // 散列表\n    \n    var loseloseHashCode = function (key) {\n        var hash = 0;                          \n        for (var i = 0; i < key.length; i++) { \n            hash += key.charCodeAt(i);         \n        }\n        return hash % 37; \n    };\n    function HashTable() {\n        var table = [];\n    \n        this.put = function (key, value) {\n            var position = loseloseHashCode(key);\n            console.log(position + ' - ' + key);\n            table[position] = value; \n        };\n        this.get = function (key) {\n            return table[loseloseHashCode(key)];\n        };\n        this.remove = function (key) {\n            table[loseloseHashCode(key)] = undefined;\n        };\n    }\n    var hash = new HashTable();\n    hash.put('Gandalf', 'gandalf@email.com');\n    hash.put('John', 'johnsnow@email.com');\n    hash.put('Tyrion', 'tyrion@email.com');\n    // 19 - Gandalf\n    // 29 - John\n    // 16 - Tyrion","slug":"JavaScript数据结构与算法-字典和哈希表","published":1,"updated":"2019-08-05T09:32:00.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4a60009a0s64w540car","content":"<h4><span id=\"1-什么是字典\">1. 什么是字典？</span></h4>\n<p>集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。</p>\n<h4><span id=\"2-手动实现dirctionary\">2. 手动实现Dirctionary</span></h4>\n<pre><code>// 字典 Dirctionary\n\nclass Dirctionary {\n    constructor(){\n        this.items = new Map();\n    }\n    set(key,value){\n        this.items.set(key,value);\n    }\n    get(key){\n        return this.items.get(key);\n    }\n    remove(key){\n        this.items.delete(key);\n    }\n    has(key){\n        return this.items.has(key);\n    }\n    size(){\n        return this.items.size();\n    }\n    clear(){\n        this.items = new Map();\n    }\n    values(){\n        const arr = []\n        for(let key of this.items.keys()){\n          arr.push(this.items.get(key));\n        }\n        return arr;\n    }\n\n}\n</code></pre>\n<h4><span id=\"3-什么是散列表\">3. 什么是散列表</span></h4>\n<p>散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。</p>\n<h4><span id=\"4-手动实现一个散列表\">4. 手动实现一个散列表</span></h4>\n<pre><code>// 散列表\n\nvar loseloseHashCode = function (key) {\n    var hash = 0;                          \n    for (var i = 0; i &lt; key.length; i++) { \n        hash += key.charCodeAt(i);         \n    }\n    return hash % 37; \n};\nfunction HashTable() {\n    var table = [];\n\n    this.put = function (key, value) {\n        var position = loseloseHashCode(key);\n        console.log(position + ' - ' + key);\n        table[position] = value; \n    };\n    this.get = function (key) {\n        return table[loseloseHashCode(key)];\n    };\n    this.remove = function (key) {\n        table[loseloseHashCode(key)] = undefined;\n    };\n}\nvar hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是字典？</h4>\n<p>集合表示一组互不相同的元素(不重复的元素)。在字典中，存储的是[键，值] 对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字 典则是以[键，值]的形式来存储元素。字典也称作映射。</p>\n<h4>2. 手动实现Dirctionary</h4>\n<pre><code>// 字典 Dirctionary\n\nclass Dirctionary {\n    constructor(){\n        this.items = new Map();\n    }\n    set(key,value){\n        this.items.set(key,value);\n    }\n    get(key){\n        return this.items.get(key);\n    }\n    remove(key){\n        this.items.delete(key);\n    }\n    has(key){\n        return this.items.has(key);\n    }\n    size(){\n        return this.items.size();\n    }\n    clear(){\n        this.items = new Map();\n    }\n    values(){\n        const arr = []\n        for(let key of this.items.keys()){\n          arr.push(this.items.get(key));\n        }\n        return arr;\n    }\n\n}\n</code></pre>\n<h4>3. 什么是散列表</h4>\n<p>散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列 函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后 返回值在表中的地址。</p>\n<h4>4. 手动实现一个散列表</h4>\n<pre><code>// 散列表\n\nvar loseloseHashCode = function (key) {\n    var hash = 0;                          \n    for (var i = 0; i &lt; key.length; i++) { \n        hash += key.charCodeAt(i);         \n    }\n    return hash % 37; \n};\nfunction HashTable() {\n    var table = [];\n\n    this.put = function (key, value) {\n        var position = loseloseHashCode(key);\n        console.log(position + ' - ' + key);\n        table[position] = value; \n    };\n    this.get = function (key) {\n        return table[loseloseHashCode(key)];\n    };\n    this.remove = function (key) {\n        table[loseloseHashCode(key)] = undefined;\n    };\n}\nvar hash = new HashTable();\nhash.put('Gandalf', 'gandalf@email.com');\nhash.put('John', 'johnsnow@email.com');\nhash.put('Tyrion', 'tyrion@email.com');\n// 19 - Gandalf\n// 29 - John\n// 16 - Tyrion</code></pre>\n"},{"title":"Docker 学习笔记 如何安装Docker","catalog":true,"url":"114.html","id":"114","date":"2019-02-21T03:41:50.000Z","subtitle":null,"header-img":null,"_content":"\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> #### 1.安装环境 CentOS7\n\n      sudo yum install docker\n    \n\n> #### 2.启动Docker\n\n       sudo yum systemctl start docker\n    \n\n> #### 3.搜索镜像\n\n       docker search ubuntu\n    \n\n> #### 4.拉取镜像\n\n    docker pull ubuntu:16.04\n    \n\n> #### 5.docker 权限问题\n> \n> 运行如下命令\n\n     sudo groupadd docker #创建docker用户组\n     sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n     sudo service docker restart # 重启docker服务，退出ssh,重新连接即可","source":"_posts/Docker 学习笔记 如何安装Docker.md","raw":"---\ntitle: Docker 学习笔记 如何安装Docker\ncatalog: true\ntags:\n  - Docker\nurl: 114.html\nid: 114\ncategories:\n  - Docker\ndate: 2019-02-21 11:41:50\nsubtitle:\nheader-img:\n---\n\n![docker](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg)\n\n> #### 1.安装环境 CentOS7\n\n      sudo yum install docker\n    \n\n> #### 2.启动Docker\n\n       sudo yum systemctl start docker\n    \n\n> #### 3.搜索镜像\n\n       docker search ubuntu\n    \n\n> #### 4.拉取镜像\n\n    docker pull ubuntu:16.04\n    \n\n> #### 5.docker 权限问题\n> \n> 运行如下命令\n\n     sudo groupadd docker #创建docker用户组\n     sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n     sudo service docker restart # 重启docker服务，退出ssh,重新连接即可","slug":"Docker 学习笔记 如何安装Docker","published":1,"updated":"2019-08-05T09:32:00.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4a8000aa0s62gxa7br4","content":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h4><span id=\"1安装环境-centos7\">1.安装环境 CentOS7</span></h4>\n</blockquote>\n<pre><code>  sudo yum install docker\n</code></pre>\n<blockquote>\n<h4><span id=\"2启动docker\">2.启动Docker</span></h4>\n</blockquote>\n<pre><code>   sudo yum systemctl start docker\n</code></pre>\n<blockquote>\n<h4><span id=\"3搜索镜像\">3.搜索镜像</span></h4>\n</blockquote>\n<pre><code>   docker search ubuntu\n</code></pre>\n<blockquote>\n<h4><span id=\"4拉取镜像\">4.拉取镜像</span></h4>\n</blockquote>\n<pre><code>docker pull ubuntu:16.04\n</code></pre>\n<blockquote>\n<h4><span id=\"5docker-权限问题\">5.docker 权限问题</span></h4>\n<p>运行如下命令</p>\n</blockquote>\n<pre><code> sudo groupadd docker #创建docker用户组\n sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n sudo service docker restart # 重启docker服务，退出ssh,重新连接即可</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=05f46e0580d4b31cf03c93bdbfed4042/2cf5e0fe9925bc31137974de55df8db1cb13704b.jpg\" alt=\"docker\"></p>\n<blockquote>\n<h4>1.安装环境 CentOS7</h4>\n</blockquote>\n<pre><code>  sudo yum install docker\n</code></pre>\n<blockquote>\n<h4>2.启动Docker</h4>\n</blockquote>\n<pre><code>   sudo yum systemctl start docker\n</code></pre>\n<blockquote>\n<h4>3.搜索镜像</h4>\n</blockquote>\n<pre><code>   docker search ubuntu\n</code></pre>\n<blockquote>\n<h4>4.拉取镜像</h4>\n</blockquote>\n<pre><code>docker pull ubuntu:16.04\n</code></pre>\n<blockquote>\n<h4>5.docker 权限问题</h4>\n<p>运行如下命令</p>\n</blockquote>\n<pre><code> sudo groupadd docker #创建docker用户组\n sudo gpasswd -a ${USER} docker #将当前用户添加该组内\n sudo service docker restart # 重启docker服务，退出ssh,重新连接即可</code></pre>\n"},{"title":"JavaScript数据结构与算法-栈（Stack）","catalog":true,"url":"181.html","id":"181","date":"2019-03-06T09:51:10.000Z","subtitle":null,"header-img":null,"_content":"\n### JavaScript 数据结构-栈\n\n#### 1\\. 什么是栈？\n\n栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #\n\n#### 2\\. 用JavaScript实现一个简单的栈\n\n    class Stack {\n      constructor() {\n        this.items = []\n      }\n      // 进栈\n      push(item) {\n        this.items.push(item);\n      }\n      // 出栈\n      pop() {\n        return this.items.pop();\n      }\n      // 返回栈顶的元素\n      peek() {\n        return this.items[this.items.length - 1]\n      }\n      // 判断栈是否为空\n      isEmpty() {\n        return this.items.length == 0;\n      }\n      // 移除栈里的所有元素\n      clear() {\n        this.items = []\n      }\n      // 返回栈的长度\n      size() {\n        return this.items.length;\n      },\n      print() {\n          return this.items.toString();\n      }\n    }\n    \n    let stack1 = new Stack();\n    console.log(stack1);  // Stack { items: [] }\n    \n    \n\n#### 3\\. 用栈解决问题\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。\n\n> 1.  十进制转二进制\n\n    function divideBy2(decNumber){\n        let stack = new Stack();\n        let binaryString = \"\";\n        let rem = \"\";\n        while(decNumber > 0){\n            rem = Math.floor(decNumber % 2);\n            stack.push(rem);\n            decNumber = Math.floor(decNumber / 2);\n        }\n        while(!stack.isEmpty()){\n            binaryString += stack.pop().toString() \n        }\n        return binaryString;\n    }\n    console.log(divideBy2(5)); // 101\n    \n\n> 2.  十进制转任意进制\n\n    function baseConverter(decNumber, base) {\n      let stack = new Stack();\n      let binaryString = '';\n      let rem = '';\n      const DIGITS = '0123456789ABCDEF';\n      while (decNumber > 0) {\n        rem = Math.floor(decNumber % base);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    \n      }\n      while (!stack.isEmpty()) {\n        binaryString += DIGITS[stack.pop()]\n      }\n      return binaryString;\n    }\n    console.log(baseConverter(455, 15)); //137EDB825","source":"_posts/JavaScript数据结构与算法-栈（Stack）.md","raw":"---\ntitle: JavaScript数据结构与算法-栈（Stack）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 181.html\nid: 181\ncategories:\n  - 数据结构\ndate: 2019-03-06 17:51:10\nsubtitle:\nheader-img:\n---\n\n### JavaScript 数据结构-栈\n\n#### 1\\. 什么是栈？\n\n栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #\n\n#### 2\\. 用JavaScript实现一个简单的栈\n\n    class Stack {\n      constructor() {\n        this.items = []\n      }\n      // 进栈\n      push(item) {\n        this.items.push(item);\n      }\n      // 出栈\n      pop() {\n        return this.items.pop();\n      }\n      // 返回栈顶的元素\n      peek() {\n        return this.items[this.items.length - 1]\n      }\n      // 判断栈是否为空\n      isEmpty() {\n        return this.items.length == 0;\n      }\n      // 移除栈里的所有元素\n      clear() {\n        this.items = []\n      }\n      // 返回栈的长度\n      size() {\n        return this.items.length;\n      },\n      print() {\n          return this.items.toString();\n      }\n    }\n    \n    let stack1 = new Stack();\n    console.log(stack1);  // Stack { items: [] }\n    \n    \n\n#### 3\\. 用栈解决问题\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。\n\n> 1.  十进制转二进制\n\n    function divideBy2(decNumber){\n        let stack = new Stack();\n        let binaryString = \"\";\n        let rem = \"\";\n        while(decNumber > 0){\n            rem = Math.floor(decNumber % 2);\n            stack.push(rem);\n            decNumber = Math.floor(decNumber / 2);\n        }\n        while(!stack.isEmpty()){\n            binaryString += stack.pop().toString() \n        }\n        return binaryString;\n    }\n    console.log(divideBy2(5)); // 101\n    \n\n> 2.  十进制转任意进制\n\n    function baseConverter(decNumber, base) {\n      let stack = new Stack();\n      let binaryString = '';\n      let rem = '';\n      const DIGITS = '0123456789ABCDEF';\n      while (decNumber > 0) {\n        rem = Math.floor(decNumber % base);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    \n      }\n      while (!stack.isEmpty()) {\n        binaryString += DIGITS[stack.pop()]\n      }\n      return binaryString;\n    }\n    console.log(baseConverter(455, 15)); //137EDB825","slug":"JavaScript数据结构与算法-栈（Stack）","published":1,"updated":"2019-08-05T09:32:00.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ab000da0s69uuqdg3s","content":"<h3><span id=\"javascript-数据结构-栈\">JavaScript 数据结构-栈</span></h3>\n<h4><span id=\"1-什么是栈\">1. 什么是栈？</span></h4>\n<p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #</p>\n<h4><span id=\"2-用javascript实现一个简单的栈\">2. 用JavaScript实现一个简单的栈</span></h4>\n<pre><code>class Stack {\n  constructor() {\n    this.items = []\n  }\n  // 进栈\n  push(item) {\n    this.items.push(item);\n  }\n  // 出栈\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n  // 判断栈是否为空\n  isEmpty() {\n    return this.items.length == 0;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = []\n  }\n  // 返回栈的长度\n  size() {\n    return this.items.length;\n  },\n  print() {\n      return this.items.toString();\n  }\n}\n\nlet stack1 = new Stack();\nconsole.log(stack1);  // Stack { items: [] }\n</code></pre>\n<h4><span id=\"3-用栈解决问题\">3. 用栈解决问题</span></h4>\n<p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。</p>\n<blockquote>\n<ol>\n<li>十进制转二进制</li>\n</ol>\n</blockquote>\n<pre><code>function divideBy2(decNumber){\n    let stack = new Stack();\n    let binaryString = &quot;&quot;;\n    let rem = &quot;&quot;;\n    while(decNumber &gt; 0){\n        rem = Math.floor(decNumber % 2);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    }\n    while(!stack.isEmpty()){\n        binaryString += stack.pop().toString() \n    }\n    return binaryString;\n}\nconsole.log(divideBy2(5)); // 101\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>十进制转任意进制</li>\n</ol>\n</blockquote>\n<pre><code>function baseConverter(decNumber, base) {\n  let stack = new Stack();\n  let binaryString = '';\n  let rem = '';\n  const DIGITS = '0123456789ABCDEF';\n  while (decNumber &gt; 0) {\n    rem = Math.floor(decNumber % base);\n    stack.push(rem);\n    decNumber = Math.floor(decNumber / 2);\n\n  }\n  while (!stack.isEmpty()) {\n    binaryString += DIGITS[stack.pop()]\n  }\n  return binaryString;\n}\nconsole.log(baseConverter(455, 15)); //137EDB825</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3>JavaScript 数据结构-栈</h3>\n<h4>1. 什么是栈？</h4>\n<p>栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈也被用在编程语言的编译器和内存中保存变量、方法调用等。 #</p>\n<h4>2. 用JavaScript实现一个简单的栈</h4>\n<pre><code>class Stack {\n  constructor() {\n    this.items = []\n  }\n  // 进栈\n  push(item) {\n    this.items.push(item);\n  }\n  // 出栈\n  pop() {\n    return this.items.pop();\n  }\n  // 返回栈顶的元素\n  peek() {\n    return this.items[this.items.length - 1]\n  }\n  // 判断栈是否为空\n  isEmpty() {\n    return this.items.length == 0;\n  }\n  // 移除栈里的所有元素\n  clear() {\n    this.items = []\n  }\n  // 返回栈的长度\n  size() {\n    return this.items.length;\n  },\n  print() {\n      return this.items.toString();\n  }\n}\n\nlet stack1 = new Stack();\nconsole.log(stack1);  // Stack { items: [] }\n</code></pre>\n<h4>3. 用栈解决问题</h4>\n<p>栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作(后 面的章节讨论图和回溯问题时，我们会学习如何应用这个例子)。Java和C#用栈来存储变量和方 法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。 既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。本节，我们将 学习使用栈的三个最著名的算法示例。首先是十进制转二进制问题，以及任意进制转换的算法; 然后是平衡圆括号问题;最后，我们会学习如何用栈解决汉诺塔问题。</p>\n<blockquote>\n<ol>\n<li>十进制转二进制</li>\n</ol>\n</blockquote>\n<pre><code>function divideBy2(decNumber){\n    let stack = new Stack();\n    let binaryString = &quot;&quot;;\n    let rem = &quot;&quot;;\n    while(decNumber &gt; 0){\n        rem = Math.floor(decNumber % 2);\n        stack.push(rem);\n        decNumber = Math.floor(decNumber / 2);\n    }\n    while(!stack.isEmpty()){\n        binaryString += stack.pop().toString() \n    }\n    return binaryString;\n}\nconsole.log(divideBy2(5)); // 101\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>十进制转任意进制</li>\n</ol>\n</blockquote>\n<pre><code>function baseConverter(decNumber, base) {\n  let stack = new Stack();\n  let binaryString = '';\n  let rem = '';\n  const DIGITS = '0123456789ABCDEF';\n  while (decNumber &gt; 0) {\n    rem = Math.floor(decNumber % base);\n    stack.push(rem);\n    decNumber = Math.floor(decNumber / 2);\n\n  }\n  while (!stack.isEmpty()) {\n    binaryString += DIGITS[stack.pop()]\n  }\n  return binaryString;\n}\nconsole.log(baseConverter(455, 15)); //137EDB825</code></pre>\n"},{"title":"JavaScript数据结构与算法-树","catalog":true,"url":"214.html","id":"214","date":"2019-03-13T11:09:28.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是树？\n\n树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: ![](http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png) 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。\n\n#### 2.二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。\n\n#### 3\\. 手动实现一个BST(二叉搜索树)\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/12121212.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/1111.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/22222222.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/5555555.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/777777.png)\n\n    // BST 二叉搜索树\n    class TreeNode {\n        constructor(key){\n           this.key = key;\n           this.left =null;\n           this.right = null;\n        }\n    }\n    // 插入节点 辅助函数\n    function insertNode(node,newNode){\n        if(node.key > newNode.key){\n            if(node.left === null){\n                node.left = newNode\n            }else{\n              insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right === null){\n                node.right = newNode\n            }else{\n                insertNode(node.right,newNode);\n            }\n        }\n    }\n    // 中序遍历 辅助函数\n    function inOrderTraverseNode(node,callback){\n       if(node!== null){\n           inOrderTraverseNode(node.left,callback);\n           callback(node.key);\n           inOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 先序遍历 辅助函数\n    function preOrderTraverseNode(node,callback){\n       if(node !==null){\n           callback(node.key);\n           preOrderTraverseNode(node.left,callback);\n           preOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 后续遍历 辅助函数\n    function postOrderTraverseNode(node,callback){\n       if(node !== null){\n           postOrderTraverseNode(node.left, callback);\n           postOrderTraverseNode(node.right, callback);\n           callback(node.key);\n       }\n    }\n    // 最小节点辅助函数\n    function minNode(node){\n        while(node && node.left !==null){\n            node = node.left;\n        }\n        return node.key;\n    }\n    // 最大节点辅助函数\n    function maxNode(node){\n        while(node && node.right !==null){\n            node = node.right;\n        }\n        return node.key;\n    }\n    // 搜索辅助函数\n    function serachNode(node,key){\n        if(node === null){\n            return false;\n        }else{\n            if(key < node.key){\n                return serachNode(node.left,key);\n            }else if(key > node.key){\n                return serachNode(node.right,key);\n            }else{\n                return true;\n            }\n        }\n    }\n    // 删除辅助函数\n    function removeNode(node, key) {\n        if (node === null) {\n            return null;\n        }\n        if (key < node.key) {\n            node.left = removeNode(node.left, key);\n            return node;\n        } else if (key > node.key) {\n            node.right = removeNode(node.right, key);\n            return node;\n        } else { //键等于node.key\n            //第一种情况——一个叶节点\n            if (node.left === null && node.right === null) {\n                node = null;\n                return node;\n            }\n            //第二种情况——一个只有一个子节点的节点 \n            if (node.left === null) {\n                node = node.right;\n                return node;\n            } else if (node.right === null) {\n                node = node.left;\n                return node;\n            }\n            //第三种情况——一个有两个子节点的节点\n            var aux = findMinNode(node.right);\n            node.key = aux.key; //\n            node.right = removeNode(node.right, aux.key);\n            return node;\n        }\n    };\n    // callback 辅助函数\n    function printNode(value){\n       console.log(value);\n    }\n    class BinarySearchTree {\n        constructor(){\n            this.root = null;\n        }\n        // 插入几点\n        insert(key){\n            let newNode = new TreeNode(key);\n            if(this.root === null){\n                this.root = newNode;\n            }else{\n                insertNode(this.root,newNode)\n            }\n        }\n        // 中序遍历 callback 对节点操作回掉函数\n        inOrderTraverse(callback){\n            inOrderTraverseNode(this.root, callback);\n        }\n        //先序遍历\n        preOrderTraverse(callback){\n            preOrderTraverseNode(this.root,callback);\n        }\n        // 后序遍历\n        postOrderTraverse(callback){\n           postOrderTraverseNode(this.root,callback);\n        }\n        // 最小值\n        min(){\n            return minNode(this.root);\n        }\n        // 最大值\n        max(){\n            return maxNode(this.root);\n        }\n        // 搜索\n        serarch(key){\n            return serachNode(this.root,key);\n        }\n        // 删除节点\n        remove(key){\n            root = removeNode(root, key);\n        }\n    }\n    \n    var tree = new BinarySearchTree();\n    tree.insert(11);\n    tree.insert(7);\n    tree.insert(15);\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(9);\n    tree.insert(8);\n    tree.insert(10);\n    tree.insert(13);\n    tree.insert(12);\n    tree.insert(14);\n    tree.insert(20);\n    tree.insert(18);\n    tree.insert(25);\n    tree.insert(6);\n    console.log(tree);\n    console.log('--------------------中序遍历-------------');\n    console.log(tree.inOrderTraverse(printNode));\n    console.log('--------------------先序遍历-------------');\n    console.log(tree.preOrderTraverse(printNode));\n    console.log('--------------------后序遍历-------------');\n    console.log(tree.postOrderTraverse(printNode));\n    console.log('--------------------最小值-------------');\n    console.log(tree.min());\n    console.log('--------------------最大值-------------');\n    console.log(tree.max());\n    \n    console.log('--------------------搜索-------------');\n    console.log(tree.serarch(100));\n    <!----------------------中序遍历--------------->\n    <!--3-->\n    <!--5-->\n    <!--6-->\n    <!--7-->\n    <!--8-->\n    <!--9-->\n    <!--10-->\n    <!--11-->\n    <!--12-->\n    <!--13-->\n    <!--14-->\n    <!--15-->\n    <!--18-->\n    <!--20-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------先序遍历--------------->\n    <!--11-->\n    <!--7-->\n    <!--5-->\n    <!--3-->\n    <!--6-->\n    <!--9-->\n    <!--8-->\n    <!--10-->\n    <!--15-->\n    <!--13-->\n    <!--12-->\n    <!--14-->\n    <!--20-->\n    <!--18-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------后序遍历--------------->\n    <!--3-->\n    <!--6-->\n    <!--5-->\n    <!--8-->\n    <!--10-->\n    <!--9-->\n    <!--7-->\n    <!--12-->\n    <!--14-->\n    <!--13-->\n    <!--18-->\n    <!--25-->\n    <!--20-->\n    <!--15-->\n    <!--11-->\n    <!--undefined-->\n    <!----------------------最小值--------------->\n    <!--3-->\n    <!----------------------最大值--------------->\n    <!--25-->\n    <!----------------------搜索--------------->\n    <!--false-->","source":"_posts/JavaScript数据结构与算法-树.md","raw":"---\ntitle: JavaScript数据结构与算法-树\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 214.html\nid: 214\ncategories:\n  - 数据结构\ndate: 2019-03-13 19:09:28\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是树？\n\n树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: ![](http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png) 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。\n\n#### 2.二叉树和二叉搜索树\n\n二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。\n\n#### 3\\. 手动实现一个BST(二叉搜索树)\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/12121212.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/1111.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/22222222.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/5555555.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png) ![](http://116.85.35.63/wp-content/uploads/2019/03/777777.png)\n\n    // BST 二叉搜索树\n    class TreeNode {\n        constructor(key){\n           this.key = key;\n           this.left =null;\n           this.right = null;\n        }\n    }\n    // 插入节点 辅助函数\n    function insertNode(node,newNode){\n        if(node.key > newNode.key){\n            if(node.left === null){\n                node.left = newNode\n            }else{\n              insertNode(node.left,newNode)\n            }\n        }else{\n            if(node.right === null){\n                node.right = newNode\n            }else{\n                insertNode(node.right,newNode);\n            }\n        }\n    }\n    // 中序遍历 辅助函数\n    function inOrderTraverseNode(node,callback){\n       if(node!== null){\n           inOrderTraverseNode(node.left,callback);\n           callback(node.key);\n           inOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 先序遍历 辅助函数\n    function preOrderTraverseNode(node,callback){\n       if(node !==null){\n           callback(node.key);\n           preOrderTraverseNode(node.left,callback);\n           preOrderTraverseNode(node.right,callback);\n       }\n    }\n    // 后续遍历 辅助函数\n    function postOrderTraverseNode(node,callback){\n       if(node !== null){\n           postOrderTraverseNode(node.left, callback);\n           postOrderTraverseNode(node.right, callback);\n           callback(node.key);\n       }\n    }\n    // 最小节点辅助函数\n    function minNode(node){\n        while(node && node.left !==null){\n            node = node.left;\n        }\n        return node.key;\n    }\n    // 最大节点辅助函数\n    function maxNode(node){\n        while(node && node.right !==null){\n            node = node.right;\n        }\n        return node.key;\n    }\n    // 搜索辅助函数\n    function serachNode(node,key){\n        if(node === null){\n            return false;\n        }else{\n            if(key < node.key){\n                return serachNode(node.left,key);\n            }else if(key > node.key){\n                return serachNode(node.right,key);\n            }else{\n                return true;\n            }\n        }\n    }\n    // 删除辅助函数\n    function removeNode(node, key) {\n        if (node === null) {\n            return null;\n        }\n        if (key < node.key) {\n            node.left = removeNode(node.left, key);\n            return node;\n        } else if (key > node.key) {\n            node.right = removeNode(node.right, key);\n            return node;\n        } else { //键等于node.key\n            //第一种情况——一个叶节点\n            if (node.left === null && node.right === null) {\n                node = null;\n                return node;\n            }\n            //第二种情况——一个只有一个子节点的节点 \n            if (node.left === null) {\n                node = node.right;\n                return node;\n            } else if (node.right === null) {\n                node = node.left;\n                return node;\n            }\n            //第三种情况——一个有两个子节点的节点\n            var aux = findMinNode(node.right);\n            node.key = aux.key; //\n            node.right = removeNode(node.right, aux.key);\n            return node;\n        }\n    };\n    // callback 辅助函数\n    function printNode(value){\n       console.log(value);\n    }\n    class BinarySearchTree {\n        constructor(){\n            this.root = null;\n        }\n        // 插入几点\n        insert(key){\n            let newNode = new TreeNode(key);\n            if(this.root === null){\n                this.root = newNode;\n            }else{\n                insertNode(this.root,newNode)\n            }\n        }\n        // 中序遍历 callback 对节点操作回掉函数\n        inOrderTraverse(callback){\n            inOrderTraverseNode(this.root, callback);\n        }\n        //先序遍历\n        preOrderTraverse(callback){\n            preOrderTraverseNode(this.root,callback);\n        }\n        // 后序遍历\n        postOrderTraverse(callback){\n           postOrderTraverseNode(this.root,callback);\n        }\n        // 最小值\n        min(){\n            return minNode(this.root);\n        }\n        // 最大值\n        max(){\n            return maxNode(this.root);\n        }\n        // 搜索\n        serarch(key){\n            return serachNode(this.root,key);\n        }\n        // 删除节点\n        remove(key){\n            root = removeNode(root, key);\n        }\n    }\n    \n    var tree = new BinarySearchTree();\n    tree.insert(11);\n    tree.insert(7);\n    tree.insert(15);\n    tree.insert(5);\n    tree.insert(3);\n    tree.insert(9);\n    tree.insert(8);\n    tree.insert(10);\n    tree.insert(13);\n    tree.insert(12);\n    tree.insert(14);\n    tree.insert(20);\n    tree.insert(18);\n    tree.insert(25);\n    tree.insert(6);\n    console.log(tree);\n    console.log('--------------------中序遍历-------------');\n    console.log(tree.inOrderTraverse(printNode));\n    console.log('--------------------先序遍历-------------');\n    console.log(tree.preOrderTraverse(printNode));\n    console.log('--------------------后序遍历-------------');\n    console.log(tree.postOrderTraverse(printNode));\n    console.log('--------------------最小值-------------');\n    console.log(tree.min());\n    console.log('--------------------最大值-------------');\n    console.log(tree.max());\n    \n    console.log('--------------------搜索-------------');\n    console.log(tree.serarch(100));\n    <!----------------------中序遍历--------------->\n    <!--3-->\n    <!--5-->\n    <!--6-->\n    <!--7-->\n    <!--8-->\n    <!--9-->\n    <!--10-->\n    <!--11-->\n    <!--12-->\n    <!--13-->\n    <!--14-->\n    <!--15-->\n    <!--18-->\n    <!--20-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------先序遍历--------------->\n    <!--11-->\n    <!--7-->\n    <!--5-->\n    <!--3-->\n    <!--6-->\n    <!--9-->\n    <!--8-->\n    <!--10-->\n    <!--15-->\n    <!--13-->\n    <!--12-->\n    <!--14-->\n    <!--20-->\n    <!--18-->\n    <!--25-->\n    <!--undefined-->\n    <!----------------------后序遍历--------------->\n    <!--3-->\n    <!--6-->\n    <!--5-->\n    <!--8-->\n    <!--10-->\n    <!--9-->\n    <!--7-->\n    <!--12-->\n    <!--14-->\n    <!--13-->\n    <!--18-->\n    <!--25-->\n    <!--20-->\n    <!--15-->\n    <!--11-->\n    <!--undefined-->\n    <!----------------------最小值--------------->\n    <!--3-->\n    <!----------------------最大值--------------->\n    <!--25-->\n    <!----------------------搜索--------------->\n    <!--false-->","slug":"JavaScript数据结构与算法-树","published":1,"updated":"2019-08-05T09:32:00.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ac000fa0s6b9fw2wpd","content":"<h4><span id=\"1-什么是树\">1. 什么是树？</span></h4>\n<p>树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png\" alt> 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。</p>\n<h4><span id=\"2二叉树和二叉搜索树\">2.二叉树和二叉搜索树</span></h4>\n<p>二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。</p>\n<h4><span id=\"3-手动实现一个bst二叉搜索树\">3. 手动实现一个BST(二叉搜索树)</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/12121212.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/1111.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/22222222.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/5555555.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/777777.png\" alt></p>\n<pre><code>// BST 二叉搜索树\nclass TreeNode {\n    constructor(key){\n       this.key = key;\n       this.left =null;\n       this.right = null;\n    }\n}\n// 插入节点 辅助函数\nfunction insertNode(node,newNode){\n    if(node.key &gt; newNode.key){\n        if(node.left === null){\n            node.left = newNode\n        }else{\n          insertNode(node.left,newNode)\n        }\n    }else{\n        if(node.right === null){\n            node.right = newNode\n        }else{\n            insertNode(node.right,newNode);\n        }\n    }\n}\n// 中序遍历 辅助函数\nfunction inOrderTraverseNode(node,callback){\n   if(node!== null){\n       inOrderTraverseNode(node.left,callback);\n       callback(node.key);\n       inOrderTraverseNode(node.right,callback);\n   }\n}\n// 先序遍历 辅助函数\nfunction preOrderTraverseNode(node,callback){\n   if(node !==null){\n       callback(node.key);\n       preOrderTraverseNode(node.left,callback);\n       preOrderTraverseNode(node.right,callback);\n   }\n}\n// 后续遍历 辅助函数\nfunction postOrderTraverseNode(node,callback){\n   if(node !== null){\n       postOrderTraverseNode(node.left, callback);\n       postOrderTraverseNode(node.right, callback);\n       callback(node.key);\n   }\n}\n// 最小节点辅助函数\nfunction minNode(node){\n    while(node &amp;&amp; node.left !==null){\n        node = node.left;\n    }\n    return node.key;\n}\n// 最大节点辅助函数\nfunction maxNode(node){\n    while(node &amp;&amp; node.right !==null){\n        node = node.right;\n    }\n    return node.key;\n}\n// 搜索辅助函数\nfunction serachNode(node,key){\n    if(node === null){\n        return false;\n    }else{\n        if(key &lt; node.key){\n            return serachNode(node.left,key);\n        }else if(key &gt; node.key){\n            return serachNode(node.right,key);\n        }else{\n            return true;\n        }\n    }\n}\n// 删除辅助函数\nfunction removeNode(node, key) {\n    if (node === null) {\n        return null;\n    }\n    if (key &lt; node.key) {\n        node.left = removeNode(node.left, key);\n        return node;\n    } else if (key &gt; node.key) {\n        node.right = removeNode(node.right, key);\n        return node;\n    } else { //键等于node.key\n        //第一种情况——一个叶节点\n        if (node.left === null &amp;&amp; node.right === null) {\n            node = null;\n            return node;\n        }\n        //第二种情况——一个只有一个子节点的节点 \n        if (node.left === null) {\n            node = node.right;\n            return node;\n        } else if (node.right === null) {\n            node = node.left;\n            return node;\n        }\n        //第三种情况——一个有两个子节点的节点\n        var aux = findMinNode(node.right);\n        node.key = aux.key; //\n        node.right = removeNode(node.right, aux.key);\n        return node;\n    }\n};\n// callback 辅助函数\nfunction printNode(value){\n   console.log(value);\n}\nclass BinarySearchTree {\n    constructor(){\n        this.root = null;\n    }\n    // 插入几点\n    insert(key){\n        let newNode = new TreeNode(key);\n        if(this.root === null){\n            this.root = newNode;\n        }else{\n            insertNode(this.root,newNode)\n        }\n    }\n    // 中序遍历 callback 对节点操作回掉函数\n    inOrderTraverse(callback){\n        inOrderTraverseNode(this.root, callback);\n    }\n    //先序遍历\n    preOrderTraverse(callback){\n        preOrderTraverseNode(this.root,callback);\n    }\n    // 后序遍历\n    postOrderTraverse(callback){\n       postOrderTraverseNode(this.root,callback);\n    }\n    // 最小值\n    min(){\n        return minNode(this.root);\n    }\n    // 最大值\n    max(){\n        return maxNode(this.root);\n    }\n    // 搜索\n    serarch(key){\n        return serachNode(this.root,key);\n    }\n    // 删除节点\n    remove(key){\n        root = removeNode(root, key);\n    }\n}\n\nvar tree = new BinarySearchTree();\ntree.insert(11);\ntree.insert(7);\ntree.insert(15);\ntree.insert(5);\ntree.insert(3);\ntree.insert(9);\ntree.insert(8);\ntree.insert(10);\ntree.insert(13);\ntree.insert(12);\ntree.insert(14);\ntree.insert(20);\ntree.insert(18);\ntree.insert(25);\ntree.insert(6);\nconsole.log(tree);\nconsole.log('--------------------中序遍历-------------');\nconsole.log(tree.inOrderTraverse(printNode));\nconsole.log('--------------------先序遍历-------------');\nconsole.log(tree.preOrderTraverse(printNode));\nconsole.log('--------------------后序遍历-------------');\nconsole.log(tree.postOrderTraverse(printNode));\nconsole.log('--------------------最小值-------------');\nconsole.log(tree.min());\nconsole.log('--------------------最大值-------------');\nconsole.log(tree.max());\n\nconsole.log('--------------------搜索-------------');\nconsole.log(tree.serarch(100));\n&lt;!----------------------中序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--5--&gt;\n&lt;!--6--&gt;\n&lt;!--7--&gt;\n&lt;!--8--&gt;\n&lt;!--9--&gt;\n&lt;!--10--&gt;\n&lt;!--11--&gt;\n&lt;!--12--&gt;\n&lt;!--13--&gt;\n&lt;!--14--&gt;\n&lt;!--15--&gt;\n&lt;!--18--&gt;\n&lt;!--20--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------先序遍历---------------&gt;\n&lt;!--11--&gt;\n&lt;!--7--&gt;\n&lt;!--5--&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--9--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--15--&gt;\n&lt;!--13--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--20--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------后序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--5--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--9--&gt;\n&lt;!--7--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--13--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--20--&gt;\n&lt;!--15--&gt;\n&lt;!--11--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------最小值---------------&gt;\n&lt;!--3--&gt;\n&lt;!----------------------最大值---------------&gt;\n&lt;!--25--&gt;\n&lt;!----------------------搜索---------------&gt;\n&lt;!--false--&gt;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是树？</h4>\n<p>树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构 图，一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点(除了顶部的第一个 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。 现在我们知道了与树相关的一些最重要的概念，下面来学习更多有关树的知识。 8.3 二叉树和二叉搜索树 二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 节点)以及零个或多个子节点: <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/QQ20190313-183758.png\" alt> 位于树顶部的节点叫作根节点(11)。它没有父节点。树中的每个元素都叫作节点，节点分 为内部节点和外部节点。至少有一个子节点的节点称为内部节点(7、5、9、15、13和20是内部 节点)。没有子元素的节点称为外部节点或叶节点(3、6、8、10、12、14、18和25是叶节点)。 一个节点可以有祖先和后代。一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7 和节点11，后代有节点3和节点6。 有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上 图中树的一棵子树。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节 9 点(5、7和11)，它的深度为3。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它 的子节点在第1层，以此类推。上图中的树的高度为3(最大高度已在图中表示——第3层)。</p>\n<h4>2.二叉树和二叉搜索树</h4>\n<p>二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。上一节的图中就展现了一棵二叉搜索树。</p>\n<h4>3. 手动实现一个BST(二叉搜索树)</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/12121212.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/1111.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/22222222.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444-1.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/5555555.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/6666666.png.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/03/777777.png\" alt></p>\n<pre><code>// BST 二叉搜索树\nclass TreeNode {\n    constructor(key){\n       this.key = key;\n       this.left =null;\n       this.right = null;\n    }\n}\n// 插入节点 辅助函数\nfunction insertNode(node,newNode){\n    if(node.key &gt; newNode.key){\n        if(node.left === null){\n            node.left = newNode\n        }else{\n          insertNode(node.left,newNode)\n        }\n    }else{\n        if(node.right === null){\n            node.right = newNode\n        }else{\n            insertNode(node.right,newNode);\n        }\n    }\n}\n// 中序遍历 辅助函数\nfunction inOrderTraverseNode(node,callback){\n   if(node!== null){\n       inOrderTraverseNode(node.left,callback);\n       callback(node.key);\n       inOrderTraverseNode(node.right,callback);\n   }\n}\n// 先序遍历 辅助函数\nfunction preOrderTraverseNode(node,callback){\n   if(node !==null){\n       callback(node.key);\n       preOrderTraverseNode(node.left,callback);\n       preOrderTraverseNode(node.right,callback);\n   }\n}\n// 后续遍历 辅助函数\nfunction postOrderTraverseNode(node,callback){\n   if(node !== null){\n       postOrderTraverseNode(node.left, callback);\n       postOrderTraverseNode(node.right, callback);\n       callback(node.key);\n   }\n}\n// 最小节点辅助函数\nfunction minNode(node){\n    while(node &amp;&amp; node.left !==null){\n        node = node.left;\n    }\n    return node.key;\n}\n// 最大节点辅助函数\nfunction maxNode(node){\n    while(node &amp;&amp; node.right !==null){\n        node = node.right;\n    }\n    return node.key;\n}\n// 搜索辅助函数\nfunction serachNode(node,key){\n    if(node === null){\n        return false;\n    }else{\n        if(key &lt; node.key){\n            return serachNode(node.left,key);\n        }else if(key &gt; node.key){\n            return serachNode(node.right,key);\n        }else{\n            return true;\n        }\n    }\n}\n// 删除辅助函数\nfunction removeNode(node, key) {\n    if (node === null) {\n        return null;\n    }\n    if (key &lt; node.key) {\n        node.left = removeNode(node.left, key);\n        return node;\n    } else if (key &gt; node.key) {\n        node.right = removeNode(node.right, key);\n        return node;\n    } else { //键等于node.key\n        //第一种情况——一个叶节点\n        if (node.left === null &amp;&amp; node.right === null) {\n            node = null;\n            return node;\n        }\n        //第二种情况——一个只有一个子节点的节点 \n        if (node.left === null) {\n            node = node.right;\n            return node;\n        } else if (node.right === null) {\n            node = node.left;\n            return node;\n        }\n        //第三种情况——一个有两个子节点的节点\n        var aux = findMinNode(node.right);\n        node.key = aux.key; //\n        node.right = removeNode(node.right, aux.key);\n        return node;\n    }\n};\n// callback 辅助函数\nfunction printNode(value){\n   console.log(value);\n}\nclass BinarySearchTree {\n    constructor(){\n        this.root = null;\n    }\n    // 插入几点\n    insert(key){\n        let newNode = new TreeNode(key);\n        if(this.root === null){\n            this.root = newNode;\n        }else{\n            insertNode(this.root,newNode)\n        }\n    }\n    // 中序遍历 callback 对节点操作回掉函数\n    inOrderTraverse(callback){\n        inOrderTraverseNode(this.root, callback);\n    }\n    //先序遍历\n    preOrderTraverse(callback){\n        preOrderTraverseNode(this.root,callback);\n    }\n    // 后序遍历\n    postOrderTraverse(callback){\n       postOrderTraverseNode(this.root,callback);\n    }\n    // 最小值\n    min(){\n        return minNode(this.root);\n    }\n    // 最大值\n    max(){\n        return maxNode(this.root);\n    }\n    // 搜索\n    serarch(key){\n        return serachNode(this.root,key);\n    }\n    // 删除节点\n    remove(key){\n        root = removeNode(root, key);\n    }\n}\n\nvar tree = new BinarySearchTree();\ntree.insert(11);\ntree.insert(7);\ntree.insert(15);\ntree.insert(5);\ntree.insert(3);\ntree.insert(9);\ntree.insert(8);\ntree.insert(10);\ntree.insert(13);\ntree.insert(12);\ntree.insert(14);\ntree.insert(20);\ntree.insert(18);\ntree.insert(25);\ntree.insert(6);\nconsole.log(tree);\nconsole.log('--------------------中序遍历-------------');\nconsole.log(tree.inOrderTraverse(printNode));\nconsole.log('--------------------先序遍历-------------');\nconsole.log(tree.preOrderTraverse(printNode));\nconsole.log('--------------------后序遍历-------------');\nconsole.log(tree.postOrderTraverse(printNode));\nconsole.log('--------------------最小值-------------');\nconsole.log(tree.min());\nconsole.log('--------------------最大值-------------');\nconsole.log(tree.max());\n\nconsole.log('--------------------搜索-------------');\nconsole.log(tree.serarch(100));\n&lt;!----------------------中序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--5--&gt;\n&lt;!--6--&gt;\n&lt;!--7--&gt;\n&lt;!--8--&gt;\n&lt;!--9--&gt;\n&lt;!--10--&gt;\n&lt;!--11--&gt;\n&lt;!--12--&gt;\n&lt;!--13--&gt;\n&lt;!--14--&gt;\n&lt;!--15--&gt;\n&lt;!--18--&gt;\n&lt;!--20--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------先序遍历---------------&gt;\n&lt;!--11--&gt;\n&lt;!--7--&gt;\n&lt;!--5--&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--9--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--15--&gt;\n&lt;!--13--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--20--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------后序遍历---------------&gt;\n&lt;!--3--&gt;\n&lt;!--6--&gt;\n&lt;!--5--&gt;\n&lt;!--8--&gt;\n&lt;!--10--&gt;\n&lt;!--9--&gt;\n&lt;!--7--&gt;\n&lt;!--12--&gt;\n&lt;!--14--&gt;\n&lt;!--13--&gt;\n&lt;!--18--&gt;\n&lt;!--25--&gt;\n&lt;!--20--&gt;\n&lt;!--15--&gt;\n&lt;!--11--&gt;\n&lt;!--undefined--&gt;\n&lt;!----------------------最小值---------------&gt;\n&lt;!--3--&gt;\n&lt;!----------------------最大值---------------&gt;\n&lt;!--25--&gt;\n&lt;!----------------------搜索---------------&gt;\n&lt;!--false--&gt;</code></pre>\n"},{"title":"Uni-App 基于Vue技术栈方向跨端技术实践","catalog":true,"date":"2019-04-29T22:37:05.000Z","subtitle":null,"header-img":"https://p4.ssl.cdn.btime.com/t0125a8daac3dbdb9f2.jpg?size=1200x616","_content":"\n### 1.什么是Uni-App?\nuni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。\n如下图：\n---\n![跨端图](http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&fm=26&gp=0.jpg)\n![功能架构图](https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png)\n\nuni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示\n\n![多端图](http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png)\n\n> PS: 学习一门技术最好的方式，就是看官网： https://uniapp.dcloud.io/\n\n### 2. 语法原理以及注意事项\n\nuni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。\n> PS: 过于啰嗦和简单，官网文档在此： https://uniapp.dcloud.io/use\n\n### 3. 技术实践\n> 1.先看一下项目的目录结构图\n\n\n![目录结构图](https://s2.ax1x.com/2019/04/30/EG8srn.png)\n\n\n1. src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。\n2. src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多\n3. src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。\n4. src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等\n5. src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件\n6. src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息\n7. src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录\n8. src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。\n9. src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --> unx,具体看官网\n10. dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令\n\n> PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~\n\n### 4. 实践结果\n![实践结果图](https://s2.ax1x.com/2019/04/30/EGJN9S.png)\n1. 目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。\n2. 采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。\n3. 解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。\n\n> PS: 商业项目没有参考示例代码，更多介绍请参见官网： https://uniapp.dcloud.io/","source":"_posts/Uni-App 基于Vue技术栈方向跨端技术实践.md","raw":"---\ntitle: Uni-App 基于Vue技术栈方向跨端技术实践\ncatalog: true\ntags:\n  - Vue\n  - Weex\n  - 微信小程序\ncategories:\n  - Vue\ndate: 2019-04-30 6:37:05\nsubtitle:\nheader-img: \"https://p4.ssl.cdn.btime.com/t0125a8daac3dbdb9f2.jpg?size=1200x616\"\n---\n\n### 1.什么是Uni-App?\nuni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。\n如下图：\n---\n![跨端图](http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&fm=26&gp=0.jpg)\n![功能架构图](https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png)\n\nuni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示\n\n![多端图](http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png)\n\n> PS: 学习一门技术最好的方式，就是看官网： https://uniapp.dcloud.io/\n\n### 2. 语法原理以及注意事项\n\nuni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。\n> PS: 过于啰嗦和简单，官网文档在此： https://uniapp.dcloud.io/use\n\n### 3. 技术实践\n> 1.先看一下项目的目录结构图\n\n\n![目录结构图](https://s2.ax1x.com/2019/04/30/EG8srn.png)\n\n\n1. src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。\n2. src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多\n3. src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。\n4. src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等\n5. src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件\n6. src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息\n7. src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录\n8. src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。\n9. src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --> unx,具体看官网\n10. dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令\n\n> PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~\n\n### 4. 实践结果\n![实践结果图](https://s2.ax1x.com/2019/04/30/EGJN9S.png)\n1. 目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。\n2. 采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。\n3. 解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。\n\n> PS: 商业项目没有参考示例代码，更多介绍请参见官网： https://uniapp.dcloud.io/","slug":"Uni-App 基于Vue技术栈方向跨端技术实践","published":1,"updated":"2019-08-05T09:32:00.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ag000ja0s6wckih49d","content":"<h3><span id=\"1什么是uni-app\">1.什么是Uni-App?</span></h3>\n<p>uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。<br>\n如下图：</p>\n<hr>\n<p><img src=\"http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&amp;fm=26&amp;gp=0.jpg\" alt=\"跨端图\"><br>\n<img src=\"https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png\" alt=\"功能架构图\"></p>\n<p>uni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示</p>\n<p><img src=\"http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png\" alt=\"多端图\"></p>\n<blockquote>\n<p>PS: 学习一门技术最好的方式，就是看官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n<h3><span id=\"2-语法原理以及注意事项\">2. 语法原理以及注意事项</span></h3>\n<p>uni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。</p>\n<blockquote>\n<p>PS: 过于啰嗦和简单，官网文档在此： <a href=\"https://uniapp.dcloud.io/use\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/use</a></p>\n</blockquote>\n<h3><span id=\"3-技术实践\">3. 技术实践</span></h3>\n<blockquote>\n<p>1.先看一下项目的目录结构图</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EG8srn.png\" alt=\"目录结构图\"></p>\n<ol>\n<li>src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。</li>\n<li>src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多</li>\n<li>src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。</li>\n<li>src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等</li>\n<li>src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件</li>\n<li>src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息</li>\n<li>src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录</li>\n<li>src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。</li>\n<li>src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --&gt; unx,具体看官网</li>\n<li>dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令</li>\n</ol>\n<blockquote>\n<p>PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~</p>\n</blockquote>\n<h3><span id=\"4-实践结果\">4. 实践结果</span></h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGJN9S.png\" alt=\"实践结果图\"></p>\n<ol>\n<li>目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。</li>\n<li>采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。</li>\n<li>解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。</li>\n</ol>\n<blockquote>\n<p>PS: 商业项目没有参考示例代码，更多介绍请参见官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>1.什么是Uni-App?</h3>\n<p>uni-app 是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。一套代码编到7个平台，最全面的跨平台。<br>\n如下图：</p>\n<hr>\n<p><img src=\"http://img4.imgtn.bdimg.com/it/u=869023636,1150895082&amp;fm=26&amp;gp=0.jpg\" alt=\"跨端图\"><br>\n<img src=\"https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/uni0124.png\" alt=\"功能架构图\"></p>\n<p>uni-app实现了一套代码，同时运行到多个平台，一套代码，同时可以运行到iOS模拟器、Android模拟器、H5、微信开发者工具、支付宝小程序Studio、百度开发者工具、字节跳动开发者工具中，如下图所示</p>\n<p><img src=\"http://img.cdn.aliyun.dcloud.net.cn/guide/uniapp/run1x7.png\" alt=\"多端图\"></p>\n<blockquote>\n<p>PS: 学习一门技术最好的方式，就是看官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n<h3>2. 语法原理以及注意事项</h3>\n<p>uni-app 在发布到H5时支持所有vue的语法；发布到App和小程序时，由于平台限制，无法实现全部vue语法，但uni-app仍是是对vue语法支持度最高的跨端框架。</p>\n<blockquote>\n<p>PS: 过于啰嗦和简单，官网文档在此： <a href=\"https://uniapp.dcloud.io/use\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/use</a></p>\n</blockquote>\n<h3>3. 技术实践</h3>\n<blockquote>\n<p>1.先看一下项目的目录结构图</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EG8srn.png\" alt=\"目录结构图\"></p>\n<ol>\n<li>src 目录 app.vue 文件相当于原生小程序的app.js，负责初始化全局globalData和一些生命周期函数等功能。</li>\n<li>src 目录 main.js 全局的入口文件，跟用vue-cli 脚手架生成的差不多</li>\n<li>src 目录 config 这个是我自定义的目录，处理全局的配置，比如请求的URL，毕竟设计多种环境，比如开发，测试，beta和正式上线。</li>\n<li>src 目录 utils 这个是我自定义的目录,用来封装全局统一用的工具库，例如：校验手机号，车辆号等等</li>\n<li>src 目录 manifest.json 这个文件是uni-app跨端框架提供的各个端配置文件</li>\n<li>src 目录 pages.json 相当于原生小程序的app.json 文件，用来配置各个页面的信息</li>\n<li>src 目录 pages目录，这个目录是核心目录，不能更改，相当于原生的pages目录</li>\n<li>src 目录 static目录， 这个目录经过我的实践发现最好不要改其他名字，uni-app给我们做了跨端情况下静态资源打包处理。所以的静态资源再不用CDN的情况下，都可以放在此目录下。</li>\n<li>src uni.scss 全局的scss 文件，uni-app对适配问题已经做了处理，rpx or px --&gt; unx,具体看官网</li>\n<li>dist 目录 该目录是编译过后的各端文件，主要分为两类，dev(开发)和buid(production),各个端文件根据文件名来区分，这里开发参考官网和package.json scripts项下的命令</li>\n</ol>\n<blockquote>\n<p>PS: 目录因人而异，自己怎么开心，就怎么写 ^_^~</p>\n</blockquote>\n<h3>4. 实践结果</h3>\n<p><img src=\"https://s2.ax1x.com/2019/04/30/EGJN9S.png\" alt=\"实践结果图\"></p>\n<ol>\n<li>目前由于百度小程序和头条小程序暂为对个人开发者开放，所以只展示 uni-app 在微信小程序和支付宝小程序的跨端实现，如上图所示（左：微信 右：支付宝）支付宝登录授权机制很像微信的授权机制。</li>\n<li>采坑： 样式在跨端的时候，有些样式不生效，因为平台不同，有些小程序组件的默认样式也不同。</li>\n<li>解决方案：1.我们自己可以内置一套全局默认的样式 2. 采用第三方跨端UI框架，比如uni-app自己实现的一套UI框架。</li>\n</ol>\n<blockquote>\n<p>PS: 商业项目没有参考示例代码，更多介绍请参见官网： <a href=\"https://uniapp.dcloud.io/\" target=\"_blank\" rel=\"noopener\">https://uniapp.dcloud.io/</a></p>\n</blockquote>\n"},{"title":"JavaScript数据结构与算法-链表（LinkedList）","catalog":true,"url":"191.html","id":"191","date":"2019-03-07T03:52:47.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1.什么是链表？\n\n要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的\\[\\]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png)\n\n#### 2\\. 实现一个链表结构（单向链表）\n\n    // JavaScript 数据结构值列表\n    function LinkedList() {\n      let Node = function (element) {\n        this.element = element;\n        this.next = null;\n      }\n      let length = 0;\n      let head = null;\n      // 添加元素\n      this.append = function (element) {\n        let node = new Node(element);\n        let current;\n        if (head == null) {\n          head = node\n        } else {\n          current = head;\n          while (current.next) {\n            current = current.next\n          }\n          current.next = node\n        }\n        length++;\n      }\n      // 插入元素\n      this.insert = function (position, element) {\n        if (position > -1 && position <= length) {\n          let node = new Node(element);\n          let current = head;\n          let pervious;\n          let index = 0;\n          if (position == 0) {\n            node.next = current;\n            head = node;\n          } else {\n            while (index++ < position) {\n              pervious = current;\n              current = current.next;\n            }\n            node.next = current;\n            pervious.next = node;\n            length++;\n            return true;\n          }\n        } else {\n          return false;\n        }\n      }\n      // 从列表中移除一项\n      this.getHead = function () {\n        return head;\n      }\n      // 从列表移除指定的一项\n      this.removeAt = function (position) {\n        if (position > -1 && position < length) {\n          let current = head;\n          let previous;\n          let index = 0;\n          // 边界检查合法的情况下\n          if (position == 0) {\n            head = current.next;\n          } else {\n            while (index++ < position) {\n              previous = current;\n              current = current.next;\n            }\n            previous.next = current.next;\n          }\n          length--;\n          return current.element;\n        } else {\n          return false;\n        }\n      }\n      // 返回元素在列表中的索引\n      this.indexOf = function (element) {\n        let current = head;\n        index = 0;\n        while (current) {\n          if (current.element === element) {\n            return index;\n          }\n          index++;\n          current = current.next();\n        }\n        return -1;\n      }\n      // 判断列表是否为空\n      this.isEmpty = function () {\n        return length === 0;\n      }\n      // 获取列表的长度\n      this.size = function () {\n        return length;\n      }\n      // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n      this.toString = function () {\n        let current = head,\n          string = '';\n        while (current) {\n          string += current.element + (current.next ? 'n' : '');\n          current = current.next;\n        }\n        return string;\n      }\n      this.remove = function (element) {\n        let index = this.indexOf(element);\n        return this.removeAt(index);\n      }\n    }\n    \n    let list = new LinkedList();\n    list.append(15);\n    list.append(14);\n    list.append(13);\n    list.append(13);\n    \n    console.log(list);\n    console.log(list.toString()); // 15n14n13n13\n    \n    \n\n#### 3 .双向链表\n\n链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/222222222.png)\n\n#### 4.循环链表\n\n`循环链表`可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/3333333.png)\n\n#### 5\\. 双向循坏列表\n\n双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/444444.png)","source":"_posts/JavaScript数据结构与算法-链表（LinkedList）.md","raw":"---\ntitle: JavaScript数据结构与算法-链表（LinkedList）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 191.html\nid: 191\ncategories:\n  - 数据结构\ndate: 2019-03-07 11:52:47\nsubtitle:\nheader-img:\n---\n\n#### 1.什么是链表？\n\n要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的\\[\\]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png)\n\n#### 2\\. 实现一个链表结构（单向链表）\n\n    // JavaScript 数据结构值列表\n    function LinkedList() {\n      let Node = function (element) {\n        this.element = element;\n        this.next = null;\n      }\n      let length = 0;\n      let head = null;\n      // 添加元素\n      this.append = function (element) {\n        let node = new Node(element);\n        let current;\n        if (head == null) {\n          head = node\n        } else {\n          current = head;\n          while (current.next) {\n            current = current.next\n          }\n          current.next = node\n        }\n        length++;\n      }\n      // 插入元素\n      this.insert = function (position, element) {\n        if (position > -1 && position <= length) {\n          let node = new Node(element);\n          let current = head;\n          let pervious;\n          let index = 0;\n          if (position == 0) {\n            node.next = current;\n            head = node;\n          } else {\n            while (index++ < position) {\n              pervious = current;\n              current = current.next;\n            }\n            node.next = current;\n            pervious.next = node;\n            length++;\n            return true;\n          }\n        } else {\n          return false;\n        }\n      }\n      // 从列表中移除一项\n      this.getHead = function () {\n        return head;\n      }\n      // 从列表移除指定的一项\n      this.removeAt = function (position) {\n        if (position > -1 && position < length) {\n          let current = head;\n          let previous;\n          let index = 0;\n          // 边界检查合法的情况下\n          if (position == 0) {\n            head = current.next;\n          } else {\n            while (index++ < position) {\n              previous = current;\n              current = current.next;\n            }\n            previous.next = current.next;\n          }\n          length--;\n          return current.element;\n        } else {\n          return false;\n        }\n      }\n      // 返回元素在列表中的索引\n      this.indexOf = function (element) {\n        let current = head;\n        index = 0;\n        while (current) {\n          if (current.element === element) {\n            return index;\n          }\n          index++;\n          current = current.next();\n        }\n        return -1;\n      }\n      // 判断列表是否为空\n      this.isEmpty = function () {\n        return length === 0;\n      }\n      // 获取列表的长度\n      this.size = function () {\n        return length;\n      }\n      // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n      this.toString = function () {\n        let current = head,\n          string = '';\n        while (current) {\n          string += current.element + (current.next ? 'n' : '');\n          current = current.next;\n        }\n        return string;\n      }\n      this.remove = function (element) {\n        let index = this.indexOf(element);\n        return this.removeAt(index);\n      }\n    }\n    \n    let list = new LinkedList();\n    list.append(15);\n    list.append(14);\n    list.append(13);\n    list.append(13);\n    \n    console.log(list);\n    console.log(list.toString()); // 15n14n13n13\n    \n    \n\n#### 3 .双向链表\n\n链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/222222222.png)\n\n#### 4.循环链表\n\n`循环链表`可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/3333333.png)\n\n#### 5\\. 双向循坏列表\n\n双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/444444.png)","slug":"JavaScript数据结构与算法-链表（LinkedList）","published":1,"updated":"2019-08-05T09:32:00.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ai000ma0s6j577xwwv","content":"<h4><span id=\"1什么是链表\">1.什么是链表？</span></h4>\n<p>要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png\" alt></p>\n<h4><span id=\"2-实现一个链表结构单向链表\">2. 实现一个链表结构（单向链表）</span></h4>\n<pre><code>// JavaScript 数据结构值列表\nfunction LinkedList() {\n  let Node = function (element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head = null;\n  // 添加元素\n  this.append = function (element) {\n    let node = new Node(element);\n    let current;\n    if (head == null) {\n      head = node\n    } else {\n      current = head;\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n    }\n    length++;\n  }\n  // 插入元素\n  this.insert = function (position, element) {\n    if (position &gt; -1 &amp;&amp; position &lt;= length) {\n      let node = new Node(element);\n      let current = head;\n      let pervious;\n      let index = 0;\n      if (position == 0) {\n        node.next = current;\n        head = node;\n      } else {\n        while (index++ &lt; position) {\n          pervious = current;\n          current = current.next;\n        }\n        node.next = current;\n        pervious.next = node;\n        length++;\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  // 从列表中移除一项\n  this.getHead = function () {\n    return head;\n  }\n  // 从列表移除指定的一项\n  this.removeAt = function (position) {\n    if (position &gt; -1 &amp;&amp; position &lt; length) {\n      let current = head;\n      let previous;\n      let index = 0;\n      // 边界检查合法的情况下\n      if (position == 0) {\n        head = current.next;\n      } else {\n        while (index++ &lt; position) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      length--;\n      return current.element;\n    } else {\n      return false;\n    }\n  }\n  // 返回元素在列表中的索引\n  this.indexOf = function (element) {\n    let current = head;\n    index = 0;\n    while (current) {\n      if (current.element === element) {\n        return index;\n      }\n      index++;\n      current = current.next();\n    }\n    return -1;\n  }\n  // 判断列表是否为空\n  this.isEmpty = function () {\n    return length === 0;\n  }\n  // 获取列表的长度\n  this.size = function () {\n    return length;\n  }\n  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n  this.toString = function () {\n    let current = head,\n      string = '';\n    while (current) {\n      string += current.element + (current.next ? 'n' : '');\n      current = current.next;\n    }\n    return string;\n  }\n  this.remove = function (element) {\n    let index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n}\n\nlet list = new LinkedList();\nlist.append(15);\nlist.append(14);\nlist.append(13);\nlist.append(13);\n\nconsole.log(list);\nconsole.log(list.toString()); // 15n14n13n13\n</code></pre>\n<h4><span id=\"3-双向链表\">3 .双向链表</span></h4>\n<p>链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/222222222.png\" alt></p>\n<h4><span id=\"4循环链表\">4.循环链表</span></h4>\n<p><code>循环链表</code>可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333.png\" alt></p>\n<h4><span id=\"5-双向循坏列表\">5. 双向循坏列表</span></h4>\n<p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h4>1.什么是链表？</h4>\n<p>要存储多个元素，数组(或列表)可能是最常用的数据结构。正如本书之前提到过的，每种 语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而， 这种数据结构有一个缺点:(在大多数语言中)数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素(尽管我们已经学过的JavaScript的array类方法可以帮 我们做这些事，但背后的情况同样是这样)。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展 示了一个链表的结构:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/11111111111.png\" alt></p>\n<h4>2. 实现一个链表结构（单向链表）</h4>\n<pre><code>// JavaScript 数据结构值列表\nfunction LinkedList() {\n  let Node = function (element) {\n    this.element = element;\n    this.next = null;\n  }\n  let length = 0;\n  let head = null;\n  // 添加元素\n  this.append = function (element) {\n    let node = new Node(element);\n    let current;\n    if (head == null) {\n      head = node\n    } else {\n      current = head;\n      while (current.next) {\n        current = current.next\n      }\n      current.next = node\n    }\n    length++;\n  }\n  // 插入元素\n  this.insert = function (position, element) {\n    if (position &gt; -1 &amp;&amp; position &lt;= length) {\n      let node = new Node(element);\n      let current = head;\n      let pervious;\n      let index = 0;\n      if (position == 0) {\n        node.next = current;\n        head = node;\n      } else {\n        while (index++ &lt; position) {\n          pervious = current;\n          current = current.next;\n        }\n        node.next = current;\n        pervious.next = node;\n        length++;\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n  // 从列表中移除一项\n  this.getHead = function () {\n    return head;\n  }\n  // 从列表移除指定的一项\n  this.removeAt = function (position) {\n    if (position &gt; -1 &amp;&amp; position &lt; length) {\n      let current = head;\n      let previous;\n      let index = 0;\n      // 边界检查合法的情况下\n      if (position == 0) {\n        head = current.next;\n      } else {\n        while (index++ &lt; position) {\n          previous = current;\n          current = current.next;\n        }\n        previous.next = current.next;\n      }\n      length--;\n      return current.element;\n    } else {\n      return false;\n    }\n  }\n  // 返回元素在列表中的索引\n  this.indexOf = function (element) {\n    let current = head;\n    index = 0;\n    while (current) {\n      if (current.element === element) {\n        return index;\n      }\n      index++;\n      current = current.next();\n    }\n    return -1;\n  }\n  // 判断列表是否为空\n  this.isEmpty = function () {\n    return length === 0;\n  }\n  // 获取列表的长度\n  this.size = function () {\n    return length;\n  }\n  // 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。\n  this.toString = function () {\n    let current = head,\n      string = '';\n    while (current) {\n      string += current.element + (current.next ? 'n' : '');\n      current = current.next;\n    }\n    return string;\n  }\n  this.remove = function (element) {\n    let index = this.indexOf(element);\n    return this.removeAt(index);\n  }\n}\n\nlet list = new LinkedList();\nlist.append(15);\nlist.append(14);\nlist.append(13);\nlist.append(13);\n\nconsole.log(list);\nconsole.log(list.toString()); // 15n14n13n13\n</code></pre>\n<h4>3 .双向链表</h4>\n<p>链表有多种不同的类型，这一节介绍双向链表。双向链表和普通链表的区别在于，在链表中， 一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的:一个链向下一个元素， 另一个链向前一个元素，如下图所示:</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/222222222.png\" alt></p>\n<h4>4.循环链表</h4>\n<p><code>循环链表</code>可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链 表之间唯一的区别在于，最后一个元素指向下一个元素的指针(tail.next)不是引用null， 而是指向第一个元素(head)，如下图所示。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/3333333.png\" alt></p>\n<h4>5. 双向循坏列表</h4>\n<p>双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/444444.png\" alt></p>\n"},{"title":"JavaScript数据结构与算法队列（Queue）","catalog":true,"url":"184.html","id":"184","date":"2019-03-06T09:53:17.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是队列？\n\n队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。\n\n#### 2\\. 代码实现一个队列Queue\n\n    class Queue {\n    \n      constructor() {\n        this.items = [];\n      }\n      // 向队列添加元素\n      push(element) {\n        this.items.push(element);\n      }\n      // 从队列移除元素\n      shift() {\n        return this.items.shift();\n      }\n      // 查看队列头元素\n      peek() {\n        return this.items[0];\n      }\n      // 检查队列是否为空\n      isEmpty() {\n        return this.items.length === 0;\n      }\n      // 打印队列\n      print() {\n        return this.items.toString();\n      }\n    \n    }\n    \n    \n\n#### 3\\. 什么是优先队列？\n\n队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。\n\n    function PriorityQueue() {\n      let items = [];\n      function QueueElement (element, priority){ // {1}\n        this.element = element;\n        this.priority = priority;\n      }\n      this.enqueue = function(element, priority){\n        let queueElement = new QueueElement(element, priority);\n        let added = false;\n        for (let i=0; i<items.length; i++){\n          if (queueElement.priority < items[i].priority){ // {2}\n            items.splice(i,0,queueElement); // {3}\n            added = true;\n            break; // {4}\n    } }\n        if (!added){\n          items.push(queueElement); //{5}\n    } };\n      this.print = function(){\n        for (let i=0; i<items.length; i++){\n          console.log(`${items[i].element} -\n          ${items[i].priority}`);\n        }\n    };\n    //其他方法和默认的Queue实现相同 }\n    \n\n#### 4\\. 什么是循环队列？\n\n还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。\n\n> 循环队列——击鼓传花\n\n    function hotPotato(nameList, num) {\n      var queue = new Queue();\n      var eliminated = \"\";\n      for (let i = 0; i < nameList.length; i++) {\n        queue.push(nameList[i]);\n      }\n      while (queue.size() > 0) {\n        for (let i = 0; i < num; i++) {\n          queue.push(queue.shift())\n        }\n        eliminated = queue.shift();\n        console.log(`eliminated: ${eliminated}`);\n      }\n      return eliminated\n    }\n    var nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\n    hotPotato(nameList, 3);\n    \n    // eliminated: golang\n    // eliminated: python\n    // eliminated: php\n    // eliminated: cpp\n    // eliminated: java\n    // eliminated: c#\n    // eliminated: javascript\n    // eliminated: basic\n    \n\n#### 5\\. JavaScript 任务队列\n\n当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。","source":"_posts/JavaScript数据结构与算法队列（Queue）.md","raw":"---\ntitle: JavaScript数据结构与算法队列（Queue）\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 184.html\nid: 184\ncategories:\n  - 数据结构\ndate: 2019-03-06 17:53:17\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是队列？\n\n队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。\n\n#### 2\\. 代码实现一个队列Queue\n\n    class Queue {\n    \n      constructor() {\n        this.items = [];\n      }\n      // 向队列添加元素\n      push(element) {\n        this.items.push(element);\n      }\n      // 从队列移除元素\n      shift() {\n        return this.items.shift();\n      }\n      // 查看队列头元素\n      peek() {\n        return this.items[0];\n      }\n      // 检查队列是否为空\n      isEmpty() {\n        return this.items.length === 0;\n      }\n      // 打印队列\n      print() {\n        return this.items.toString();\n      }\n    \n    }\n    \n    \n\n#### 3\\. 什么是优先队列？\n\n队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。\n\n    function PriorityQueue() {\n      let items = [];\n      function QueueElement (element, priority){ // {1}\n        this.element = element;\n        this.priority = priority;\n      }\n      this.enqueue = function(element, priority){\n        let queueElement = new QueueElement(element, priority);\n        let added = false;\n        for (let i=0; i<items.length; i++){\n          if (queueElement.priority < items[i].priority){ // {2}\n            items.splice(i,0,queueElement); // {3}\n            added = true;\n            break; // {4}\n    } }\n        if (!added){\n          items.push(queueElement); //{5}\n    } };\n      this.print = function(){\n        for (let i=0; i<items.length; i++){\n          console.log(`${items[i].element} -\n          ${items[i].priority}`);\n        }\n    };\n    //其他方法和默认的Queue实现相同 }\n    \n\n#### 4\\. 什么是循环队列？\n\n还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。\n\n> 循环队列——击鼓传花\n\n    function hotPotato(nameList, num) {\n      var queue = new Queue();\n      var eliminated = \"\";\n      for (let i = 0; i < nameList.length; i++) {\n        queue.push(nameList[i]);\n      }\n      while (queue.size() > 0) {\n        for (let i = 0; i < num; i++) {\n          queue.push(queue.shift())\n        }\n        eliminated = queue.shift();\n        console.log(`eliminated: ${eliminated}`);\n      }\n      return eliminated\n    }\n    var nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\n    hotPotato(nameList, 3);\n    \n    // eliminated: golang\n    // eliminated: python\n    // eliminated: php\n    // eliminated: cpp\n    // eliminated: java\n    // eliminated: c#\n    // eliminated: javascript\n    // eliminated: basic\n    \n\n#### 5\\. JavaScript 任务队列\n\n当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。","slug":"JavaScript数据结构与算法队列（Queue）","published":1,"updated":"2019-08-05T09:32:00.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ak000ra0s6u13bx6ct","content":"<h4><span id=\"1-什么是队列\">1. 什么是队列？</span></h4>\n<p>队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。</p>\n<h4><span id=\"2-代码实现一个队列queue\">2. 代码实现一个队列Queue</span></h4>\n<pre><code>class Queue {\n\n  constructor() {\n    this.items = [];\n  }\n  // 向队列添加元素\n  push(element) {\n    this.items.push(element);\n  }\n  // 从队列移除元素\n  shift() {\n    return this.items.shift();\n  }\n  // 查看队列头元素\n  peek() {\n    return this.items[0];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 打印队列\n  print() {\n    return this.items.toString();\n  }\n\n}\n</code></pre>\n<h4><span id=\"3-什么是优先队列\">3. 什么是优先队列？</span></h4>\n<p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。</p>\n<pre><code>function PriorityQueue() {\n  let items = [];\n  function QueueElement (element, priority){ // {1}\n    this.element = element;\n    this.priority = priority;\n  }\n  this.enqueue = function(element, priority){\n    let queueElement = new QueueElement(element, priority);\n    let added = false;\n    for (let i=0; i&lt;items.length; i++){\n      if (queueElement.priority &lt; items[i].priority){ // {2}\n        items.splice(i,0,queueElement); // {3}\n        added = true;\n        break; // {4}\n} }\n    if (!added){\n      items.push(queueElement); //{5}\n} };\n  this.print = function(){\n    for (let i=0; i&lt;items.length; i++){\n      console.log(`${items[i].element} -\n      ${items[i].priority}`);\n    }\n};\n//其他方法和默认的Queue实现相同 }\n</code></pre>\n<h4><span id=\"4-什么是循环队列\">4. 什么是循环队列？</span></h4>\n<p>还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。</p>\n<blockquote>\n<p>循环队列——击鼓传花</p>\n</blockquote>\n<pre><code>function hotPotato(nameList, num) {\n  var queue = new Queue();\n  var eliminated = &quot;&quot;;\n  for (let i = 0; i &lt; nameList.length; i++) {\n    queue.push(nameList[i]);\n  }\n  while (queue.size() &gt; 0) {\n    for (let i = 0; i &lt; num; i++) {\n      queue.push(queue.shift())\n    }\n    eliminated = queue.shift();\n    console.log(`eliminated: ${eliminated}`);\n  }\n  return eliminated\n}\nvar nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\nhotPotato(nameList, 3);\n\n// eliminated: golang\n// eliminated: python\n// eliminated: php\n// eliminated: cpp\n// eliminated: java\n// eliminated: c#\n// eliminated: javascript\n// eliminated: basic\n</code></pre>\n<h4><span id=\"5-javascript-任务队列\">5. JavaScript 任务队列</span></h4>\n<p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是队列？</h4>\n<p>队列是遵循FIFO(First In First Out，先进先出，也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打 开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文 档会首先被打印，以此类推，直到打印完所有文档。</p>\n<h4>2. 代码实现一个队列Queue</h4>\n<pre><code>class Queue {\n\n  constructor() {\n    this.items = [];\n  }\n  // 向队列添加元素\n  push(element) {\n    this.items.push(element);\n  }\n  // 从队列移除元素\n  shift() {\n    return this.items.shift();\n  }\n  // 查看队列头元素\n  peek() {\n    return this.items[0];\n  }\n  // 检查队列是否为空\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  // 打印队列\n  print() {\n    return this.items.toString();\n  }\n\n}\n</code></pre>\n<h4>3. 什么是优先队列？</h4>\n<p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些 修改版本。 其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机 场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。 另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通 常，护士会鉴别分类，根据患者病情的严重程度放号。 实现一个优先队列，有两种选项:设置优先级，然后在正确的位置添加元素;或者用入列操 作添加元素，然后按照优先级移除它们。在这个示例中，我们将会在正确的位置添加元素，因此 可以对它们使用默认的出列操作。</p>\n<pre><code>function PriorityQueue() {\n  let items = [];\n  function QueueElement (element, priority){ // {1}\n    this.element = element;\n    this.priority = priority;\n  }\n  this.enqueue = function(element, priority){\n    let queueElement = new QueueElement(element, priority);\n    let added = false;\n    for (let i=0; i&lt;items.length; i++){\n      if (queueElement.priority &lt; items[i].priority){ // {2}\n        items.splice(i,0,queueElement); // {3}\n        added = true;\n        break; // {4}\n} }\n    if (!added){\n      items.push(queueElement); //{5}\n} };\n  this.print = function(){\n    for (let i=0; i&lt;items.length; i++){\n      console.log(`${items[i].element} -\n      ${items[i].priority}`);\n    }\n};\n//其他方法和默认的Queue实现相同 }\n</code></pre>\n<h4>4. 什么是循环队列？</h4>\n<p>还有另一个修改版的队列实现，就是循环队列。循环队列的一个例子就是击鼓传花游戏(Hot Potato)。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止， 这个时候花在谁手里，谁就退出圆圈结束游戏。重复这个过程，直到只剩一个孩子(胜者)。</p>\n<blockquote>\n<p>循环队列——击鼓传花</p>\n</blockquote>\n<pre><code>function hotPotato(nameList, num) {\n  var queue = new Queue();\n  var eliminated = &quot;&quot;;\n  for (let i = 0; i &lt; nameList.length; i++) {\n    queue.push(nameList[i]);\n  }\n  while (queue.size() &gt; 0) {\n    for (let i = 0; i &lt; num; i++) {\n      queue.push(queue.shift())\n    }\n    eliminated = queue.shift();\n    console.log(`eliminated: ${eliminated}`);\n  }\n  return eliminated\n}\nvar nameList = ['java', 'cpp', 'c#', 'golang', 'php', 'basic', 'javascript', 'python'];\nhotPotato(nameList, 3);\n\n// eliminated: golang\n// eliminated: python\n// eliminated: php\n// eliminated: cpp\n// eliminated: java\n// eliminated: c#\n// eliminated: javascript\n// eliminated: basic\n</code></pre>\n<h4>5. JavaScript 任务队列</h4>\n<p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处 理所有的任务，它被称为事件循环。浏览器要负责多个任务，如渲染HTML，执行JavaScript代码， 处理用户交互(用户输入、鼠标点击等)，执行和处理异步请求。</p>\n"},{"title":"centOS中利用Docker安装gitlab","catalog":true,"url":"111.html","id":"111","date":"2019-02-21T03:37:05.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://images0.cnblogs.com/news/66372/201507/052157452643027.png)\n\n#### 首先安装虚拟机或者直接在你的云主机上操作\n\n#### 修改centos 默认配置 查看IP\n\n> centos 配置最好高于：4G 2核，否则运行不起来\n\n#### 查看centos的IP地址\n\n     ip addr \n    \n\n#### 无法查询IP的解决办法\n\n> 进入`ect/sysconfig/network-scripts`文件夹,修改对应的网卡配置文件，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/17.png)\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/18.png)\n\n      service network start\n    \n\n> 然后查看IP地址\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/19.png)\n\n#### 安装docker 并启动\n\n> 1.  `yum -y install docker`\n> 2.  `systemctl start docker`\n> 3.  `docker login #输入你的用户名和密码`\n> 4.  `docker pull gitlab/gitlab-ce:latest #可能需要一些时间`\n> \n> 最后创建并启动容器\n\n    docker run -d \\\n    --hostname 192.168.50.27 \\\n    -p 443:443 \\\n    -p 80:80 \\\n    -p 9090:9090 \\\n    --name gitlab \\\n    --restart always \\\n    -v /home/gitlab/config:/etc/gitlab \\\n    -v /home/gitlab/log:/var/log/gitlab \\\n    -v /home/gitlab/opt:/var/opt/gitlab \\\n    --privileged=true gitlab/gitlab-ce:latest\n    \n\n#### 需要等一会，打开游览器输入虚拟机或者云服务器的公网IP\n\n> 如图 1\\. 重置密码\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/20.png)\n\n> 2.  登录和注册\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/21.png)\n\n> 3.  登录后主界面\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/22.png)\n\n#### 配置gitlab\n\n> 查看容器id `shell docekr ps -a` 进入容器命令行\n\n      docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n    \n\n> 参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)","source":"_posts/centOS中利用Docker安装gitlab.md","raw":"---\ntitle: centOS中利用Docker安装gitlab\ncatalog: true\ntags:\n  - Docker\n  - git\n  - gitlab\nurl: 111.html\nid: 111\ncategories:\n  - Docker\ndate: 2019-02-21 11:37:05\nsubtitle:\nheader-img:\n---\n\n![](http://images0.cnblogs.com/news/66372/201507/052157452643027.png)\n\n#### 首先安装虚拟机或者直接在你的云主机上操作\n\n#### 修改centos 默认配置 查看IP\n\n> centos 配置最好高于：4G 2核，否则运行不起来\n\n#### 查看centos的IP地址\n\n     ip addr \n    \n\n#### 无法查询IP的解决办法\n\n> 进入`ect/sysconfig/network-scripts`文件夹,修改对应的网卡配置文件，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/17.png)\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/18.png)\n\n      service network start\n    \n\n> 然后查看IP地址\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/19.png)\n\n#### 安装docker 并启动\n\n> 1.  `yum -y install docker`\n> 2.  `systemctl start docker`\n> 3.  `docker login #输入你的用户名和密码`\n> 4.  `docker pull gitlab/gitlab-ce:latest #可能需要一些时间`\n> \n> 最后创建并启动容器\n\n    docker run -d \\\n    --hostname 192.168.50.27 \\\n    -p 443:443 \\\n    -p 80:80 \\\n    -p 9090:9090 \\\n    --name gitlab \\\n    --restart always \\\n    -v /home/gitlab/config:/etc/gitlab \\\n    -v /home/gitlab/log:/var/log/gitlab \\\n    -v /home/gitlab/opt:/var/opt/gitlab \\\n    --privileged=true gitlab/gitlab-ce:latest\n    \n\n#### 需要等一会，打开游览器输入虚拟机或者云服务器的公网IP\n\n> 如图 1\\. 重置密码\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/20.png)\n\n> 2.  登录和注册\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/21.png)\n\n> 3.  登录后主界面\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/22.png)\n\n#### 配置gitlab\n\n> 查看容器id `shell docekr ps -a` 进入容器命令行\n\n      docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n    \n\n> 参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)","slug":"centOS中利用Docker安装gitlab","published":1,"updated":"2019-08-05T09:32:00.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4al000ta0s6amxo90na","content":"<p><img src=\"http://images0.cnblogs.com/news/66372/201507/052157452643027.png\" alt></p>\n<h4><span id=\"首先安装虚拟机或者直接在你的云主机上操作\">首先安装虚拟机或者直接在你的云主机上操作</span></h4>\n<h4><span id=\"修改centos-默认配置-查看ip\">修改centos 默认配置 查看IP</span></h4>\n<blockquote>\n<p>centos 配置最好高于：4G 2核，否则运行不起来</p>\n</blockquote>\n<h4><span id=\"查看centos的ip地址\">查看centos的IP地址</span></h4>\n<pre><code> ip addr \n</code></pre>\n<h4><span id=\"无法查询ip的解决办法\">无法查询IP的解决办法</span></h4>\n<blockquote>\n<p>进入<code>ect/sysconfig/network-scripts</code>文件夹,修改对应的网卡配置文件，如图所示</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/17.png\" alt></p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/18.png\" alt></p>\n<pre><code>  service network start\n</code></pre>\n<blockquote>\n<p>然后查看IP地址</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/19.png\" alt></p>\n<h4><span id=\"安装docker-并启动\">安装docker 并启动</span></h4>\n<blockquote>\n<ol>\n<li><code>yum -y install docker</code></li>\n<li><code>systemctl start docker</code></li>\n<li><code>docker login #输入你的用户名和密码</code></li>\n<li><code>docker pull gitlab/gitlab-ce:latest #可能需要一些时间</code></li>\n</ol>\n<p>最后创建并启动容器</p>\n</blockquote>\n<pre><code>docker run -d \\\n--hostname 192.168.50.27 \\\n-p 443:443 \\\n-p 80:80 \\\n-p 9090:9090 \\\n--name gitlab \\\n--restart always \\\n-v /home/gitlab/config:/etc/gitlab \\\n-v /home/gitlab/log:/var/log/gitlab \\\n-v /home/gitlab/opt:/var/opt/gitlab \\\n--privileged=true gitlab/gitlab-ce:latest\n</code></pre>\n<h4><span id=\"需要等一会打开游览器输入虚拟机或者云服务器的公网ip\">需要等一会，打开游览器输入虚拟机或者云服务器的公网IP</span></h4>\n<blockquote>\n<p>如图 1. 重置密码</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/20.png\" alt></p>\n<blockquote>\n<ol start=\"2\">\n<li>登录和注册</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/21.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>登录后主界面</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/22.png\" alt></p>\n<h4><span id=\"配置gitlab\">配置gitlab</span></h4>\n<blockquote>\n<p>查看容器id <code>shell docekr ps -a</code> 进入容器命令行</p>\n</blockquote>\n<pre><code>  docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n</code></pre>\n<blockquote>\n<p>参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://images0.cnblogs.com/news/66372/201507/052157452643027.png\" alt></p>\n<h4>首先安装虚拟机或者直接在你的云主机上操作</h4>\n<h4>修改centos 默认配置 查看IP</h4>\n<blockquote>\n<p>centos 配置最好高于：4G 2核，否则运行不起来</p>\n</blockquote>\n<h4>查看centos的IP地址</h4>\n<pre><code> ip addr \n</code></pre>\n<h4>无法查询IP的解决办法</h4>\n<blockquote>\n<p>进入<code>ect/sysconfig/network-scripts</code>文件夹,修改对应的网卡配置文件，如图所示</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/17.png\" alt></p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/18.png\" alt></p>\n<pre><code>  service network start\n</code></pre>\n<blockquote>\n<p>然后查看IP地址</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/19.png\" alt></p>\n<h4>安装docker 并启动</h4>\n<blockquote>\n<ol>\n<li><code>yum -y install docker</code></li>\n<li><code>systemctl start docker</code></li>\n<li><code>docker login #输入你的用户名和密码</code></li>\n<li><code>docker pull gitlab/gitlab-ce:latest #可能需要一些时间</code></li>\n</ol>\n<p>最后创建并启动容器</p>\n</blockquote>\n<pre><code>docker run -d \\\n--hostname 192.168.50.27 \\\n-p 443:443 \\\n-p 80:80 \\\n-p 9090:9090 \\\n--name gitlab \\\n--restart always \\\n-v /home/gitlab/config:/etc/gitlab \\\n-v /home/gitlab/log:/var/log/gitlab \\\n-v /home/gitlab/opt:/var/opt/gitlab \\\n--privileged=true gitlab/gitlab-ce:latest\n</code></pre>\n<h4>需要等一会，打开游览器输入虚拟机或者云服务器的公网IP</h4>\n<blockquote>\n<p>如图 1. 重置密码</p>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/20.png\" alt></p>\n<blockquote>\n<ol start=\"2\">\n<li>登录和注册</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/21.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>登录后主界面</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/22.png\" alt></p>\n<h4>配置gitlab</h4>\n<blockquote>\n<p>查看容器id <code>shell docekr ps -a</code> 进入容器命令行</p>\n</blockquote>\n<pre><code>  docker exec -it containerID  /bin/bash // containerID 代表该gitlab的ID\n</code></pre>\n<blockquote>\n<p>参照官网修改gitlab.rb 文件修改gitlab配置(由于容器数据卷挂载地方不同，通常是在/etc/gitlab/ 文件夹下)</p>\n</blockquote>\n"},{"title":"graphQL 如和在客户端调用","catalog":true,"url":"92.html","id":"92","date":"2019-02-20T09:45:16.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://116.85.35.63/wp-content/uploads/2019/02/12.png)\n\n> 源码地址：[github地址](https://github.com/maliaoMJ/graphql-api-server)\n\n#### 1\\. 先展示目录结构\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/13.png)\n\n#### 2\\. 如何搭建\n\n> 1.  在上一篇文章的基础上，在 `index.js` 添加Express静态文件托管并且指明静态文件夹目录\n\n    app.use(express.static('public'));\n    \n\n> 2.  创建public目录并且在此文件中创建`index.html` 文件\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    </html>\n    \n\n此时你可以访问`localhost:3000/index.html` 可以看见你创建的index.html 文件，如下图：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/14.png)\n\n> 3.  我们要请求GraphQL数据 `(GraphQL 只支持GET和POST请求)`，在index.html的js中，添加如下代码：\n\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    \n\n1.  这里的query 请求的查询语句\n2.  这里的variables 是变量\n3.  这里的$id:Int!中的`!` 表示该参数不能为空,具体细节看下图:\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/15.png)\n\n> 4.  点击按钮，请求数据，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16.png)\n\n#### 3\\. 最后附源代码：\n\n> 1.  index.js 代码\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    \n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n    \n\n> 2.  index.html\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    <script type=\"text/javascript\">\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    </script>\n    \n    </html>\n    \n\n> 3.  执行命令,打开游览器localhost:3000/index.html\n\n      nodemon index.js","source":"_posts/graphQL 如和在客户端调用.md","raw":"---\ntitle: graphQL 如和在客户端调用\ncatalog: true\ntags:\n  - graphql\n  - nodejs\nurl: 92.html\nid: 92\ncategories:\n  - GraphQL\ndate: 2019-02-20 17:45:16\nsubtitle:\nheader-img:\n---\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/12.png)\n\n> 源码地址：[github地址](https://github.com/maliaoMJ/graphql-api-server)\n\n#### 1\\. 先展示目录结构\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/13.png)\n\n#### 2\\. 如何搭建\n\n> 1.  在上一篇文章的基础上，在 `index.js` 添加Express静态文件托管并且指明静态文件夹目录\n\n    app.use(express.static('public'));\n    \n\n> 2.  创建public目录并且在此文件中创建`index.html` 文件\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    </html>\n    \n\n此时你可以访问`localhost:3000/index.html` 可以看见你创建的index.html 文件，如下图：\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/14.png)\n\n> 3.  我们要请求GraphQL数据 `(GraphQL 只支持GET和POST请求)`，在index.html的js中，添加如下代码：\n\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    \n\n1.  这里的query 请求的查询语句\n2.  这里的variables 是变量\n3.  这里的$id:Int!中的`!` 表示该参数不能为空,具体细节看下图:\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/15.png)\n\n> 4.  点击按钮，请求数据，如图所示\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16.png)\n\n#### 3\\. 最后附源代码：\n\n> 1.  index.js 代码\n\n    const express = require('express');\n    const { buildSchema } = require('graphql');\n    const graphqlHTTP = require('express-graphql');\n    const originData = [{\n            id: 10000,\n            name: 'superMario',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10001,\n            name: 'Jack',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10002,\n            name: 'Tom',\n            gender: 'man',\n            age: 23\n        },\n        {\n            id: 10003,\n            name: 'Alice',\n            gender: 'woman',\n            age: 23\n        }\n    ]\n    \n    const app = express();\n    // Express 托管静态文件\n    app.use(express.static('public'));\n    \n    const schema = buildSchema(`\n        type User {\n            name: String\n            age: Int\n            id: Int\n            gender: String\n        }\n      type Query {\n        hello: String\n        users: [User!]\n        randomUser: User\n        userInfo(id:Int!):User\n      }\n    `)\n    \n    const rootValue = {\n        hello: () => 'hello world',\n        users: () => {\n            return originData\n        },\n        randomUser: () => {\n            let random = Number.parseInt(Math.random() * 3);\n            return originData[random];\n        },\n        userInfo: ({id}) => {\n            const tempData = originData.filter(item => item.id == id);\n            return tempData[0]\n        }\n    }\n    \n    app.use('/graphql', graphqlHTTP({\n        schema,\n        rootValue,\n        graphiql: true\n    }));\n    \n    app.listen(3000, () => {\n        console.log(\"Now open localhost:3000!\");\n    });\n    \n    \n\n> 2.  index.html\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    \n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Learn GraphQL Page</title>\n        <style type=\"text/css\">\n        #btn {\n            width: 100px;\n            height: 41px;\n            background: #2196F3;\n            border-radius: 23px;\n            color: #fff;\n            text-align: center;\n            line-height: 41px;\n            cursor: pointer;\n            box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n        }\n        </style>\n    </head>\n    \n    <body>\n        <div id=\"btn\">GET DATA</div>\n    </body>\n    <script type=\"text/javascript\">\n    let btn = document.getElementById('btn');\n    btn.onclick = function() {\n        const userId = 10001;\n        const query = `query AllUser($id:Int!) {\n        userInfo(id: $id) {\n            name\n            age\n            gender\n        }\n      }`;\n        fetch('/graphql', {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"Accept\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    variables: { id: userId }\n                })\n            }).then(res => res.json())\n            .then(resData => {\n                console.log(resData.data);\n            })\n    \n    }\n    </script>\n    \n    </html>\n    \n\n> 3.  执行命令,打开游览器localhost:3000/index.html\n\n      nodemon index.js","slug":"graphQL 如和在客户端调用","published":1,"updated":"2019-08-05T09:32:00.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4an000xa0s63c7mdfay","content":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/12.png\" alt></p>\n<blockquote>\n<p>源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n<h4><span id=\"1-先展示目录结构\">1. 先展示目录结构</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/13.png\" alt></p>\n<h4><span id=\"2-如何搭建\">2. 如何搭建</span></h4>\n<blockquote>\n<ol>\n<li>在上一篇文章的基础上，在 <code>index.js</code> 添加Express静态文件托管并且指明静态文件夹目录</li>\n</ol>\n</blockquote>\n<pre><code>app.use(express.static('public'));\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>创建public目录并且在此文件中创建<code>index.html</code> 文件</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时你可以访问<code>localhost:3000/index.html</code> 可以看见你创建的index.html 文件，如下图：</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/14.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>我们要请求GraphQL数据 <code>(GraphQL 只支持GET和POST请求)</code>，在index.html的js中，添加如下代码：</li>\n</ol>\n</blockquote>\n<pre><code>let btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n</code></pre>\n<ol>\n<li>这里的query 请求的查询语句</li>\n<li>这里的variables 是变量</li>\n<li>这里的$id:Int!中的<code>!</code> 表示该参数不能为空,具体细节看下图:</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/15.png\" alt></p>\n<blockquote>\n<ol start=\"4\">\n<li>点击按钮，请求数据，如图所示</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16.png\" alt></p>\n<h4><span id=\"3-最后附源代码\">3. 最后附源代码：</span></h4>\n<blockquote>\n<ol>\n<li>index.js 代码</li>\n</ol>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\n\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>index.html</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nlet btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>执行命令,打开游览器localhost:3000/index.html</li>\n</ol>\n</blockquote>\n<pre><code>  nodemon index.js</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/12.png\" alt></p>\n<blockquote>\n<p>源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github地址</a></p>\n</blockquote>\n<h4>1. 先展示目录结构</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/13.png\" alt></p>\n<h4>2. 如何搭建</h4>\n<blockquote>\n<ol>\n<li>在上一篇文章的基础上，在 <code>index.js</code> 添加Express静态文件托管并且指明静态文件夹目录</li>\n</ol>\n</blockquote>\n<pre><code>app.use(express.static('public'));\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>创建public目录并且在此文件中创建<code>index.html</code> 文件</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时你可以访问<code>localhost:3000/index.html</code> 可以看见你创建的index.html 文件，如下图：</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/14.png\" alt></p>\n<blockquote>\n<ol start=\"3\">\n<li>我们要请求GraphQL数据 <code>(GraphQL 只支持GET和POST请求)</code>，在index.html的js中，添加如下代码：</li>\n</ol>\n</blockquote>\n<pre><code>let btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n</code></pre>\n<ol>\n<li>这里的query 请求的查询语句</li>\n<li>这里的variables 是变量</li>\n<li>这里的$id:Int!中的<code>!</code> 表示该参数不能为空,具体细节看下图:</li>\n</ol>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/15.png\" alt></p>\n<blockquote>\n<ol start=\"4\">\n<li>点击按钮，请求数据，如图所示</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16.png\" alt></p>\n<h4>3. 最后附源代码：</h4>\n<blockquote>\n<ol>\n<li>index.js 代码</li>\n</ol>\n</blockquote>\n<pre><code>const express = require('express');\nconst { buildSchema } = require('graphql');\nconst graphqlHTTP = require('express-graphql');\nconst originData = [{\n        id: 10000,\n        name: 'superMario',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10001,\n        name: 'Jack',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10002,\n        name: 'Tom',\n        gender: 'man',\n        age: 23\n    },\n    {\n        id: 10003,\n        name: 'Alice',\n        gender: 'woman',\n        age: 23\n    }\n]\n\nconst app = express();\n// Express 托管静态文件\napp.use(express.static('public'));\n\nconst schema = buildSchema(`\n    type User {\n        name: String\n        age: Int\n        id: Int\n        gender: String\n    }\n  type Query {\n    hello: String\n    users: [User!]\n    randomUser: User\n    userInfo(id:Int!):User\n  }\n`)\n\nconst rootValue = {\n    hello: () =&gt; 'hello world',\n    users: () =&gt; {\n        return originData\n    },\n    randomUser: () =&gt; {\n        let random = Number.parseInt(Math.random() * 3);\n        return originData[random];\n    },\n    userInfo: ({id}) =&gt; {\n        const tempData = originData.filter(item =&gt; item.id == id);\n        return tempData[0]\n    }\n}\n\napp.use('/graphql', graphqlHTTP({\n    schema,\n    rootValue,\n    graphiql: true\n}));\n\napp.listen(3000, () =&gt; {\n    console.log(&quot;Now open localhost:3000!&quot;);\n});\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>index.html</li>\n</ol>\n</blockquote>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Learn GraphQL Page&lt;/title&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n    #btn {\n        width: 100px;\n        height: 41px;\n        background: #2196F3;\n        border-radius: 23px;\n        color: #fff;\n        text-align: center;\n        line-height: 41px;\n        cursor: pointer;\n        box-shadow: 4px 3px 19px rgba(0, 0, 0, 0.5);\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;btn&quot;&gt;GET DATA&lt;/div&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\nlet btn = document.getElementById('btn');\nbtn.onclick = function() {\n    const userId = 10001;\n    const query = `query AllUser($id:Int!) {\n    userInfo(id: $id) {\n        name\n        age\n        gender\n    }\n  }`;\n    fetch('/graphql', {\n            method: &quot;POST&quot;,\n            headers: {\n                &quot;Content-Type&quot;: &quot;application/json&quot;,\n                &quot;Accept&quot;: &quot;application/json&quot;\n            },\n            body: JSON.stringify({\n                query,\n                variables: { id: userId }\n            })\n        }).then(res =&gt; res.json())\n        .then(resData =&gt; {\n            console.log(resData.data);\n        })\n\n}\n&lt;/script&gt;\n\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>执行命令,打开游览器localhost:3000/index.html</li>\n</ol>\n</blockquote>\n<pre><code>  nodemon index.js</code></pre>\n"},{"title":"前端面试系列 — HMTL基础篇","catalog":true,"url":"133.html","id":"133","date":"2019-02-26T04:25:17.000Z","subtitle":null,"header-img":null,"_content":"\n![banner image](http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg)\n\n> ##### 1\\. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。\n\n1.  DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）\n2.  DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。\n3.  DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。\n4.  如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。\n\n> ##### 2\\. HTML 与 XML 有什么区别\n\n主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。\n\n> ##### 3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。\n\n1.  块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr...\n2.  内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u...\n3.  判断行内元素和块级元素的快捷方法就是判断是否能并列。\n\n> ##### 4.说说HTML5新增了那些元素，以及如何更好的语义化。\n\n1.  header--显示头部信息，article---定义独立内容，常用于用户评语或博客条目，section---节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav---导航链接，在一个html中可以有多个nav， hgroup---适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer---眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。\n2.  其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等\n\n> #### 5.HTML5新增了那些API?\n> \n> 1.  Media API\n> 2.  Text Track API\n> 3.  Application Cache API\n> 4.  User Interaction\n> 5.  Data Transfer API\n> 6.  Command API\n> 7.  Constraint Validation API\n> 8.  History API\n> 9.  Canvas API\n> 10.  Geolocation API等等","source":"_posts/前端面试系列 — HMTL基础篇.md","raw":"---\ntitle: 前端面试系列 — HMTL基础篇\ncatalog: true\nurl: 133.html\nid: 133\ncategories:\n  - HTML5\ndate: 2019-02-26 12:25:17\nsubtitle:\nheader-img:\ntags:\n---\n\n![banner image](http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg)\n\n> ##### 1\\. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。\n\n1.  DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）\n2.  DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。\n3.  DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。\n4.  如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。\n\n> ##### 2\\. HTML 与 XML 有什么区别\n\n主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。\n\n> ##### 3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。\n\n1.  块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr...\n2.  内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u...\n3.  判断行内元素和块级元素的快捷方法就是判断是否能并列。\n\n> ##### 4.说说HTML5新增了那些元素，以及如何更好的语义化。\n\n1.  header--显示头部信息，article---定义独立内容，常用于用户评语或博客条目，section---节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav---导航链接，在一个html中可以有多个nav， hgroup---适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer---眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。\n2.  其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等\n\n> #### 5.HTML5新增了那些API?\n> \n> 1.  Media API\n> 2.  Text Track API\n> 3.  Application Cache API\n> 4.  User Interaction\n> 5.  Data Transfer API\n> 6.  Command API\n> 7.  Constraint Validation API\n> 8.  History API\n> 9.  Canvas API\n> 10.  Geolocation API等等","slug":"前端面试系列 — HMTL基础篇","published":1,"updated":"2019-08-05T09:32:00.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ap000za0s6ahx2xsfi","content":"<p><img src=\"http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg\" alt=\"banner image\"></p>\n<blockquote>\n<h5><span id=\"1-html中首行-有什么作用-doctype-又分哪几类其中这些每一类由对应有什么作用请简单描述一下\">1. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。</span></h5>\n</blockquote>\n<ol>\n<li>DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）</li>\n<li>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。</li>\n<li>DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。</li>\n<li>如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。</li>\n</ol>\n<blockquote>\n<h5><span id=\"2-html-与-xml-有什么区别\">2. HTML 与 XML 有什么区别</span></h5>\n</blockquote>\n<p>主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。</p>\n<blockquote>\n<h5><span id=\"3说说html中有哪些块级元素那些内联元素以及块级元素与内联元素的区别\">3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。</span></h5>\n</blockquote>\n<ol>\n<li>块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr…</li>\n<li>内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u…</li>\n<li>判断行内元素和块级元素的快捷方法就是判断是否能并列。</li>\n</ol>\n<blockquote>\n<h5><span id=\"4说说html5新增了那些元素以及如何更好的语义化\">4.说说HTML5新增了那些元素，以及如何更好的语义化。</span></h5>\n</blockquote>\n<ol>\n<li>header–显示头部信息，article—定义独立内容，常用于用户评语或博客条目，section—节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav—导航链接，在一个html中可以有多个nav， hgroup—适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer—眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。</li>\n<li>其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等</li>\n</ol>\n<blockquote>\n<h4><span id=\"5html5新增了那些api\">5.HTML5新增了那些API?</span></h4>\n<ol>\n<li>Media API</li>\n<li>Text Track API</li>\n<li>Application Cache API</li>\n<li>User Interaction</li>\n<li>Data Transfer API</li>\n<li>Command API</li>\n<li>Constraint Validation API</li>\n<li>History API</li>\n<li>Canvas API</li>\n<li>Geolocation API等等</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.90sjimg.com/back_pic/qk/back_origin_pic/00/01/52/d2060da501854ef147f75e63d4412978.jpg\" alt=\"banner image\"></p>\n<blockquote>\n<h5>1. HTML中首行 有什么作用? doctype 又分哪几类?其中这些每一类由对应有什么作用？请简单描述一下。</h5>\n</blockquote>\n<ol>\n<li>DOCTYPE 是 document type(文档类型的）的简写。是为了告诉浏览器需要通过哪一种规范（文档类型定义，DTD）解析文档（比如HTML或XHTML规范）</li>\n<li>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义 XML 或 (X)HTML 的文件类型。浏览器会使用它来判断文档类型， 决定使用何种协议来解析，以及切换浏览器模式。</li>\n<li>DTD总体分为三类，HTML4.0 HTML5, XHML。其中HTML4.0 分为三种模式：严格模式(strict)，过渡模式（Transitional）, Frameset模式。区别主要在于是不是允许展示性和弃用的元素，是否允许框架集。</li>\n<li>如何不写DOCTYPE，游览器可会以怪异模式来渲染文档，最好还是写DOCTYPE，这样游览器会以w3c 标准模式来渲染文档。</li>\n</ol>\n<blockquote>\n<h5>2. HTML 与 XML 有什么区别</h5>\n</blockquote>\n<p>主要区别： XML区分大小写。 XML标签必须闭合，单元素需要以/作为闭合结尾，嵌套不能出错。 XML属性必须放在引号中。 XML属性必须有属性值，不能省略。 XML中空格不会被自动删除。</p>\n<blockquote>\n<h5>3.说说html中有哪些块级元素，那些内联元素，以及块级元素与内联元素的区别。</h5>\n</blockquote>\n<ol>\n<li>块级元素 address, blockquoto, center, dir, div, dl,fieldset, form, h1-h6,hr,ol,ul,li,p,pre,table,th,tbody,td,tfoot,thead,tr…</li>\n<li>内联元素 a, abbr, acronym, b, big, br, cite, code, dfn, em, font, i, img, input, kdb,label,q,slect,small,span,strike,strong,sub,sup,textarea,tt,u…</li>\n<li>判断行内元素和块级元素的快捷方法就是判断是否能并列。</li>\n</ol>\n<blockquote>\n<h5>4.说说HTML5新增了那些元素，以及如何更好的语义化。</h5>\n</blockquote>\n<ol>\n<li>header–显示头部信息，article—定义独立内容，常用于用户评语或博客条目，section—节，例如文章的章节、页眉、页脚等，该标记中还新增一个cite属性，引用资源的URL，nav—导航链接，在一个html中可以有多个nav， hgroup—适用于多标题文档，对标题进行组合，可以理解hgroup相当一个容器，里面包含有正副标题， footer—眉脚，页面底部，footer元素内使用address元素， aside定义所处的内容之外的内容，但与附近内容有关（注释、引用、提示）， figure 定义媒介内容， dialog定义对话框或窗口，带有open属性，跟用户互动， mark元素标记，相当于荧光笔在纸上标记文字，time元素定义时间（24小时制）、日期，meter元素定义度量衡，process元素定义运行中的进度。</li>\n<li>其他新增元素：video、audio、source、embed、canvas、bdi、command、datalist、details、keygen、output、rp、rt、ruby、track、summary等</li>\n</ol>\n<blockquote>\n<h4>5.HTML5新增了那些API?</h4>\n<ol>\n<li>Media API</li>\n<li>Text Track API</li>\n<li>Application Cache API</li>\n<li>User Interaction</li>\n<li>Data Transfer API</li>\n<li>Command API</li>\n<li>Constraint Validation API</li>\n<li>History API</li>\n<li>Canvas API</li>\n<li>Geolocation API等等</li>\n</ol>\n</blockquote>\n"},{"title":"JavaScript数据结构与算法-集合","catalog":true,"url":"195.html","id":"195","date":"2019-03-07T06:49:23.000Z","subtitle":null,"header-img":null,"_content":"\n#### 1\\. 什么是集合 ？\n\n集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。\n\n#### 2\\. 代码实现集合\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      values() {\n        return [...this.set]\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    console.log(setA.values());\n    console.log(setA.has(3));\n    \n    \n\n#### 3\\. 集合操作 交集\n\n交集的数学概念是集合A和集合B的交集\n\n     intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n    \n\n#### 4\\. 集合操作 并集\n\n并集的数学概念是集合A和集合B的并集\n\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n    \n\n#### 5\\. 集合操作 差集\n\n差集的数学概念是集合A和集合B的差集\n\n     difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n    \n\n#### 6\\. 集合操作 子集\n\n子集的数学概念是集合A是集合B的子集\n\n     subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    \n\n#### PS: 完整代码以及结果\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      value() {\n        return [...this.set]\n      }\n      // 交集\n      intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n      // 并集\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n      // 差集\n      difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n      // 子集\n      subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    setB.add(4);\n    setB.add(4);\n    setB.add(5);\n    console.log(setA.value());\n    console.log(setB.value());\n    console.log(setA.has(3));\n    console.log(setA.union(setB));\n    console.log(setA.intersection(setB));\n    console.log(setA.difference(setB));\n    console.log(setA.subset(setB));\n    // [ 2, 3, 4, 5 ]\n    // [ 4, 5 ]\n    // true\n    // Set { 2, 3, 4, 5 }\n    // Set { 4, 5 }\n    // Set { 2, 3 }\n    // true","source":"_posts/JavaScript数据结构与算法-集合.md","raw":"---\ntitle: JavaScript数据结构与算法-集合\ncatalog: true\ntags:\n  - javascript\n  - 数据结构\nurl: 195.html\nid: 195\ncategories:\n  - 数据结构\ndate: 2019-03-07 14:49:23\nsubtitle:\nheader-img:\n---\n\n#### 1\\. 什么是集合 ？\n\n集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。\n\n#### 2\\. 代码实现集合\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      values() {\n        return [...this.set]\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    console.log(setA.values());\n    console.log(setA.has(3));\n    \n    \n\n#### 3\\. 集合操作 交集\n\n交集的数学概念是集合A和集合B的交集\n\n     intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n    \n\n#### 4\\. 集合操作 并集\n\n并集的数学概念是集合A和集合B的并集\n\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n    \n\n#### 5\\. 集合操作 差集\n\n差集的数学概念是集合A和集合B的差集\n\n     difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n    \n\n#### 6\\. 集合操作 子集\n\n子集的数学概念是集合A是集合B的子集\n\n     subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    \n\n#### PS: 完整代码以及结果\n\n    // 数据结构 之 集合 我们用ES6来实现\n    \n    class Collect {\n      constructor() {\n        this.set = new Set();\n      }\n      add(element) {\n        this.set.add(element);\n      }\n      delete(element) {\n        this.set.delete(element);\n      }\n      has(element) {\n        return this.set.has(element);\n      }\n      clear() {\n        this.set = new Set();\n      }\n      size() {\n        return this.set.size();\n      }\n      value() {\n        return [...this.set]\n      }\n      // 交集\n      intersection(otherSet) {\n        let intersectionSet = new Set();\n        for (let value of this.set.values()) {\n          if (otherSet.has(value)) {\n            intersectionSet.add(value)\n          }\n        }\n        return intersectionSet;\n      }\n      // 并集\n      union(otherSet) {\n        return new Set([...this.set].concat([...otherSet.set]));\n      }\n      // 差集\n      difference(otherSet) {\n        let differSet = new Set();\n        for (let value of this.set.values()) {\n          if (!otherSet.has(value)) {\n            differSet.add(value);\n          }\n        }\n        return differSet;\n      }\n      // 子集\n      subset(childSet) {\n        for (let value of childSet.set) {\n          if (!this.set.has(value)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n    \n    let setA = new Collect();\n    let setB = new Collect();\n    \n    setA.add(2);\n    setA.add(3);\n    setA.add(4);\n    setA.add(4);\n    setA.add(5);\n    setB.add(4);\n    setB.add(4);\n    setB.add(5);\n    console.log(setA.value());\n    console.log(setB.value());\n    console.log(setA.has(3));\n    console.log(setA.union(setB));\n    console.log(setA.intersection(setB));\n    console.log(setA.difference(setB));\n    console.log(setA.subset(setB));\n    // [ 2, 3, 4, 5 ]\n    // [ 4, 5 ]\n    // true\n    // Set { 2, 3, 4, 5 }\n    // Set { 4, 5 }\n    // Set { 2, 3 }\n    // true","slug":"JavaScript数据结构与算法-集合","published":1,"updated":"2019-08-05T09:32:00.513Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ar0013a0s65senzmh2","content":"<h4><span id=\"1-什么是集合\">1. 什么是集合 ？</span></h4>\n<p>集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。</p>\n<h4><span id=\"2-代码实现集合\">2. 代码实现集合</span></h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  values() {\n    return [...this.set]\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nconsole.log(setA.values());\nconsole.log(setA.has(3));\n</code></pre>\n<h4><span id=\"3-集合操作-交集\">3. 集合操作 交集</span></h4>\n<p>交集的数学概念是集合A和集合B的交集</p>\n<pre><code> intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n</code></pre>\n<h4><span id=\"4-集合操作-并集\">4. 集合操作 并集</span></h4>\n<p>并集的数学概念是集合A和集合B的并集</p>\n<pre><code>  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n</code></pre>\n<h4><span id=\"5-集合操作-差集\">5. 集合操作 差集</span></h4>\n<p>差集的数学概念是集合A和集合B的差集</p>\n<pre><code> difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n</code></pre>\n<h4><span id=\"6-集合操作-子集\">6. 集合操作 子集</span></h4>\n<p>子集的数学概念是集合A是集合B的子集</p>\n<pre><code> subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n</code></pre>\n<h4><span id=\"ps-完整代码以及结果\">PS: 完整代码以及结果</span></h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  value() {\n    return [...this.set]\n  }\n  // 交集\n  intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n  // 并集\n  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n  // 差集\n  difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n  // 子集\n  subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nsetB.add(4);\nsetB.add(4);\nsetB.add(5);\nconsole.log(setA.value());\nconsole.log(setB.value());\nconsole.log(setA.has(3));\nconsole.log(setA.union(setB));\nconsole.log(setA.intersection(setB));\nconsole.log(setA.difference(setB));\nconsole.log(setA.subset(setB));\n// [ 2, 3, 4, 5 ]\n// [ 4, 5 ]\n// true\n// Set { 2, 3, 4, 5 }\n// Set { 4, 5 }\n// Set { 2, 3 }\n// true</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>1. 什么是集合 ？</h4>\n<p>集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。</p>\n<h4>2. 代码实现集合</h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  values() {\n    return [...this.set]\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nconsole.log(setA.values());\nconsole.log(setA.has(3));\n</code></pre>\n<h4>3. 集合操作 交集</h4>\n<p>交集的数学概念是集合A和集合B的交集</p>\n<pre><code> intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n</code></pre>\n<h4>4. 集合操作 并集</h4>\n<p>并集的数学概念是集合A和集合B的并集</p>\n<pre><code>  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n</code></pre>\n<h4>5. 集合操作 差集</h4>\n<p>差集的数学概念是集合A和集合B的差集</p>\n<pre><code> difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n</code></pre>\n<h4>6. 集合操作 子集</h4>\n<p>子集的数学概念是集合A是集合B的子集</p>\n<pre><code> subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n</code></pre>\n<h4>PS: 完整代码以及结果</h4>\n<pre><code>// 数据结构 之 集合 我们用ES6来实现\n\nclass Collect {\n  constructor() {\n    this.set = new Set();\n  }\n  add(element) {\n    this.set.add(element);\n  }\n  delete(element) {\n    this.set.delete(element);\n  }\n  has(element) {\n    return this.set.has(element);\n  }\n  clear() {\n    this.set = new Set();\n  }\n  size() {\n    return this.set.size();\n  }\n  value() {\n    return [...this.set]\n  }\n  // 交集\n  intersection(otherSet) {\n    let intersectionSet = new Set();\n    for (let value of this.set.values()) {\n      if (otherSet.has(value)) {\n        intersectionSet.add(value)\n      }\n    }\n    return intersectionSet;\n  }\n  // 并集\n  union(otherSet) {\n    return new Set([...this.set].concat([...otherSet.set]));\n  }\n  // 差集\n  difference(otherSet) {\n    let differSet = new Set();\n    for (let value of this.set.values()) {\n      if (!otherSet.has(value)) {\n        differSet.add(value);\n      }\n    }\n    return differSet;\n  }\n  // 子集\n  subset(childSet) {\n    for (let value of childSet.set) {\n      if (!this.set.has(value)) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\nlet setA = new Collect();\nlet setB = new Collect();\n\nsetA.add(2);\nsetA.add(3);\nsetA.add(4);\nsetA.add(4);\nsetA.add(5);\nsetB.add(4);\nsetB.add(4);\nsetB.add(5);\nconsole.log(setA.value());\nconsole.log(setB.value());\nconsole.log(setA.has(3));\nconsole.log(setA.union(setB));\nconsole.log(setA.intersection(setB));\nconsole.log(setA.difference(setB));\nconsole.log(setA.subset(setB));\n// [ 2, 3, 4, 5 ]\n// [ 4, 5 ]\n// true\n// Set { 2, 3, 4, 5 }\n// Set { 4, 5 }\n// Set { 2, 3 }\n// true</code></pre>\n"},{"title":"前端面试系列 — 布局篇","catalog":true,"url":"137.html","id":"137","date":"2019-02-26T04:28:40.000Z","subtitle":null,"header-img":null,"_content":"\n![images](http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg)\n\n> 一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。\n\n1.  利用浮动布局（圣杯布局和双飞翼布局）\n2.  利用定位布局\n3.  flex 布局\n4.  table 表格布局\n5.  grid 布局\n\n代码如下:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>layout</title>\n        <style>\n            *{\n                padding:0;\n                margin:0;\n            }\n            .layout{\n                height: 100px;\n                width: 100%;\n                margin-bottom:50px;\n                overflow: hidden;\n                position: relative;\n            }\n            .layout>div{\n                height:100px;\n            }\n            .float .left,.float .right {\n             width: 200px;\n             height:100px;\n            }\n            .float>.left{\n                float:left;\n                background:red;\n    \n            }\n            .float>.right{\n             float:right;\n             background:blue;\n            }\n            .float>.center{\n                background:green;\n    \n            }\n            /*定位 解决方案*/\n            .position>.left{\n                position:absolute;\n                left:0;\n                top:0;\n                background: red;\n                width:200px;\n                height:100px;\n            }\n            .position>.right{\n                position:absolute;\n                right:0;\n                top:0;\n                background: yellow;\n                width:200px;\n                height:100px;\n            }\n            .position>.center{\n                position: absolute;\n                left:200px;\n                right:200px;\n                background:green;\n            }\n            /*flex 解决方案*/\n            .flex{\n                display: flex;\n                height:100px;\n            }\n            .flex .right, .flex .left{\n                width:200px;\n                background:blue;\n            }\n            .flex .center{\n                flex:1;\n                background:red;\n            }\n            /*table 解决方案*/\n            .table{\n                display: table;\n            }\n            .table>.left,.table>.right{\n                height:100px;\n                width:300px;\n                display: table-cell;\n                background:yellow;\n            }\n            .table>.center{\n                background:red;\n                display: table-cell;\n            }\n            /*grid 解决方案*/\n            .grid {\n                display: grid;\n                grid-template-rows: 100;\n                grid-template-columns: 300px auto 300px;\n            }\n            .grid > .left,.grid >.right{\n               background:red;\n            }\n            .grid > .center{\n               background:yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <!-- float布局 圣杯和双飞翼布局-->\n        <section class=\"layout float\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>float 解决方案</h1>\n                <p>float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案</p>\n            </div>\n        </section>\n        <!-- 定位布局 -->\n        <section class=\"layout position\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>定位 解决方案</h1>\n                <p>定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案</p>\n            </div>\n        </section>\n        <!-- flex 布局 实现太过于简单略-->\n        <section class=\"layout flex\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>flex 解决方案</h1>\n                <p>flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- table 布局 -->\n        <section class=\"layout table\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>table 解决方案</h1>\n                <p>table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- grid 布局 -->\n        <section class=\"layout grid\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>Grid 解决方案</h1>\n                <p>Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n    </body>\n    </html>\n    \n    \n\n> ##### 思考假如高度不固定，上述的方案中又有那些符合要求。\n\n1.  flex布局\n2.  table布局\n3.  grid 布局","source":"_posts/前端面试系列 — 布局篇.md","raw":"---\ntitle: 前端面试系列 — 布局篇\ncatalog: true\nurl: 137.html\nid: 137\ncategories:\n  - CSS3\ndate: 2019-02-26 12:28:40\nsubtitle:\nheader-img:\ntags:\n---\n\n![images](http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg)\n\n> 一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。\n\n1.  利用浮动布局（圣杯布局和双飞翼布局）\n2.  利用定位布局\n3.  flex 布局\n4.  table 表格布局\n5.  grid 布局\n\n代码如下:\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>layout</title>\n        <style>\n            *{\n                padding:0;\n                margin:0;\n            }\n            .layout{\n                height: 100px;\n                width: 100%;\n                margin-bottom:50px;\n                overflow: hidden;\n                position: relative;\n            }\n            .layout>div{\n                height:100px;\n            }\n            .float .left,.float .right {\n             width: 200px;\n             height:100px;\n            }\n            .float>.left{\n                float:left;\n                background:red;\n    \n            }\n            .float>.right{\n             float:right;\n             background:blue;\n            }\n            .float>.center{\n                background:green;\n    \n            }\n            /*定位 解决方案*/\n            .position>.left{\n                position:absolute;\n                left:0;\n                top:0;\n                background: red;\n                width:200px;\n                height:100px;\n            }\n            .position>.right{\n                position:absolute;\n                right:0;\n                top:0;\n                background: yellow;\n                width:200px;\n                height:100px;\n            }\n            .position>.center{\n                position: absolute;\n                left:200px;\n                right:200px;\n                background:green;\n            }\n            /*flex 解决方案*/\n            .flex{\n                display: flex;\n                height:100px;\n            }\n            .flex .right, .flex .left{\n                width:200px;\n                background:blue;\n            }\n            .flex .center{\n                flex:1;\n                background:red;\n            }\n            /*table 解决方案*/\n            .table{\n                display: table;\n            }\n            .table>.left,.table>.right{\n                height:100px;\n                width:300px;\n                display: table-cell;\n                background:yellow;\n            }\n            .table>.center{\n                background:red;\n                display: table-cell;\n            }\n            /*grid 解决方案*/\n            .grid {\n                display: grid;\n                grid-template-rows: 100;\n                grid-template-columns: 300px auto 300px;\n            }\n            .grid > .left,.grid >.right{\n               background:red;\n            }\n            .grid > .center{\n               background:yellow;\n            }\n        </style>\n    </head>\n    <body>\n        <!-- float布局 圣杯和双飞翼布局-->\n        <section class=\"layout float\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>float 解决方案</h1>\n                <p>float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案</p>\n            </div>\n        </section>\n        <!-- 定位布局 -->\n        <section class=\"layout position\">\n            <div class=\"left\">left</div>\n            <div class=\"right\">right</div>\n            <div class=\"center\">\n                <h1>定位 解决方案</h1>\n                <p>定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案</p>\n            </div>\n        </section>\n        <!-- flex 布局 实现太过于简单略-->\n        <section class=\"layout flex\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>flex 解决方案</h1>\n                <p>flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- table 布局 -->\n        <section class=\"layout table\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>table 解决方案</h1>\n                <p>table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n        <!-- grid 布局 -->\n        <section class=\"layout grid\">\n            <div class=\"left\">left</div>\n            <div class=\"center\">\n                <h1>Grid 解决方案</h1>\n                <p>Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案</p>\n            </div>\n            <div class=\"right\">right</div>\n        </section>\n    </body>\n    </html>\n    \n    \n\n> ##### 思考假如高度不固定，上述的方案中又有那些符合要求。\n\n1.  flex布局\n2.  table布局\n3.  grid 布局","slug":"前端面试系列 — 布局篇","published":1,"updated":"2019-08-05T09:32:00.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4as0015a0s68opue3sj","content":"<p><img src=\"http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg\" alt=\"images\"></p>\n<blockquote>\n<p>一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。</p>\n</blockquote>\n<ol>\n<li>利用浮动布局（圣杯布局和双飞翼布局）</li>\n<li>利用定位布局</li>\n<li>flex 布局</li>\n<li>table 表格布局</li>\n<li>grid 布局</li>\n</ol>\n<p>代码如下:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;layout&lt;/title&gt;\n    &lt;style&gt;\n        *{\n            padding:0;\n            margin:0;\n        }\n        .layout{\n            height: 100px;\n            width: 100%;\n            margin-bottom:50px;\n            overflow: hidden;\n            position: relative;\n        }\n        .layout&gt;div{\n            height:100px;\n        }\n        .float .left,.float .right {\n         width: 200px;\n         height:100px;\n        }\n        .float&gt;.left{\n            float:left;\n            background:red;\n\n        }\n        .float&gt;.right{\n         float:right;\n         background:blue;\n        }\n        .float&gt;.center{\n            background:green;\n\n        }\n        /*定位 解决方案*/\n        .position&gt;.left{\n            position:absolute;\n            left:0;\n            top:0;\n            background: red;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.right{\n            position:absolute;\n            right:0;\n            top:0;\n            background: yellow;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.center{\n            position: absolute;\n            left:200px;\n            right:200px;\n            background:green;\n        }\n        /*flex 解决方案*/\n        .flex{\n            display: flex;\n            height:100px;\n        }\n        .flex .right, .flex .left{\n            width:200px;\n            background:blue;\n        }\n        .flex .center{\n            flex:1;\n            background:red;\n        }\n        /*table 解决方案*/\n        .table{\n            display: table;\n        }\n        .table&gt;.left,.table&gt;.right{\n            height:100px;\n            width:300px;\n            display: table-cell;\n            background:yellow;\n        }\n        .table&gt;.center{\n            background:red;\n            display: table-cell;\n        }\n        /*grid 解决方案*/\n        .grid {\n            display: grid;\n            grid-template-rows: 100;\n            grid-template-columns: 300px auto 300px;\n        }\n        .grid &gt; .left,.grid &gt;.right{\n           background:red;\n        }\n        .grid &gt; .center{\n           background:yellow;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- float布局 圣杯和双飞翼布局--&gt;\n    &lt;section class=&quot;layout float&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;float 解决方案&lt;/h1&gt;\n            &lt;p&gt;float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- 定位布局 --&gt;\n    &lt;section class=&quot;layout position&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;定位 解决方案&lt;/h1&gt;\n            &lt;p&gt;定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- flex 布局 实现太过于简单略--&gt;\n    &lt;section class=&quot;layout flex&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;flex 解决方案&lt;/h1&gt;\n            &lt;p&gt;flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- table 布局 --&gt;\n    &lt;section class=&quot;layout table&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;table 解决方案&lt;/h1&gt;\n            &lt;p&gt;table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- grid 布局 --&gt;\n    &lt;section class=&quot;layout grid&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;Grid 解决方案&lt;/h1&gt;\n            &lt;p&gt;Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<h5><span id=\"思考假如高度不固定上述的方案中又有那些符合要求\">思考假如高度不固定，上述的方案中又有那些符合要求。</span></h5>\n</blockquote>\n<ol>\n<li>flex布局</li>\n<li>table布局</li>\n<li>grid 布局</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.90sjimg.com/back_pic/00/04/27/49/850f91ae69da1df596423db51c0e8486.jpg\" alt=\"images\"></p>\n<blockquote>\n<p>一. 三栏布局，固定高度，左右固定宽度，中间自适应。请写出合理的布局方案。</p>\n</blockquote>\n<ol>\n<li>利用浮动布局（圣杯布局和双飞翼布局）</li>\n<li>利用定位布局</li>\n<li>flex 布局</li>\n<li>table 表格布局</li>\n<li>grid 布局</li>\n</ol>\n<p>代码如下:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;layout&lt;/title&gt;\n    &lt;style&gt;\n        *{\n            padding:0;\n            margin:0;\n        }\n        .layout{\n            height: 100px;\n            width: 100%;\n            margin-bottom:50px;\n            overflow: hidden;\n            position: relative;\n        }\n        .layout&gt;div{\n            height:100px;\n        }\n        .float .left,.float .right {\n         width: 200px;\n         height:100px;\n        }\n        .float&gt;.left{\n            float:left;\n            background:red;\n\n        }\n        .float&gt;.right{\n         float:right;\n         background:blue;\n        }\n        .float&gt;.center{\n            background:green;\n\n        }\n        /*定位 解决方案*/\n        .position&gt;.left{\n            position:absolute;\n            left:0;\n            top:0;\n            background: red;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.right{\n            position:absolute;\n            right:0;\n            top:0;\n            background: yellow;\n            width:200px;\n            height:100px;\n        }\n        .position&gt;.center{\n            position: absolute;\n            left:200px;\n            right:200px;\n            background:green;\n        }\n        /*flex 解决方案*/\n        .flex{\n            display: flex;\n            height:100px;\n        }\n        .flex .right, .flex .left{\n            width:200px;\n            background:blue;\n        }\n        .flex .center{\n            flex:1;\n            background:red;\n        }\n        /*table 解决方案*/\n        .table{\n            display: table;\n        }\n        .table&gt;.left,.table&gt;.right{\n            height:100px;\n            width:300px;\n            display: table-cell;\n            background:yellow;\n        }\n        .table&gt;.center{\n            background:red;\n            display: table-cell;\n        }\n        /*grid 解决方案*/\n        .grid {\n            display: grid;\n            grid-template-rows: 100;\n            grid-template-columns: 300px auto 300px;\n        }\n        .grid &gt; .left,.grid &gt;.right{\n           background:red;\n        }\n        .grid &gt; .center{\n           background:yellow;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;!-- float布局 圣杯和双飞翼布局--&gt;\n    &lt;section class=&quot;layout float&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;float 解决方案&lt;/h1&gt;\n            &lt;p&gt;float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案float 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- 定位布局 --&gt;\n    &lt;section class=&quot;layout position&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;定位 解决方案&lt;/h1&gt;\n            &lt;p&gt;定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案定位 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- flex 布局 实现太过于简单略--&gt;\n    &lt;section class=&quot;layout flex&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;flex 解决方案&lt;/h1&gt;\n            &lt;p&gt;flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案flex 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- table 布局 --&gt;\n    &lt;section class=&quot;layout table&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;table 解决方案&lt;/h1&gt;\n            &lt;p&gt;table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案table 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n    &lt;!-- grid 布局 --&gt;\n    &lt;section class=&quot;layout grid&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;\n        &lt;div class=&quot;center&quot;&gt;\n            &lt;h1&gt;Grid 解决方案&lt;/h1&gt;\n            &lt;p&gt;Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案Grid 解决方案&lt;/p&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;\n    &lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<h5>思考假如高度不固定，上述的方案中又有那些符合要求。</h5>\n</blockquote>\n<ol>\n<li>flex布局</li>\n<li>table布局</li>\n<li>grid 布局</li>\n</ol>\n"},{"title":"前端面试系列- CSS基础篇","catalog":true,"url":"153.html","id":"153","date":"2019-02-26T04:41:20.000Z","subtitle":null,"header-img":null,"_content":"\n![banner](http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg)\n\n> 一. 有哪几种游览器内核 1\\. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。\\[又称为MSHTML\\] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。\\[Opera内核原为：Presto，现为：Blink\\] 4. Webkit内核：Safari,Chrome等。\\[Chrome的:Blink(Webkit的分支)\\] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both\n\n最好的一种方式：伪类清除浮动\n\n    .clearfix:after {\n      visibility: hidden;\n      display: block;\n      font-size: 0;\n      content: \" \";\n      clear: both;\n      height: 0;\n    }\n    .clearfix{\n        zoom:1\n    }","source":"_posts/前端面试系列- CSS基础篇.md","raw":"---\ntitle: 前端面试系列- CSS基础篇\ncatalog: true\ntags:\n  - CSS3\n  - Frontend Interview\n  - html\nurl: 153.html\nid: 153\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:41:20\nsubtitle:\nheader-img:\n---\n\n![banner](http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg)\n\n> 一. 有哪几种游览器内核 1\\. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。\\[又称为MSHTML\\] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。\\[Opera内核原为：Presto，现为：Blink\\] 4. Webkit内核：Safari,Chrome等。\\[Chrome的:Blink(Webkit的分支)\\] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both\n\n最好的一种方式：伪类清除浮动\n\n    .clearfix:after {\n      visibility: hidden;\n      display: block;\n      font-size: 0;\n      content: \" \";\n      clear: both;\n      height: 0;\n    }\n    .clearfix{\n        zoom:1\n    }","slug":"前端面试系列- CSS基础篇","published":1,"updated":"2019-08-05T09:32:00.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4at0018a0s6ixng3do1","content":"<p><img src=\"http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg\" alt=\"banner\"></p>\n<blockquote>\n<p>一. 有哪几种游览器内核 1. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink] 4. Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both</p>\n</blockquote>\n<p>最好的一种方式：伪类清除浮动</p>\n<pre><code>.clearfix:after {\n  visibility: hidden;\n  display: block;\n  font-size: 0;\n  content: &quot; &quot;;\n  clear: both;\n  height: 0;\n}\n.clearfix{\n    zoom:1\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://pic.97uimg.com/back_pic/20/15/11/09/7a16651588b11b8555782f9f7751bcfd.jpg\" alt=\"banner\"></p>\n<blockquote>\n<p>一. 有哪几种游览器内核 1. Trident内核：IE,MaxThon,TT,The Word,360,搜狗浏览器等。[又称为MSHTML] 2. Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等； 3. Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink] 4. Webkit内核：Safari,Chrome等。[Chrome的:Blink(Webkit的分支)] 二. 如何清除浮动，解决浮动坍塌。 1. 父级div定义height。 2. 结尾处加空div标签clear：both。 3. 父级div定义伪类：after和zoom。 4. 父级div定义overflow：hidden。 5. 父级div定义overflow：auto。 6. 父级div也浮动，需要定义宽度。 7.父级div定义display：table。 8. 结尾处加br标签clear:both</p>\n</blockquote>\n<p>最好的一种方式：伪类清除浮动</p>\n<pre><code>.clearfix:after {\n  visibility: hidden;\n  display: block;\n  font-size: 0;\n  content: &quot; &quot;;\n  clear: both;\n  height: 0;\n}\n.clearfix{\n    zoom:1\n}</code></pre>\n"},{"title":"前端面试系列-JS基础数据类型","catalog":true,"url":"141.html","id":"141","date":"2019-02-26T04:30:16.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  typeof 结果可能有哪些值\n\n`number`,`string`, `function`, `object`, `undfined`, `boolean`, `symbol`\n\n> 2.  JS 的数据类型\n\n1.  值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。\n2.  引用数据类型：对象(Object)、数组(Array)、函数(Function)。\n    \n    > 3.  JS 中有哪些内置函数 - 数据封装类对象\n    \n    1.  Object\n    2.  Array\n    3.  Boolean\n    4.  Number\n    5.  String\n    6.  Function\n    7.  Date\n    8.  RegExp\n    9.  Error\n    10.  Math(对象)","source":"_posts/前端面试系列-JS基础数据类型.md","raw":"---\ntitle: 前端面试系列-JS基础数据类型\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 141.html\nid: 141\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:30:16\nsubtitle:\nheader-img:\n---\n\n> 1.  typeof 结果可能有哪些值\n\n`number`,`string`, `function`, `object`, `undfined`, `boolean`, `symbol`\n\n> 2.  JS 的数据类型\n\n1.  值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。\n2.  引用数据类型：对象(Object)、数组(Array)、函数(Function)。\n    \n    > 3.  JS 中有哪些内置函数 - 数据封装类对象\n    \n    1.  Object\n    2.  Array\n    3.  Boolean\n    4.  Number\n    5.  String\n    6.  Function\n    7.  Date\n    8.  RegExp\n    9.  Error\n    10.  Math(对象)","slug":"前端面试系列-JS基础数据类型","published":1,"updated":"2019-08-05T09:32:00.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4av001ca0s6uvrfh5os","content":"<blockquote>\n<ol>\n<li>typeof 结果可能有哪些值</li>\n</ol>\n</blockquote>\n<p><code>number</code>,<code>string</code>, <code>function</code>, <code>object</code>, <code>undfined</code>, <code>boolean</code>, <code>symbol</code></p>\n<blockquote>\n<ol start=\"2\">\n<li>JS 的数据类型</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>\n</li>\n<li>\n<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>\n<blockquote>\n<ol start=\"3\">\n<li>JS 中有哪些内置函数 - 数据封装类对象</li>\n</ol>\n</blockquote>\n<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Function</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>Math(对象)</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>typeof 结果可能有哪些值</li>\n</ol>\n</blockquote>\n<p><code>number</code>,<code>string</code>, <code>function</code>, <code>object</code>, <code>undfined</code>, <code>boolean</code>, <code>symbol</code></p>\n<blockquote>\n<ol start=\"2\">\n<li>JS 的数据类型</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>\n</li>\n<li>\n<p>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</p>\n<blockquote>\n<ol start=\"3\">\n<li>JS 中有哪些内置函数 - 数据封装类对象</li>\n</ol>\n</blockquote>\n<ol>\n<li>Object</li>\n<li>Array</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n<li>Function</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>Error</li>\n<li>Math(对象)</li>\n</ol>\n</li>\n</ol>\n"},{"title":"前端面试系列-HTTP常考点","catalog":true,"url":"172.html","id":"172","date":"2019-03-05T08:44:04.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg)\n\n#### 经典五层模型\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png)\n\n1.  物理层主要作用是定义物理设备如何传输数据\n2.  数据链路层在通信的实体间建立数据链路连接\n3.  网络层为数据在结点之间传输创建逻辑链路\n4.  传输层（TCP，UDP...）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。\n5.  应用层（HTTP，FTP...）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。\n\n> 1.  从输入 URL 到页面加载完成的过程\n\n1.  首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP\n    \n2.  协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n    \n3.  TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件\n    \n4.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错\n    \n5.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件\n    \n6.  文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML\n    \n7.  解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。\n    \n8.  初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件\n    \n9.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n    \n10.  在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了\n    \n\n> 2.  DNS\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg)\n\n1\\. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。\n\n> 3.  HTTPS与HTTP的一些区别\n\n*   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n*   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n*   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n*   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n\n> 4.  HTTP1.x与HTTP2.0的区别\n\n*   `新的二进制格式`（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n*   `MultiPlexing）`，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n*   `header压缩`，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n*   `服务端推送（server push）`，同SPDY一样，HTTP2.0也具有server push功能。\n\n> 5.  HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？\n\n*   HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；\n*   HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；\n*   HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；\n\n### HTTP----HTTP缓存机制\n\n#### 强缓存\n\n实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200\n\n    Expires: Wed, 22 Oct 2018 08:41:00 GMT\n    \n\n`Expires` 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。\n\n    Cache-control: max-age=30\n    \n\n`Cache-Control` 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。\n\n#### 协商缓存\n\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。\n\n> 1.  Last-Modified 和 If-Modified-Since\n\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。\n\n> 2.  ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。\n\n#### 选择合适的缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n*   对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n*   对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n*   对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。","source":"_posts/前端面试系列-HTTP常考点.md","raw":"---\ntitle: 前端面试系列-HTTP常考点\ncatalog: true\ntags:\n  - http\nurl: 172.html\nid: 172\ncategories:\n  - HTTP\ndate: 2019-03-05 16:44:04\nsubtitle:\nheader-img:\n---\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg)\n\n#### 经典五层模型\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png)\n\n1.  物理层主要作用是定义物理设备如何传输数据\n2.  数据链路层在通信的实体间建立数据链路连接\n3.  网络层为数据在结点之间传输创建逻辑链路\n4.  传输层（TCP，UDP...）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。\n5.  应用层（HTTP，FTP...）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。\n\n> 1.  从输入 URL 到页面加载完成的过程\n\n1.  首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP\n    \n2.  协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n    \n3.  TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件\n    \n4.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错\n    \n5.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件\n    \n6.  文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML\n    \n7.  解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。\n    \n8.  初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件\n    \n9.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n    \n10.  在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了\n    \n\n> 2.  DNS\n\n![](http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg)\n\n1\\. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。\n\n> 3.  HTTPS与HTTP的一些区别\n\n*   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n*   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n*   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n*   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n\n> 4.  HTTP1.x与HTTP2.0的区别\n\n*   `新的二进制格式`（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n*   `MultiPlexing）`，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n*   `header压缩`，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n*   `服务端推送（server push）`，同SPDY一样，HTTP2.0也具有server push功能。\n\n> 5.  HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？\n\n*   HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；\n*   HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；\n*   HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；\n\n### HTTP----HTTP缓存机制\n\n#### 强缓存\n\n实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200\n\n    Expires: Wed, 22 Oct 2018 08:41:00 GMT\n    \n\n`Expires` 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。\n\n    Cache-control: max-age=30\n    \n\n`Cache-Control` 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。\n\n#### 协商缓存\n\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。\n\n> 1.  Last-Modified 和 If-Modified-Since\n\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。\n\n> 2.  ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。\n\n#### 选择合适的缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n\n*   对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存\n*   对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。\n*   对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。","slug":"前端面试系列-HTTP常考点","published":1,"updated":"2019-08-05T09:32:00.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4aw001ga0s6qs6qojwe","content":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg\" alt></p>\n<h4><span id=\"经典五层模型\">经典五层模型</span></h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png\" alt></p>\n<ol>\n<li>物理层主要作用是定义物理设备如何传输数据</li>\n<li>数据链路层在通信的实体间建立数据链路连接</li>\n<li>网络层为数据在结点之间传输创建逻辑链路</li>\n<li>传输层（TCP，UDP…）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。</li>\n<li>应用层（HTTP，FTP…）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。</li>\n</ol>\n<blockquote>\n<ol>\n<li>从输入 URL 到页面加载完成的过程</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP</p>\n</li>\n<li>\n<p>协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</p>\n</li>\n<li>\n<p>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</p>\n</li>\n<li>\n<p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</p>\n</li>\n<li>\n<p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</p>\n</li>\n<li>\n<p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML</p>\n</li>\n<li>\n<p>解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</p>\n</li>\n<li>\n<p>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</p>\n</li>\n<li>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n</li>\n<li>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"2\">\n<li>DNS</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg\" alt></p>\n<p>1. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。</p>\n<blockquote>\n<ol start=\"3\">\n<li>HTTPS与HTTP的一些区别</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>\n<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>\n<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>\n<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>HTTP1.x与HTTP2.0的区别</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>新的二进制格式</code>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li><code>MultiPlexing）</code>，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>\n<li><code>header压缩</code>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>\n<li><code>服务端推送（server push）</code>，同SPDY一样，HTTP2.0也具有server push功能。</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h3><span id=\"http-http缓存机制\">HTTP----HTTP缓存机制</span></h3>\n<h4><span id=\"强缓存\">强缓存</span></h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，state code 为 200</p>\n<pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre><code>Cache-control: max-age=30\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4><span id=\"协商缓存\">协商缓存</span></h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<blockquote>\n<ol>\n<li>Last-Modified 和 If-Modified-Since</li>\n</ol>\n</blockquote>\n<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。</p>\n<blockquote>\n<ol start=\"2\">\n<li>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</li>\n</ol>\n</blockquote>\n<h4><span id=\"选择合适的缓存策略\">选择合适的缓存策略</span></h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg\" alt></p>\n<h4>经典五层模型</h4>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png\" alt></p>\n<ol>\n<li>物理层主要作用是定义物理设备如何传输数据</li>\n<li>数据链路层在通信的实体间建立数据链路连接</li>\n<li>网络层为数据在结点之间传输创建逻辑链路</li>\n<li>传输层（TCP，UDP…）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。</li>\n<li>应用层（HTTP，FTP…）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。</li>\n</ol>\n<blockquote>\n<ol>\n<li>从输入 URL 到页面加载完成的过程</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP</p>\n</li>\n<li>\n<p>协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</p>\n</li>\n<li>\n<p>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</p>\n</li>\n<li>\n<p>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</p>\n</li>\n<li>\n<p>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</p>\n</li>\n<li>\n<p>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML</p>\n</li>\n<li>\n<p>解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</p>\n</li>\n<li>\n<p>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</p>\n</li>\n<li>\n<p>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</p>\n</li>\n<li>\n<p>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"2\">\n<li>DNS</li>\n</ol>\n</blockquote>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg\" alt></p>\n<p>1. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。</p>\n<blockquote>\n<ol start=\"3\">\n<li>HTTPS与HTTP的一些区别</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li>\n<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li>\n<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>\n<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li>\n</ul>\n<blockquote>\n<ol start=\"4\">\n<li>HTTP1.x与HTTP2.0的区别</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>新的二进制格式</code>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li><code>MultiPlexing）</code>，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>\n<li><code>header压缩</code>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>\n<li><code>服务端推送（server push）</code>，同SPDY一样，HTTP2.0也具有server push功能。</li>\n</ul>\n<blockquote>\n<ol start=\"5\">\n<li>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</li>\n</ol>\n</blockquote>\n<ul>\n<li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h3>HTTP----HTTP缓存机制</h3>\n<h4>强缓存</h4>\n<p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，state code 为 200</p>\n<pre><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT\n</code></pre>\n<p><code>Expires</code> 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>\n<pre><code>Cache-control: max-age=30\n</code></pre>\n<p><code>Cache-Control</code> 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>\n<h4>协商缓存</h4>\n<p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>\n<blockquote>\n<ol>\n<li>Last-Modified 和 If-Modified-Since</li>\n</ol>\n</blockquote>\n<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。</p>\n<blockquote>\n<ol start=\"2\">\n<li>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</li>\n</ol>\n</blockquote>\n<h4>选择合适的缓存策略</h4>\n<p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p>\n<ul>\n<li>对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存</li>\n<li>对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li>\n<li>对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li>\n</ul>\n"},{"title":"前端面试系列-JavaScript 数组","catalog":true,"url":"156.html","id":"156","date":"2019-02-26T04:45:15.000Z","subtitle":null,"header-img":null,"_content":"\n#### 一. 如何对一个多维数组进行扁平化\n\n首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组\n\n    const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n    \n\n> 1.  利用递归思想来解决\n\n    let tempArr = [];\n    function flattenArrFirst(array){\n    array.map(item=>{\n        if(Array.isArray(item)){\n            tempArr.concat(flattenArrFirst(item));\n        }else{\n            tempArr.push(item);\n        }\n    });\n    return tempArr;\n    }\n    \n    console.log(flattenArrFirst(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 2.  利用toString()方法和split方法\n\n    function flattenArrSecond(array){\n        let arrStr = array.toString().split(',');\n    \n        return arrStr.map(item=>Number(item));\n    }\n    console.log(flattenArrSecond(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 3.  第三种 利用ES6语法\n\n    function flattenArrThird(array){\n        while(array.some(item => Array.isArray(item))){\n          array = [].concat(...array);\n        }\n        return array;\n    }\n    console.log(flattenArrThird(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 4.  利用数组reduce方法（高端操作，哈哈 ^_^~）\n\n    function flattenFour(array){\n       return array.reduce((result,item)=>{\n           return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n       },[])\n    }\n    console.log(flattenFour(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 5.  利用join方法和split 方法\n\n    function flattenArrFive(array){\n        return arr.join(\",\").split(\",\").map(item => Number(item))\n    }\n    \n    console.log(flattenArrFive(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n#### 二. 如何对一个数组去重\n\n假如现在有数组:\n\n    const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n    \n\n> 1.第一种利用循环遍历\n\n    function uniqueFirst(arr){\n        let tempArr = [];\n        for (let i = 0; i < arr.length; i++) {\n          if(tempArr.indexOf(arr[i]) == -1){\n              tempArr.push(arr[i]);\n          }\n        }\n        return tempArr;\n    }\n    console.log(uniqueFirst(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 2.第二种排序相邻去重法\n\n    function uniqueSecond(arr){\n        arr.sort();\n        let tempArr = [arr[0]];\n        for(let i = 1; i < arr.length; i++){\n           if(tempArr[tempArr.length-1] !== arr[i]){\n               tempArr.push(arr[i])\n           }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSecond(arr));\n    // 打印结果：\n    // [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 3.第三种利用ES6 Set\n\n    var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\n    function uniqueThird(arr){\n        return Array.from(new Set(arr));\n    }\n    console.log(uniqueThird(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 4.第四种利用reduce\n\n    function uniqueFour(array) {\n        return array.reduce((a,b)=>{\n            a.indexOf(b) == -1 ? false : a.push(b);\n            return a\n        },[])\n    }\n    console.log(uniqueFour(arr));\n    // 打印结果：\n    //[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 5.第五种利用filter和includes方法\n\n    function uniqueFive(array){\n        let tempArr = [];\n       tempArr = array.filter(item=>{\n          return tempArr.includes(item)? false : tempArr.push(item)\n       });\n       return tempArr;\n    }\n    console.log(uniqueFive(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 6.第六种 对象键值对法\n\n    function uniqueSix(array){\n        let obj = {};\n        let tempArr = [];\n        for(let i =0;i<array.length;i++){\n            if(!obj[array[i]]){\n               tempArr.push(array[i]);\n               obj[arr[i]] = arr[i];\n            }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSix(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 7.  面试官追问题：如何对一个对象数组按照规定的字段去重\n\n    var usersArr = [\n        { name: \"name1\", age: \"1\" },\n        { name: \"name2\", age: \"11\" },\n        { name: \"name7\", age: \"11\" },\n        { name: \"name3\", age: \"12\" },\n        { name: \"name4\", age: \"13\" },\n        { name: \"name2\", age: \"1\" },\n        { name: \"name6\", age: \"12\" }\n    ]\n    \n    function uniqueByFields(array,fields){\n       let hash = {}\n       return array.reduce((arr,item)=>{\n           hash[item[fields]] ? \"\" : hash[item[fields]] = true && arr.push(item);\n           return arr\n       },[])\n    }\n    \n    console.log(uniqueByFields(usersArr, \"age\"));\n    // 打印结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name4', age: '13' } ]\n    \n\n> 8.  面试时关联题目：如何对对象数组按照特定字段进行排序\n\n    function sortByFileds(arr,fields){\n        return arr.sort((a,b)=>{\n            return a[fields] - b[fields];\n        });\n    }\n    console.log(sortByFileds(usersArr, \"age\"));\n    // 输出结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name7', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name6', age: '12' },\n      { name: 'name4', age: '13' } ]","source":"_posts/前端面试系列-JavaScript 数组.md","raw":"---\ntitle: 前端面试系列-JavaScript 数组\ncatalog: true\ntags:\n  - ES6\n  - Frontend Interview\n  - javascript\nurl: 156.html\nid: 156\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:45:15\nsubtitle:\nheader-img:\n---\n\n#### 一. 如何对一个多维数组进行扁平化\n\n首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组\n\n    const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n    \n\n> 1.  利用递归思想来解决\n\n    let tempArr = [];\n    function flattenArrFirst(array){\n    array.map(item=>{\n        if(Array.isArray(item)){\n            tempArr.concat(flattenArrFirst(item));\n        }else{\n            tempArr.push(item);\n        }\n    });\n    return tempArr;\n    }\n    \n    console.log(flattenArrFirst(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 2.  利用toString()方法和split方法\n\n    function flattenArrSecond(array){\n        let arrStr = array.toString().split(',');\n    \n        return arrStr.map(item=>Number(item));\n    }\n    console.log(flattenArrSecond(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 3.  第三种 利用ES6语法\n\n    function flattenArrThird(array){\n        while(array.some(item => Array.isArray(item))){\n          array = [].concat(...array);\n        }\n        return array;\n    }\n    console.log(flattenArrThird(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 4.  利用数组reduce方法（高端操作，哈哈 ^_^~）\n\n    function flattenFour(array){\n       return array.reduce((result,item)=>{\n           return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n       },[])\n    }\n    console.log(flattenFour(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n> 5.  利用join方法和split 方法\n\n    function flattenArrFive(array){\n        return arr.join(\",\").split(\",\").map(item => Number(item))\n    }\n    \n    console.log(flattenArrFive(arr));\n    // 打印结果:\n    // [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n    \n\n#### 二. 如何对一个数组去重\n\n假如现在有数组:\n\n    const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n    \n\n> 1.第一种利用循环遍历\n\n    function uniqueFirst(arr){\n        let tempArr = [];\n        for (let i = 0; i < arr.length; i++) {\n          if(tempArr.indexOf(arr[i]) == -1){\n              tempArr.push(arr[i]);\n          }\n        }\n        return tempArr;\n    }\n    console.log(uniqueFirst(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 2.第二种排序相邻去重法\n\n    function uniqueSecond(arr){\n        arr.sort();\n        let tempArr = [arr[0]];\n        for(let i = 1; i < arr.length; i++){\n           if(tempArr[tempArr.length-1] !== arr[i]){\n               tempArr.push(arr[i])\n           }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSecond(arr));\n    // 打印结果：\n    // [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 3.第三种利用ES6 Set\n\n    var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\n    function uniqueThird(arr){\n        return Array.from(new Set(arr));\n    }\n    console.log(uniqueThird(arr));\n    // 打印结果：\n    // [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 4.第四种利用reduce\n\n    function uniqueFour(array) {\n        return array.reduce((a,b)=>{\n            a.indexOf(b) == -1 ? false : a.push(b);\n            return a\n        },[])\n    }\n    console.log(uniqueFour(arr));\n    // 打印结果：\n    //[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n    \n\n> 5.第五种利用filter和includes方法\n\n    function uniqueFive(array){\n        let tempArr = [];\n       tempArr = array.filter(item=>{\n          return tempArr.includes(item)? false : tempArr.push(item)\n       });\n       return tempArr;\n    }\n    console.log(uniqueFive(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 6.第六种 对象键值对法\n\n    function uniqueSix(array){\n        let obj = {};\n        let tempArr = [];\n        for(let i =0;i<array.length;i++){\n            if(!obj[array[i]]){\n               tempArr.push(array[i]);\n               obj[arr[i]] = arr[i];\n            }\n        }\n        return tempArr;\n    }\n    console.log(uniqueSix(arr));\n    // 打印结果：\n    [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n    \n\n> 7.  面试官追问题：如何对一个对象数组按照规定的字段去重\n\n    var usersArr = [\n        { name: \"name1\", age: \"1\" },\n        { name: \"name2\", age: \"11\" },\n        { name: \"name7\", age: \"11\" },\n        { name: \"name3\", age: \"12\" },\n        { name: \"name4\", age: \"13\" },\n        { name: \"name2\", age: \"1\" },\n        { name: \"name6\", age: \"12\" }\n    ]\n    \n    function uniqueByFields(array,fields){\n       let hash = {}\n       return array.reduce((arr,item)=>{\n           hash[item[fields]] ? \"\" : hash[item[fields]] = true && arr.push(item);\n           return arr\n       },[])\n    }\n    \n    console.log(uniqueByFields(usersArr, \"age\"));\n    // 打印结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name4', age: '13' } ]\n    \n\n> 8.  面试时关联题目：如何对对象数组按照特定字段进行排序\n\n    function sortByFileds(arr,fields){\n        return arr.sort((a,b)=>{\n            return a[fields] - b[fields];\n        });\n    }\n    console.log(sortByFileds(usersArr, \"age\"));\n    // 输出结果：\n    [ { name: 'name1', age: '1' },\n      { name: 'name2', age: '1' },\n      { name: 'name2', age: '11' },\n      { name: 'name7', age: '11' },\n      { name: 'name3', age: '12' },\n      { name: 'name6', age: '12' },\n      { name: 'name4', age: '13' } ]","slug":"前端面试系列-JavaScript 数组","published":1,"updated":"2019-08-05T09:32:00.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4ay001ja0s6ypg6axqw","content":"<h4><span id=\"一-如何对一个多维数组进行扁平化\">一. 如何对一个多维数组进行扁平化</span></h4>\n<p>首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组</p>\n<pre><code>const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n</code></pre>\n<blockquote>\n<ol>\n<li>利用递归思想来解决</li>\n</ol>\n</blockquote>\n<pre><code>let tempArr = [];\nfunction flattenArrFirst(array){\narray.map(item=&gt;{\n    if(Array.isArray(item)){\n        tempArr.concat(flattenArrFirst(item));\n    }else{\n        tempArr.push(item);\n    }\n});\nreturn tempArr;\n}\n\nconsole.log(flattenArrFirst(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>利用toString()方法和split方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrSecond(array){\n    let arrStr = array.toString().split(',');\n\n    return arrStr.map(item=&gt;Number(item));\n}\nconsole.log(flattenArrSecond(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>第三种 利用ES6语法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrThird(array){\n    while(array.some(item =&gt; Array.isArray(item))){\n      array = [].concat(...array);\n    }\n    return array;\n}\nconsole.log(flattenArrThird(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>利用数组reduce方法（高端操作，哈哈 ^_^~）</li>\n</ol>\n</blockquote>\n<pre><code>function flattenFour(array){\n   return array.reduce((result,item)=&gt;{\n       return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n   },[])\n}\nconsole.log(flattenFour(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>利用join方法和split 方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrFive(array){\n    return arr.join(&quot;,&quot;).split(&quot;,&quot;).map(item =&gt; Number(item))\n}\n\nconsole.log(flattenArrFive(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<h4><span id=\"二-如何对一个数组去重\">二. 如何对一个数组去重</span></h4>\n<p>假如现在有数组:</p>\n<pre><code>const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n</code></pre>\n<blockquote>\n<p>1.第一种利用循环遍历</p>\n</blockquote>\n<pre><code>function uniqueFirst(arr){\n    let tempArr = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n      if(tempArr.indexOf(arr[i]) == -1){\n          tempArr.push(arr[i]);\n      }\n    }\n    return tempArr;\n}\nconsole.log(uniqueFirst(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>2.第二种排序相邻去重法</p>\n</blockquote>\n<pre><code>function uniqueSecond(arr){\n    arr.sort();\n    let tempArr = [arr[0]];\n    for(let i = 1; i &lt; arr.length; i++){\n       if(tempArr[tempArr.length-1] !== arr[i]){\n           tempArr.push(arr[i])\n       }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSecond(arr));\n// 打印结果：\n// [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>3.第三种利用ES6 Set</p>\n</blockquote>\n<pre><code>var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\nfunction uniqueThird(arr){\n    return Array.from(new Set(arr));\n}\nconsole.log(uniqueThird(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>4.第四种利用reduce</p>\n</blockquote>\n<pre><code>function uniqueFour(array) {\n    return array.reduce((a,b)=&gt;{\n        a.indexOf(b) == -1 ? false : a.push(b);\n        return a\n    },[])\n}\nconsole.log(uniqueFour(arr));\n// 打印结果：\n//[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>5.第五种利用filter和includes方法</p>\n</blockquote>\n<pre><code>function uniqueFive(array){\n    let tempArr = [];\n   tempArr = array.filter(item=&gt;{\n      return tempArr.includes(item)? false : tempArr.push(item)\n   });\n   return tempArr;\n}\nconsole.log(uniqueFive(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>6.第六种 对象键值对法</p>\n</blockquote>\n<pre><code>function uniqueSix(array){\n    let obj = {};\n    let tempArr = [];\n    for(let i =0;i&lt;array.length;i++){\n        if(!obj[array[i]]){\n           tempArr.push(array[i]);\n           obj[arr[i]] = arr[i];\n        }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSix(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<ol start=\"7\">\n<li>面试官追问题：如何对一个对象数组按照规定的字段去重</li>\n</ol>\n</blockquote>\n<pre><code>var usersArr = [\n    { name: &quot;name1&quot;, age: &quot;1&quot; },\n    { name: &quot;name2&quot;, age: &quot;11&quot; },\n    { name: &quot;name7&quot;, age: &quot;11&quot; },\n    { name: &quot;name3&quot;, age: &quot;12&quot; },\n    { name: &quot;name4&quot;, age: &quot;13&quot; },\n    { name: &quot;name2&quot;, age: &quot;1&quot; },\n    { name: &quot;name6&quot;, age: &quot;12&quot; }\n]\n\nfunction uniqueByFields(array,fields){\n   let hash = {}\n   return array.reduce((arr,item)=&gt;{\n       hash[item[fields]] ? &quot;&quot; : hash[item[fields]] = true &amp;&amp; arr.push(item);\n       return arr\n   },[])\n}\n\nconsole.log(uniqueByFields(usersArr, &quot;age&quot;));\n// 打印结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name4', age: '13' } ]\n</code></pre>\n<blockquote>\n<ol start=\"8\">\n<li>面试时关联题目：如何对对象数组按照特定字段进行排序</li>\n</ol>\n</blockquote>\n<pre><code>function sortByFileds(arr,fields){\n    return arr.sort((a,b)=&gt;{\n        return a[fields] - b[fields];\n    });\n}\nconsole.log(sortByFileds(usersArr, &quot;age&quot;));\n// 输出结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name7', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name6', age: '12' },\n  { name: 'name4', age: '13' } ]</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4>一. 如何对一个多维数组进行扁平化</h4>\n<p>首先需要对数组进行降维，有很多种解决方案 假设我们现在有一个高维数组</p>\n<pre><code>const arr = [1,2,[2,323,434,[2323,[2322,5646],23],255]];\n</code></pre>\n<blockquote>\n<ol>\n<li>利用递归思想来解决</li>\n</ol>\n</blockquote>\n<pre><code>let tempArr = [];\nfunction flattenArrFirst(array){\narray.map(item=&gt;{\n    if(Array.isArray(item)){\n        tempArr.concat(flattenArrFirst(item));\n    }else{\n        tempArr.push(item);\n    }\n});\nreturn tempArr;\n}\n\nconsole.log(flattenArrFirst(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>利用toString()方法和split方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrSecond(array){\n    let arrStr = array.toString().split(',');\n\n    return arrStr.map(item=&gt;Number(item));\n}\nconsole.log(flattenArrSecond(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>第三种 利用ES6语法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrThird(array){\n    while(array.some(item =&gt; Array.isArray(item))){\n      array = [].concat(...array);\n    }\n    return array;\n}\nconsole.log(flattenArrThird(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>利用数组reduce方法（高端操作，哈哈 ^_^~）</li>\n</ol>\n</blockquote>\n<pre><code>function flattenFour(array){\n   return array.reduce((result,item)=&gt;{\n       return result.concat(Array.isArray(item) ? flattenFour(item) : item)\n   },[])\n}\nconsole.log(flattenFour(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>利用join方法和split 方法</li>\n</ol>\n</blockquote>\n<pre><code>function flattenArrFive(array){\n    return arr.join(&quot;,&quot;).split(&quot;,&quot;).map(item =&gt; Number(item))\n}\n\nconsole.log(flattenArrFive(arr));\n// 打印结果:\n// [ 1, 2, 2, 323, 434, 2323, 2322, 5646, 23, 255 ]\n</code></pre>\n<h4>二. 如何对一个数组去重</h4>\n<p>假如现在有数组:</p>\n<pre><code>const arr = [2,243,44,36,2645,22,2,53,2323,6454,42,32];\n</code></pre>\n<blockquote>\n<p>1.第一种利用循环遍历</p>\n</blockquote>\n<pre><code>function uniqueFirst(arr){\n    let tempArr = [];\n    for (let i = 0; i &lt; arr.length; i++) {\n      if(tempArr.indexOf(arr[i]) == -1){\n          tempArr.push(arr[i]);\n      }\n    }\n    return tempArr;\n}\nconsole.log(uniqueFirst(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>2.第二种排序相邻去重法</p>\n</blockquote>\n<pre><code>function uniqueSecond(arr){\n    arr.sort();\n    let tempArr = [arr[0]];\n    for(let i = 1; i &lt; arr.length; i++){\n       if(tempArr[tempArr.length-1] !== arr[i]){\n           tempArr.push(arr[i])\n       }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSecond(arr));\n// 打印结果：\n// [ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>3.第三种利用ES6 Set</p>\n</blockquote>\n<pre><code>var arr = [2, 2, 2, 243, 44, 36, 2645, 22, 2, 53, 2323, 6454, 42, 32, 2, 2, 2];\nfunction uniqueThird(arr){\n    return Array.from(new Set(arr));\n}\nconsole.log(uniqueThird(arr));\n// 打印结果：\n// [ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>4.第四种利用reduce</p>\n</blockquote>\n<pre><code>function uniqueFour(array) {\n    return array.reduce((a,b)=&gt;{\n        a.indexOf(b) == -1 ? false : a.push(b);\n        return a\n    },[])\n}\nconsole.log(uniqueFour(arr));\n// 打印结果：\n//[ 2, 22, 2323, 243, 2645, 32, 36, 42, 44, 53, 6454 ]\n</code></pre>\n<blockquote>\n<p>5.第五种利用filter和includes方法</p>\n</blockquote>\n<pre><code>function uniqueFive(array){\n    let tempArr = [];\n   tempArr = array.filter(item=&gt;{\n      return tempArr.includes(item)? false : tempArr.push(item)\n   });\n   return tempArr;\n}\nconsole.log(uniqueFive(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<p>6.第六种 对象键值对法</p>\n</blockquote>\n<pre><code>function uniqueSix(array){\n    let obj = {};\n    let tempArr = [];\n    for(let i =0;i&lt;array.length;i++){\n        if(!obj[array[i]]){\n           tempArr.push(array[i]);\n           obj[arr[i]] = arr[i];\n        }\n    }\n    return tempArr;\n}\nconsole.log(uniqueSix(arr));\n// 打印结果：\n[ 2, 243, 44, 36, 2645, 22, 53, 2323, 6454, 42, 32 ]\n</code></pre>\n<blockquote>\n<ol start=\"7\">\n<li>面试官追问题：如何对一个对象数组按照规定的字段去重</li>\n</ol>\n</blockquote>\n<pre><code>var usersArr = [\n    { name: &quot;name1&quot;, age: &quot;1&quot; },\n    { name: &quot;name2&quot;, age: &quot;11&quot; },\n    { name: &quot;name7&quot;, age: &quot;11&quot; },\n    { name: &quot;name3&quot;, age: &quot;12&quot; },\n    { name: &quot;name4&quot;, age: &quot;13&quot; },\n    { name: &quot;name2&quot;, age: &quot;1&quot; },\n    { name: &quot;name6&quot;, age: &quot;12&quot; }\n]\n\nfunction uniqueByFields(array,fields){\n   let hash = {}\n   return array.reduce((arr,item)=&gt;{\n       hash[item[fields]] ? &quot;&quot; : hash[item[fields]] = true &amp;&amp; arr.push(item);\n       return arr\n   },[])\n}\n\nconsole.log(uniqueByFields(usersArr, &quot;age&quot;));\n// 打印结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name4', age: '13' } ]\n</code></pre>\n<blockquote>\n<ol start=\"8\">\n<li>面试时关联题目：如何对对象数组按照特定字段进行排序</li>\n</ol>\n</blockquote>\n<pre><code>function sortByFileds(arr,fields){\n    return arr.sort((a,b)=&gt;{\n        return a[fields] - b[fields];\n    });\n}\nconsole.log(sortByFileds(usersArr, &quot;age&quot;));\n// 输出结果：\n[ { name: 'name1', age: '1' },\n  { name: 'name2', age: '1' },\n  { name: 'name2', age: '11' },\n  { name: 'name7', age: '11' },\n  { name: 'name3', age: '12' },\n  { name: 'name6', age: '12' },\n  { name: 'name4', age: '13' } ]</code></pre>\n"},{"title":"前端面试系列-JavaScript中的this指向问题","catalog":true,"url":"150.html","id":"150","date":"2019-02-26T04:39:33.000Z","subtitle":null,"header-img":null,"_content":"\n谁调用它他就指向谁，箭头函数没有this\n\n> 1.  new 的过程中发生了什么\n\n1.  首先创建一个新的对象\n2.  链接到原型\n3.  绑定this\n4.  返回新的对象\n\n代码实现：\n\n    function create() {\n      let obj = {};\n      let Constructor = [].shift.call(arguments);\n      obj.__proto__ = Constructor.prototype\n      let result = Constructor.apply(obj, arguments);\n      return typeof result === 'object' ? result : obj\n    }\n    \n\n> 2.  怎么实现bind, call, apply 手动实现一下\n> 3.  如果不传入参数默认是window\n> 4.  改变this的指向，让新的对象执行该函数\n> 5.  先给新的对象添加一个该函数，然后执行，执行后删除\n\n代码模拟实现Call：\n\n    Function.prototype.myCall = function (context) {\n      var context = context || window;\n      context.fn = this;\n      let args = [...arguments].slice(1);\n      let result = context.fn(...args);\n      delete context.fn;\n      return result;\n    }\n    \n\n代码模拟实现Apply：\n\n    Function.prototype.myApply = function (context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn\n      return result;\n    }\n    \n\n代码模拟实现Bind：\n\n    Function.prototype.myBind = function (context) {\n      if (typeof this != 'object') {\n        throw new TypeError('type error');\n      }\n      var self = this;\n      var args = [...arguments].slice(1);\n      return function Fn() {\n        if (typeof this instanceof Fn) {\n          return new self(...args, ...arguments);\n        } else {\n          return self.apply(context, args.concat(...arguments));\n        }\n      }\n    }\n    \n    \n\n> 3.instanceof 原理是什么？手动实现一下\n\n    function instanceOf(left, right) {\n      let prototype = right.prototype;\n      let left = left.__proto__\n      while (true) {\n        if (left == null) return false\n        if (left == prototype) return true\n        left = left.__proto__\n      }\n    }","source":"_posts/前端面试系列-JavaScript中的this指向问题.md","raw":"---\ntitle: 前端面试系列-JavaScript中的this指向问题\ncatalog: true\ntags:\n  - Frontend Interview\n  - html\n  - javascript\nurl: 150.html\nid: 150\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:39:33\nsubtitle:\nheader-img:\n---\n\n谁调用它他就指向谁，箭头函数没有this\n\n> 1.  new 的过程中发生了什么\n\n1.  首先创建一个新的对象\n2.  链接到原型\n3.  绑定this\n4.  返回新的对象\n\n代码实现：\n\n    function create() {\n      let obj = {};\n      let Constructor = [].shift.call(arguments);\n      obj.__proto__ = Constructor.prototype\n      let result = Constructor.apply(obj, arguments);\n      return typeof result === 'object' ? result : obj\n    }\n    \n\n> 2.  怎么实现bind, call, apply 手动实现一下\n> 3.  如果不传入参数默认是window\n> 4.  改变this的指向，让新的对象执行该函数\n> 5.  先给新的对象添加一个该函数，然后执行，执行后删除\n\n代码模拟实现Call：\n\n    Function.prototype.myCall = function (context) {\n      var context = context || window;\n      context.fn = this;\n      let args = [...arguments].slice(1);\n      let result = context.fn(...args);\n      delete context.fn;\n      return result;\n    }\n    \n\n代码模拟实现Apply：\n\n    Function.prototype.myApply = function (context) {\n      var context = context || window;\n      context.fn = this;\n      var result;\n      if (arguments[1]) {\n        result = context.fn(...arguments[1]);\n      } else {\n        result = context.fn();\n      }\n      delete context.fn\n      return result;\n    }\n    \n\n代码模拟实现Bind：\n\n    Function.prototype.myBind = function (context) {\n      if (typeof this != 'object') {\n        throw new TypeError('type error');\n      }\n      var self = this;\n      var args = [...arguments].slice(1);\n      return function Fn() {\n        if (typeof this instanceof Fn) {\n          return new self(...args, ...arguments);\n        } else {\n          return self.apply(context, args.concat(...arguments));\n        }\n      }\n    }\n    \n    \n\n> 3.instanceof 原理是什么？手动实现一下\n\n    function instanceOf(left, right) {\n      let prototype = right.prototype;\n      let left = left.__proto__\n      while (true) {\n        if (left == null) return false\n        if (left == prototype) return true\n        left = left.__proto__\n      }\n    }","slug":"前端面试系列-JavaScript中的this指向问题","published":1,"updated":"2019-08-05T09:32:00.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4az001ma0s6h6cgu6vy","content":"<p>谁调用它他就指向谁，箭头函数没有this</p>\n<blockquote>\n<ol>\n<li>new 的过程中发生了什么</li>\n</ol>\n</blockquote>\n<ol>\n<li>首先创建一个新的对象</li>\n<li>链接到原型</li>\n<li>绑定this</li>\n<li>返回新的对象</li>\n</ol>\n<p>代码实现：</p>\n<pre><code>function create() {\n  let obj = {};\n  let Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments);\n  return typeof result === 'object' ? result : obj\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>怎么实现bind, call, apply 手动实现一下</li>\n<li>如果不传入参数默认是window</li>\n<li>改变this的指向，让新的对象执行该函数</li>\n<li>先给新的对象添加一个该函数，然后执行，执行后删除</li>\n</ol>\n</blockquote>\n<p>代码模拟实现Call：</p>\n<pre><code>Function.prototype.myCall = function (context) {\n  var context = context || window;\n  context.fn = this;\n  let args = [...arguments].slice(1);\n  let result = context.fn(...args);\n  delete context.fn;\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Apply：</p>\n<pre><code>Function.prototype.myApply = function (context) {\n  var context = context || window;\n  context.fn = this;\n  var result;\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Bind：</p>\n<pre><code>Function.prototype.myBind = function (context) {\n  if (typeof this != 'object') {\n    throw new TypeError('type error');\n  }\n  var self = this;\n  var args = [...arguments].slice(1);\n  return function Fn() {\n    if (typeof this instanceof Fn) {\n      return new self(...args, ...arguments);\n    } else {\n      return self.apply(context, args.concat(...arguments));\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>3.instanceof 原理是什么？手动实现一下</p>\n</blockquote>\n<pre><code>function instanceOf(left, right) {\n  let prototype = right.prototype;\n  let left = left.__proto__\n  while (true) {\n    if (left == null) return false\n    if (left == prototype) return true\n    left = left.__proto__\n  }\n}</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>谁调用它他就指向谁，箭头函数没有this</p>\n<blockquote>\n<ol>\n<li>new 的过程中发生了什么</li>\n</ol>\n</blockquote>\n<ol>\n<li>首先创建一个新的对象</li>\n<li>链接到原型</li>\n<li>绑定this</li>\n<li>返回新的对象</li>\n</ol>\n<p>代码实现：</p>\n<pre><code>function create() {\n  let obj = {};\n  let Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype\n  let result = Constructor.apply(obj, arguments);\n  return typeof result === 'object' ? result : obj\n}\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>怎么实现bind, call, apply 手动实现一下</li>\n<li>如果不传入参数默认是window</li>\n<li>改变this的指向，让新的对象执行该函数</li>\n<li>先给新的对象添加一个该函数，然后执行，执行后删除</li>\n</ol>\n</blockquote>\n<p>代码模拟实现Call：</p>\n<pre><code>Function.prototype.myCall = function (context) {\n  var context = context || window;\n  context.fn = this;\n  let args = [...arguments].slice(1);\n  let result = context.fn(...args);\n  delete context.fn;\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Apply：</p>\n<pre><code>Function.prototype.myApply = function (context) {\n  var context = context || window;\n  context.fn = this;\n  var result;\n  if (arguments[1]) {\n    result = context.fn(...arguments[1]);\n  } else {\n    result = context.fn();\n  }\n  delete context.fn\n  return result;\n}\n</code></pre>\n<p>代码模拟实现Bind：</p>\n<pre><code>Function.prototype.myBind = function (context) {\n  if (typeof this != 'object') {\n    throw new TypeError('type error');\n  }\n  var self = this;\n  var args = [...arguments].slice(1);\n  return function Fn() {\n    if (typeof this instanceof Fn) {\n      return new self(...args, ...arguments);\n    } else {\n      return self.apply(context, args.concat(...arguments));\n    }\n  }\n}\n</code></pre>\n<blockquote>\n<p>3.instanceof 原理是什么？手动实现一下</p>\n</blockquote>\n<pre><code>function instanceOf(left, right) {\n  let prototype = right.prototype;\n  let left = left.__proto__\n  while (true) {\n    if (left == null) return false\n    if (left == prototype) return true\n    left = left.__proto__\n  }\n}</code></pre>\n"},{"title":"前端面试系列-前端跨域常用的几种方式","catalog":true,"url":"143.html","id":"143","date":"2019-02-26T04:32:55.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。\n\n封装JOSNP\n\n    function jsonp(url,callback,success){\n        var scprit = document.createElement('script');\n        script.src=url;\n        script.async = true;\n        script.type = 'text/javascript';\n        window[callback] = function(data){\n            success && success(data)\n        }\n        document.body.appendChild(script);\n    }\n    // 调用\n    jsonp('http://xvideo.com',callback,function(data){\n        console.log(data);\n    })\n    \n\n> 2.  CORS 推荐 我最常用的手段之一\n\n1.  CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。\n    \n2.  浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n    \n3.  服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n    \n\n> 3.  `document.domain` 可以思考思考如何做单点登录和cookie跨域\n\n1.  该方式只能用于`二级域名相同`的情况下，比如 `a.test.com` 和 \\`\\`\\`b.test.com\\`\\` 适用于该方式。\n    \n2.  只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域\n    \n\n> 4.PostMessage\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n    // 发送消息端\n    window.parent.postMessage('message', 'http://test.com');\n    // 接收消息端\n    var mc = new MessageChannel();\n    mc.addEventListener('message', event => {\n        var origin = event.origin || event.originalEvent.origin\n        if (origin === 'http://test.com') {\n            console.log('验证通过')\n        }\n    })\n    \n\n##### 还有更多种跨域，比如window.name等等","source":"_posts/前端面试系列-前端跨域常用的几种方式.md","raw":"---\ntitle: 前端面试系列-前端跨域常用的几种方式\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 143.html\nid: 143\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:32:55\nsubtitle:\nheader-img:\n---\n\n> 1.  JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。\n\n封装JOSNP\n\n    function jsonp(url,callback,success){\n        var scprit = document.createElement('script');\n        script.src=url;\n        script.async = true;\n        script.type = 'text/javascript';\n        window[callback] = function(data){\n            success && success(data)\n        }\n        document.body.appendChild(script);\n    }\n    // 调用\n    jsonp('http://xvideo.com',callback,function(data){\n        console.log(data);\n    })\n    \n\n> 2.  CORS 推荐 我最常用的手段之一\n\n1.  CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。\n    \n2.  浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。\n    \n3.  服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n    \n\n> 3.  `document.domain` 可以思考思考如何做单点登录和cookie跨域\n\n1.  该方式只能用于`二级域名相同`的情况下，比如 `a.test.com` 和 \\`\\`\\`b.test.com\\`\\` 适用于该方式。\n    \n2.  只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域\n    \n\n> 4.PostMessage\n\n这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n\n    // 发送消息端\n    window.parent.postMessage('message', 'http://test.com');\n    // 接收消息端\n    var mc = new MessageChannel();\n    mc.addEventListener('message', event => {\n        var origin = event.origin || event.originalEvent.origin\n        if (origin === 'http://test.com') {\n            console.log('验证通过')\n        }\n    })\n    \n\n##### 还有更多种跨域，比如window.name等等","slug":"前端面试系列-前端跨域常用的几种方式","published":1,"updated":"2019-08-05T09:32:00.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4b2001qa0s6iomgl8wl","content":"<blockquote>\n<ol>\n<li>JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。</li>\n</ol>\n</blockquote>\n<p>封装JOSNP</p>\n<pre><code>function jsonp(url,callback,success){\n    var scprit = document.createElement('script');\n    script.src=url;\n    script.async = true;\n    script.type = 'text/javascript';\n    window[callback] = function(data){\n        success &amp;&amp; success(data)\n    }\n    document.body.appendChild(script);\n}\n// 调用\njsonp('http://xvideo.com',callback,function(data){\n    console.log(data);\n})\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>CORS 推荐 我最常用的手段之一</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>\n</li>\n<li>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n</li>\n<li>\n<p>服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li><code>document.domain</code> 可以思考思考如何做单点登录和cookie跨域</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>该方式只能用于<code>二级域名相同</code>的情况下，比如 <code>a.test.com</code> 和 ```b.test.com`` 适用于该方式。</p>\n</li>\n<li>\n<p>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</p>\n</li>\n</ol>\n<blockquote>\n<p>4.PostMessage</p>\n</blockquote>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<pre><code>// 发送消息端\nwindow.parent.postMessage('message', 'http://test.com');\n// 接收消息端\nvar mc = new MessageChannel();\nmc.addEventListener('message', event =&gt; {\n    var origin = event.origin || event.originalEvent.origin\n    if (origin === 'http://test.com') {\n        console.log('验证通过')\n    }\n})\n</code></pre>\n<h5><span id=\"还有更多种跨域比如windowname等等\">还有更多种跨域，比如window.name等等</span></h5>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>JSONP JSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过 script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。我反正不常用。</li>\n</ol>\n</blockquote>\n<p>封装JOSNP</p>\n<pre><code>function jsonp(url,callback,success){\n    var scprit = document.createElement('script');\n    script.src=url;\n    script.async = true;\n    script.type = 'text/javascript';\n    window[callback] = function(data){\n        success &amp;&amp; success(data)\n    }\n    document.body.appendChild(script);\n}\n// 调用\njsonp('http://xvideo.com',callback,function(data){\n    console.log(data);\n})\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>CORS 推荐 我最常用的手段之一</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>\n</li>\n<li>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>\n</li>\n<li>\n<p>服务端设置 Access - Control - Allow - Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>\n</li>\n</ol>\n<blockquote>\n<ol start=\"3\">\n<li><code>document.domain</code> 可以思考思考如何做单点登录和cookie跨域</li>\n</ol>\n</blockquote>\n<ol>\n<li>\n<p>该方式只能用于<code>二级域名相同</code>的情况下，比如 <code>a.test.com</code> 和 ```b.test.com`` 适用于该方式。</p>\n</li>\n<li>\n<p>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</p>\n</li>\n</ol>\n<blockquote>\n<p>4.PostMessage</p>\n</blockquote>\n<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>\n<pre><code>// 发送消息端\nwindow.parent.postMessage('message', 'http://test.com');\n// 接收消息端\nvar mc = new MessageChannel();\nmc.addEventListener('message', event =&gt; {\n    var origin = event.origin || event.originalEvent.origin\n    if (origin === 'http://test.com') {\n        console.log('验证通过')\n    }\n})\n</code></pre>\n<h5>还有更多种跨域，比如window.name等等</h5>\n"},{"title":"前端面试系列-游览器中的事件","catalog":true,"url":"147.html","id":"147","date":"2019-02-26T04:36:25.000Z","subtitle":null,"header-img":null,"_content":"\n> 1.  事件触发的过程\n> \n> \\- `window` 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）\n\n*   传播到事件处发处注册事件会触发\n    \n*   从事件触发处往window传播，遇见注册的事件冒泡会触发\n    \n*   事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n    \n\n    // 以下会先打印冒泡然后是捕获\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('冒泡')\n      },\n      false\n    )\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('捕获 ')\n      },\n      true\n    )\n    \n\n> 2.  事件代理\n\n    <ul id=\"ul\">\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n    </ul>\n    <script>\n      let ul = document.querySelector('#ul')\n      ul.addEventListener('click', event => {\n        console.log(event.target)\n      })\n    </script>\n    \n\n> 3.自定义事件\n\n1.  第一种利用customEvent\n\n    let customEvent = new CustomEvent(\"customEventName\", {\n        detail:{\n            data: \"hello customEvent\"\n        }\n    });\n    \n    // 分派事件对象\n    document.dispatchEvent(customEvent);\n    // 监听事件\n    document.addEventListener('customEventName', (e)=>{\n        console.log(e.detail.data); // \"hello customEvent\"\n    });\n    \n\n2.  第二种利用createEvent\n\n    // 创建事件对象\n    let customCreateEvent = new createEvent('customEventName');\n    // 初始化事件对象\n    customCreateEvent.initCustomEvent(\"ev\", false, true, {data: \"hello createEvent\"});\n    // 分派事件\n    document.dispatchEvent(customCreateEvent);\n    // 监听事件\n    document.addEventListener('ev',e=>{\n        console.log(e.detail.data) // \"hello createEvent\"\n    });","source":"_posts/前端面试系列-游览器中的事件.md","raw":"---\ntitle: 前端面试系列-游览器中的事件\ncatalog: true\ntags:\n  - Frontend Interview\nurl: 147.html\nid: 147\ncategories:\n  - 前端面试\ndate: 2019-02-26 12:36:25\nsubtitle:\nheader-img:\n---\n\n> 1.  事件触发的过程\n> \n> \\- `window` 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）\n\n*   传播到事件处发处注册事件会触发\n    \n*   从事件触发处往window传播，遇见注册的事件冒泡会触发\n    \n*   事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。\n    \n\n    // 以下会先打印冒泡然后是捕获\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('冒泡')\n      },\n      false\n    )\n    node.addEventListener(\n      'click',\n      event => {\n        console.log('捕获 ')\n      },\n      true\n    )\n    \n\n> 2.  事件代理\n\n    <ul id=\"ul\">\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n    </ul>\n    <script>\n      let ul = document.querySelector('#ul')\n      ul.addEventListener('click', event => {\n        console.log(event.target)\n      })\n    </script>\n    \n\n> 3.自定义事件\n\n1.  第一种利用customEvent\n\n    let customEvent = new CustomEvent(\"customEventName\", {\n        detail:{\n            data: \"hello customEvent\"\n        }\n    });\n    \n    // 分派事件对象\n    document.dispatchEvent(customEvent);\n    // 监听事件\n    document.addEventListener('customEventName', (e)=>{\n        console.log(e.detail.data); // \"hello customEvent\"\n    });\n    \n\n2.  第二种利用createEvent\n\n    // 创建事件对象\n    let customCreateEvent = new createEvent('customEventName');\n    // 初始化事件对象\n    customCreateEvent.initCustomEvent(\"ev\", false, true, {data: \"hello createEvent\"});\n    // 分派事件\n    document.dispatchEvent(customCreateEvent);\n    // 监听事件\n    document.addEventListener('ev',e=>{\n        console.log(e.detail.data) // \"hello createEvent\"\n    });","slug":"前端面试系列-游览器中的事件","published":1,"updated":"2019-08-05T09:32:00.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4b3001ta0s6p2uwcp40","content":"<blockquote>\n<ol>\n<li>事件触发的过程</li>\n</ol>\n<p>- <code>window</code> 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）</p>\n</blockquote>\n<ul>\n<li>\n<p>传播到事件处发处注册事件会触发</p>\n</li>\n<li>\n<p>从事件触发处往window传播，遇见注册的事件冒泡会触发</p>\n</li>\n<li>\n<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>\n</li>\n</ul>\n<pre><code>// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('捕获 ')\n  },\n  true\n)\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>事件代理</li>\n</ol>\n</blockquote>\n<pre><code>&lt;ul id=&quot;ul&quot;&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  &lt;li&gt;4&lt;/li&gt;\n  &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n  let ul = document.querySelector('#ul')\n  ul.addEventListener('click', event =&gt; {\n    console.log(event.target)\n  })\n&lt;/script&gt;\n</code></pre>\n<blockquote>\n<p>3.自定义事件</p>\n</blockquote>\n<ol>\n<li>\n<p>第一种利用customEvent</p>\n<p>let customEvent = new CustomEvent(“customEventName”, {<br>\ndetail:{<br>\ndata: “hello customEvent”<br>\n}<br>\n});</p>\n<p>// 分派事件对象<br>\ndocument.dispatchEvent(customEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘customEventName’, (e)=&gt;{<br>\nconsole.log(e.detail.data); // “hello customEvent”<br>\n});</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>第二种利用createEvent</p>\n<p>// 创建事件对象<br>\nlet customCreateEvent = new createEvent(‘customEventName’);<br>\n// 初始化事件对象<br>\ncustomCreateEvent.initCustomEvent(“ev”, false, true, {data: “hello createEvent”});<br>\n// 分派事件<br>\ndocument.dispatchEvent(customCreateEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘ev’,e=&gt;{<br>\nconsole.log(e.detail.data) // “hello createEvent”<br>\n});</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>事件触发的过程</li>\n</ol>\n<p>- <code>window</code> 往事件触发处传播，遇到注册的事件捕获 （这一个过程称作事件的捕获）</p>\n</blockquote>\n<ul>\n<li>\n<p>传播到事件处发处注册事件会触发</p>\n</li>\n<li>\n<p>从事件触发处往window传播，遇见注册的事件冒泡会触发</p>\n</li>\n<li>\n<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>\n</li>\n</ul>\n<pre><code>// 以下会先打印冒泡然后是捕获\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('冒泡')\n  },\n  false\n)\nnode.addEventListener(\n  'click',\n  event =&gt; {\n    console.log('捕获 ')\n  },\n  true\n)\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>事件代理</li>\n</ol>\n</blockquote>\n<pre><code>&lt;ul id=&quot;ul&quot;&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n  &lt;li&gt;3&lt;/li&gt;\n  &lt;li&gt;4&lt;/li&gt;\n  &lt;li&gt;5&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n  let ul = document.querySelector('#ul')\n  ul.addEventListener('click', event =&gt; {\n    console.log(event.target)\n  })\n&lt;/script&gt;\n</code></pre>\n<blockquote>\n<p>3.自定义事件</p>\n</blockquote>\n<ol>\n<li>\n<p>第一种利用customEvent</p>\n<p>let customEvent = new CustomEvent(“customEventName”, {<br>\ndetail:{<br>\ndata: “hello customEvent”<br>\n}<br>\n});</p>\n<p>// 分派事件对象<br>\ndocument.dispatchEvent(customEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘customEventName’, (e)=&gt;{<br>\nconsole.log(e.detail.data); // “hello customEvent”<br>\n});</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>\n<p>第二种利用createEvent</p>\n<p>// 创建事件对象<br>\nlet customCreateEvent = new createEvent(‘customEventName’);<br>\n// 初始化事件对象<br>\ncustomCreateEvent.initCustomEvent(“ev”, false, true, {data: “hello createEvent”});<br>\n// 分派事件<br>\ndocument.dispatchEvent(customCreateEvent);<br>\n// 监听事件<br>\ndocument.addEventListener(‘ev’,e=&gt;{<br>\nconsole.log(e.detail.data) // “hello createEvent”<br>\n});</p>\n</li>\n</ol>\n"},{"title":"如何在Vue SPA中集成GraphQL","catalog":true,"url":"101.html","id":"101","date":"2019-02-20T10:50:50.000Z","subtitle":null,"header-img":null,"_content":"\n![](https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67)\n\n> 1.  为了快速搭建，首先我们安装vue-cli@3.x\n\n     sudo npm install -g @vue/cli\n     yarn global add @vue/cli\n    \n\n> 2.  我们快速搭建一个Vue-SPA项目\n\n      mkdir learn_vue_with_graphql\n      cd learn_vue_with_graphql\n      vue create vue-ssr-graphql\n      # 按照你自己的需求选择插件\n      # 安装完毕后，进入vue-ssr-graphql目录\n      cd vue-ssr-graphql\n    \n\n> 3.  安装关于在vue中使用graphQL的一些包\n\n    npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n或者\n\n    yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n> 4.  在项目`src` 目录下创建`apolloClient.js`文件\n\n    import { ApolloClient } from 'apollo-client';\n    import { HttpLink } from 'apollo-link-http';\n    import { InMemoryCache } from 'apollo-cache-inmemory';\n    \n    const httpLink = new HttpLink({\n      uri: 'http://localhost:3000/graphql'\n    });\n    \n    const cache = new InMemoryCache();\n    // 导出 ApolloClient graphQL客户端\n    export default new ApolloClient({\n      link: httpLink,\n      cache\n    });\n    \n\n> 5.  修改`main.js`安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）\n\n    import Vue from 'vue'\n    import App from './App.vue'\n    import router from './router'\n    import store from './store'\n    import apolloClient from './apolloClient'\n    import './registerServiceWorker'\n    import VueApollo from 'vue-apollo';\n    \n    Vue.config.productionTip = false\n    \n    const apolloProvider = new VueApollo({\n      defaultClient: apolloClient\n    })\n    Vue.use(VueApollo);\n    new Vue({\n      router,\n      store,\n      apolloProvider,\n      render: h => h(App)\n    }).$mount('#app')\n    \n    \n\n> 6.在组件中使用（需要配合graphQL服务端）\n\n服务端源码地址：[github](https://github.com/maliaoMJ/graphql-api-server)\n\n1.  首先打开`views`目录下的`Home.vue` 文件\n\n在vue文件的JS部分做如下修改\n\n    <script>\n    // @ is an alias to /src\n    import gql from \"graphql-tag\";\n    export default {\n      name: \"home\",\n      computed: {\n        loading() {\n          return this.$apollo.loading;\n        }\n      },\n      data() {\n        return {\n          hello: \"\"\n        };\n      },\n      mounted() {\n        console.log(this.$apollo.loading, this.$apollo.data);\n      },\n      apollo: {\n        hello: {\n          query: gql`\n            query getUserInfo($id: Int!) {\n              hello\n              userInfo(id: $id) {\n                name\n                age\n                gender\n                id\n              }\n            }\n          `,\n          variables: {\n            id: 10001\n          }\n        }\n      }\n    };\n    </script>\n    \n    \n\n2.  运行项目\n\n运行如下命令\n\n    yarn run serve\n    \n\n然后打开游览器访问`localhost:8080`可以看到如下结果\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16-1.png)\n\n##### 最后附上源代码文件地址 [github](https://github.com/maliaoMJ/vue-graphQL-template)","source":"_posts/如何在Vue SPA中集成GraphQL.md","raw":"---\ntitle: 如何在Vue SPA中集成GraphQL\ncatalog: true\ntags:\n  - graphql\n  - nodejs\n  - vuejs\nurl: 101.html\nid: 101\ncategories:\n  - GraphQL\ndate: 2019-02-20 18:50:50\nsubtitle:\nheader-img:\n---\n\n![](https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67)\n\n> 1.  为了快速搭建，首先我们安装vue-cli@3.x\n\n     sudo npm install -g @vue/cli\n     yarn global add @vue/cli\n    \n\n> 2.  我们快速搭建一个Vue-SPA项目\n\n      mkdir learn_vue_with_graphql\n      cd learn_vue_with_graphql\n      vue create vue-ssr-graphql\n      # 按照你自己的需求选择插件\n      # 安装完毕后，进入vue-ssr-graphql目录\n      cd vue-ssr-graphql\n    \n\n> 3.  安装关于在vue中使用graphQL的一些包\n\n    npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n或者\n\n    yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n    \n\n> 4.  在项目`src` 目录下创建`apolloClient.js`文件\n\n    import { ApolloClient } from 'apollo-client';\n    import { HttpLink } from 'apollo-link-http';\n    import { InMemoryCache } from 'apollo-cache-inmemory';\n    \n    const httpLink = new HttpLink({\n      uri: 'http://localhost:3000/graphql'\n    });\n    \n    const cache = new InMemoryCache();\n    // 导出 ApolloClient graphQL客户端\n    export default new ApolloClient({\n      link: httpLink,\n      cache\n    });\n    \n\n> 5.  修改`main.js`安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）\n\n    import Vue from 'vue'\n    import App from './App.vue'\n    import router from './router'\n    import store from './store'\n    import apolloClient from './apolloClient'\n    import './registerServiceWorker'\n    import VueApollo from 'vue-apollo';\n    \n    Vue.config.productionTip = false\n    \n    const apolloProvider = new VueApollo({\n      defaultClient: apolloClient\n    })\n    Vue.use(VueApollo);\n    new Vue({\n      router,\n      store,\n      apolloProvider,\n      render: h => h(App)\n    }).$mount('#app')\n    \n    \n\n> 6.在组件中使用（需要配合graphQL服务端）\n\n服务端源码地址：[github](https://github.com/maliaoMJ/graphql-api-server)\n\n1.  首先打开`views`目录下的`Home.vue` 文件\n\n在vue文件的JS部分做如下修改\n\n    <script>\n    // @ is an alias to /src\n    import gql from \"graphql-tag\";\n    export default {\n      name: \"home\",\n      computed: {\n        loading() {\n          return this.$apollo.loading;\n        }\n      },\n      data() {\n        return {\n          hello: \"\"\n        };\n      },\n      mounted() {\n        console.log(this.$apollo.loading, this.$apollo.data);\n      },\n      apollo: {\n        hello: {\n          query: gql`\n            query getUserInfo($id: Int!) {\n              hello\n              userInfo(id: $id) {\n                name\n                age\n                gender\n                id\n              }\n            }\n          `,\n          variables: {\n            id: 10001\n          }\n        }\n      }\n    };\n    </script>\n    \n    \n\n2.  运行项目\n\n运行如下命令\n\n    yarn run serve\n    \n\n然后打开游览器访问`localhost:8080`可以看到如下结果\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/16-1.png)\n\n##### 最后附上源代码文件地址 [github](https://github.com/maliaoMJ/vue-graphQL-template)","slug":"如何在Vue SPA中集成GraphQL","published":1,"updated":"2019-08-05T09:32:00.518Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4b6001wa0s6rqokf6gb","content":"<p><img src=\"https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67\" alt></p>\n<blockquote>\n<ol>\n<li>为了快速搭建，首先我们安装vue-cli@3.x</li>\n</ol>\n</blockquote>\n<pre><code> sudo npm install -g @vue/cli\n yarn global add @vue/cli\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>我们快速搭建一个Vue-SPA项目</li>\n</ol>\n</blockquote>\n<pre><code>  mkdir learn_vue_with_graphql\n  cd learn_vue_with_graphql\n  vue create vue-ssr-graphql\n  # 按照你自己的需求选择插件\n  # 安装完毕后，进入vue-ssr-graphql目录\n  cd vue-ssr-graphql\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>安装关于在vue中使用graphQL的一些包</li>\n</ol>\n</blockquote>\n<pre><code>npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<p>或者</p>\n<pre><code>yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>在项目<code>src</code> 目录下创建<code>apolloClient.js</code>文件</li>\n</ol>\n</blockquote>\n<pre><code>import { ApolloClient } from 'apollo-client';\nimport { HttpLink } from 'apollo-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:3000/graphql'\n});\n\nconst cache = new InMemoryCache();\n// 导出 ApolloClient graphQL客户端\nexport default new ApolloClient({\n  link: httpLink,\n  cache\n});\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>修改<code>main.js</code>安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）</li>\n</ol>\n</blockquote>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nimport apolloClient from './apolloClient'\nimport './registerServiceWorker'\nimport VueApollo from 'vue-apollo';\n\nVue.config.productionTip = false\n\nconst apolloProvider = new VueApollo({\n  defaultClient: apolloClient\n})\nVue.use(VueApollo);\nnew Vue({\n  router,\n  store,\n  apolloProvider,\n  render: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<blockquote>\n<p>6.在组件中使用（需要配合graphQL服务端）</p>\n</blockquote>\n<p>服务端源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ol>\n<li>首先打开<code>views</code>目录下的<code>Home.vue</code> 文件</li>\n</ol>\n<p>在vue文件的JS部分做如下修改</p>\n<pre><code>&lt;script&gt;\n// @ is an alias to /src\nimport gql from &quot;graphql-tag&quot;;\nexport default {\n  name: &quot;home&quot;,\n  computed: {\n    loading() {\n      return this.$apollo.loading;\n    }\n  },\n  data() {\n    return {\n      hello: &quot;&quot;\n    };\n  },\n  mounted() {\n    console.log(this.$apollo.loading, this.$apollo.data);\n  },\n  apollo: {\n    hello: {\n      query: gql`\n        query getUserInfo($id: Int!) {\n          hello\n          userInfo(id: $id) {\n            name\n            age\n            gender\n            id\n          }\n        }\n      `,\n      variables: {\n        id: 10001\n      }\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>运行项目</li>\n</ol>\n<p>运行如下命令</p>\n<pre><code>yarn run serve\n</code></pre>\n<p>然后打开游览器访问<code>localhost:8080</code>可以看到如下结果</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16-1.png\" alt></p>\n<h5><span id=\"最后附上源代码文件地址-github\">最后附上源代码文件地址 </span></h5>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://camo.githubusercontent.com/e78e52aa36ff76ef5e142bfeced3b5f657b3fc26/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a483941414e6f6f664c716a53313058643554775259772e706e67\" alt></p>\n<blockquote>\n<ol>\n<li>为了快速搭建，首先我们安装vue-cli@3.x</li>\n</ol>\n</blockquote>\n<pre><code> sudo npm install -g @vue/cli\n yarn global add @vue/cli\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li>我们快速搭建一个Vue-SPA项目</li>\n</ol>\n</blockquote>\n<pre><code>  mkdir learn_vue_with_graphql\n  cd learn_vue_with_graphql\n  vue create vue-ssr-graphql\n  # 按照你自己的需求选择插件\n  # 安装完毕后，进入vue-ssr-graphql目录\n  cd vue-ssr-graphql\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li>安装关于在vue中使用graphQL的一些包</li>\n</ol>\n</blockquote>\n<pre><code>npm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<p>或者</p>\n<pre><code>yarn add vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li>在项目<code>src</code> 目录下创建<code>apolloClient.js</code>文件</li>\n</ol>\n</blockquote>\n<pre><code>import { ApolloClient } from 'apollo-client';\nimport { HttpLink } from 'apollo-link-http';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\nconst httpLink = new HttpLink({\n  uri: 'http://localhost:3000/graphql'\n});\n\nconst cache = new InMemoryCache();\n// 导出 ApolloClient graphQL客户端\nexport default new ApolloClient({\n  link: httpLink,\n  cache\n});\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li>修改<code>main.js</code>安装插件到Vue和Apollo provider（Provider 保存了可以在接下来被所有子组件使用的 Apollo 客户端实例。）</li>\n</ol>\n</blockquote>\n<pre><code>import Vue from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport store from './store'\nimport apolloClient from './apolloClient'\nimport './registerServiceWorker'\nimport VueApollo from 'vue-apollo';\n\nVue.config.productionTip = false\n\nconst apolloProvider = new VueApollo({\n  defaultClient: apolloClient\n})\nVue.use(VueApollo);\nnew Vue({\n  router,\n  store,\n  apolloProvider,\n  render: h =&gt; h(App)\n}).$mount('#app')\n</code></pre>\n<blockquote>\n<p>6.在组件中使用（需要配合graphQL服务端）</p>\n</blockquote>\n<p>服务端源码地址：<a href=\"https://github.com/maliaoMJ/graphql-api-server\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<ol>\n<li>首先打开<code>views</code>目录下的<code>Home.vue</code> 文件</li>\n</ol>\n<p>在vue文件的JS部分做如下修改</p>\n<pre><code>&lt;script&gt;\n// @ is an alias to /src\nimport gql from &quot;graphql-tag&quot;;\nexport default {\n  name: &quot;home&quot;,\n  computed: {\n    loading() {\n      return this.$apollo.loading;\n    }\n  },\n  data() {\n    return {\n      hello: &quot;&quot;\n    };\n  },\n  mounted() {\n    console.log(this.$apollo.loading, this.$apollo.data);\n  },\n  apollo: {\n    hello: {\n      query: gql`\n        query getUserInfo($id: Int!) {\n          hello\n          userInfo(id: $id) {\n            name\n            age\n            gender\n            id\n          }\n        }\n      `,\n      variables: {\n        id: 10001\n      }\n    }\n  }\n};\n&lt;/script&gt;\n</code></pre>\n<ol start=\"2\">\n<li>运行项目</li>\n</ol>\n<p>运行如下命令</p>\n<pre><code>yarn run serve\n</code></pre>\n<p>然后打开游览器访问<code>localhost:8080</code>可以看到如下结果</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/16-1.png\" alt></p>\n<h5>最后附上源代码文件地址 <a href=\"https://github.com/maliaoMJ/vue-graphQL-template\" target=\"_blank\" rel=\"noopener\">github</a></h5>\n"},{"title":"前端面试系列-JavaScript继承","catalog":true,"url":"178.html","id":"178","date":"2019-03-05T15:12:36.000Z","subtitle":null,"header-img":null,"_content":"\n![](http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg)\n\n### Javascript 继承\n\n#### 1\\. 通过构造函数实现继承\n\n    function Parent(){\n        this.parent = 'parent'\n        this.getWho = function(){\n            return 'getWho:'+this.parent\n        }\n    }\n    Parent.prototype.sayWho = function(){\n       console.log(`prototype from ${this.parent}`);\n        return `prototype from ${this.parent}`\n    }\n    \n    function Child(){\n        Parent.call(this);\n        this.child = \"child\"\n    }\n    \n    let children = new Child();\n    \n    console.log(children.child);// child\n    console.log(children.getWho());// getWho:parent\n    console.log(children.parent); // parent\n    console.log(children.sayWho()); // TypeError: children.sayWho is not a function\n    \n    \n\n这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。\n\n#### 2\\. 借助原型链实现继承\n\n    function Parent1(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n        this.lookList=function(){\n            return this.list\n        }\n    }\n    Parent1.prototype.getList=function(){\n        return this.list\n    }\n    function Child1(){\n        this.child = 'child'\n    }\n    Child1.prototype = new Parent1();\n    \n    let s1 = new Child1();\n    let s2 = new Child1();\n    console.log(s1.list); // [ 1, 2, 3 ]\n    s1.list.push(4)\n    console.log(s2.list); // [ 1, 2, 3, 4 ]\n    console.log(s1.lookList()); // [ 1, 2, 3, 4 ]\n    console.log(s1.getList()); // [ 1, 2, 3, 4 ]\n    \n\n通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); <=> Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.pro 和 s2.pro指向同一个地址即 父类的 prototype\n\n#### 3\\. 组合式继承\n\n    function Parent2(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n    }\n    Parent2.prototype.getList = function(){\n        return this.list\n    }\n    function Child2(){\n        Parent2.call(this)\n        this.child = 'child';\n    }\n    Child2.prototype = new Parent2();\n    \n    let s3 = new Child2();\n    let s4 = new Child2();\n    \n    console.log(s3.getList());// [ 1, 2, 3 ]\n    console.log(s4.list);//[ 1, 2, 3]\n    s3.list.push(4);\n    console.log(s3.list); // [ 1, 2, 3, 4 ]\n    \n\n将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。\n\n#### 4\\. 寄生组合继承\n\n    function Parent3() {\n        this.parent = 'parent3'\n        this.list = [1, 2, 3]\n    }\n    Parent3.prototype.getList = function () {\n        return this.list\n    }\n    function Child3() {\n        Parent3.call(this)\n        this.child = 'child';\n    }\n    Child3.prototype =Object.create(Parent3.prototype); //重点\n    Child3.prototype.constructor = Child3;// 重点\n    let s5 = new Child3();\n    let s6 = new Child3();\n    \n    console.log(s5.getList());// [ 1, 2, 3 ]\n    s5.list.push(4);\n    console.log(s5.list); // [ 1, 2, 3, 4 ]\n    console.log(s6.list);//[ 1, 2, 3]\n    \n\n这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor","source":"_posts/前端面试系列-JavaScript继承.md","raw":"---\ntitle: 前端面试系列-JavaScript继承\ncatalog: true\ntags:\n  - javascript\nurl: 178.html\nid: 178\ncategories:\n  - JavaScript\ndate: 2019-03-05 23:12:36\nsubtitle:\nheader-img:\n---\n\n![](http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg)\n\n### Javascript 继承\n\n#### 1\\. 通过构造函数实现继承\n\n    function Parent(){\n        this.parent = 'parent'\n        this.getWho = function(){\n            return 'getWho:'+this.parent\n        }\n    }\n    Parent.prototype.sayWho = function(){\n       console.log(`prototype from ${this.parent}`);\n        return `prototype from ${this.parent}`\n    }\n    \n    function Child(){\n        Parent.call(this);\n        this.child = \"child\"\n    }\n    \n    let children = new Child();\n    \n    console.log(children.child);// child\n    console.log(children.getWho());// getWho:parent\n    console.log(children.parent); // parent\n    console.log(children.sayWho()); // TypeError: children.sayWho is not a function\n    \n    \n\n这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。\n\n#### 2\\. 借助原型链实现继承\n\n    function Parent1(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n        this.lookList=function(){\n            return this.list\n        }\n    }\n    Parent1.prototype.getList=function(){\n        return this.list\n    }\n    function Child1(){\n        this.child = 'child'\n    }\n    Child1.prototype = new Parent1();\n    \n    let s1 = new Child1();\n    let s2 = new Child1();\n    console.log(s1.list); // [ 1, 2, 3 ]\n    s1.list.push(4)\n    console.log(s2.list); // [ 1, 2, 3, 4 ]\n    console.log(s1.lookList()); // [ 1, 2, 3, 4 ]\n    console.log(s1.getList()); // [ 1, 2, 3, 4 ]\n    \n\n通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); <=> Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.pro 和 s2.pro指向同一个地址即 父类的 prototype\n\n#### 3\\. 组合式继承\n\n    function Parent2(){\n        this.parent = 'parent'\n        this.list = [1,2,3]\n    }\n    Parent2.prototype.getList = function(){\n        return this.list\n    }\n    function Child2(){\n        Parent2.call(this)\n        this.child = 'child';\n    }\n    Child2.prototype = new Parent2();\n    \n    let s3 = new Child2();\n    let s4 = new Child2();\n    \n    console.log(s3.getList());// [ 1, 2, 3 ]\n    console.log(s4.list);//[ 1, 2, 3]\n    s3.list.push(4);\n    console.log(s3.list); // [ 1, 2, 3, 4 ]\n    \n\n将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。\n\n#### 4\\. 寄生组合继承\n\n    function Parent3() {\n        this.parent = 'parent3'\n        this.list = [1, 2, 3]\n    }\n    Parent3.prototype.getList = function () {\n        return this.list\n    }\n    function Child3() {\n        Parent3.call(this)\n        this.child = 'child';\n    }\n    Child3.prototype =Object.create(Parent3.prototype); //重点\n    Child3.prototype.constructor = Child3;// 重点\n    let s5 = new Child3();\n    let s6 = new Child3();\n    \n    console.log(s5.getList());// [ 1, 2, 3 ]\n    s5.list.push(4);\n    console.log(s5.list); // [ 1, 2, 3, 4 ]\n    console.log(s6.list);//[ 1, 2, 3]\n    \n\n这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor","slug":"前端面试系列-JavaScript继承","published":1,"updated":"2019-08-05T09:32:00.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4b7001xa0s6s0ss561x","content":"<p><img src=\"http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg\" alt></p>\n<h3><span id=\"javascript-继承\">Javascript 继承</span></h3>\n<h4><span id=\"1-通过构造函数实现继承\">1. 通过构造函数实现继承</span></h4>\n<pre><code>function Parent(){\n    this.parent = 'parent'\n    this.getWho = function(){\n        return 'getWho:'+this.parent\n    }\n}\nParent.prototype.sayWho = function(){\n   console.log(`prototype from ${this.parent}`);\n    return `prototype from ${this.parent}`\n}\n\nfunction Child(){\n    Parent.call(this);\n    this.child = &quot;child&quot;\n}\n\nlet children = new Child();\n\nconsole.log(children.child);// child\nconsole.log(children.getWho());// getWho:parent\nconsole.log(children.parent); // parent\nconsole.log(children.sayWho()); // TypeError: children.sayWho is not a function\n</code></pre>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4><span id=\"2-借助原型链实现继承\">2. 借助原型链实现继承</span></h4>\n<pre><code>function Parent1(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n    this.lookList=function(){\n        return this.list\n    }\n}\nParent1.prototype.getList=function(){\n    return this.list\n}\nfunction Child1(){\n    this.child = 'child'\n}\nChild1.prototype = new Parent1();\n\nlet s1 = new Child1();\nlet s2 = new Child1();\nconsole.log(s1.list); // [ 1, 2, 3 ]\ns1.list.push(4)\nconsole.log(s2.list); // [ 1, 2, 3, 4 ]\nconsole.log(s1.lookList()); // [ 1, 2, 3, 4 ]\nconsole.log(s1.getList()); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); &lt;=&gt; Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 <a href=\"http://s1.pro\" target=\"_blank\" rel=\"noopener\">s1.pro</a> 和 s2.pro指向同一个地址即 父类的 prototype</p>\n<h4><span id=\"3-组合式继承\">3. 组合式继承</span></h4>\n<pre><code>function Parent2(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n}\nParent2.prototype.getList = function(){\n    return this.list\n}\nfunction Child2(){\n    Parent2.call(this)\n    this.child = 'child';\n}\nChild2.prototype = new Parent2();\n\nlet s3 = new Child2();\nlet s4 = new Child2();\n\nconsole.log(s3.getList());// [ 1, 2, 3 ]\nconsole.log(s4.list);//[ 1, 2, 3]\ns3.list.push(4);\nconsole.log(s3.list); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。</p>\n<h4><span id=\"4-寄生组合继承\">4. 寄生组合继承</span></h4>\n<pre><code>function Parent3() {\n    this.parent = 'parent3'\n    this.list = [1, 2, 3]\n}\nParent3.prototype.getList = function () {\n    return this.list\n}\nfunction Child3() {\n    Parent3.call(this)\n    this.child = 'child';\n}\nChild3.prototype =Object.create(Parent3.prototype); //重点\nChild3.prototype.constructor = Child3;// 重点\nlet s5 = new Child3();\nlet s6 = new Child3();\n\nconsole.log(s5.getList());// [ 1, 2, 3 ]\ns5.list.push(4);\nconsole.log(s5.list); // [ 1, 2, 3, 4 ]\nconsole.log(s6.list);//[ 1, 2, 3]\n</code></pre>\n<p>这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://www.hnaccp.com/uploads/allimg/170928/0U3021263-5.jpg\" alt></p>\n<h3>Javascript 继承</h3>\n<h4>1. 通过构造函数实现继承</h4>\n<pre><code>function Parent(){\n    this.parent = 'parent'\n    this.getWho = function(){\n        return 'getWho:'+this.parent\n    }\n}\nParent.prototype.sayWho = function(){\n   console.log(`prototype from ${this.parent}`);\n    return `prototype from ${this.parent}`\n}\n\nfunction Child(){\n    Parent.call(this);\n    this.child = &quot;child&quot;\n}\n\nlet children = new Child();\n\nconsole.log(children.child);// child\nconsole.log(children.getWho());// getWho:parent\nconsole.log(children.parent); // parent\nconsole.log(children.sayWho()); // TypeError: children.sayWho is not a function\n</code></pre>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child。有个缺点，从打印结果看出 Child 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4>2. 借助原型链实现继承</h4>\n<pre><code>function Parent1(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n    this.lookList=function(){\n        return this.list\n    }\n}\nParent1.prototype.getList=function(){\n    return this.list\n}\nfunction Child1(){\n    this.child = 'child'\n}\nChild1.prototype = new Parent1();\n\nlet s1 = new Child1();\nlet s2 = new Child1();\nconsole.log(s1.list); // [ 1, 2, 3 ]\ns1.list.push(4)\nconsole.log(s2.list); // [ 1, 2, 3, 4 ]\nconsole.log(s1.lookList()); // [ 1, 2, 3, 4 ]\nconsole.log(s1.getList()); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.proto = 父亲对象的.prototype,但实际上我们是不能直接 操作proto，这时我们可以借用 new 来做，所以 Child1.prototype = new Parent1(); &lt;=&gt; Child1.prototype.proto = Parent1.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.list 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 <a href=\"http://s1.pro\" target=\"_blank\" rel=\"noopener\">s1.pro</a> 和 s2.pro指向同一个地址即 父类的 prototype</p>\n<h4>3. 组合式继承</h4>\n<pre><code>function Parent2(){\n    this.parent = 'parent'\n    this.list = [1,2,3]\n}\nParent2.prototype.getList = function(){\n    return this.list\n}\nfunction Child2(){\n    Parent2.call(this)\n    this.child = 'child';\n}\nChild2.prototype = new Parent2();\n\nlet s3 = new Child2();\nlet s4 = new Child2();\n\nconsole.log(s3.getList());// [ 1, 2, 3 ]\nconsole.log(s4.list);//[ 1, 2, 3]\ns3.list.push(4);\nconsole.log(s3.list); // [ 1, 2, 3, 4 ]\n</code></pre>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 let s3 = new Child2()对应 Child2.prototype = new Parent2()还要 new 一次。</p>\n<h4>4. 寄生组合继承</h4>\n<pre><code>function Parent3() {\n    this.parent = 'parent3'\n    this.list = [1, 2, 3]\n}\nParent3.prototype.getList = function () {\n    return this.list\n}\nfunction Child3() {\n    Parent3.call(this)\n    this.child = 'child';\n}\nChild3.prototype =Object.create(Parent3.prototype); //重点\nChild3.prototype.constructor = Child3;// 重点\nlet s5 = new Child3();\nlet s6 = new Child3();\n\nconsole.log(s5.getList());// [ 1, 2, 3 ]\ns5.list.push(4);\nconsole.log(s5.list); // [ 1, 2, 3, 4 ]\nconsole.log(s6.list);//[ 1, 2, 3]\n</code></pre>\n<p>这里主要使用Object.create()，它的作用是将对象继承到proto属性上。这时 Child3.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent3.prototype, constructor 还是 Parent3 ,所以要给 Child3.prototype 写自己的 constructor</p>\n"},{"title":"微信小程序开发技术选型分享","catalog":true,"url":"117.html","id":"117","date":"2019-02-21T04:28:11.000Z","subtitle":null,"header-img":null,"_content":"\n微信小程序开发技术分享:anchor:\n===================\n\n![](http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg)\n\n##### 目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。\n\n### 什么是Taro?\n\n多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。\n\n### 为什么要用Taro?\n\n当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.jpg)\n\n### Taro与其它框架进行对比\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png) ![image](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png)\n\n对比分析\n\n微信小程序\n\nmpuve\n\nwepy\n\nTaro\n\n语法规范\n\n小程序规范\n\nVue.js规范\n\n类Vue.js规范\n\nReact规范\n\n模板系统\n\n字符串模板\n\n字符串模板\n\n字符串模板\n\nJSX\n\n类型系统\n\n不支持\n\n业务代码\n\n业务代码\n\n业务代码 \\+ JSX\n\n组件规范\n\n小程序组件\n\nHTML标签+小程序组件\n\n小程序组件\n\n小程序组件\n\n样式规范\n\nwxss\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\n组件化\n\n小程序组件化\n\nVue组件化\n\n自定义组件化\n\nReact组件化\n\n多端复用\n\n复用，不存在的\n\nH5,APP(Weex)等\n\n没看到有介绍\n\nH5,APP(ReactNative)等\n\n自动构建\n\n无\n\nwebpack\n\n内部构建系统\n\nwebpack+内部构建系统\n\n开发要求\n\n全新学习\n\n熟悉Vue语法即可\n\n熟悉Vue+wepy语法\n\n熟悉React语法\n\n数据流管理\n\n无\n\nVuex\n\nRedux\n\nRedux+React-thunk\n\n> 从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。\n\n### Taro框架设计思想 [具体细节请看官网](https://nervjs.github.io/taro/)\n\n> 图片来源于网络 ![image](http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png)\n\n### Taro特性\n\n*   React 语法风格\n*   快速开发微信小程序\n    *   支持使用 npm/yarn 安装管理第三方依赖\n    *   支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置\n    *   支持使用 CSS 预编译器，例如 Sass 等\n    *   支持使用 Redux进行状态管理\n    *   小程序API优化，异步API Promise化等等\n*   支持多端开发转化\n\n> ### 开发配置\n\n*   环境配置\n    *   sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)\n    *   npm init lavectorApp && cd lavctorApp && npm run dev:weapp/h5\n    *   用微信开发者工具添加项目打开dist目录即可\n*   页面设计尺寸配置\n    *   Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改\n    *   Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位\n*   编辑器\n    *   建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网....\n\n> ### 如何引用fontAwesome字体文件\n\n比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 [查看](https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css) 如何使用： \\`\\`\\`javascript import Taro, { Component } from '@tarojs/taro'; import { View, Icon, Image } from '@tarojs/components'; import 'your/path/fontawesome.css' //引用图片 import img from 'your/path/image.png' export default class Icon extends Taro.Component { ...... render(){ <View className='icon_box'> <Icon className='fa fa-home'/> <Image src={img} /> </View> } } \\`\\`\\`\n\n> ### 页面配置\n\n    //是不是跟小程序入口配置文件差不多?\n    config = {\n    // pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n        pages: [\n          'pages/book/book',\n          'pages/detail/detail',\n          'pages/user/user',\n          'pages/index/index'\n        ],\n        window: {\n          backgroundTextStyle: 'light',\n          navigationBarBackgroundColor: '#f55002',\n          navigationBarTitleText: '首页',\n          navigationBarTextStyle: 'light',\n          enablePullDownRefresh: false,\n          onReachBottomDistance: 30,\n          backgroundColor: '#f55002'\n        },\n        tabBar: {\n          backgroundColor: '#eee',\n          selectedColor: '#f55002',\n          color: '#aaa',\n          borderStyle: '#f55002',\n          list: [\n            {\n              pagePath: 'pages/index/index',\n              iconPath: './static/images/home_default.png',\n              selectedIconPath: './static/images/home_selected.png',\n              text: '首页'\n            },\n            {\n              pagePath: 'pages/book/book',\n              iconPath: './static/images/book_default.png',\n              selectedIconPath: './static/images/book_selected.png',\n              text: '书架'\n            },\n            {\n              pagePath: 'pages/user/user',\n              text: '我的',\n              iconPath: './static/images/user_default.png',\n              selectedIconPath: './static/images/user_selected.png'\n            }\n          ]\n        },\n        networkTimeout: {\n          request: 6000,\n          downloadFile: 10000\n        },\n        debug: true\n      };\n    \n    \n\n> ### 消息机制\n> \n> > #### Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~\n\n    import Taro, {Events} from '@tarojs/taro'\n    const events = new Events()\n    // 监听一个事件，接受参数\n    events.on('eventName', (arg) => {\n      // doSth\n    })\n    // 监听同个事件，同时绑定多个handler\n    events.on('eventName', handler1)\n    events.on('eventName', handler2)\n    events.on('eventName', handler3)\n    // 触发一个事件，传参\n    events.trigger('eventName', arg)\n    // 触发事件，传入多个参数\n    events.trigger('eventName', arg1, arg2, ...)\n    // 取消监听一个事件\n    events.off('eventName')\n    // 取消监听一个事件某个handler\n    events.off('eventName', handler1)\n    // 取消监听所有事件\n    events.off()\n    \n\n同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例\n\n    import Taro from '@tarojs/taro'\n    \n    Taro.eventCenter.on\n    Taro.eventCenter.trigger\n    Taro.eventCenter.off\n    \n\n> ### :checkered_flag: 组件和页面的定义\n\n``javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { <!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--> backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ <!--DOM 只能写在render函数中--> const test = `test` return ( <!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--> <View className='lavectorApp' style='background:#fff'> <Text>hello Lavector<Text> <Text>{test}</Text> // Taro中所有的事件都要以On 开头 <Button onClick={this.toOtherPage.bind(this,'params')}>To Other Page</Button> </View> ); } }``\n\n> ### 配合使用Redux\n> \n> > ##### 在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件\n> > \n> > npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger\n\n    // src/store/index.js\n    import { createStore, applyMiddleware } from 'redux'\n    import thunkMiddleware from 'redux-thunk'\n    import { createLogger } from 'redux-logger'\n    import rootReducer from '../reducers'\n    \n    const middlewares = [\n      thunkMiddleware,\n      createLogger()\n    ]\n    \n    export default function configStore () {\n      const store = createStore(rootReducer, applyMiddleware(...middlewares))\n      return store\n    }\n    \n\n入口文件app.js\n\n    // src/app.js\n    import Taro, { Component } from '@tarojs/taro'\n    import { Provider } from '@tarojs/redux'\n    \n    import configStore from './store'\n    import Index from './pages/index'\n    \n    import './app.scss'\n    \n    const store = configStore()\n    \n    class App extends Component {\n      config = {\n        pages: [\n          'pages/index/index'\n        ],\n        window: {\n          navigationBarTitleText: 'Test'\n        }\n      }\n    \n      render() {\n        return (\n          <Provider store={store}>\n            <Index />\n          </Provider>\n        )\n      }\n    }\n    \n    Taro.render(<App />, document.getElementById('app'))\n    \n    \n\n> 然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)\n\n补充 JSX语法支持程度\n============\n\n*   不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）\n*   不能在包含 JSX 元素的 map 循环中使用 if 表达式\n*   不能使用 Array#map 之外的方法操作 JSX 数组\n*   不能在 JSX 参数中使用匿名函数\n*   暂不支持在 render() 之外的方法定义 JSX\n*   不允许在 JSX 参数(props)中传入 JSX 元素\n*   不能在 JSX 参数中使用对象展开符*   不支持无状态组件\n\n### 结束语\n\n无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。\n\n> 以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网[京东Taro](https://nervjs.github.io/taro/)\n\n### 可能你需要学习的：\n\n【Mpvue】(http://mpvue.com/) 【Mpvue资源合集】(https://github.com/mpvue/awesome-mpvue) 【Taro】(https://nervjs.github.io/taro/) 【Vuejs】(https://cn.vuejs.org/) 【Redux】(http://www.redux.org.cn/)","source":"_posts/微信小程序开发技术选型分享.md","raw":"---\ntitle: 微信小程序开发技术选型分享\ncatalog: true\nurl: 117.html\nid: 117\ncategories:\n  - 微信小程序\ndate: 2019-02-21 12:28:11\nsubtitle:\nheader-img:\ntags:\n---\n\n微信小程序开发技术分享:anchor:\n===================\n\n![](http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg)\n\n##### 目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。\n\n### 什么是Taro?\n\n多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。\n\n### 为什么要用Taro?\n\n当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1.jpg)\n\n### Taro与其它框架进行对比\n\n![](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png) ![image](http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png)\n\n对比分析\n\n微信小程序\n\nmpuve\n\nwepy\n\nTaro\n\n语法规范\n\n小程序规范\n\nVue.js规范\n\n类Vue.js规范\n\nReact规范\n\n模板系统\n\n字符串模板\n\n字符串模板\n\n字符串模板\n\nJSX\n\n类型系统\n\n不支持\n\n业务代码\n\n业务代码\n\n业务代码 \\+ JSX\n\n组件规范\n\n小程序组件\n\nHTML标签+小程序组件\n\n小程序组件\n\n小程序组件\n\n样式规范\n\nwxss\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\ncss,less.sass,styus\n\n组件化\n\n小程序组件化\n\nVue组件化\n\n自定义组件化\n\nReact组件化\n\n多端复用\n\n复用，不存在的\n\nH5,APP(Weex)等\n\n没看到有介绍\n\nH5,APP(ReactNative)等\n\n自动构建\n\n无\n\nwebpack\n\n内部构建系统\n\nwebpack+内部构建系统\n\n开发要求\n\n全新学习\n\n熟悉Vue语法即可\n\n熟悉Vue+wepy语法\n\n熟悉React语法\n\n数据流管理\n\n无\n\nVuex\n\nRedux\n\nRedux+React-thunk\n\n> 从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。\n\n### Taro框架设计思想 [具体细节请看官网](https://nervjs.github.io/taro/)\n\n> 图片来源于网络 ![image](http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png)\n\n### Taro特性\n\n*   React 语法风格\n*   快速开发微信小程序\n    *   支持使用 npm/yarn 安装管理第三方依赖\n    *   支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置\n    *   支持使用 CSS 预编译器，例如 Sass 等\n    *   支持使用 Redux进行状态管理\n    *   小程序API优化，异步API Promise化等等\n*   支持多端开发转化\n\n> ### 开发配置\n\n*   环境配置\n    *   sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)\n    *   npm init lavectorApp && cd lavctorApp && npm run dev:weapp/h5\n    *   用微信开发者工具添加项目打开dist目录即可\n*   页面设计尺寸配置\n    *   Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改\n    *   Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位\n*   编辑器\n    *   建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网....\n\n> ### 如何引用fontAwesome字体文件\n\n比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 [查看](https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css) 如何使用： \\`\\`\\`javascript import Taro, { Component } from '@tarojs/taro'; import { View, Icon, Image } from '@tarojs/components'; import 'your/path/fontawesome.css' //引用图片 import img from 'your/path/image.png' export default class Icon extends Taro.Component { ...... render(){ <View className='icon_box'> <Icon className='fa fa-home'/> <Image src={img} /> </View> } } \\`\\`\\`\n\n> ### 页面配置\n\n    //是不是跟小程序入口配置文件差不多?\n    config = {\n    // pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n        pages: [\n          'pages/book/book',\n          'pages/detail/detail',\n          'pages/user/user',\n          'pages/index/index'\n        ],\n        window: {\n          backgroundTextStyle: 'light',\n          navigationBarBackgroundColor: '#f55002',\n          navigationBarTitleText: '首页',\n          navigationBarTextStyle: 'light',\n          enablePullDownRefresh: false,\n          onReachBottomDistance: 30,\n          backgroundColor: '#f55002'\n        },\n        tabBar: {\n          backgroundColor: '#eee',\n          selectedColor: '#f55002',\n          color: '#aaa',\n          borderStyle: '#f55002',\n          list: [\n            {\n              pagePath: 'pages/index/index',\n              iconPath: './static/images/home_default.png',\n              selectedIconPath: './static/images/home_selected.png',\n              text: '首页'\n            },\n            {\n              pagePath: 'pages/book/book',\n              iconPath: './static/images/book_default.png',\n              selectedIconPath: './static/images/book_selected.png',\n              text: '书架'\n            },\n            {\n              pagePath: 'pages/user/user',\n              text: '我的',\n              iconPath: './static/images/user_default.png',\n              selectedIconPath: './static/images/user_selected.png'\n            }\n          ]\n        },\n        networkTimeout: {\n          request: 6000,\n          downloadFile: 10000\n        },\n        debug: true\n      };\n    \n    \n\n> ### 消息机制\n> \n> > #### Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~\n\n    import Taro, {Events} from '@tarojs/taro'\n    const events = new Events()\n    // 监听一个事件，接受参数\n    events.on('eventName', (arg) => {\n      // doSth\n    })\n    // 监听同个事件，同时绑定多个handler\n    events.on('eventName', handler1)\n    events.on('eventName', handler2)\n    events.on('eventName', handler3)\n    // 触发一个事件，传参\n    events.trigger('eventName', arg)\n    // 触发事件，传入多个参数\n    events.trigger('eventName', arg1, arg2, ...)\n    // 取消监听一个事件\n    events.off('eventName')\n    // 取消监听一个事件某个handler\n    events.off('eventName', handler1)\n    // 取消监听所有事件\n    events.off()\n    \n\n同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例\n\n    import Taro from '@tarojs/taro'\n    \n    Taro.eventCenter.on\n    Taro.eventCenter.trigger\n    Taro.eventCenter.off\n    \n\n> ### :checkered_flag: 组件和页面的定义\n\n``javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { <!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--> backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ <!--DOM 只能写在render函数中--> const test = `test` return ( <!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--> <View className='lavectorApp' style='background:#fff'> <Text>hello Lavector<Text> <Text>{test}</Text> // Taro中所有的事件都要以On 开头 <Button onClick={this.toOtherPage.bind(this,'params')}>To Other Page</Button> </View> ); } }``\n\n> ### 配合使用Redux\n> \n> > ##### 在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件\n> > \n> > npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger\n\n    // src/store/index.js\n    import { createStore, applyMiddleware } from 'redux'\n    import thunkMiddleware from 'redux-thunk'\n    import { createLogger } from 'redux-logger'\n    import rootReducer from '../reducers'\n    \n    const middlewares = [\n      thunkMiddleware,\n      createLogger()\n    ]\n    \n    export default function configStore () {\n      const store = createStore(rootReducer, applyMiddleware(...middlewares))\n      return store\n    }\n    \n\n入口文件app.js\n\n    // src/app.js\n    import Taro, { Component } from '@tarojs/taro'\n    import { Provider } from '@tarojs/redux'\n    \n    import configStore from './store'\n    import Index from './pages/index'\n    \n    import './app.scss'\n    \n    const store = configStore()\n    \n    class App extends Component {\n      config = {\n        pages: [\n          'pages/index/index'\n        ],\n        window: {\n          navigationBarTitleText: 'Test'\n        }\n      }\n    \n      render() {\n        return (\n          <Provider store={store}>\n            <Index />\n          </Provider>\n        )\n      }\n    }\n    \n    Taro.render(<App />, document.getElementById('app'))\n    \n    \n\n> 然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)\n\n补充 JSX语法支持程度\n============\n\n*   不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）\n*   不能在包含 JSX 元素的 map 循环中使用 if 表达式\n*   不能使用 Array#map 之外的方法操作 JSX 数组\n*   不能在 JSX 参数中使用匿名函数\n*   暂不支持在 render() 之外的方法定义 JSX\n*   不允许在 JSX 参数(props)中传入 JSX 元素\n*   不能在 JSX 参数中使用对象展开符*   不支持无状态组件\n\n### 结束语\n\n无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。\n\n> 以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网[京东Taro](https://nervjs.github.io/taro/)\n\n### 可能你需要学习的：\n\n【Mpvue】(http://mpvue.com/) 【Mpvue资源合集】(https://github.com/mpvue/awesome-mpvue) 【Taro】(https://nervjs.github.io/taro/) 【Vuejs】(https://cn.vuejs.org/) 【Redux】(http://www.redux.org.cn/)","slug":"微信小程序开发技术选型分享","published":1,"updated":"2019-08-05T09:32:00.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4b90022a0s6vsznw7w6","content":"<h1><span id=\"微信小程序开发技术分享anchor\">微信小程序开发技术分享:anchor:</span></h1>\n<p><img src=\"http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg\" alt></p>\n<h5><span id=\"目前编写微信小程序的技术有如下微信开发者工具自带的一套开发技术基于腾讯的wepy框架美团的mpvue京东的taro这四个开发小程序技术目前是应用最为广泛的-今天最主要介绍的是来自京东凹凸团队的taro框架\">目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。</span></h5>\n<h3><span id=\"什么是taro\">什么是Taro?</span></h3>\n<p>多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。</p>\n<h3><span id=\"为什么要用taro\">为什么要用Taro?</span></h3>\n<p>当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.jpg\" alt></p>\n<h3><span id=\"taro与其它框架进行对比\">Taro与其它框架进行对比</span></h3>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png\" alt=\"image\"></p>\n<p>对比分析</p>\n<p>微信小程序</p>\n<p>mpuve</p>\n<p>wepy</p>\n<p>Taro</p>\n<p>语法规范</p>\n<p>小程序规范</p>\n<p>Vue.js规范</p>\n<p>类Vue.js规范</p>\n<p>React规范</p>\n<p>模板系统</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>JSX</p>\n<p>类型系统</p>\n<p>不支持</p>\n<p>业务代码</p>\n<p>业务代码</p>\n<p>业务代码 + JSX</p>\n<p>组件规范</p>\n<p>小程序组件</p>\n<p>HTML标签+小程序组件</p>\n<p>小程序组件</p>\n<p>小程序组件</p>\n<p>样式规范</p>\n<p>wxss</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>组件化</p>\n<p>小程序组件化</p>\n<p>Vue组件化</p>\n<p>自定义组件化</p>\n<p>React组件化</p>\n<p>多端复用</p>\n<p>复用，不存在的</p>\n<p>H5,APP(Weex)等</p>\n<p>没看到有介绍</p>\n<p>H5,APP(ReactNative)等</p>\n<p>自动构建</p>\n<p>无</p>\n<p>webpack</p>\n<p>内部构建系统</p>\n<p>webpack+内部构建系统</p>\n<p>开发要求</p>\n<p>全新学习</p>\n<p>熟悉Vue语法即可</p>\n<p>熟悉Vue+wepy语法</p>\n<p>熟悉React语法</p>\n<p>数据流管理</p>\n<p>无</p>\n<p>Vuex</p>\n<p>Redux</p>\n<p>Redux+React-thunk</p>\n<blockquote>\n<p>从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。</p>\n</blockquote>\n<h3><span id=\"taro框架设计思想-具体细节请看官网\">Taro框架设计思想 </span></h3>\n<blockquote>\n<p>图片来源于网络 <img src=\"http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png\" alt=\"image\"></p>\n</blockquote>\n<h3><span id=\"taro特性\">Taro特性</span></h3>\n<ul>\n<li>React 语法风格</li>\n<li>快速开发微信小程序\n<ul>\n<li>支持使用 npm/yarn 安装管理第三方依赖</li>\n<li>支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置</li>\n<li>支持使用 CSS 预编译器，例如 Sass 等</li>\n<li>支持使用 Redux进行状态管理</li>\n<li>小程序API优化，异步API Promise化等等</li>\n</ul>\n</li>\n<li>支持多端开发转化</li>\n</ul>\n<blockquote>\n<h3><span id=\"开发配置\">开发配置</span></h3>\n</blockquote>\n<ul>\n<li>环境配置\n<ul>\n<li>sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)</li>\n<li>npm init lavectorApp &amp;&amp; cd lavctorApp &amp;&amp; npm run dev:weapp/h5</li>\n<li>用微信开发者工具添加项目打开dist目录即可</li>\n</ul>\n</li>\n<li>页面设计尺寸配置\n<ul>\n<li>Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改</li>\n<li>Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位</li>\n</ul>\n</li>\n<li>编辑器\n<ul>\n<li>建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网…</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h3><span id=\"如何引用fontawesome字体文件\">如何引用fontAwesome字体文件</span></h3>\n</blockquote>\n<p>比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 <a href=\"https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css\" target=\"_blank\" rel=\"noopener\">查看</a> 如何使用： ```javascript import Taro, { Component } from ‘@tarojs/taro’; import { View, Icon, Image } from ‘@tarojs/components’; import ‘your/path/fontawesome.css’ //引用图片 import img from ‘your/path/image.png’ export default class Icon extends Taro.Component { … render(){ <view classname=\"icon_box\"> <icon classname=\"fa fa-home\"> <image src=\"{img}\"> </image></icon></view> } } ```</p>\n<blockquote>\n<h3><span id=\"页面配置\">页面配置</span></h3>\n</blockquote>\n<pre><code>//是不是跟小程序入口配置文件差不多?\nconfig = {\n// pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n    pages: [\n      'pages/book/book',\n      'pages/detail/detail',\n      'pages/user/user',\n      'pages/index/index'\n    ],\n    window: {\n      backgroundTextStyle: 'light',\n      navigationBarBackgroundColor: '#f55002',\n      navigationBarTitleText: '首页',\n      navigationBarTextStyle: 'light',\n      enablePullDownRefresh: false,\n      onReachBottomDistance: 30,\n      backgroundColor: '#f55002'\n    },\n    tabBar: {\n      backgroundColor: '#eee',\n      selectedColor: '#f55002',\n      color: '#aaa',\n      borderStyle: '#f55002',\n      list: [\n        {\n          pagePath: 'pages/index/index',\n          iconPath: './static/images/home_default.png',\n          selectedIconPath: './static/images/home_selected.png',\n          text: '首页'\n        },\n        {\n          pagePath: 'pages/book/book',\n          iconPath: './static/images/book_default.png',\n          selectedIconPath: './static/images/book_selected.png',\n          text: '书架'\n        },\n        {\n          pagePath: 'pages/user/user',\n          text: '我的',\n          iconPath: './static/images/user_default.png',\n          selectedIconPath: './static/images/user_selected.png'\n        }\n      ]\n    },\n    networkTimeout: {\n      request: 6000,\n      downloadFile: 10000\n    },\n    debug: true\n  };\n</code></pre>\n<blockquote>\n<h3><span id=\"消息机制\">消息机制</span></h3>\n<blockquote>\n<h4><span id=\"taro-提供了-taroevents-来实现消息机制使用时需要实例化它看完文档感觉跟vue的global-event-bus很像-可以用作非父子组件间的通讯应用场景看业务需求~\">Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~</span></h4>\n</blockquote>\n</blockquote>\n<pre><code>import Taro, {Events} from '@tarojs/taro'\nconst events = new Events()\n// 监听一个事件，接受参数\nevents.on('eventName', (arg) =&gt; {\n  // doSth\n})\n// 监听同个事件，同时绑定多个handler\nevents.on('eventName', handler1)\nevents.on('eventName', handler2)\nevents.on('eventName', handler3)\n// 触发一个事件，传参\nevents.trigger('eventName', arg)\n// 触发事件，传入多个参数\nevents.trigger('eventName', arg1, arg2, ...)\n// 取消监听一个事件\nevents.off('eventName')\n// 取消监听一个事件某个handler\nevents.off('eventName', handler1)\n// 取消监听所有事件\nevents.off()\n</code></pre>\n<p>同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例</p>\n<pre><code>import Taro from '@tarojs/taro'\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n</code></pre>\n<blockquote>\n<h3><span id=\"checkered_flag-组件和页面的定义\">:checkered_flag: 组件和页面的定义</span></h3>\n</blockquote>\n<p><code>javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { &lt;!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--&gt; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ &lt;!--DOM 只能写在render函数中--&gt; const test = `test` return ( &lt;!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--&gt; &lt;View className='lavectorApp' style='background:#fff'&gt; &lt;Text&gt;hello Lavector&lt;Text&gt; &lt;Text&gt;{test}&lt;/Text&gt; // Taro中所有的事件都要以On 开头 &lt;Button onClick={this.toOtherPage.bind(this,'params')}&gt;To Other Page&lt;/Button&gt; &lt;/View&gt; ); } }</code></p>\n<blockquote>\n<h3><span id=\"配合使用redux\">配合使用Redux</span></h3>\n<blockquote>\n<h5><span id=\"在-taro-中可以自由地使用-react-生态中非常流行的数据流管理工具-redux-来解决复杂项目的数据管理问题-而为了更方便地使用-redux-taro-提供了与-react-redux-api-几乎一致的包-tarojsredux-来让开发人员获得更加良好的开发体验-首先要安装-reduxtarojsredux和tarojsredux-h5以及一些需要用到的redux中间件\">在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件</span></h5>\n<p>npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger</p>\n</blockquote>\n</blockquote>\n<pre><code>// src/store/index.js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport rootReducer from '../reducers'\n\nconst middlewares = [\n  thunkMiddleware,\n  createLogger()\n]\n\nexport default function configStore () {\n  const store = createStore(rootReducer, applyMiddleware(...middlewares))\n  return store\n}\n</code></pre>\n<p>入口文件app.js</p>\n<pre><code>// src/app.js\nimport Taro, { Component } from '@tarojs/taro'\nimport { Provider } from '@tarojs/redux'\n\nimport configStore from './store'\nimport Index from './pages/index'\n\nimport './app.scss'\n\nconst store = configStore()\n\nclass App extends Component {\n  config = {\n    pages: [\n      'pages/index/index'\n    ],\n    window: {\n      navigationBarTitleText: 'Test'\n    }\n  }\n\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;Index /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n\nTaro.render(&lt;App /&gt;, document.getElementById('app'))\n</code></pre>\n<blockquote>\n<p>然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)</p>\n</blockquote>\n<h1><span id=\"补充-jsx语法支持程度\">补充 JSX语法支持程度</span></h1>\n<ul>\n<li>不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）</li>\n<li>不能在包含 JSX 元素的 map 循环中使用 if 表达式</li>\n<li>不能使用 Array#map 之外的方法操作 JSX 数组</li>\n<li>不能在 JSX 参数中使用匿名函数</li>\n<li>暂不支持在 render() 之外的方法定义 JSX</li>\n<li>不允许在 JSX 参数(props)中传入 JSX 元素</li>\n<li>不能在 JSX 参数中使用对象展开符*   不支持无状态组件</li>\n</ul>\n<h3><span id=\"结束语\">结束语</span></h3>\n<p>无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。</p>\n<blockquote>\n<p>以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">京东Taro</a></p>\n</blockquote>\n<h3><span id=\"可能你需要学习的\">可能你需要学习的：</span></h3>\n<p>【Mpvue】(<a href=\"http://mpvue.com/\" target=\"_blank\" rel=\"noopener\">http://mpvue.com/</a>) 【Mpvue资源合集】(<a href=\"https://github.com/mpvue/awesome-mpvue\" target=\"_blank\" rel=\"noopener\">https://github.com/mpvue/awesome-mpvue</a>) 【Taro】(<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">https://nervjs.github.io/taro/</a>) 【Vuejs】(<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/</a>) 【Redux】(<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.redux.org.cn/</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>微信小程序开发技术分享:anchor:</h1>\n<p><img src=\"http://img.mukewang.com/5c0a36790001b17606000338-590-330.jpg\" alt></p>\n<h5>目前编写微信小程序的技术有如下：微信开发者工具自带的一套开发技术，基于腾讯的WePY框架，美团的Mpvue，京东的Taro，这四个开发小程序技术目前是应用最为广泛的。今天最主要介绍的是来自京东凹凸团队的Taro框架。</h5>\n<h3>什么是Taro?</h3>\n<p>多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。</p>\n<h3>为什么要用Taro?</h3>\n<p>当今市面上产品端的形态多种多样，有传统的Web端、有可以运行在移动端App端(React Native,Weex,Ionic等)、还有微信小程序，支付宝小程序等各种五花八门端，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，而且不易于维护，这时候我们只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码（当然来自美团的Mpvue框架也可以）。有效地提升了开发效率和开发成本且易于维护。</p>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1.jpg\" alt></p>\n<h3>Taro与其它框架进行对比</h3>\n<p><img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017205626377-1927757016.png\" alt> <img src=\"http://116.85.35.63/wp-content/uploads/2019/02/1055667-20181017200035057-744596897.png\" alt=\"image\"></p>\n<p>对比分析</p>\n<p>微信小程序</p>\n<p>mpuve</p>\n<p>wepy</p>\n<p>Taro</p>\n<p>语法规范</p>\n<p>小程序规范</p>\n<p>Vue.js规范</p>\n<p>类Vue.js规范</p>\n<p>React规范</p>\n<p>模板系统</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>字符串模板</p>\n<p>JSX</p>\n<p>类型系统</p>\n<p>不支持</p>\n<p>业务代码</p>\n<p>业务代码</p>\n<p>业务代码 + JSX</p>\n<p>组件规范</p>\n<p>小程序组件</p>\n<p>HTML标签+小程序组件</p>\n<p>小程序组件</p>\n<p>小程序组件</p>\n<p>样式规范</p>\n<p>wxss</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>css,less.sass,styus</p>\n<p>组件化</p>\n<p>小程序组件化</p>\n<p>Vue组件化</p>\n<p>自定义组件化</p>\n<p>React组件化</p>\n<p>多端复用</p>\n<p>复用，不存在的</p>\n<p>H5,APP(Weex)等</p>\n<p>没看到有介绍</p>\n<p>H5,APP(ReactNative)等</p>\n<p>自动构建</p>\n<p>无</p>\n<p>webpack</p>\n<p>内部构建系统</p>\n<p>webpack+内部构建系统</p>\n<p>开发要求</p>\n<p>全新学习</p>\n<p>熟悉Vue语法即可</p>\n<p>熟悉Vue+wepy语法</p>\n<p>熟悉React语法</p>\n<p>数据流管理</p>\n<p>无</p>\n<p>Vuex</p>\n<p>Redux</p>\n<p>Redux+React-thunk</p>\n<blockquote>\n<p>从整体可行性，多端代码复用性上来说目前感觉Mpvue和Taro 更胜一筹。</p>\n</blockquote>\n<h3>Taro框架设计思想 <a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">具体细节请看官网</a></h3>\n<blockquote>\n<p>图片来源于网络 <img src=\"http://img.colabug.com/2018/06/906f6741aaff19e0e2bfc34f20dd8f9f.png\" alt=\"image\"></p>\n</blockquote>\n<h3>Taro特性</h3>\n<ul>\n<li>React 语法风格</li>\n<li>快速开发微信小程序\n<ul>\n<li>支持使用 npm/yarn 安装管理第三方依赖</li>\n<li>支持使用 ES7/ES8 甚至更新的ES规范，一切都可自行配置</li>\n<li>支持使用 CSS 预编译器，例如 Sass 等</li>\n<li>支持使用 Redux进行状态管理</li>\n<li>小程序API优化，异步API Promise化等等</li>\n</ul>\n</li>\n<li>支持多端开发转化</li>\n</ul>\n<blockquote>\n<h3>开发配置</h3>\n</blockquote>\n<ul>\n<li>环境配置\n<ul>\n<li>sudo npm/yarn global add @tarojs/cli 也可以npx (npm5.2+)</li>\n<li>npm init lavectorApp &amp;&amp; cd lavctorApp &amp;&amp; npm run dev:weapp/h5</li>\n<li>用微信开发者工具添加项目打开dist目录即可</li>\n</ul>\n</li>\n<li>页面设计尺寸配置\n<ul>\n<li>Taro默认是以iPhone6设计图作为默认尺寸 750 可以在config/index.js 中的修改</li>\n<li>Taro项目中所有的px 最终转化小程序是以rpx作为单位，转为H5是以rem为单位</li>\n</ul>\n</li>\n<li>编辑器\n<ul>\n<li>建议VSCode, Taro会有代码提示，支持ES6/7/8语法，ESlint等功能（这个随意，开心就好） *更多配置参见官网…</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<h3>如何引用fontAwesome字体文件</h3>\n</blockquote>\n<p>比起图片，iconfont 更加容易控制其字体颜色，大小，减少HTTP请求等。 我已经做好了一个这个的文件（可自行百度，google）,点击查看 <a href=\"https://github.com/maliaoMJ/Taro_weixin/blob/master/src/static/style/fontawesome.css\" target=\"_blank\" rel=\"noopener\">查看</a> 如何使用： ```javascript import Taro, { Component } from ‘@tarojs/taro’; import { View, Icon, Image } from ‘@tarojs/components’; import ‘your/path/fontawesome.css’ //引用图片 import img from ‘your/path/image.png’ export default class Icon extends Taro.Component { … render(){ <view classname=\"icon_box\"> <icon classname=\"fa fa-home\"> <image src=\"{img}\"> </image></icon></view> } } ```</p>\n<blockquote>\n<h3>页面配置</h3>\n</blockquote>\n<pre><code>//是不是跟小程序入口配置文件差不多?\nconfig = {\n// pages 配置 Taro中首页一定放在第一个（注重顺序），在Mpvue中首页一定要加^符号（不注重顺序）\n    pages: [\n      'pages/book/book',\n      'pages/detail/detail',\n      'pages/user/user',\n      'pages/index/index'\n    ],\n    window: {\n      backgroundTextStyle: 'light',\n      navigationBarBackgroundColor: '#f55002',\n      navigationBarTitleText: '首页',\n      navigationBarTextStyle: 'light',\n      enablePullDownRefresh: false,\n      onReachBottomDistance: 30,\n      backgroundColor: '#f55002'\n    },\n    tabBar: {\n      backgroundColor: '#eee',\n      selectedColor: '#f55002',\n      color: '#aaa',\n      borderStyle: '#f55002',\n      list: [\n        {\n          pagePath: 'pages/index/index',\n          iconPath: './static/images/home_default.png',\n          selectedIconPath: './static/images/home_selected.png',\n          text: '首页'\n        },\n        {\n          pagePath: 'pages/book/book',\n          iconPath: './static/images/book_default.png',\n          selectedIconPath: './static/images/book_selected.png',\n          text: '书架'\n        },\n        {\n          pagePath: 'pages/user/user',\n          text: '我的',\n          iconPath: './static/images/user_default.png',\n          selectedIconPath: './static/images/user_selected.png'\n        }\n      ]\n    },\n    networkTimeout: {\n      request: 6000,\n      downloadFile: 10000\n    },\n    debug: true\n  };\n</code></pre>\n<blockquote>\n<h3>消息机制</h3>\n<blockquote>\n<h4>Taro 提供了 Taro.Events 来实现消息机制，使用时需要实例化它，看完文档感觉跟vue的global event bus很像 可以用作非父子组件间的通讯，应用场景，看业务需求~</h4>\n</blockquote>\n</blockquote>\n<pre><code>import Taro, {Events} from '@tarojs/taro'\nconst events = new Events()\n// 监听一个事件，接受参数\nevents.on('eventName', (arg) =&gt; {\n  // doSth\n})\n// 监听同个事件，同时绑定多个handler\nevents.on('eventName', handler1)\nevents.on('eventName', handler2)\nevents.on('eventName', handler3)\n// 触发一个事件，传参\nevents.trigger('eventName', arg)\n// 触发事件，传入多个参数\nevents.trigger('eventName', arg1, arg2, ...)\n// 取消监听一个事件\nevents.off('eventName')\n// 取消监听一个事件某个handler\nevents.off('eventName', handler1)\n// 取消监听所有事件\nevents.off()\n</code></pre>\n<p>同时 Taro 还提供了一个全局消息中心 Taro.eventCenter 以供使用，它是 Taro.Events 的实例</p>\n<pre><code>import Taro from '@tarojs/taro'\n\nTaro.eventCenter.on\nTaro.eventCenter.trigger\nTaro.eventCenter.off\n</code></pre>\n<blockquote>\n<h3>:checkered_flag: 组件和页面的定义</h3>\n</blockquote>\n<p><code>javascript import Taro, { Component } from '@tarojs/taro'; import { View, Text, Icon, Image,Button } from '@tarojs/components'; //......... //import Proptypes from 'prop-types' // 可以引入prop-types 进行类型检查 export default class App extends Component { constructor(props) { super(props); this.state = { test: [] }; } //static propTypes = { // lavectorName:PropTypes.object.isRequired, // ....... //} //只有页面有的 config = { &lt;!--这里面的配置会覆盖app.js 里面window里的数据 跟小程序的app.json配置文件类似--&gt; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#f55002', navigationBarTitleText: '首页', navigationBarTextStyle: 'light', enablePullDownRefresh: false, onReachBottomDistance: 30, backgroundColor: '#f55002' } componentDidShow(){} componentDidHide(){} ...... // 页面与组件都有的 componentDidMount(){} componentWillReceiveProps(nextProps) {} componentWillUnmount() {} componentCatchError() {} ...... //Mpvue生命周期函数多的你数不过来 大概有23个 可以查看 http://mpvue.com/mpvue/ //自定义方法 function toOtherPage () { // 跳转路由 这种方法不能跳转Tab页面，如要跳转tab页面用Taro.switchTab({}) Taro.navigateTo({ url: 'https://lavector.com?timestmp=323233232323' }) // 在目的页面获取路由参数通过 this.$router.params.timestmp } render(){ &lt;!--DOM 只能写在render函数中--&gt; const test = `test` return ( &lt;!--不支持style={ {...}} CSS in JS, 不支持{...props}这样写--&gt; &lt;View className='lavectorApp' style='background:#fff'&gt; &lt;Text&gt;hello Lavector&lt;Text&gt; &lt;Text&gt;{test}&lt;/Text&gt; // Taro中所有的事件都要以On 开头 &lt;Button onClick={this.toOtherPage.bind(this,'params')}&gt;To Other Page&lt;/Button&gt; &lt;/View&gt; ); } }</code></p>\n<blockquote>\n<h3>配合使用Redux</h3>\n<blockquote>\n<h5>在 Taro 中可以自由地使用 React 生态中非常流行的数据流管理工具 Redux 来解决复杂项目的数据管理问题。而为了更方便地使用 Redux ，Taro 提供了与 react-redux API 几乎一致的包 @tarojs/redux 来让开发人员获得更加良好的开发体验。首先要安装 redux,@tarojs/redux和@tarojs/redux-h5以及一些需要用到的redux中间件</h5>\n<p>npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger</p>\n</blockquote>\n</blockquote>\n<pre><code>// src/store/index.js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport { createLogger } from 'redux-logger'\nimport rootReducer from '../reducers'\n\nconst middlewares = [\n  thunkMiddleware,\n  createLogger()\n]\n\nexport default function configStore () {\n  const store = createStore(rootReducer, applyMiddleware(...middlewares))\n  return store\n}\n</code></pre>\n<p>入口文件app.js</p>\n<pre><code>// src/app.js\nimport Taro, { Component } from '@tarojs/taro'\nimport { Provider } from '@tarojs/redux'\n\nimport configStore from './store'\nimport Index from './pages/index'\n\nimport './app.scss'\n\nconst store = configStore()\n\nclass App extends Component {\n  config = {\n    pages: [\n      'pages/index/index'\n    ],\n    window: {\n      navigationBarTitleText: 'Test'\n    }\n  }\n\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;Index /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n\nTaro.render(&lt;App /&gt;, document.getElementById('app'))\n</code></pre>\n<blockquote>\n<p>然后就可以开始使用了。如 redux 推荐的那样，可以增加constants 目录，用来放置所有的 action type 常量,actions 目录，用来放置所有的 actions,reducers 目录，用来放置所有的 reducers(具体可以查看taro生成的Vuex项目中的对应文件)</p>\n</blockquote>\n<h1>补充 JSX语法支持程度</h1>\n<ul>\n<li>不能在自定义组件中写 children（mpvue中的插槽功能slot也不能用，wepy应该支持类似功能）</li>\n<li>不能在包含 JSX 元素的 map 循环中使用 if 表达式</li>\n<li>不能使用 Array#map 之外的方法操作 JSX 数组</li>\n<li>不能在 JSX 参数中使用匿名函数</li>\n<li>暂不支持在 render() 之外的方法定义 JSX</li>\n<li>不允许在 JSX 参数(props)中传入 JSX 元素</li>\n<li>不能在 JSX 参数中使用对象展开符*   不支持无状态组件</li>\n</ul>\n<h3>结束语</h3>\n<p>无论是打算学习Taro还是Mpvue，都应该先学习原生的微信小程序，然后在学习React/Vue进而再学习Taro和Vue,如果你精通React和Vue，感觉上手Mpvue和Taro很快，但是一开始用的不是很习惯。限制了Vue/React许多飘逸的写法与操作。</p>\n<blockquote>\n<p>以上是本人粗鄙的见解，欢迎指正！（看到我手里的菜刀了吗,想好了再说！） Tips:更多用法请参考官网<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">京东Taro</a></p>\n</blockquote>\n<h3>可能你需要学习的：</h3>\n<p>【Mpvue】(<a href=\"http://mpvue.com/\" target=\"_blank\" rel=\"noopener\">http://mpvue.com/</a>) 【Mpvue资源合集】(<a href=\"https://github.com/mpvue/awesome-mpvue\" target=\"_blank\" rel=\"noopener\">https://github.com/mpvue/awesome-mpvue</a>) 【Taro】(<a href=\"https://nervjs.github.io/taro/\" target=\"_blank\" rel=\"noopener\">https://nervjs.github.io/taro/</a>) 【Vuejs】(<a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/</a>) 【Redux】(<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">http://www.redux.org.cn/</a>)</p>\n"},{"title":"ThreeJS学习 第一章 创建一个场景","catalog":true,"date":"2019-08-05T08:37:05.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/item/201608/06/20160806232840_WZCjT.jpeg","_content":"\n#### 1.创建基本的页面结构\n\n> 从Threejs官网下载Three.js 到本地并且引入此文件。 [下载地址](https://threejs.org/build/three.js)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n  // TODO\n</script>\n</html>\n\n\n```\n\n#### 2. 创建一个简单的场景\n\n> 为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。\n\n```javascript\n   // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n\n```\n\n我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。\n\n第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。\n\n接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。\n\n接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。\n\n除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。\n\n如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。\n\n最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。\n\n#### 3. 创建一个立方体\n\n```javascript\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n\n```\n要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。\n\n接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。\n\n第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。\n\n默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n\n\n#### 4. 渲染创建的场景，使立方体动起来\n\n```javascript\n      // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n\n```\n\n现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。\n\n在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。\n\n#### 5.结果\n\n![结果图片](https://s2.ax1x.com/2019/08/05/e2WEXF.png)\n\n> 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n    // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1,)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n    // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n</script>\n</html>\n\n```","source":"_posts/第一章 TheeJS 创建场景.md","raw":"---\ntitle: ThreeJS学习 第一章 创建一个场景\ncatalog: true\ntags:\n  - HTML\n  - JavaScript\n  - Threejs\ncategories:\n  - ThreeJS\ndate: 2019-08-05 16:37:05\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/item/201608/06/20160806232840_WZCjT.jpeg\"\n---\n\n#### 1.创建基本的页面结构\n\n> 从Threejs官网下载Three.js 到本地并且引入此文件。 [下载地址](https://threejs.org/build/three.js)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n  // TODO\n</script>\n</html>\n\n\n```\n\n#### 2. 创建一个简单的场景\n\n> 为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。\n\n```javascript\n   // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n\n```\n\n我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。\n\n第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。\n\n接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。\n\n接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。\n\n除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。\n\n如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。\n\n最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。\n\n#### 3. 创建一个立方体\n\n```javascript\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n\n```\n要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。\n\n接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。\n\n第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。\n\n默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n\n\n#### 4. 渲染创建的场景，使立方体动起来\n\n```javascript\n      // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n\n```\n\n现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。\n\n在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。\n\n#### 5.结果\n\n![结果图片](https://s2.ax1x.com/2019/08/05/e2WEXF.png)\n\n> 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Learn Three.js</title>\n    <style> *{padding:0;margin:0;}\n    body { margin: 0; }\n    canvas { width: 100%; height: 100% }\n    </style>\n</head>\n<body>\n\n</body>\n<script src=\"./js/three.js\"></script>\n<script>\n    // 创建一个场景\n    let scene = new THREE.Scene()\n    // 创建一个相机\n    let camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1, 1000)\n    // 创建一个渲染器\n    let renderer = new THREE.WebGLRenderer();\n    // 设定渲染的区域\n    renderer.setSize(window.innerWidth,window.innerHeight)\n    // 添加DOM\n    document.body.appendChild(renderer.domElement)\n    // 创建一个几何体\n    let geometry = new THREE.BoxGeometry(1,1,1,)\n    // 创建一个材质\n    let material = new THREE.MeshBasicMaterial({color: '#FFC107'})\n    // 创建一个网格和正方体\n    let cube = new THREE.Mesh(geometry,material)\n    // 将建立的模型放入场景中\n    scene.add( cube )\n    // 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。\n    camera.position.z = 5\n    // 渲染动画\n    let animate = function () {\n        requestAnimationFrame(animate)\n        cube.rotation.x += 0.01\n        cube.rotation.y += 0.01\n        renderer.render(scene,camera)\n    }\n    // 调用动画，渲染界面\n    animate()\n</script>\n</html>\n\n```","slug":"第一章 TheeJS 创建场景","published":1,"updated":"2019-08-05T09:42:49.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyy7k4bb0024a0s6zbppse6m","content":"<h4><span id=\"1创建基本的页面结构\">1.创建基本的页面结构</span></h4>\n<blockquote>\n<p>从Threejs官网下载Three.js 到本地并且引入此文件。 <a href=\"https://threejs.org/build/three.js\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  // TODO</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"2-创建一个简单的场景\">2. 创建一个简单的场景</span></h4>\n<blockquote>\n<p>为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个场景</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个相机</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个渲染器</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span><br><span class=\"line\"> <span class=\"comment\">// 设定渲染的区域</span></span><br><span class=\"line\"> renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span><br><span class=\"line\"> <span class=\"comment\">// 添加DOM</span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span><br></pre></td></tr></table></figure>\n<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</p>\n<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>\n<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>\n<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>\n<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>\n<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</canvas></p>\n<p>最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</canvas></p>\n<h4><span id=\"3-创建一个立方体\">3. 创建一个立方体</span></h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个几何体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个材质</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个网格和正方体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span><br><span class=\"line\"><span class=\"comment\">// 将建立的模型放入场景中</span></span><br><span class=\"line\">scene.add( cube )</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span><br><span class=\"line\">camera.position.z = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。</p>\n<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。</p>\n<p>第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>\n<p>默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>\n<h4><span id=\"4-渲染创建的场景使立方体动起来\">4. 渲染创建的场景，使立方体动起来</span></h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 渲染动画</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    requestAnimationFrame(animate)</span><br><span class=\"line\">    cube.rotation.x += <span class=\"number\">0.01</span></span><br><span class=\"line\">    cube.rotation.y += <span class=\"number\">0.01</span></span><br><span class=\"line\">    renderer.render(scene,camera)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用动画，渲染界面</span></span><br><span class=\"line\">animate()</span><br></pre></td></tr></table></figure>\n<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>\n<p>在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。</p>\n<h4><span id=\"5结果\">5.结果</span></h4>\n<p><img src=\"https://s2.ax1x.com/2019/08/05/e2WEXF.png\" alt=\"结果图片\"></p>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个场景</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个相机</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个渲染器</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 设定渲染的区域</span></span></span><br><span class=\"line\"><span class=\"javascript\">    renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 添加DOM</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个几何体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个材质</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个网格和正方体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将建立的模型放入场景中</span></span></span><br><span class=\"line\"><span class=\"undefined\">    scene.add( cube )</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span></span><br><span class=\"line\"><span class=\"undefined\">    camera.position.z = 5</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 渲染动画</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        requestAnimationFrame(animate)</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.x += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.y += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        renderer.render(scene,camera)</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用动画，渲染界面</span></span></span><br><span class=\"line\"><span class=\"undefined\">    animate()</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4>1.创建基本的页面结构</h4>\n<blockquote>\n<p>从Threejs官网下载Three.js 到本地并且引入此文件。 <a href=\"https://threejs.org/build/three.js\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  // TODO</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4>2. 创建一个简单的场景</h4>\n<blockquote>\n<p>为了真正能够让你的场景借助three.js来进行显示，我们需要以下几个对象：场景、相机和渲染器，这样我们就能透过摄像机渲染出场景。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个场景</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个相机</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\"> <span class=\"comment\">// 创建一个渲染器</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span><br><span class=\"line\"> <span class=\"comment\">// 设定渲染的区域</span></span><br><span class=\"line\"> renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span><br><span class=\"line\"> <span class=\"comment\">// 添加DOM</span></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span><br></pre></td></tr></table></figure>\n<p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。three.js里有几种不同的相机，在这里，我们使用的是PerspectiveCamera（透视摄像机）。</p>\n<p>第一个参数是视野角度（FOV）。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的值是角度单位。第二个参数是长宽比（aspect ratio）。 也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p>\n<p>接下来的两个参数是近截面（near）和远截面（far）。 当物体某些部分比摄像机的远截面远或者比近截面近的时候，该这些部分将不会被渲染到场景中。你或许现在并不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p>\n<p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL时，可以使用这几种渲染器进行降级。</p>\n<p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用setSize传入一个较小的值，例如window.innerWidth/2和window.innerHeight/2，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p>\n<p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用setSize时，将updateStyle（第三个参数）设为false。例如，假设你的<canvas>标签现在已经具有了100%的宽和高，调用setSize(window.innerWidth/2, window.innerHeight/2, false)将使得你的应用程序以一半的分辨率来进行渲染。</canvas></p>\n<p>最后一步很重要，我们将renderer（渲染器）的dom元素（renderer.domElement）添加到我们的HTML文档中。这就是渲染器用来显示场景给我们看的<canvas>元素。</canvas></p>\n<h4>3. 创建一个立方体</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个几何体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个材质</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 创建一个网格和正方体</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span><br><span class=\"line\"><span class=\"comment\">// 将建立的模型放入场景中</span></span><br><span class=\"line\">scene.add( cube )</span><br><span class=\"line\"><span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span><br><span class=\"line\">camera.position.z = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>要创建一个立方体，我们需要一个BoxGeometry（立方体）对象. 这个对象包含了一个立方体中所有的顶点（vertices）和面（faces）。未来我们将在这方面进行更多的探索。</p>\n<p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是MeshBasicMaterial。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为#FFC107，也就是橙色。这里所做的事情，和在CSS或者Photoshop中使用十六进制(hex colors)颜色格式来设置颜色的方式一致。</p>\n<p>第三步，我们需要一个Mesh（网格）。 网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p>\n<p>默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p>\n<h4>4. 渲染创建的场景，使立方体动起来</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 渲染动画</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    requestAnimationFrame(animate)</span><br><span class=\"line\">    cube.rotation.x += <span class=\"number\">0.01</span></span><br><span class=\"line\">    cube.rotation.y += <span class=\"number\">0.01</span></span><br><span class=\"line\">    renderer.render(scene,camera)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 调用动画，渲染界面</span></span><br><span class=\"line\">animate()</span><br></pre></td></tr></table></figure>\n<p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用“渲染循环”（render loop）或者“动画循环”（animate loop）的东西。</p>\n<p>在将创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说“为什么我们不直接用setInterval来实现刷新的功能呢？”当然啦，我们的确可以用setInterval，但是，requestAnimationFrame有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，以及损耗电池的使用寿命。</p>\n<h4>5.结果</h4>\n<p><img src=\"https://s2.ax1x.com/2019/08/05/e2WEXF.png\" alt=\"结果图片\"></p>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Learn Three.js<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> *&#123;padding:0;margin:0;&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    body &#123; margin: 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    canvas &#123; width: 100%; height: 100% &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./js/three.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个场景</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> scene = <span class=\"keyword\">new</span> THREE.Scene()</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个相机</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> camera = <span class=\"keyword\">new</span> THREE.PerspectiveCamera(<span class=\"number\">75</span>,<span class=\"built_in\">window</span>.innerWidth/<span class=\"built_in\">window</span>.innerHeight,<span class=\"number\">0.1</span>, <span class=\"number\">1000</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个渲染器</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> renderer = <span class=\"keyword\">new</span> THREE.WebGLRenderer();</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 设定渲染的区域</span></span></span><br><span class=\"line\"><span class=\"javascript\">    renderer.setSize(<span class=\"built_in\">window</span>.innerWidth,<span class=\"built_in\">window</span>.innerHeight)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 添加DOM</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.body.appendChild(renderer.domElement)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个几何体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> geometry = <span class=\"keyword\">new</span> THREE.BoxGeometry(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个材质</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> material = <span class=\"keyword\">new</span> THREE.MeshBasicMaterial(&#123;<span class=\"attr\">color</span>: <span class=\"string\">'#FFC107'</span>&#125;)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 创建一个网格和正方体</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> cube = <span class=\"keyword\">new</span> THREE.Mesh(geometry,material)</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 将建立的模型放入场景中</span></span></span><br><span class=\"line\"><span class=\"undefined\">    scene.add( cube )</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 默认情况下，当我们调用scene.add()的时候，物体将会被添加到(0,0,0)坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</span></span></span><br><span class=\"line\"><span class=\"undefined\">    camera.position.z = 5</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 渲染动画</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> animate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">        requestAnimationFrame(animate)</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.x += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        cube.rotation.y += 0.01</span></span><br><span class=\"line\"><span class=\"undefined\">        renderer.render(scene,camera)</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">// 调用动画，渲染界面</span></span></span><br><span class=\"line\"><span class=\"undefined\">    animate()</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"TypeScript 学习第一章 初识TypeScript","catalog":true,"date":"2019-08-14T13:37:05.000Z","subtitle":null,"header-img":"http://www.3dmgame.com/uploads/allimg/170612/1316-1F6121I945.jpg","_content":"\n# 初识 TypeScript\n\nTypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。\n\n## TypeScript 的特点\n\nTypeScript 主要有 3 大特点：\n\n- **始于JavaScript，归于JavaScript**\n\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。\n\n- **强大的工具构建大型应用程序**\n\n类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。\n\n- **先进的 JavaScript**\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。\n\n\n## 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\n```bash\nnpm install -g typescript\n```\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\n```bash\ntsc -V \n```\n\n\n## 总结\n\nTypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。\n                                                                          \n\n","source":"_posts/TypeScript 学习第一章 初识TypeScript.md","raw":"---\ntitle: TypeScript 学习第一章 初识TypeScript\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-14 21:37:05\nsubtitle:\nheader-img: \"http://www.3dmgame.com/uploads/allimg/170612/1316-1F6121I945.jpg\"\n---\n\n# 初识 TypeScript\n\nTypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。\n\n## TypeScript 的特点\n\nTypeScript 主要有 3 大特点：\n\n- **始于JavaScript，归于JavaScript**\n\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。\n\n- **强大的工具构建大型应用程序**\n\n类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。\n\n类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。\n\n- **先进的 JavaScript**\n\nTypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。\n\n这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。\n\n\n## 安装 TypeScript\n\n命令行运行如下命令，全局安装 TypeScript：\n\n```bash\nnpm install -g typescript\n```\n\n安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：\n\n```bash\ntsc -V \n```\n\n\n## 总结\n\nTypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。\n                                                                          \n\n","slug":"TypeScript 学习第一章 初识TypeScript","published":1,"updated":"2019-08-14T14:56:10.000Z","_id":"cjzbdlbyd00052v2sr9rg1fon","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"初识-typescript\">初识 TypeScript</span></h1>\n<p>TypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p>\n<h2><span id=\"typescript-的特点\">TypeScript 的特点</span></h2>\n<p>TypeScript 主要有 3 大特点：</p>\n<ul>\n<li><strong>始于JavaScript，归于JavaScript</strong></li>\n</ul>\n<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>\n<ul>\n<li><strong>强大的工具构建大型应用程序</strong></li>\n</ul>\n<p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>\n<p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p>\n<ul>\n<li><strong>先进的 JavaScript</strong></li>\n</ul>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>\n<p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p>\n<h2><span id=\"安装-typescript\">安装 TypeScript</span></h2>\n<p>命令行运行如下命令，全局安装 TypeScript：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc -V</span><br></pre></td></tr></table></figure>\n<h2><span id=\"总结\">总结</span></h2>\n<p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>初识 TypeScript</h1>\n<p>TypeScript 作为 JavaScript 语言的超级，它为 JavaScript 添加了可选择的类型标注，大大增强了代码的可读性和可维护性。同时，它提供最新和不断发展的 JavaScript 特性，能让我们建立更健壮的组件。</p>\n<h2>TypeScript 的特点</h2>\n<p>TypeScript 主要有 3 大特点：</p>\n<ul>\n<li><strong>始于JavaScript，归于JavaScript</strong></li>\n</ul>\n<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>\n<ul>\n<li><strong>强大的工具构建大型应用程序</strong></li>\n</ul>\n<p>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>\n<p>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为。</p>\n<ul>\n<li><strong>先进的 JavaScript</strong></li>\n</ul>\n<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>\n<p>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的JavaScript。</p>\n<h2>安装 TypeScript</h2>\n<p>命令行运行如下命令，全局安装 TypeScript：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g typescript</span><br></pre></td></tr></table></figure>\n<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc -V</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。</p>\n"},{"title":"TypeScript 学习第二章 编写第一个 TypeScript","catalog":true,"date":"2019-08-15T11:37:05.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/blog/201403/20/20140320120519_M2nYE.jpeg","_content":"\n# 编写第一个 TypeScript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\n\n```javascript\nfunction greeter (person) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\n## 编译代码\n\n我们使用了 `.ts` 扩展名，但是这段代码仅仅是 JavaScript 而已。\n\n在命令行上，运行 TypeScript 编译器：\n\n```bash\ntsc greeter.ts\n```\n\n输出结果为一个 `greeter.js` 文件，它包含了和输入文件中相同的 JavsScript 代码。\n\n在命令行上，通过 Node.js 运行这段代码：\n\n```bash\nnode greeter.js\n```\n\n控制台输出：\n\n```\nHello, Yee\n```\n\n## 类型注解\n\n接下来让我们看看 TypeScript 工具带来的高级功能。 给  `person` 函数的参数添加 `: string` 类型注解，如下：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\nTypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 `greeter` 函数接收一个字符串参数。 然后尝试把 `greeter` 的调用改成传入一个数组：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n```\n\n重新编译，你会看到产生了一个错误：\n\n```\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n```\n\n类似地，尝试删除 `greeter` 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，`greeter.js` 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。\n\n## 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 `firstName` 和 `lastName` 字段的对象。 在 `TypeScript` 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 `implements` 语句。\n\n```typescript\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = {\n  firstName: 'Yee',\n  lastName: 'Huang'\n}\n\nconsole.log(greeter(user))\n```\n\n## 类\n\n最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 `Student` 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\n```typescript\nclass User {\n  fullName: string\n  firstName: string\n  lastName: string\n\n  constructor (firstName: string, lastName: string) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = firstName + ' ' + lastName\n  }\n}\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = new User('Yee', 'Huang')\n\nconsole.log(greeter(user))\n```\n\n重新运行 `tsc greeter.ts`，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 `JavaScript` 函数的实现。\n\n## 总结\n\n到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。\n\n\n\n\n","source":"_posts/TypeScript 学习第二章 编写第一个 TypeScript.md","raw":"---\ntitle: TypeScript 学习第二章 编写第一个 TypeScript\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-15 19:37:05\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/blog/201403/20/20140320120519_M2nYE.jpeg\"\n---\n\n# 编写第一个 TypeScript 程序\n\n在编辑器，将下面的代码输入到 greeter.ts 文件里：\n\n\n```javascript\nfunction greeter (person) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\n## 编译代码\n\n我们使用了 `.ts` 扩展名，但是这段代码仅仅是 JavaScript 而已。\n\n在命令行上，运行 TypeScript 编译器：\n\n```bash\ntsc greeter.ts\n```\n\n输出结果为一个 `greeter.js` 文件，它包含了和输入文件中相同的 JavsScript 代码。\n\n在命令行上，通过 Node.js 运行这段代码：\n\n```bash\nnode greeter.js\n```\n\n控制台输出：\n\n```\nHello, Yee\n```\n\n## 类型注解\n\n接下来让我们看看 TypeScript 工具带来的高级功能。 给  `person` 函数的参数添加 `: string` 类型注解，如下：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = 'Yee'\n\nconsole.log(greeter(user))\n```\n\nTypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 `greeter` 函数接收一个字符串参数。 然后尝试把 `greeter` 的调用改成传入一个数组：\n\n```typescript\nfunction greeter (person: string) {\n  return 'Hello, ' + person\n}\n\nlet user = [0, 1, 2]\n\nconsole.log(greeter(user))\n```\n\n重新编译，你会看到产生了一个错误：\n\n```\nerror TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.\n```\n\n类似地，尝试删除 `greeter` 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。\n\n要注意的是尽管有错误，`greeter.js` 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。\n\n## 接口\n\n让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 `firstName` 和 `lastName` 字段的对象。 在 `TypeScript` 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 `implements` 语句。\n\n```typescript\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = {\n  firstName: 'Yee',\n  lastName: 'Huang'\n}\n\nconsole.log(greeter(user))\n```\n\n## 类\n\n最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。\n\n让我们创建一个 `Student` 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。\n\n还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。\n\n```typescript\nclass User {\n  fullName: string\n  firstName: string\n  lastName: string\n\n  constructor (firstName: string, lastName: string) {\n    this.firstName = firstName\n    this.lastName = lastName\n    this.fullName = firstName + ' ' + lastName\n  }\n}\n\ninterface Person {\n  firstName: string\n  lastName: string\n}\n\nfunction greeter (person: Person) {\n  return 'Hello, ' + person.firstName + ' ' + person.lastName\n}\n\nlet user = new User('Yee', 'Huang')\n\nconsole.log(greeter(user))\n```\n\n重新运行 `tsc greeter.ts`，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 `JavaScript` 函数的实现。\n\n## 总结\n\n到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。\n\n\n\n\n","slug":"TypeScript 学习第二章 编写第一个 TypeScript","published":1,"updated":"2019-08-14T15:00:29.000Z","_id":"cjzbdpxeq000e2v2s2hnzu0eb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"编写第一个-typescript-程序\">编写第一个 TypeScript 程序</span></h1>\n<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"编译代码\">编译代码</span></h2>\n<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>\n<p>在命令行上，运行 TypeScript 编译器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc greeter.ts</span><br></pre></td></tr></table></figure>\n<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>\n<p>在命令行上，通过 Node.js 运行这段代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node greeter.js</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, Yee</span><br></pre></td></tr></table></figure>\n<h2><span id=\"类型注解\">类型注解</span></h2>\n<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新编译，你会看到产生了一个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>\n<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>\n<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>\n<h2><span id=\"接口\">接口</span></h2>\n<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Yee'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Huang'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2><span id=\"类\">类</span></h2>\n<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>\n<p>让我们创建一个 <code>Student</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>\n<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'Yee'</span>, <span class=\"string\">'Huang'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>\n<h2><span id=\"总结\">总结</span></h2>\n<p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>编写第一个 TypeScript 程序</h1>\n<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2>编译代码</h2>\n<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>\n<p>在命令行上，运行 TypeScript 编译器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc greeter.ts</span><br></pre></td></tr></table></figure>\n<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>\n<p>在命令行上，通过 Node.js 运行这段代码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node greeter.js</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, Yee</span><br></pre></td></tr></table></figure>\n<h2>类型注解</h2>\n<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"string\">'Yee'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新编译，你会看到产生了一个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error TS2345: Argument of type &apos;number[]&apos; is not assignable to parameter of type &apos;string&apos;.</span><br></pre></td></tr></table></figure>\n<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>\n<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>\n<h2>接口</h2>\n<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = &#123;</span><br><span class=\"line\">  firstName: <span class=\"string\">'Yee'</span>,</span><br><span class=\"line\">  lastName: <span class=\"string\">'Huang'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<h2>类</h2>\n<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>\n<p>让我们创建一个 <code>Student</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>\n<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> User &#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span> (<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = firstName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = lastName</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = firstName + <span class=\"string\">' '</span> + lastName</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  firstName: <span class=\"built_in\">string</span></span><br><span class=\"line\">  lastName: <span class=\"built_in\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greeter</span> (<span class=\"params\">person: Person</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + person.firstName + <span class=\"string\">' '</span> + person.lastName</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> user = <span class=\"keyword\">new</span> User(<span class=\"string\">'Yee'</span>, <span class=\"string\">'Huang'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter(user))</span><br></pre></td></tr></table></figure>\n<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>\n<h2>总结</h2>\n<p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>\n"},{"title":"TypeScript 学习第三章 TypeScript基本类型","catalog":true,"date":"2019-08-16T12:07:25.000Z","subtitle":null,"header-img":"http://b-ssl.duitang.com/uploads/item/201508/23/20150823200229_GuUiP.jpeg","_content":"\n# 基础类型\n\nTypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 `boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false\n```\n\n## 数字\n\n和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 20\nlet hexLiteral: number = 0x14\nlet binaryLiteral: number = 0b10100\nlet octalLiteral: number = 0o24\n```\n\n## 字符串\n\nJavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 `string` 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（`\"`）或单引号（`'`）表示字符串。\n\n```typescript\nlet name: string = 'bob'\nname = 'smith'\n```\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ``` ` ```），并且以 `${ expr }` 这种形式嵌入表达式\n\n```typescript\nlet name: string = `Yee`\nlet age: number = 37\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`\n```\n\n这与下面定义 `sentence` 的方式效果相同：\n\n```typescript\nlet sentence: string = 'Hello, my name is ' + name + '.\\n\\n' +\n    'I\\'ll be ' + (age + 1) + ' years old next month.'\n```\n\n## 数组\n\nTypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3]\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3]\n```\n\n## 元祖 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。\n\n```typescript\nlet x: [string, number]\nx = ['hello', 10] // OK\nx = [10, 'hello'] // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)) // OK\nconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法\n```\n\n当访问一个越界的元素，会使用联合类型替代：\n\n```typescript\nx[3] = 'world' // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true // Error, 布尔不是(string | number)类型\n```\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n## 枚举\n\n`enum` 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green\n```\n\n默认情况下，从 `0` 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1` 开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]\n\nconsole.log(colorName)  // 显示'Green'因为上面代码里它的值是2\n```\n\n## any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any` 类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4\nnotSure = 'maybe a string instead'\nnotSure = false // 也可以是个 boolean\n```\n\n在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，`any` 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n```\n\n## void\n\n某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：\n\n```typescript\nfunction warnUser(): void {\n  console.log('This is my warning message')\n}\n\n```\n\n声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`：\n\n```typescript\nlet unusable: void = undefined\n```\n\n## null 和 undefined\n\nTypeScript 里，`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`。 和 `void` 相似，它们的本身的类型用处不是很大：\n\n```typescript\nlet u: undefined = undefined\nlet n: null = null\n```\n\n默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n\n然而，当你指定了 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。 再次说明，稍后我们会介绍联合类型。\n\n## never\n\n`never` 类型表示的是那些永不存在的值的类型。 例如， `never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n\n`never` 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 `never` 的子类型或可以赋值给`never` 类型（除了 `never` 本身之外）。 即使 `any` 也不可以赋值给 `never`。\n\n下面是一些返回 `never` 类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n```\n\n## object\n\n`object` 表示非原始类型，也就是除 `number`，`string`，`boolean`，`symbol`，`null`或`undefined` 之外的类型。\n\n使用 `object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。例如：\n\n```typescript\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // OK\ncreate(null) // OK\n\ncreate(42) // Error\ncreate('string') // Error\ncreate(false) // Error\ncreate(undefined) // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (<string>someValue).length\n```\n\n另一个为 `as` 语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (someValue as string).length\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 `as` 语法断言是被允许的。\n\n\n\n\n","source":"_posts/TypeScript 学习第三章 TypeScript基本类型.md","raw":"---\ntitle: TypeScript 学习第三章 TypeScript基本类型\ncatalog: true\ntags:\n  - JavaScript\n  - TypeScript\ncategories:\n  - TypeScript\ndate: 2019-08-16 20:07:25\nsubtitle:\nheader-img: \"http://b-ssl.duitang.com/uploads/item/201508/23/20150823200229_GuUiP.jpeg\"\n---\n\n# 基础类型\n\nTypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n\n## 布尔值\n\n最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 `boolean`（其它语言中也一样）。\n\n```typescript\nlet isDone: boolean = false\n```\n\n## 数字\n\n和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 20\nlet hexLiteral: number = 0x14\nlet binaryLiteral: number = 0b10100\nlet octalLiteral: number = 0o24\n```\n\n## 字符串\n\nJavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 `string` 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（`\"`）或单引号（`'`）表示字符串。\n\n```typescript\nlet name: string = 'bob'\nname = 'smith'\n```\n\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ``` ` ```），并且以 `${ expr }` 这种形式嵌入表达式\n\n```typescript\nlet name: string = `Yee`\nlet age: number = 37\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`\n```\n\n这与下面定义 `sentence` 的方式效果相同：\n\n```typescript\nlet sentence: string = 'Hello, my name is ' + name + '.\\n\\n' +\n    'I\\'ll be ' + (age + 1) + ' years old next month.'\n```\n\n## 数组\n\nTypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 `[]`，表示由此类型元素组成的一个数组：\n\n```typescript\nlet list: number[] = [1, 2, 3]\n```\n\n第二种方式是使用数组泛型，`Array<元素类型>`：\n\n```typescript\nlet list: Array<number> = [1, 2, 3]\n```\n\n## 元祖 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 `string` 和 `number` 类型的元组。\n\n```typescript\nlet x: [string, number]\nx = ['hello', 10] // OK\nx = [10, 'hello'] // Error\n```\n\n当访问一个已知索引的元素，会得到正确的类型：\n\n```typescript\nconsole.log(x[0].substr(1)) // OK\nconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法\n```\n\n当访问一个越界的元素，会使用联合类型替代：\n\n```typescript\nx[3] = 'world' // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true // Error, 布尔不是(string | number)类型\n```\n\n联合类型是高级主题，我们会在以后的章节里讨论它。\n\n## 枚举\n\n`enum` 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n\n```typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green\n```\n\n默认情况下，从 `0` 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 `1` 开始编号：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green\n```\n\n或者，全部都采用手动赋值：\n\n```typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green\n```\n\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：\n\n```typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2]\n\nconsole.log(colorName)  // 显示'Green'因为上面代码里它的值是2\n```\n\n## any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any` 类型来标记这些变量：\n\n```typescript\nlet notSure: any = 4\nnotSure = 'maybe a string instead'\nnotSure = false // 也可以是个 boolean\n```\n\n在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，`any` 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n\n```typescript\nlet list: any[] = [1, true, 'free']\n\nlist[1] = 100\n```\n\n## void\n\n某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：\n\n```typescript\nfunction warnUser(): void {\n  console.log('This is my warning message')\n}\n\n```\n\n声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`：\n\n```typescript\nlet unusable: void = undefined\n```\n\n## null 和 undefined\n\nTypeScript 里，`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`。 和 `void` 相似，它们的本身的类型用处不是很大：\n\n```typescript\nlet u: undefined = undefined\nlet n: null = null\n```\n\n默认情况下 `null` 和 `undefined` 是所有类型的子类型。 就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n\n然而，当你指定了 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。 再次说明，稍后我们会介绍联合类型。\n\n## never\n\n`never` 类型表示的是那些永不存在的值的类型。 例如， `never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n\n`never` 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 `never` 的子类型或可以赋值给`never` 类型（除了 `never` 本身之外）。 即使 `any` 也不可以赋值给 `never`。\n\n下面是一些返回 `never` 类型的函数：\n\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message)\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\")\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {\n  }\n}\n```\n\n## object\n\n`object` 表示非原始类型，也就是除 `number`，`string`，`boolean`，`symbol`，`null`或`undefined` 之外的类型。\n\n使用 `object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。例如：\n\n```typescript\ndeclare function create(o: object | null): void\n\ncreate({ prop: 0 }) // OK\ncreate(null) // OK\n\ncreate(42) // Error\ncreate('string') // Error\ncreate(false) // Error\ncreate(undefined) // Error\n```\n\n## 类型断言\n\n有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (<string>someValue).length\n```\n\n另一个为 `as` 语法：\n\n```typescript\nlet someValue: any = 'this is a string'\n\nlet strLength: number = (someValue as string).length\n```\n\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 `as` 语法断言是被允许的。\n\n\n\n\n","slug":"TypeScript 学习第三章 TypeScript基本类型","published":1,"updated":"2019-08-14T15:01:19.000Z","_id":"cjzbdsnca000i2v2s2cmzxjtw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"基础类型\">基础类型</span></h1>\n<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h2><span id=\"布尔值\">布尔值</span></h2>\n<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"数字\">数字</span></h2>\n<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0x14</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b10100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o24</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"字符串\">字符串</span></h2>\n<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">'bob'</span></span><br><span class=\"line\">name = <span class=\"string\">'smith'</span></span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <figure class=\"highlight plain\"><figcaption><span>```），并且以 `$&#123; expr &#125;` 这种形式嵌入表达式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```typescript</span><br><span class=\"line\">let name: string = `Yee`</span><br><span class=\"line\">let age: number = 37</span><br><span class=\"line\">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">I&apos;ll be $&#123; age + 1 &#125; years old next month.`</span><br></pre></td></tr></table></figure></p>\n<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.\\n\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'I\\'ll be '</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">' years old next month.'</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"数组\">数组</span></h2>\n<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h2><span id=\"元祖-tuple\">元祖 Tuple</span></h2>\n<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\">x = [<span class=\"string\">'hello'</span>, <span class=\"number\">10</span>] <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">'hello'</span>] <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">'world'</span> <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()) <span class=\"comment\">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h2><span id=\"枚举\">枚举</span></h2>\n<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName)  <span class=\"comment\">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"any\">any</span></h2>\n<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span></span><br><span class=\"line\">notSure = <span class=\"string\">'maybe a string instead'</span></span><br><span class=\"line\">notSure = <span class=\"literal\">false</span> <span class=\"comment\">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">'free'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"void\">void</span></h2>\n<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is my warning message'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"null-和-undefined\">null 和 undefined</span></h2>\n<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>\n<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>\n<h2><span id=\"never\">never</span></h2>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>\n<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n<p>下面是一些返回 <code>never</code> 类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"object\">object</span></h2>\n<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>\n<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: object | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">&#123; prop: 0 &#125;</span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">null</span></span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">42</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">'<span class=\"built_in\">string</span>'</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">false</span></span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">undefined</span></span>) // <span class=\"title\">Error</span></span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"类型断言\">类型断言</span></h2>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure>\n<p>另一个为 <code>as</code> 语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>基础类型</h1>\n<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h2>布尔值</h2>\n<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h2>数字</h2>\n<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0x14</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b10100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o24</span></span><br></pre></td></tr></table></figure>\n<h2>字符串</h2>\n<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">'bob'</span></span><br><span class=\"line\">name = <span class=\"string\">'smith'</span></span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <figure class=\"highlight plain\"><figcaption><span>```），并且以 `$&#123; expr &#125;` 这种形式嵌入表达式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```typescript</span><br><span class=\"line\">let name: string = `Yee`</span><br><span class=\"line\">let age: number = 37</span><br><span class=\"line\">let sentence: string = `Hello, my name is $&#123; name &#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">I&apos;ll be $&#123; age + 1 &#125; years old next month.`</span><br></pre></td></tr></table></figure></p>\n<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.\\n\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'I\\'ll be '</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">' years old next month.'</span></span><br></pre></td></tr></table></figure>\n<h2>数组</h2>\n<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n<h2>元祖 Tuple</h2>\n<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>]</span><br><span class=\"line\">x = [<span class=\"string\">'hello'</span>, <span class=\"number\">10</span>] <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">'hello'</span>] <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)) <span class=\"comment\">// Error, 'number' 不存在 'substr' 方法</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">'world'</span> <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()) <span class=\"comment\">// OK, 'string' 和 'number' 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span> <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h2>枚举</h2>\n<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName)  <span class=\"comment\">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h2>any</h2>\n<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span></span><br><span class=\"line\">notSure = <span class=\"string\">'maybe a string instead'</span></span><br><span class=\"line\">notSure = <span class=\"literal\">false</span> <span class=\"comment\">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">'free'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<h2>void</h2>\n<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'This is my warning message'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<h2>null 和 undefined</h2>\n<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>\n<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>\n<h2>never</h2>\n<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>\n<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n<p>下面是一些返回 <code>never</code> 类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">\"Something failed\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>object</h2>\n<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>\n<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: object | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">&#123; prop: 0 &#125;</span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">null</span></span>) // <span class=\"title\">OK</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">42</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">'<span class=\"built_in\">string</span>'</span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">false</span></span>) // <span class=\"title\">Error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"literal\">undefined</span></span>) // <span class=\"title\">Error</span></span></span><br></pre></td></tr></table></figure>\n<h2>类型断言</h2>\n<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length</span><br></pre></td></tr></table></figure>\n<p>另一个为 <code>as</code> 语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">'this is a string'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjyy7k49s0001a0s6xnqrgy8q","category_id":"cjyy7k4a00005a0s6sbv2r5kc","_id":"cjyy7k4ae000ga0s6q0o1ii6r"},{"post_id":"cjyy7k4a8000aa0s62gxa7br4","category_id":"cjyy7k4a00005a0s6sbv2r5kc","_id":"cjyy7k4ah000ka0s6yburp33n"},{"post_id":"cjyy7k49w0003a0s6brwdg8e5","category_id":"cjyy7k4a9000ba0s6gqx3po7p","_id":"cjyy7k4aj000pa0s6fzn0ae6h"},{"post_id":"cjyy7k4a20007a0s6dm0lxnu5","category_id":"cjyy7k4a9000ba0s6gqx3po7p","_id":"cjyy7k4am000ua0s63de7gy8j"},{"post_id":"cjyy7k4ak000ra0s6u13bx6ct","category_id":"cjyy7k4aj000oa0s6ceam6nk2","_id":"cjyy7k4aq0010a0s6rzhcet1o"},{"post_id":"cjyy7k4a60009a0s64w540car","category_id":"cjyy7k4aj000oa0s6ceam6nk2","_id":"cjyy7k4as0014a0s600ifhbr5"},{"post_id":"cjyy7k4al000ta0s6amxo90na","category_id":"cjyy7k4a00005a0s6sbv2r5kc","_id":"cjyy7k4at0016a0s6pqn07kxh"},{"post_id":"cjyy7k4an000xa0s63c7mdfay","category_id":"cjyy7k4a9000ba0s6gqx3po7p","_id":"cjyy7k4au0019a0s659ui1xtc"},{"post_id":"cjyy7k4ab000da0s69uuqdg3s","category_id":"cjyy7k4aj000oa0s6ceam6nk2","_id":"cjyy7k4aw001da0s6ggh3zxrq"},{"post_id":"cjyy7k4ar0013a0s65senzmh2","category_id":"cjyy7k4aj000oa0s6ceam6nk2","_id":"cjyy7k4ax001ha0s6r72ijb5r"},{"post_id":"cjyy7k4ac000fa0s6b9fw2wpd","category_id":"cjyy7k4aj000oa0s6ceam6nk2","_id":"cjyy7k4az001ka0s62ql574r4"},{"post_id":"cjyy7k4ag000ja0s6wckih49d","category_id":"cjyy7k4at0017a0s6yv8c9t3q","_id":"cjyy7k4b1001na0s6x8ufzyif"},{"post_id":"cjyy7k4ai000ma0s6j577xwwv","category_id":"cjyy7k4aj000oa0s6ceam6nk2","_id":"cjyy7k4b3001ra0s6ot4r7035"},{"post_id":"cjyy7k4ap000za0s6ahx2xsfi","category_id":"cjyy7k4az001la0s6m9593mlm","_id":"cjyy7k4b8001ya0s6xtni1i2l"},{"post_id":"cjyy7k4b6001wa0s6rqokf6gb","category_id":"cjyy7k4a9000ba0s6gqx3po7p","_id":"cjyy7k4bb0025a0s6qtrcsetb"},{"post_id":"cjyy7k4as0015a0s68opue3sj","category_id":"cjyy7k4b4001ua0s6ynwcur2f","_id":"cjyy7k4bc0029a0s6yh6yn2ro"},{"post_id":"cjyy7k4at0018a0s6ixng3do1","category_id":"cjyy7k4b90020a0s6h2e36th5","_id":"cjyy7k4bd002ba0s6ksouaze1"},{"post_id":"cjyy7k4av001ca0s6uvrfh5os","category_id":"cjyy7k4b90020a0s6h2e36th5","_id":"cjyy7k4be002da0s6a0sszohs"},{"post_id":"cjyy7k4aw001ga0s6qs6qojwe","category_id":"cjyy7k4bd002aa0s6lb9eqj7e","_id":"cjyy7k4bh002ja0s6fs2nxbo1"},{"post_id":"cjyy7k4ay001ja0s6ypg6axqw","category_id":"cjyy7k4b90020a0s6h2e36th5","_id":"cjyy7k4bi002na0s689hv69ux"},{"post_id":"cjyy7k4az001ma0s6h6cgu6vy","category_id":"cjyy7k4b90020a0s6h2e36th5","_id":"cjyy7k4bk002sa0s6d317xmdx"},{"post_id":"cjyy7k4b2001qa0s6iomgl8wl","category_id":"cjyy7k4b90020a0s6h2e36th5","_id":"cjyy7k4bl002va0s6moudjwlo"},{"post_id":"cjyy7k4b3001ta0s6p2uwcp40","category_id":"cjyy7k4b90020a0s6h2e36th5","_id":"cjyy7k4bl002za0s6q0oofmnt"},{"post_id":"cjyy7k4b7001xa0s6s0ss561x","category_id":"cjyy7k4bk002ua0s6d59qlya7","_id":"cjyy7k4bm0032a0s6iunxtv99"},{"post_id":"cjyy7k4b90022a0s6vsznw7w6","category_id":"cjyy7k4bl0030a0s61vgnpu2z","_id":"cjyy7k4bm0037a0s60ygpk4w3"},{"post_id":"cjyy7k4bb0024a0s6zbppse6m","category_id":"cjyy7k4bm0033a0s6y38jzgfy","_id":"cjyy7k4bn003ba0s6ixf50jyr"},{"post_id":"cjzbdlbyd00052v2sr9rg1fon","category_id":"cjzbdlz0u000c2v2szx1zjuxt","_id":"cjzbdlz0w000d2v2suorjb4i6"},{"post_id":"cjzbdpxeq000e2v2s2hnzu0eb","category_id":"cjzbdlz0u000c2v2szx1zjuxt","_id":"cjzbdq4o5000h2v2st9cn4esi"},{"post_id":"cjzbdsnca000i2v2s2cmzxjtw","category_id":"cjzbdlz0u000c2v2szx1zjuxt","_id":"cjzbdsvd2000l2v2suj8l3va4"}],"PostTag":[{"post_id":"cjyy7k4a8000aa0s62gxa7br4","tag_id":"cjyy7k4a20006a0s6amstwfbj","_id":"cjyy7k4ac000ea0s6onvt8mc9"},{"post_id":"cjyy7k49s0001a0s6xnqrgy8q","tag_id":"cjyy7k4a20006a0s6amstwfbj","_id":"cjyy7k4ah000la0s60mwv5q0s"},{"post_id":"cjyy7k49s0001a0s6xnqrgy8q","tag_id":"cjyy7k4aa000ca0s6lp95s44b","_id":"cjyy7k4aj000na0s6busc03la"},{"post_id":"cjyy7k49w0003a0s6brwdg8e5","tag_id":"cjyy7k4ae000ia0s6rj2uqm7r","_id":"cjyy7k4al000sa0s62kczb7xe"},{"post_id":"cjyy7k4a20007a0s6dm0lxnu5","tag_id":"cjyy7k4ae000ia0s6rj2uqm7r","_id":"cjyy7k4ao000ya0s6jyg2dm6x"},{"post_id":"cjyy7k4a60009a0s64w540car","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4av001ba0s6cn5vrzd9"},{"post_id":"cjyy7k4a60009a0s64w540car","tag_id":"cjyy7k4aq0012a0s6uw43yf9z","_id":"cjyy7k4aw001fa0s6b7zptyxl"},{"post_id":"cjyy7k4ab000da0s69uuqdg3s","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4b1001pa0s6ltoegj90"},{"post_id":"cjyy7k4ab000da0s69uuqdg3s","tag_id":"cjyy7k4aq0012a0s6uw43yf9z","_id":"cjyy7k4b3001sa0s65kawfqca"},{"post_id":"cjyy7k4ac000fa0s6b9fw2wpd","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4b90021a0s6nliuts3m"},{"post_id":"cjyy7k4ac000fa0s6b9fw2wpd","tag_id":"cjyy7k4aq0012a0s6uw43yf9z","_id":"cjyy7k4ba0023a0s63qnovi5v"},{"post_id":"cjyy7k4b7001xa0s6s0ss561x","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4bc0028a0s61addf4wf"},{"post_id":"cjyy7k4ag000ja0s6wckih49d","tag_id":"cjyy7k4b8001za0s6zg74etue","_id":"cjyy7k4bg002ga0s6uaju1sw5"},{"post_id":"cjyy7k4ag000ja0s6wckih49d","tag_id":"cjyy7k4bc0026a0s664zh2nkc","_id":"cjyy7k4bg002ha0s694p1yf6t"},{"post_id":"cjyy7k4ag000ja0s6wckih49d","tag_id":"cjyy7k4bd002ca0s6lnn83ncp","_id":"cjyy7k4bi002la0s6x3jqy40v"},{"post_id":"cjyy7k4ai000ma0s6j577xwwv","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4bj002pa0s69o86eepm"},{"post_id":"cjyy7k4ai000ma0s6j577xwwv","tag_id":"cjyy7k4aq0012a0s6uw43yf9z","_id":"cjyy7k4bj002qa0s6a1zb0uk8"},{"post_id":"cjyy7k4ak000ra0s6u13bx6ct","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4bl002xa0s69nxhbl55"},{"post_id":"cjyy7k4ak000ra0s6u13bx6ct","tag_id":"cjyy7k4aq0012a0s6uw43yf9z","_id":"cjyy7k4bl002ya0s6o9f0h1fp"},{"post_id":"cjyy7k4al000ta0s6amxo90na","tag_id":"cjyy7k4a20006a0s6amstwfbj","_id":"cjyy7k4bm0035a0s6kbwqc4e9"},{"post_id":"cjyy7k4al000ta0s6amxo90na","tag_id":"cjyy7k4bl002wa0s6zgmlj599","_id":"cjyy7k4bm0036a0s6odzznfoe"},{"post_id":"cjyy7k4al000ta0s6amxo90na","tag_id":"cjyy7k4bl0031a0s6u7irom1r","_id":"cjyy7k4bn0039a0s69lkvdte6"},{"post_id":"cjyy7k4an000xa0s63c7mdfay","tag_id":"cjyy7k4ae000ia0s6rj2uqm7r","_id":"cjyy7k4bn003aa0s6fnxzisq5"},{"post_id":"cjyy7k4an000xa0s63c7mdfay","tag_id":"cjyy7k4bm0034a0s6ssccx48p","_id":"cjyy7k4bo003da0s6pl42wf9o"},{"post_id":"cjyy7k4ar0013a0s65senzmh2","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4bo003ea0s64acxl5k6"},{"post_id":"cjyy7k4ar0013a0s65senzmh2","tag_id":"cjyy7k4aq0012a0s6uw43yf9z","_id":"cjyy7k4bo003ga0s6lhf33042"},{"post_id":"cjyy7k4at0018a0s6ixng3do1","tag_id":"cjyy7k4bn003ca0s6hndm0nvp","_id":"cjyy7k4bp003ja0s6nepctgcr"},{"post_id":"cjyy7k4at0018a0s6ixng3do1","tag_id":"cjyy7k4bo003fa0s6866mcmje","_id":"cjyy7k4bp003ka0s6neea58yw"},{"post_id":"cjyy7k4at0018a0s6ixng3do1","tag_id":"cjyy7k4bp003ha0s6sxa3i4ha","_id":"cjyy7k4bq003ma0s6pi7mawlo"},{"post_id":"cjyy7k4av001ca0s6uvrfh5os","tag_id":"cjyy7k4bo003fa0s6866mcmje","_id":"cjyy7k4bq003na0s66bxywwro"},{"post_id":"cjyy7k4aw001ga0s6qs6qojwe","tag_id":"cjyy7k4bp003la0s66u4lmiai","_id":"cjyy7k4bq003pa0s6b1kv6lx8"},{"post_id":"cjyy7k4ay001ja0s6ypg6axqw","tag_id":"cjyy7k4bq003oa0s678z9u12b","_id":"cjyy7k4bs003sa0s63l4xnjp3"},{"post_id":"cjyy7k4ay001ja0s6ypg6axqw","tag_id":"cjyy7k4bo003fa0s6866mcmje","_id":"cjyy7k4bt003ta0s6oqqzcdr9"},{"post_id":"cjyy7k4ay001ja0s6ypg6axqw","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4bt003va0s6ypo7ewtg"},{"post_id":"cjyy7k4az001ma0s6h6cgu6vy","tag_id":"cjyy7k4bo003fa0s6866mcmje","_id":"cjyy7k4bu003xa0s6fh32sj2z"},{"post_id":"cjyy7k4az001ma0s6h6cgu6vy","tag_id":"cjyy7k4bp003ha0s6sxa3i4ha","_id":"cjyy7k4bu003ya0s6fd4kzndk"},{"post_id":"cjyy7k4az001ma0s6h6cgu6vy","tag_id":"cjyy7k4an000wa0s691suqzku","_id":"cjyy7k4bu0040a0s6lmpiraag"},{"post_id":"cjyy7k4b2001qa0s6iomgl8wl","tag_id":"cjyy7k4bo003fa0s6866mcmje","_id":"cjyy7k4bv0041a0s60zlxa3sn"},{"post_id":"cjyy7k4b3001ta0s6p2uwcp40","tag_id":"cjyy7k4bo003fa0s6866mcmje","_id":"cjyy7k4bw0043a0s6k5dmv1cn"},{"post_id":"cjyy7k4b6001wa0s6rqokf6gb","tag_id":"cjyy7k4ae000ia0s6rj2uqm7r","_id":"cjyy7k4bx0046a0s6urevcez0"},{"post_id":"cjyy7k4b6001wa0s6rqokf6gb","tag_id":"cjyy7k4bm0034a0s6ssccx48p","_id":"cjyy7k4bx0047a0s6ec5ua2sc"},{"post_id":"cjyy7k4b6001wa0s6rqokf6gb","tag_id":"cjyy7k4bw0044a0s6rydzg0mw","_id":"cjyy7k4by0049a0s6h2roy9co"},{"post_id":"cjyy7k4bb0024a0s6zbppse6m","tag_id":"cjyy7k4bx0045a0s6iu76g5nr","_id":"cjyy7k4c0004ba0s6eileu22t"},{"post_id":"cjyy7k4bb0024a0s6zbppse6m","tag_id":"cjyy7k4bx0048a0s6ko4rvr7p","_id":"cjyy7k4c0004ca0s61zi3r1iq"},{"post_id":"cjyy7k4bb0024a0s6zbppse6m","tag_id":"cjyy7k4by004aa0s6xbu7u4xf","_id":"cjyy7k4c0004da0s6k6orzpzl"},{"post_id":"cjzbdlbyd00052v2sr9rg1fon","tag_id":"cjyy7k4bx0048a0s6ko4rvr7p","_id":"cjzbdlbyf00072v2s0aw0xai1"},{"post_id":"cjzbdlbyd00052v2sr9rg1fon","tag_id":"cjzbdltoc000a2v2samoe00g5","_id":"cjzbdltoc000b2v2svjzckla8"},{"post_id":"cjzbdpxeq000e2v2s2hnzu0eb","tag_id":"cjyy7k4bx0048a0s6ko4rvr7p","_id":"cjzbdq4o4000f2v2seailojsl"},{"post_id":"cjzbdpxeq000e2v2s2hnzu0eb","tag_id":"cjzbdltoc000a2v2samoe00g5","_id":"cjzbdq4o5000g2v2s522zyptu"},{"post_id":"cjzbdsnca000i2v2s2cmzxjtw","tag_id":"cjyy7k4bx0048a0s6ko4rvr7p","_id":"cjzbdsvd1000j2v2s49ire8gc"},{"post_id":"cjzbdsnca000i2v2s2cmzxjtw","tag_id":"cjzbdltoc000a2v2samoe00g5","_id":"cjzbdsvd2000k2v2s0jnlibdd"}],"Tag":[{"name":"Docker","_id":"cjyy7k4a20006a0s6amstwfbj"},{"name":"WordPress","_id":"cjyy7k4aa000ca0s6lp95s44b"},{"name":"graphql","_id":"cjyy7k4ae000ia0s6rj2uqm7r"},{"name":"javascript","_id":"cjyy7k4an000wa0s691suqzku"},{"name":"数据结构","_id":"cjyy7k4aq0012a0s6uw43yf9z"},{"name":"Vue","_id":"cjyy7k4b8001za0s6zg74etue"},{"name":"Weex","_id":"cjyy7k4bc0026a0s664zh2nkc"},{"name":"微信小程序","_id":"cjyy7k4bd002ca0s6lnn83ncp"},{"name":"git","_id":"cjyy7k4bl002wa0s6zgmlj599"},{"name":"gitlab","_id":"cjyy7k4bl0031a0s6u7irom1r"},{"name":"nodejs","_id":"cjyy7k4bm0034a0s6ssccx48p"},{"name":"CSS3","_id":"cjyy7k4bn003ca0s6hndm0nvp"},{"name":"Frontend Interview","_id":"cjyy7k4bo003fa0s6866mcmje"},{"name":"html","_id":"cjyy7k4bp003ha0s6sxa3i4ha"},{"name":"http","_id":"cjyy7k4bp003la0s66u4lmiai"},{"name":"ES6","_id":"cjyy7k4bq003oa0s678z9u12b"},{"name":"vuejs","_id":"cjyy7k4bw0044a0s6rydzg0mw"},{"name":"HTML","_id":"cjyy7k4bx0045a0s6iu76g5nr"},{"name":"JavaScript","_id":"cjyy7k4bx0048a0s6ko4rvr7p"},{"name":"Threejs","_id":"cjyy7k4by004aa0s6xbu7u4xf"},{"name":"TypeScript","_id":"cjzbdltoc000a2v2samoe00g5"}]}}