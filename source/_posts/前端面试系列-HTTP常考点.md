---
title: 前端面试系列-HTTP常考点
catalog: true
tags:
  - http
url: 172.html
id: 172
categories:
  - HTTP
date: 2019-03-05 16:44:04
subtitle:
header-img:
---

![](http://116.85.35.63/wp-content/uploads/2019/03/wKioL1TSyM_jvXcjAAHwHaPR-6k608.jpg)

#### 经典五层模型

![](http://116.85.35.63/wp-content/uploads/2019/03/191800353854087.png)

1.  物理层主要作用是定义物理设备如何传输数据
2.  数据链路层在通信的实体间建立数据链路连接
3.  网络层为数据在结点之间传输创建逻辑链路
4.  传输层（TCP，UDP...）向用户提供可靠的端到端（End-to-End）服务。向高层屏蔽了下层数据通信的细节。
5.  应用层（HTTP，FTP...）为软件提供很多的服务，构建在TCP协议之上，屏蔽网络传输相关的细节。

> 1.  从输入 URL 到页面加载完成的过程

1.  首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP
    
2.  协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了
    
3.  TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件
    
4.  首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错
    
5.  浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
    
6.  文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML
    
7.  解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。
    
8.  初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件
    
9.  CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
    
10.  在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了
    

> 2.  DNS

![](http://116.85.35.63/wp-content/uploads/2019/03/dns-51-1.jpg)

1\. 操作系统会首先在本地缓存中查询 2. 没有的话会去系统配置的 DNS 服务器中查询 3. 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器 4. 然后去该服务器查询 google 这个二级域名 5. 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP 6. 以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。 7. PS：DNS 是基于 UDP 做的查询。

> 3.  HTTPS与HTTP的一些区别

*   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
*   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
*   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
*   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

> 4.  HTTP1.x与HTTP2.0的区别

*   `新的二进制格式`（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
*   `MultiPlexing）`，即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
*   `header压缩`，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
*   `服务端推送（server push）`，同SPDY一样，HTTP2.0也具有server push功能。

> 5.  HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？

*   HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
*   HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
*   HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；

### HTTP----HTTP缓存机制

#### 强缓存

实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，state code 为 200

    Expires: Wed, 22 Oct 2018 08:41:00 GMT
    

`Expires` 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

    Cache-control: max-age=30
    

`Cache-Control` 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。

#### 协商缓存

如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。

> 1.  Last-Modified 和 If-Modified-Since

Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。

> 2.  ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。

#### 选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

*   对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
*   对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
*   对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。